{
    "vyper/codegen/function_definitions/external_function.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         ret.append([\"goto\", sig.external_function_base_entry_label])"
            },
            "2": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ret = [\"if\", [\"eq\", \"_calldata_method_id\", method_id], ret]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        method_id_check = [\"eq\", \"_calldata_method_id\", method_id]"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        # if there is a function whose selector is 0, it won't be distinguished"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        # from the case where nil calldata is supplied, b/c calldataload loads"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        # 0s past the end of physical calldata (cf. yellow paper)."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        # since supplying 0 calldata is expected to trigger the fallback fn,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        # we check that calldatasize > 0, which distinguishes the 0 selector"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        # from the fallback function \"selector\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        # (equiv. to \"all selectors not in the selector table\")."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        # note: cases where not enough calldata is supplied (besides"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        # calldatasize==0) are not addressed here b/c a calldatasize"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        # well-formedness check is already present in the function body"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        # as part of abi validation"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        if method_id.value == 0:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+            method_id_check = [\"and\", [\"gt\", \"calldatasize\", 0], method_id_check]"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        ret = [\"if\", method_id_check, ret]"
            },
            "22": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         return ret"
            },
            "23": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     ret = [\"seq\"]"
            }
        },
        "frontPatchFile": [
            "from typing import Any, List",
            "",
            "import vyper.utils as util",
            "from vyper.address_space import CALLDATA, DATA, MEMORY",
            "from vyper.ast.signatures.function_signature import FunctionSignature",
            "from vyper.codegen.abi_encoder import abi_encoding_matches_vyper",
            "from vyper.codegen.context import Context, VariableRecord",
            "from vyper.codegen.core import get_element_ptr, getpos, make_setter, needs_clamp",
            "from vyper.codegen.expr import Expr",
            "from vyper.codegen.function_definitions.utils import get_nonreentrant_lock",
            "from vyper.codegen.ir_node import Encoding, IRnode",
            "from vyper.codegen.stmt import parse_body",
            "from vyper.semantics.types import TupleT",
            "",
            "",
            "# register function args with the local calling context.",
            "# also allocate the ones that live in memory (i.e. kwargs)",
            "def _register_function_args(context: Context, sig: FunctionSignature) -> List[IRnode]:",
            "    ret = []",
            "",
            "    # the type of the calldata",
            "    base_args_t = TupleT(tuple(arg.typ for arg in sig.base_args))",
            "",
            "    # tuple with the abi_encoded args",
            "    if sig.is_init_func:",
            "        base_args_ofst = IRnode(0, location=DATA, typ=base_args_t, encoding=Encoding.ABI)",
            "    else:",
            "        base_args_ofst = IRnode(4, location=CALLDATA, typ=base_args_t, encoding=Encoding.ABI)",
            "",
            "    for i, arg in enumerate(sig.base_args):",
            "",
            "        arg_ir = get_element_ptr(base_args_ofst, i)",
            "",
            "        if needs_clamp(arg.typ, Encoding.ABI):",
            "            # allocate a memory slot for it and copy",
            "            p = context.new_variable(arg.name, arg.typ, is_mutable=False)",
            "            dst = IRnode(p, typ=arg.typ, location=MEMORY)",
            "",
            "            copy_arg = make_setter(dst, arg_ir)",
            "            copy_arg.source_pos = getpos(arg.ast_source)",
            "            ret.append(copy_arg)",
            "        else:",
            "            assert abi_encoding_matches_vyper(arg.typ)",
            "            # leave it in place",
            "            context.vars[arg.name] = VariableRecord(",
            "                name=arg.name,",
            "                pos=arg_ir,",
            "                typ=arg.typ,",
            "                mutable=False,",
            "                location=arg_ir.location,",
            "                encoding=Encoding.ABI,",
            "            )",
            "",
            "    return ret",
            "",
            "",
            "def _annotated_method_id(abi_sig):",
            "    method_id = util.method_id_int(abi_sig)",
            "    annotation = f\"{hex(method_id)}: {abi_sig}\"",
            "    return IRnode(method_id, annotation=annotation)",
            "",
            "",
            "def _generate_kwarg_handlers(context: Context, sig: FunctionSignature) -> List[Any]:",
            "    # generate kwarg handlers.",
            "    # since they might come in thru calldata or be default,",
            "    # allocate them in memory and then fill it in based on calldata or default,",
            "    # depending on the signature",
            "    # a kwarg handler looks like",
            "    # (if (eq _method_id <method_id>)",
            "    #    copy calldata args to memory",
            "    #    write default args to memory",
            "    #    goto external_function_common_ir",
            "",
            "    def handler_for(calldata_kwargs, default_kwargs):",
            "        calldata_args = sig.base_args + calldata_kwargs",
            "        # create a fake type so that get_element_ptr works",
            "        calldata_args_t = TupleT(list(arg.typ for arg in calldata_args))",
            "",
            "        abi_sig = sig.abi_signature_for_kwargs(calldata_kwargs)",
            "        method_id = _annotated_method_id(abi_sig)",
            "",
            "        calldata_kwargs_ofst = IRnode(",
            "            4, location=CALLDATA, typ=calldata_args_t, encoding=Encoding.ABI",
            "        )",
            "",
            "        # a sequence of statements to strictify kwargs into memory",
            "        ret = [\"seq\"]",
            "",
            "        # ensure calldata is at least of minimum length",
            "        args_abi_t = calldata_args_t.abi_type",
            "        calldata_min_size = args_abi_t.min_size() + 4",
            "        ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
            "",
            "        # TODO optimize make_setter by using",
            "        # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))",
            "        # (must ensure memory area is contiguous)",
            "",
            "        n_base_args = len(sig.base_args)",
            "",
            "        for i, arg_meta in enumerate(calldata_kwargs):",
            "            k = n_base_args + i",
            "",
            "            dst = context.lookup_var(arg_meta.name).pos",
            "",
            "            lhs = IRnode(dst, location=MEMORY, typ=arg_meta.typ)",
            "",
            "            rhs = get_element_ptr(calldata_kwargs_ofst, k, array_bounds_check=False)",
            "",
            "            copy_arg = make_setter(lhs, rhs)",
            "            copy_arg.source_pos = getpos(arg_meta.ast_source)",
            "            ret.append(copy_arg)",
            "",
            "        for x in default_kwargs:",
            "            dst = context.lookup_var(x.name).pos",
            "            lhs = IRnode(dst, location=MEMORY, typ=x.typ)",
            "            lhs.source_pos = getpos(x.ast_source)",
            "            kw_ast_val = sig.default_values[x.name]  # e.g. `3` in x: int = 3",
            "            rhs = Expr(kw_ast_val, context).ir_node",
            "",
            "            copy_arg = make_setter(lhs, rhs)",
            "            copy_arg.source_pos = getpos(x.ast_source)",
            "            ret.append(copy_arg)",
            "",
            "        ret.append([\"goto\", sig.external_function_base_entry_label])",
            "",
            "        ret = [\"if\", [\"eq\", \"_calldata_method_id\", method_id], ret]",
            "        return ret",
            "",
            "    ret = [\"seq\"]",
            "",
            "    keyword_args = sig.default_args",
            "",
            "    # allocate variable slots in memory",
            "    for arg in keyword_args:",
            "        context.new_variable(arg.name, arg.typ, is_mutable=False)",
            "",
            "    for i, _ in enumerate(keyword_args):",
            "        calldata_kwargs = keyword_args[:i]",
            "        default_kwargs = keyword_args[i:]",
            "",
            "        ret.append(handler_for(calldata_kwargs, default_kwargs))",
            "",
            "    ret.append(handler_for(keyword_args, []))",
            "",
            "    return ret",
            "",
            "",
            "# TODO it would be nice if this returned a data structure which were",
            "# amenable to generating a jump table instead of the linear search for",
            "# method_id we have now.",
            "def generate_ir_for_external_function(code, sig, context, skip_nonpayable_check):",
            "    # TODO type hints:",
            "    # def generate_ir_for_external_function(",
            "    #    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context, check_nonpayable: bool,",
            "    # ) -> IRnode:",
            "    \"\"\"Return the IR for an external function. Includes code to inspect the method_id,",
            "    enter the function (nonpayable and reentrancy checks), handle kwargs and exit",
            "    the function (clean up reentrancy storage variables)",
            "    \"\"\"",
            "    func_type = code._metadata[\"type\"]",
            "",
            "    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)",
            "",
            "    # generate handlers for base args and register the variable records",
            "    handle_base_args = _register_function_args(context, sig)",
            "",
            "    # generate handlers for kwargs and register the variable records",
            "    kwarg_handlers = _generate_kwarg_handlers(context, sig)",
            "",
            "    body = [\"seq\"]",
            "    # once optional args have been handled,",
            "    # generate the main body of the function",
            "    body += handle_base_args",
            "",
            "    if sig.mutability != \"payable\" and not skip_nonpayable_check:",
            "        # if the contract contains payable functions, but this is not one of them",
            "        # add an assertion that the value of the call is zero",
            "        body += [[\"assert\", [\"iszero\", \"callvalue\"]]]",
            "",
            "    body += nonreentrant_pre",
            "",
            "    body += [parse_body(code.body, context, ensure_terminated=True)]",
            "",
            "    # wrap the body in labeled block",
            "    body = [\"label\", sig.external_function_base_entry_label, [\"var_list\"], body]",
            "",
            "    exit_sequence = [\"seq\"] + nonreentrant_post",
            "    if sig.is_init_func:",
            "        pass  # init func has special exit sequence generated by module.py",
            "    elif context.return_type is None:",
            "        exit_sequence += [[\"stop\"]]",
            "    else:",
            "        exit_sequence += [[\"return\", \"ret_ofst\", \"ret_len\"]]",
            "",
            "    exit_sequence_args = [\"var_list\"]",
            "    if context.return_type is not None:",
            "        exit_sequence_args += [\"ret_ofst\", \"ret_len\"]",
            "    # wrap the exit in a labeled block",
            "    exit = [\"label\", sig.exit_sequence_label, exit_sequence_args, exit_sequence]",
            "",
            "    # the ir which comprises the main body of the function,",
            "    # besides any kwarg handling",
            "    func_common_ir = [\"seq\", body, exit]",
            "",
            "    if sig.is_default_func or sig.is_init_func:",
            "        ret = [\"seq\"]",
            "        # add a goto to make the function entry look like other functions",
            "        # (for zksync interpreter)",
            "        ret.append([\"goto\", sig.external_function_base_entry_label])",
            "        ret.append(func_common_ir)",
            "    else:",
            "        ret = kwarg_handlers",
            "        # sneak the base code into the kwarg handler",
            "        # TODO rethink this / make it clearer",
            "        ret[-1][-1].append(func_common_ir)",
            "",
            "    return IRnode.from_list(ret, source_pos=getpos(sig.func_ast_code))"
        ],
        "afterPatchFile": [
            "from typing import Any, List",
            "",
            "import vyper.utils as util",
            "from vyper.address_space import CALLDATA, DATA, MEMORY",
            "from vyper.ast.signatures.function_signature import FunctionSignature",
            "from vyper.codegen.abi_encoder import abi_encoding_matches_vyper",
            "from vyper.codegen.context import Context, VariableRecord",
            "from vyper.codegen.core import get_element_ptr, getpos, make_setter, needs_clamp",
            "from vyper.codegen.expr import Expr",
            "from vyper.codegen.function_definitions.utils import get_nonreentrant_lock",
            "from vyper.codegen.ir_node import Encoding, IRnode",
            "from vyper.codegen.stmt import parse_body",
            "from vyper.semantics.types import TupleT",
            "",
            "",
            "# register function args with the local calling context.",
            "# also allocate the ones that live in memory (i.e. kwargs)",
            "def _register_function_args(context: Context, sig: FunctionSignature) -> List[IRnode]:",
            "    ret = []",
            "",
            "    # the type of the calldata",
            "    base_args_t = TupleT(tuple(arg.typ for arg in sig.base_args))",
            "",
            "    # tuple with the abi_encoded args",
            "    if sig.is_init_func:",
            "        base_args_ofst = IRnode(0, location=DATA, typ=base_args_t, encoding=Encoding.ABI)",
            "    else:",
            "        base_args_ofst = IRnode(4, location=CALLDATA, typ=base_args_t, encoding=Encoding.ABI)",
            "",
            "    for i, arg in enumerate(sig.base_args):",
            "",
            "        arg_ir = get_element_ptr(base_args_ofst, i)",
            "",
            "        if needs_clamp(arg.typ, Encoding.ABI):",
            "            # allocate a memory slot for it and copy",
            "            p = context.new_variable(arg.name, arg.typ, is_mutable=False)",
            "            dst = IRnode(p, typ=arg.typ, location=MEMORY)",
            "",
            "            copy_arg = make_setter(dst, arg_ir)",
            "            copy_arg.source_pos = getpos(arg.ast_source)",
            "            ret.append(copy_arg)",
            "        else:",
            "            assert abi_encoding_matches_vyper(arg.typ)",
            "            # leave it in place",
            "            context.vars[arg.name] = VariableRecord(",
            "                name=arg.name,",
            "                pos=arg_ir,",
            "                typ=arg.typ,",
            "                mutable=False,",
            "                location=arg_ir.location,",
            "                encoding=Encoding.ABI,",
            "            )",
            "",
            "    return ret",
            "",
            "",
            "def _annotated_method_id(abi_sig):",
            "    method_id = util.method_id_int(abi_sig)",
            "    annotation = f\"{hex(method_id)}: {abi_sig}\"",
            "    return IRnode(method_id, annotation=annotation)",
            "",
            "",
            "def _generate_kwarg_handlers(context: Context, sig: FunctionSignature) -> List[Any]:",
            "    # generate kwarg handlers.",
            "    # since they might come in thru calldata or be default,",
            "    # allocate them in memory and then fill it in based on calldata or default,",
            "    # depending on the signature",
            "    # a kwarg handler looks like",
            "    # (if (eq _method_id <method_id>)",
            "    #    copy calldata args to memory",
            "    #    write default args to memory",
            "    #    goto external_function_common_ir",
            "",
            "    def handler_for(calldata_kwargs, default_kwargs):",
            "        calldata_args = sig.base_args + calldata_kwargs",
            "        # create a fake type so that get_element_ptr works",
            "        calldata_args_t = TupleT(list(arg.typ for arg in calldata_args))",
            "",
            "        abi_sig = sig.abi_signature_for_kwargs(calldata_kwargs)",
            "        method_id = _annotated_method_id(abi_sig)",
            "",
            "        calldata_kwargs_ofst = IRnode(",
            "            4, location=CALLDATA, typ=calldata_args_t, encoding=Encoding.ABI",
            "        )",
            "",
            "        # a sequence of statements to strictify kwargs into memory",
            "        ret = [\"seq\"]",
            "",
            "        # ensure calldata is at least of minimum length",
            "        args_abi_t = calldata_args_t.abi_type",
            "        calldata_min_size = args_abi_t.min_size() + 4",
            "        ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
            "",
            "        # TODO optimize make_setter by using",
            "        # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))",
            "        # (must ensure memory area is contiguous)",
            "",
            "        n_base_args = len(sig.base_args)",
            "",
            "        for i, arg_meta in enumerate(calldata_kwargs):",
            "            k = n_base_args + i",
            "",
            "            dst = context.lookup_var(arg_meta.name).pos",
            "",
            "            lhs = IRnode(dst, location=MEMORY, typ=arg_meta.typ)",
            "",
            "            rhs = get_element_ptr(calldata_kwargs_ofst, k, array_bounds_check=False)",
            "",
            "            copy_arg = make_setter(lhs, rhs)",
            "            copy_arg.source_pos = getpos(arg_meta.ast_source)",
            "            ret.append(copy_arg)",
            "",
            "        for x in default_kwargs:",
            "            dst = context.lookup_var(x.name).pos",
            "            lhs = IRnode(dst, location=MEMORY, typ=x.typ)",
            "            lhs.source_pos = getpos(x.ast_source)",
            "            kw_ast_val = sig.default_values[x.name]  # e.g. `3` in x: int = 3",
            "            rhs = Expr(kw_ast_val, context).ir_node",
            "",
            "            copy_arg = make_setter(lhs, rhs)",
            "            copy_arg.source_pos = getpos(x.ast_source)",
            "            ret.append(copy_arg)",
            "",
            "        ret.append([\"goto\", sig.external_function_base_entry_label])",
            "",
            "        method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
            "",
            "        # if there is a function whose selector is 0, it won't be distinguished",
            "        # from the case where nil calldata is supplied, b/c calldataload loads",
            "        # 0s past the end of physical calldata (cf. yellow paper).",
            "        # since supplying 0 calldata is expected to trigger the fallback fn,",
            "        # we check that calldatasize > 0, which distinguishes the 0 selector",
            "        # from the fallback function \"selector\"",
            "        # (equiv. to \"all selectors not in the selector table\").",
            "",
            "        # note: cases where not enough calldata is supplied (besides",
            "        # calldatasize==0) are not addressed here b/c a calldatasize",
            "        # well-formedness check is already present in the function body",
            "        # as part of abi validation",
            "        if method_id.value == 0:",
            "            method_id_check = [\"and\", [\"gt\", \"calldatasize\", 0], method_id_check]",
            "",
            "        ret = [\"if\", method_id_check, ret]",
            "        return ret",
            "",
            "    ret = [\"seq\"]",
            "",
            "    keyword_args = sig.default_args",
            "",
            "    # allocate variable slots in memory",
            "    for arg in keyword_args:",
            "        context.new_variable(arg.name, arg.typ, is_mutable=False)",
            "",
            "    for i, _ in enumerate(keyword_args):",
            "        calldata_kwargs = keyword_args[:i]",
            "        default_kwargs = keyword_args[i:]",
            "",
            "        ret.append(handler_for(calldata_kwargs, default_kwargs))",
            "",
            "    ret.append(handler_for(keyword_args, []))",
            "",
            "    return ret",
            "",
            "",
            "# TODO it would be nice if this returned a data structure which were",
            "# amenable to generating a jump table instead of the linear search for",
            "# method_id we have now.",
            "def generate_ir_for_external_function(code, sig, context, skip_nonpayable_check):",
            "    # TODO type hints:",
            "    # def generate_ir_for_external_function(",
            "    #    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context, check_nonpayable: bool,",
            "    # ) -> IRnode:",
            "    \"\"\"Return the IR for an external function. Includes code to inspect the method_id,",
            "    enter the function (nonpayable and reentrancy checks), handle kwargs and exit",
            "    the function (clean up reentrancy storage variables)",
            "    \"\"\"",
            "    func_type = code._metadata[\"type\"]",
            "",
            "    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)",
            "",
            "    # generate handlers for base args and register the variable records",
            "    handle_base_args = _register_function_args(context, sig)",
            "",
            "    # generate handlers for kwargs and register the variable records",
            "    kwarg_handlers = _generate_kwarg_handlers(context, sig)",
            "",
            "    body = [\"seq\"]",
            "    # once optional args have been handled,",
            "    # generate the main body of the function",
            "    body += handle_base_args",
            "",
            "    if sig.mutability != \"payable\" and not skip_nonpayable_check:",
            "        # if the contract contains payable functions, but this is not one of them",
            "        # add an assertion that the value of the call is zero",
            "        body += [[\"assert\", [\"iszero\", \"callvalue\"]]]",
            "",
            "    body += nonreentrant_pre",
            "",
            "    body += [parse_body(code.body, context, ensure_terminated=True)]",
            "",
            "    # wrap the body in labeled block",
            "    body = [\"label\", sig.external_function_base_entry_label, [\"var_list\"], body]",
            "",
            "    exit_sequence = [\"seq\"] + nonreentrant_post",
            "    if sig.is_init_func:",
            "        pass  # init func has special exit sequence generated by module.py",
            "    elif context.return_type is None:",
            "        exit_sequence += [[\"stop\"]]",
            "    else:",
            "        exit_sequence += [[\"return\", \"ret_ofst\", \"ret_len\"]]",
            "",
            "    exit_sequence_args = [\"var_list\"]",
            "    if context.return_type is not None:",
            "        exit_sequence_args += [\"ret_ofst\", \"ret_len\"]",
            "    # wrap the exit in a labeled block",
            "    exit = [\"label\", sig.exit_sequence_label, exit_sequence_args, exit_sequence]",
            "",
            "    # the ir which comprises the main body of the function,",
            "    # besides any kwarg handling",
            "    func_common_ir = [\"seq\", body, exit]",
            "",
            "    if sig.is_default_func or sig.is_init_func:",
            "        ret = [\"seq\"]",
            "        # add a goto to make the function entry look like other functions",
            "        # (for zksync interpreter)",
            "        ret.append([\"goto\", sig.external_function_base_entry_label])",
            "        ret.append(func_common_ir)",
            "    else:",
            "        ret = kwarg_handlers",
            "        # sneak the base code into the kwarg handler",
            "        # TODO rethink this / make it clearer",
            "        ret[-1][-1].append(func_common_ir)",
            "",
            "    return IRnode.from_list(ret, source_pos=getpos(sig.func_ast_code))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "126": [
                "_generate_kwarg_handlers",
                "handler_for"
            ]
        },
        "addLocation": []
    },
    "vyper/codegen/module.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     runtime = ["
            },
            "2": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         \"seq\","
            },
            "3": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # check that calldatasize is at least 4, otherwise"
            },
            "4": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # calldataload will load zeros (cf. yellow paper)."
            },
            "5": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],"
            },
            "6": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],"
            },
            "7": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         close_selector_section,"
            },
            "8": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],"
            }
        },
        "frontPatchFile": [
            "# a contract.vy -- all functions and constructor",
            "",
            "from typing import Any, Dict, List, Optional, Tuple",
            "",
            "from vyper import ast as vy_ast",
            "from vyper.ast.signatures.function_signature import FunctionSignature, FunctionSignatures",
            "from vyper.codegen.core import shr",
            "from vyper.codegen.function_definitions import generate_ir_for_function",
            "from vyper.codegen.global_context import GlobalContext",
            "from vyper.codegen.ir_node import IRnode",
            "from vyper.exceptions import CompilerPanic",
            "from vyper.semantics.types.function import StateMutability",
            "",
            "",
            "def _topsort_helper(functions, lookup):",
            "    #  single pass to get a global topological sort of functions (so that each",
            "    # function comes after each of its callees). may have duplicates, which get",
            "    # filtered out in _topsort()",
            "",
            "    ret = []",
            "    for f in functions:",
            "        # called_functions is a list of ContractFunctions, need to map",
            "        # back to FunctionDefs.",
            "        callees = [lookup[t.name] for t in f._metadata[\"type\"].called_functions]",
            "        ret.extend(_topsort_helper(callees, lookup))",
            "        ret.append(f)",
            "",
            "    return ret",
            "",
            "",
            "def _topsort(functions):",
            "    lookup = {f.name: f for f in functions}",
            "    # strip duplicates",
            "    return list(dict.fromkeys(_topsort_helper(functions, lookup)))",
            "",
            "",
            "def _is_init_func(func_ast):",
            "    return func_ast._metadata[\"signature\"].is_init_func",
            "",
            "",
            "def _is_default_func(func_ast):",
            "    return func_ast._metadata[\"signature\"].is_default_func",
            "",
            "",
            "def _is_internal(func_ast):",
            "    return func_ast._metadata[\"type\"].is_internal",
            "",
            "",
            "def _is_payable(func_ast):",
            "    return func_ast._metadata[\"type\"].mutability == StateMutability.PAYABLE",
            "",
            "",
            "# codegen for all runtime functions + callvalue/calldata checks + method selector routines",
            "def _runtime_ir(runtime_functions, all_sigs, global_ctx):",
            "    # categorize the runtime functions because we will organize the runtime",
            "    # code into the following sections:",
            "    # payable functions, nonpayable functions, fallback function, internal_functions",
            "    internal_functions = [f for f in runtime_functions if _is_internal(f)]",
            "",
            "    external_functions = [f for f in runtime_functions if not _is_internal(f)]",
            "    default_function = next((f for f in external_functions if _is_default_func(f)), None)",
            "",
            "    # functions that need to go exposed in the selector section",
            "    regular_functions = [f for f in external_functions if not _is_default_func(f)]",
            "    payables = [f for f in regular_functions if _is_payable(f)]",
            "    nonpayables = [f for f in regular_functions if not _is_payable(f)]",
            "",
            "    # create a map of the IR functions since they might live in both",
            "    # runtime and deploy code (if init function calls them)",
            "    internal_functions_map: Dict[str, IRnode] = {}",
            "",
            "    for func_ast in internal_functions:",
            "        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)",
            "        internal_functions_map[func_ast.name] = func_ir",
            "",
            "    # for some reason, somebody may want to deploy a contract with no",
            "    # external functions, or more likely, a \"pure data\" contract which",
            "    # contains immutables",
            "    if len(external_functions) == 0:",
            "        # TODO: prune internal functions in this case?",
            "        runtime = [\"seq\"] + list(internal_functions_map.values())",
            "        return runtime, internal_functions_map",
            "",
            "    # note: if the user does not provide one, the default fallback function",
            "    # reverts anyway. so it does not hurt to batch the payable check.",
            "    default_is_nonpayable = default_function is None or not _is_payable(default_function)",
            "",
            "    # when a contract has a nonpayable default function,",
            "    # we can do a single check for all nonpayable functions",
            "    batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable",
            "    skip_nonpayable_check = batch_payable_check",
            "",
            "    selector_section = [\"seq\"]",
            "",
            "    for func_ast in payables:",
            "        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)",
            "        selector_section.append(func_ir)",
            "",
            "    if batch_payable_check:",
            "        selector_section.append([\"assert\", [\"iszero\", \"callvalue\"]])",
            "",
            "    for func_ast in nonpayables:",
            "        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, skip_nonpayable_check)",
            "        selector_section.append(func_ir)",
            "",
            "    if default_function:",
            "        fallback_ir = generate_ir_for_function(",
            "            default_function, all_sigs, global_ctx, skip_nonpayable_check",
            "        )",
            "    else:",
            "        fallback_ir = IRnode.from_list(",
            "            [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"",
            "        )",
            "",
            "    # ensure the external jumptable section gets closed out",
            "    # (for basic block hygiene and also for zksync interpreter)",
            "    # NOTE: this jump gets optimized out in assembly since the",
            "    # fallback label is the immediate next instruction,",
            "    close_selector_section = [\"goto\", \"fallback\"]",
            "",
            "    runtime = [",
            "        \"seq\",",
            "        # check that calldatasize is at least 4, otherwise",
            "        # calldataload will load zeros (cf. yellow paper).",
            "        [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],",
            "        [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
            "        close_selector_section,",
            "        [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
            "    ]",
            "",
            "    # TODO: prune unreachable functions?",
            "    runtime.extend(internal_functions_map.values())",
            "",
            "    return runtime, internal_functions_map",
            "",
            "",
            "# take a GlobalContext, which is basically",
            "# and generate the runtime and deploy IR, also return the dict of all signatures",
            "def generate_ir_for_module(global_ctx: GlobalContext) -> Tuple[IRnode, IRnode, FunctionSignatures]:",
            "    # order functions so that each function comes after all of its callees",
            "    function_defs = _topsort(global_ctx.functions)",
            "",
            "    # FunctionSignatures for all interfaces defined in this module",
            "    all_sigs: Dict[str, FunctionSignatures] = {}",
            "",
            "    init_function: Optional[vy_ast.FunctionDef] = None",
            "    local_sigs: FunctionSignatures = {}  # internal/local functions",
            "",
            "    # generate all signatures",
            "    # TODO really this should live in GlobalContext",
            "    for f in function_defs:",
            "        sig = FunctionSignature.from_definition(f, global_ctx)",
            "        # add it to the global namespace.",
            "        local_sigs[sig.name] = sig",
            "        # a little hacky, eventually FunctionSignature should be",
            "        # merged with ContractFunction and we can remove this.",
            "        f._metadata[\"signature\"] = sig",
            "",
            "    assert \"self\" not in all_sigs",
            "    all_sigs[\"self\"] = local_sigs",
            "",
            "    runtime_functions = [f for f in function_defs if not _is_init_func(f)]",
            "    init_function = next((f for f in function_defs if _is_init_func(f)), None)",
            "",
            "    runtime, internal_functions = _runtime_ir(runtime_functions, all_sigs, global_ctx)",
            "",
            "    deploy_code: List[Any] = [\"seq\"]",
            "    immutables_len = global_ctx.immutable_section_bytes",
            "    if init_function:",
            "        init_func_ir = generate_ir_for_function(init_function, all_sigs, global_ctx, False)",
            "        deploy_code.append(init_func_ir)",
            "",
            "        # pass the amount of memory allocated for the init function",
            "        # so that deployment does not clobber while preparing immutables",
            "        # note: (deploy mem_ofst, code, extra_padding)",
            "        init_mem_used = init_function._metadata[\"signature\"].frame_info.mem_used",
            "        deploy_code.append([\"deploy\", init_mem_used, runtime, immutables_len])",
            "",
            "        # internal functions come after everything else",
            "        for f in init_function._metadata[\"type\"].called_functions:",
            "            deploy_code.append(internal_functions[f.name])",
            "",
            "    else:",
            "        if immutables_len != 0:",
            "            raise CompilerPanic(\"unreachable\")",
            "        deploy_code.append([\"deploy\", 0, runtime, 0])",
            "",
            "    return IRnode.from_list(deploy_code), IRnode.from_list(runtime), local_sigs"
        ],
        "afterPatchFile": [
            "# a contract.vy -- all functions and constructor",
            "",
            "from typing import Any, Dict, List, Optional, Tuple",
            "",
            "from vyper import ast as vy_ast",
            "from vyper.ast.signatures.function_signature import FunctionSignature, FunctionSignatures",
            "from vyper.codegen.core import shr",
            "from vyper.codegen.function_definitions import generate_ir_for_function",
            "from vyper.codegen.global_context import GlobalContext",
            "from vyper.codegen.ir_node import IRnode",
            "from vyper.exceptions import CompilerPanic",
            "from vyper.semantics.types.function import StateMutability",
            "",
            "",
            "def _topsort_helper(functions, lookup):",
            "    #  single pass to get a global topological sort of functions (so that each",
            "    # function comes after each of its callees). may have duplicates, which get",
            "    # filtered out in _topsort()",
            "",
            "    ret = []",
            "    for f in functions:",
            "        # called_functions is a list of ContractFunctions, need to map",
            "        # back to FunctionDefs.",
            "        callees = [lookup[t.name] for t in f._metadata[\"type\"].called_functions]",
            "        ret.extend(_topsort_helper(callees, lookup))",
            "        ret.append(f)",
            "",
            "    return ret",
            "",
            "",
            "def _topsort(functions):",
            "    lookup = {f.name: f for f in functions}",
            "    # strip duplicates",
            "    return list(dict.fromkeys(_topsort_helper(functions, lookup)))",
            "",
            "",
            "def _is_init_func(func_ast):",
            "    return func_ast._metadata[\"signature\"].is_init_func",
            "",
            "",
            "def _is_default_func(func_ast):",
            "    return func_ast._metadata[\"signature\"].is_default_func",
            "",
            "",
            "def _is_internal(func_ast):",
            "    return func_ast._metadata[\"type\"].is_internal",
            "",
            "",
            "def _is_payable(func_ast):",
            "    return func_ast._metadata[\"type\"].mutability == StateMutability.PAYABLE",
            "",
            "",
            "# codegen for all runtime functions + callvalue/calldata checks + method selector routines",
            "def _runtime_ir(runtime_functions, all_sigs, global_ctx):",
            "    # categorize the runtime functions because we will organize the runtime",
            "    # code into the following sections:",
            "    # payable functions, nonpayable functions, fallback function, internal_functions",
            "    internal_functions = [f for f in runtime_functions if _is_internal(f)]",
            "",
            "    external_functions = [f for f in runtime_functions if not _is_internal(f)]",
            "    default_function = next((f for f in external_functions if _is_default_func(f)), None)",
            "",
            "    # functions that need to go exposed in the selector section",
            "    regular_functions = [f for f in external_functions if not _is_default_func(f)]",
            "    payables = [f for f in regular_functions if _is_payable(f)]",
            "    nonpayables = [f for f in regular_functions if not _is_payable(f)]",
            "",
            "    # create a map of the IR functions since they might live in both",
            "    # runtime and deploy code (if init function calls them)",
            "    internal_functions_map: Dict[str, IRnode] = {}",
            "",
            "    for func_ast in internal_functions:",
            "        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)",
            "        internal_functions_map[func_ast.name] = func_ir",
            "",
            "    # for some reason, somebody may want to deploy a contract with no",
            "    # external functions, or more likely, a \"pure data\" contract which",
            "    # contains immutables",
            "    if len(external_functions) == 0:",
            "        # TODO: prune internal functions in this case?",
            "        runtime = [\"seq\"] + list(internal_functions_map.values())",
            "        return runtime, internal_functions_map",
            "",
            "    # note: if the user does not provide one, the default fallback function",
            "    # reverts anyway. so it does not hurt to batch the payable check.",
            "    default_is_nonpayable = default_function is None or not _is_payable(default_function)",
            "",
            "    # when a contract has a nonpayable default function,",
            "    # we can do a single check for all nonpayable functions",
            "    batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable",
            "    skip_nonpayable_check = batch_payable_check",
            "",
            "    selector_section = [\"seq\"]",
            "",
            "    for func_ast in payables:",
            "        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)",
            "        selector_section.append(func_ir)",
            "",
            "    if batch_payable_check:",
            "        selector_section.append([\"assert\", [\"iszero\", \"callvalue\"]])",
            "",
            "    for func_ast in nonpayables:",
            "        func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, skip_nonpayable_check)",
            "        selector_section.append(func_ir)",
            "",
            "    if default_function:",
            "        fallback_ir = generate_ir_for_function(",
            "            default_function, all_sigs, global_ctx, skip_nonpayable_check",
            "        )",
            "    else:",
            "        fallback_ir = IRnode.from_list(",
            "            [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"",
            "        )",
            "",
            "    # ensure the external jumptable section gets closed out",
            "    # (for basic block hygiene and also for zksync interpreter)",
            "    # NOTE: this jump gets optimized out in assembly since the",
            "    # fallback label is the immediate next instruction,",
            "    close_selector_section = [\"goto\", \"fallback\"]",
            "",
            "    runtime = [",
            "        \"seq\",",
            "        [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
            "        close_selector_section,",
            "        [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
            "    ]",
            "",
            "    # TODO: prune unreachable functions?",
            "    runtime.extend(internal_functions_map.values())",
            "",
            "    return runtime, internal_functions_map",
            "",
            "",
            "# take a GlobalContext, which is basically",
            "# and generate the runtime and deploy IR, also return the dict of all signatures",
            "def generate_ir_for_module(global_ctx: GlobalContext) -> Tuple[IRnode, IRnode, FunctionSignatures]:",
            "    # order functions so that each function comes after all of its callees",
            "    function_defs = _topsort(global_ctx.functions)",
            "",
            "    # FunctionSignatures for all interfaces defined in this module",
            "    all_sigs: Dict[str, FunctionSignatures] = {}",
            "",
            "    init_function: Optional[vy_ast.FunctionDef] = None",
            "    local_sigs: FunctionSignatures = {}  # internal/local functions",
            "",
            "    # generate all signatures",
            "    # TODO really this should live in GlobalContext",
            "    for f in function_defs:",
            "        sig = FunctionSignature.from_definition(f, global_ctx)",
            "        # add it to the global namespace.",
            "        local_sigs[sig.name] = sig",
            "        # a little hacky, eventually FunctionSignature should be",
            "        # merged with ContractFunction and we can remove this.",
            "        f._metadata[\"signature\"] = sig",
            "",
            "    assert \"self\" not in all_sigs",
            "    all_sigs[\"self\"] = local_sigs",
            "",
            "    runtime_functions = [f for f in function_defs if not _is_init_func(f)]",
            "    init_function = next((f for f in function_defs if _is_init_func(f)), None)",
            "",
            "    runtime, internal_functions = _runtime_ir(runtime_functions, all_sigs, global_ctx)",
            "",
            "    deploy_code: List[Any] = [\"seq\"]",
            "    immutables_len = global_ctx.immutable_section_bytes",
            "    if init_function:",
            "        init_func_ir = generate_ir_for_function(init_function, all_sigs, global_ctx, False)",
            "        deploy_code.append(init_func_ir)",
            "",
            "        # pass the amount of memory allocated for the init function",
            "        # so that deployment does not clobber while preparing immutables",
            "        # note: (deploy mem_ofst, code, extra_padding)",
            "        init_mem_used = init_function._metadata[\"signature\"].frame_info.mem_used",
            "        deploy_code.append([\"deploy\", init_mem_used, runtime, immutables_len])",
            "",
            "        # internal functions come after everything else",
            "        for f in init_function._metadata[\"type\"].called_functions:",
            "            deploy_code.append(internal_functions[f.name])",
            "",
            "    else:",
            "        if immutables_len != 0:",
            "            raise CompilerPanic(\"unreachable\")",
            "        deploy_code.append([\"deploy\", 0, runtime, 0])",
            "",
            "    return IRnode.from_list(deploy_code), IRnode.from_list(runtime), local_sigs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "123": [
                "_runtime_ir"
            ],
            "124": [
                "_runtime_ir"
            ],
            "125": [
                "_runtime_ir"
            ]
        },
        "addLocation": []
    }
}