{
    "lib/streamlit/web/server/app_static_file_handler.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     def validate_absolute_path(self, root: str, absolute_path: str) -> str | None:"
            },
            "1": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         full_path = os.path.realpath(absolute_path)"
            },
            "2": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        ret_val = super().validate_absolute_path(root, absolute_path)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         if os.path.isdir(full_path):"
            },
            "6": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             # we don't want to serve directories, and serve only files"
            },
            "7": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             raise tornado.web.HTTPError(404)"
            },
            "8": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "                 reason=\"File is too large\","
            },
            "9": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "             )"
            },
            "10": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return super().validate_absolute_path(root, absolute_path)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        return ret_val"
            },
            "13": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     def set_default_headers(self):"
            },
            "15": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         # CORS protection is disabled because we need access to this endpoint"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from __future__ import annotations",
            "",
            "import mimetypes",
            "import os",
            "from pathlib import Path",
            "from typing import Final",
            "",
            "import tornado.web",
            "",
            "from streamlit.logger import get_logger",
            "",
            "_LOGGER: Final = get_logger(__name__)",
            "",
            "# We agreed on these limitations for the initial release of static file sharing,",
            "# based on security concerns from the SiS and Community Cloud teams",
            "# The maximum possible size of single serving static file.",
            "MAX_APP_STATIC_FILE_SIZE = 200 * 1024 * 1024  # 200 MB",
            "# The list of file extensions that we serve with the corresponding Content-Type header.",
            "# All files with other extensions will be served with Content-Type: text/plain",
            "SAFE_APP_STATIC_FILE_EXTENSIONS = (\".jpg\", \".jpeg\", \".png\", \".gif\", \".webp\")",
            "",
            "",
            "class AppStaticFileHandler(tornado.web.StaticFileHandler):",
            "    def initialize(self, path: str, default_filename: str | None = None) -> None:",
            "        super().initialize(path, default_filename)",
            "        mimetypes.add_type(\"image/webp\", \".webp\")",
            "",
            "    def validate_absolute_path(self, root: str, absolute_path: str) -> str | None:",
            "        full_path = os.path.realpath(absolute_path)",
            "",
            "        if os.path.isdir(full_path):",
            "            # we don't want to serve directories, and serve only files",
            "            raise tornado.web.HTTPError(404)",
            "",
            "        if os.path.commonpath([full_path, root]) != root:",
            "            # Don't allow misbehaving clients to break out of the static files directory",
            "            _LOGGER.warning(",
            "                \"Serving files outside of the static directory is not supported\"",
            "            )",
            "            raise tornado.web.HTTPError(404)",
            "",
            "        if (",
            "            os.path.exists(full_path)",
            "            and os.path.getsize(full_path) > MAX_APP_STATIC_FILE_SIZE",
            "        ):",
            "            raise tornado.web.HTTPError(",
            "                404,",
            "                \"File is too large, its size should not exceed \"",
            "                f\"{MAX_APP_STATIC_FILE_SIZE} bytes\",",
            "                reason=\"File is too large\",",
            "            )",
            "",
            "        return super().validate_absolute_path(root, absolute_path)",
            "",
            "    def set_default_headers(self):",
            "        # CORS protection is disabled because we need access to this endpoint",
            "        # from the inner iframe.",
            "        self.set_header(\"Access-Control-Allow-Origin\", \"*\")",
            "",
            "    def set_extra_headers(self, path: str) -> None:",
            "        if Path(path).suffix not in SAFE_APP_STATIC_FILE_EXTENSIONS:",
            "            self.set_header(\"Content-Type\", \"text/plain\")",
            "        self.set_header(\"X-Content-Type-Options\", \"nosniff\")"
        ],
        "afterPatchFile": [
            "# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from __future__ import annotations",
            "",
            "import mimetypes",
            "import os",
            "from pathlib import Path",
            "from typing import Final",
            "",
            "import tornado.web",
            "",
            "from streamlit.logger import get_logger",
            "",
            "_LOGGER: Final = get_logger(__name__)",
            "",
            "# We agreed on these limitations for the initial release of static file sharing,",
            "# based on security concerns from the SiS and Community Cloud teams",
            "# The maximum possible size of single serving static file.",
            "MAX_APP_STATIC_FILE_SIZE = 200 * 1024 * 1024  # 200 MB",
            "# The list of file extensions that we serve with the corresponding Content-Type header.",
            "# All files with other extensions will be served with Content-Type: text/plain",
            "SAFE_APP_STATIC_FILE_EXTENSIONS = (\".jpg\", \".jpeg\", \".png\", \".gif\", \".webp\")",
            "",
            "",
            "class AppStaticFileHandler(tornado.web.StaticFileHandler):",
            "    def initialize(self, path: str, default_filename: str | None = None) -> None:",
            "        super().initialize(path, default_filename)",
            "        mimetypes.add_type(\"image/webp\", \".webp\")",
            "",
            "    def validate_absolute_path(self, root: str, absolute_path: str) -> str | None:",
            "        full_path = os.path.realpath(absolute_path)",
            "",
            "        ret_val = super().validate_absolute_path(root, absolute_path)",
            "",
            "        if os.path.isdir(full_path):",
            "            # we don't want to serve directories, and serve only files",
            "            raise tornado.web.HTTPError(404)",
            "",
            "        if os.path.commonpath([full_path, root]) != root:",
            "            # Don't allow misbehaving clients to break out of the static files directory",
            "            _LOGGER.warning(",
            "                \"Serving files outside of the static directory is not supported\"",
            "            )",
            "            raise tornado.web.HTTPError(404)",
            "",
            "        if (",
            "            os.path.exists(full_path)",
            "            and os.path.getsize(full_path) > MAX_APP_STATIC_FILE_SIZE",
            "        ):",
            "            raise tornado.web.HTTPError(",
            "                404,",
            "                \"File is too large, its size should not exceed \"",
            "                f\"{MAX_APP_STATIC_FILE_SIZE} bytes\",",
            "                reason=\"File is too large\",",
            "            )",
            "",
            "        return ret_val",
            "",
            "    def set_default_headers(self):",
            "        # CORS protection is disabled because we need access to this endpoint",
            "        # from the inner iframe.",
            "        self.set_header(\"Access-Control-Allow-Origin\", \"*\")",
            "",
            "    def set_extra_headers(self, path: str) -> None:",
            "        if Path(path).suffix not in SAFE_APP_STATIC_FILE_EXTENSIONS:",
            "            self.set_header(\"Content-Type\", \"text/plain\")",
            "        self.set_header(\"X-Content-Type-Options\", \"nosniff\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "67": [
                "AppStaticFileHandler",
                "validate_absolute_path"
            ]
        },
        "addLocation": [
            "src.pyload.core.database.user_database"
        ]
    },
    "lib/tests/streamlit/web/server/app_static_file_handler_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         self._tmp_webp_image_file = tempfile.NamedTemporaryFile("
            },
            "1": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             dir=self._tmpdir.name, suffix=\"image.webp\", delete=False"
            },
            "2": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        self._tmp_dir_inside_static_folder = tempfile.TemporaryDirectory("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            dir=self._tmpdir.name"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        )"
            },
            "6": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         self._symlink_outside_directory = \"symlink_outside\""
            },
            "8": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         self._symlink_inside_directory = \"symlink_inside\""
            },
            "9": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         responses = ["
            },
            "10": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "             # Access to directory without trailing slash"
            },
            "11": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "             self.fetch(\"/app/static\"),"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            # Access to non-existent file"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            self.fetch(\"/app/static/nonexistent.jpg\"),"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        ]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        for r in responses:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            assert r.code == 404"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            assert ("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                r.body == b\"<html><title>404: Not Found</title>\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                b\"<body>404: Not Found</body></html>\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            )"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    def test_staticfiles_403(self):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        \"\"\"files outside static directory and symlinks pointing to"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        files outside static directory and directories should return 403."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        \"\"\""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        responses = ["
            },
            "27": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "             # Access to directory with trailing slash"
            },
            "28": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "             self.fetch(\"/app/static/\"),"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            # Access to directory inside static folder without trailing slash"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            self.fetch(f\"/app/static/{self._tmp_dir_inside_static_folder.name}\"),"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            # Access to directory inside static folder with trailing slash"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            self.fetch(f\"/app/static/{self._tmp_dir_inside_static_folder.name}/\"),"
            },
            "33": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "             # Access to file outside static directory"
            },
            "34": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             self.fetch(\"/app/static/../test_file_outside_directory.py\"),"
            },
            "35": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             # Access to file outside static directory with same prefix"
            },
            "36": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "             ),"
            },
            "37": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "             # Access to symlink outside static directory"
            },
            "38": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "             self.fetch(f\"/app/static/{self._symlink_outside_directory}\"),"
            },
            "39": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Access to non-existent file"
            },
            "40": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.fetch(\"/app/static/nonexistent.jpg\"),"
            },
            "41": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         ]"
            },
            "42": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         for r in responses:"
            },
            "43": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            assert r.code == 404"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            assert r.code == 403"
            },
            "45": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "             assert ("
            },
            "46": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                r.body == b\"<html><title>404: Not Found</title>\""
            },
            "47": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                b\"<body>404: Not Found</body></html>\""
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+                r.body == b\"<html><title>403: Forbidden</title>\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+                b\"<body>403: Forbidden</body></html>\""
            },
            "50": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "             )"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from __future__ import annotations",
            "",
            "import os",
            "import sys",
            "import tempfile",
            "import unittest",
            "from unittest.mock import MagicMock, patch",
            "",
            "import tornado.httpserver",
            "import tornado.testing",
            "import tornado.web",
            "import tornado.websocket",
            "",
            "from streamlit.web.server.app_static_file_handler import (",
            "    MAX_APP_STATIC_FILE_SIZE,",
            "    AppStaticFileHandler,",
            ")",
            "",
            "",
            "@unittest.skipIf(",
            "    \"win32\" in sys.platform,",
            "    \"Most windows installs do not support symlinks except as admin\",",
            ")",
            "class AppStaticFileHandlerTest(tornado.testing.AsyncHTTPTestCase):",
            "    def setUp(self) -> None:",
            "        self._tmpdir = tempfile.TemporaryDirectory(dir=os.getcwd())",
            "        self._tmpfile = tempfile.NamedTemporaryFile(dir=self._tmpdir.name, delete=False)",
            "        self._tmp_js_file = tempfile.NamedTemporaryFile(",
            "            dir=self._tmpdir.name, suffix=\"script.js\", delete=False",
            "        )",
            "        self._tmp_png_image_file = tempfile.NamedTemporaryFile(",
            "            dir=self._tmpdir.name, suffix=\"image.png\", delete=False",
            "        )",
            "        self._tmp_webp_image_file = tempfile.NamedTemporaryFile(",
            "            dir=self._tmpdir.name, suffix=\"image.webp\", delete=False",
            "        )",
            "",
            "        self._symlink_outside_directory = \"symlink_outside\"",
            "        self._symlink_inside_directory = \"symlink_inside\"",
            "",
            "        os.symlink(",
            "            \"/\", os.path.join(self._tmpdir.name, self._symlink_outside_directory)",
            "        )",
            "        os.symlink(",
            "            self._tmpfile.name,",
            "            os.path.join(self._tmpdir.name, self._symlink_inside_directory),",
            "        )",
            "",
            "        self._filename = os.path.basename(self._tmpfile.name)",
            "        self._js_filename = os.path.basename(self._tmp_js_file.name)",
            "        self._png_image_filename = os.path.basename(self._tmp_png_image_file.name)",
            "        self._webp_image_filename = os.path.basename(self._tmp_webp_image_file.name)",
            "",
            "        super().setUp()",
            "",
            "    def tearDown(self) -> None:",
            "        super().tearDown()",
            "        self._tmpdir.cleanup()",
            "",
            "    def get_app(self):",
            "        return tornado.web.Application(",
            "            [",
            "                (",
            "                    r\"/app/static/(.*)\",",
            "                    AppStaticFileHandler,",
            "                    {\"path\": \"%s\" % self._tmpdir.name},",
            "                )",
            "            ]",
            "        )",
            "",
            "    def test_static_files_200(self):",
            "        \"\"\"Files with extensions NOT listed in app_static_file_handler.py",
            "        `SAFE_APP_STATIC_FILE_EXTENSIONS` should have the `Content-Type` header value",
            "        equals to `text-plain`.",
            "        \"\"\"",
            "        responses = [",
            "            # self._filename is file without extension",
            "            self.fetch(f\"/app/static/{self._filename}\"),",
            "            # self._js_filename is file with '.js' extension",
            "            self.fetch(f\"/app/static/{self._js_filename}\"),",
            "            # self._symlink_inside_directory is symlink to",
            "            # self._tmpfile (inside static directory)",
            "            self.fetch(f\"/app/static/{self._symlink_inside_directory}\"),",
            "        ]",
            "        for r in responses:",
            "            assert r.headers[\"Content-Type\"] == \"text/plain\"",
            "            assert r.headers[\"X-Content-Type-Options\"] == \"nosniff\"",
            "            assert r.code == 200",
            "",
            "    def test_static_png_image_200(self):",
            "        \"\"\"Files with extensions listed in app_static_file_handler.py",
            "        `SAFE_APP_STATIC_FILE_EXTENSIONS` (e.g. png) should have the",
            "        `Content-Type` header based on their extension.",
            "        \"\"\"",
            "        response = self.fetch(f\"/app/static/{self._png_image_filename}\")",
            "",
            "        assert response.code == 200",
            "        assert response.headers[\"Content-Type\"] == \"image/png\"",
            "        assert response.headers[\"X-Content-Type-Options\"] == \"nosniff\"",
            "",
            "    def test_static_webp_image_200(self):",
            "        \"\"\"Files with extensions listed in app_static_file_handler.py",
            "        `SAFE_APP_STATIC_FILE_EXTENSIONS` (e.g. webp) should have the",
            "        `Content-Type` header based on their extension.",
            "        \"\"\"",
            "        response = self.fetch(f\"/app/static/{self._webp_image_filename}\")",
            "",
            "        assert response.code == 200",
            "        assert response.headers[\"Content-Type\"] == \"image/webp\"",
            "        assert response.headers[\"X-Content-Type-Options\"] == \"nosniff\"",
            "",
            "    @patch(\"os.path.getsize\", MagicMock(return_value=MAX_APP_STATIC_FILE_SIZE + 1))",
            "    def test_big_file_404(self):",
            "        \"\"\"Files with size greater than MAX_APP_STATIC_FILE_SIZE should return 404.\"\"\"",
            "        response = self.fetch(f\"/app/static/{self._png_image_filename}\")",
            "        assert response.code == 404",
            "        self.assertEqual(",
            "            b\"<html><title>404: File is too large</title>\"",
            "            b\"<body>404: File is too large</body></html>\",",
            "            response.body,",
            "        )",
            "",
            "    def test_staticfiles_404(self):",
            "        \"\"\"Non-existent files, files outside static directory and symlinks pointing to",
            "        files outside static directory and directories should return 404.",
            "        \"\"\"",
            "        responses = [",
            "            # Access to directory without trailing slash",
            "            self.fetch(\"/app/static\"),",
            "            # Access to directory with trailing slash",
            "            self.fetch(\"/app/static/\"),",
            "            # Access to file outside static directory",
            "            self.fetch(\"/app/static/../test_file_outside_directory.py\"),",
            "            # Access to file outside static directory with same prefix",
            "            self.fetch(",
            "                f\"/app/static/{self._tmpdir.name}_foo/test_file_outside_directory.py\"",
            "            ),",
            "            # Access to symlink outside static directory",
            "            self.fetch(f\"/app/static/{self._symlink_outside_directory}\"),",
            "            # Access to non-existent file",
            "            self.fetch(\"/app/static/nonexistent.jpg\"),",
            "        ]",
            "        for r in responses:",
            "            assert r.code == 404",
            "            assert (",
            "                r.body == b\"<html><title>404: Not Found</title>\"",
            "                b\"<body>404: Not Found</body></html>\"",
            "            )"
        ],
        "afterPatchFile": [
            "# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from __future__ import annotations",
            "",
            "import os",
            "import sys",
            "import tempfile",
            "import unittest",
            "from unittest.mock import MagicMock, patch",
            "",
            "import tornado.httpserver",
            "import tornado.testing",
            "import tornado.web",
            "import tornado.websocket",
            "",
            "from streamlit.web.server.app_static_file_handler import (",
            "    MAX_APP_STATIC_FILE_SIZE,",
            "    AppStaticFileHandler,",
            ")",
            "",
            "",
            "@unittest.skipIf(",
            "    \"win32\" in sys.platform,",
            "    \"Most windows installs do not support symlinks except as admin\",",
            ")",
            "class AppStaticFileHandlerTest(tornado.testing.AsyncHTTPTestCase):",
            "    def setUp(self) -> None:",
            "        self._tmpdir = tempfile.TemporaryDirectory(dir=os.getcwd())",
            "        self._tmpfile = tempfile.NamedTemporaryFile(dir=self._tmpdir.name, delete=False)",
            "        self._tmp_js_file = tempfile.NamedTemporaryFile(",
            "            dir=self._tmpdir.name, suffix=\"script.js\", delete=False",
            "        )",
            "        self._tmp_png_image_file = tempfile.NamedTemporaryFile(",
            "            dir=self._tmpdir.name, suffix=\"image.png\", delete=False",
            "        )",
            "        self._tmp_webp_image_file = tempfile.NamedTemporaryFile(",
            "            dir=self._tmpdir.name, suffix=\"image.webp\", delete=False",
            "        )",
            "        self._tmp_dir_inside_static_folder = tempfile.TemporaryDirectory(",
            "            dir=self._tmpdir.name",
            "        )",
            "",
            "        self._symlink_outside_directory = \"symlink_outside\"",
            "        self._symlink_inside_directory = \"symlink_inside\"",
            "",
            "        os.symlink(",
            "            \"/\", os.path.join(self._tmpdir.name, self._symlink_outside_directory)",
            "        )",
            "        os.symlink(",
            "            self._tmpfile.name,",
            "            os.path.join(self._tmpdir.name, self._symlink_inside_directory),",
            "        )",
            "",
            "        self._filename = os.path.basename(self._tmpfile.name)",
            "        self._js_filename = os.path.basename(self._tmp_js_file.name)",
            "        self._png_image_filename = os.path.basename(self._tmp_png_image_file.name)",
            "        self._webp_image_filename = os.path.basename(self._tmp_webp_image_file.name)",
            "",
            "        super().setUp()",
            "",
            "    def tearDown(self) -> None:",
            "        super().tearDown()",
            "        self._tmpdir.cleanup()",
            "",
            "    def get_app(self):",
            "        return tornado.web.Application(",
            "            [",
            "                (",
            "                    r\"/app/static/(.*)\",",
            "                    AppStaticFileHandler,",
            "                    {\"path\": \"%s\" % self._tmpdir.name},",
            "                )",
            "            ]",
            "        )",
            "",
            "    def test_static_files_200(self):",
            "        \"\"\"Files with extensions NOT listed in app_static_file_handler.py",
            "        `SAFE_APP_STATIC_FILE_EXTENSIONS` should have the `Content-Type` header value",
            "        equals to `text-plain`.",
            "        \"\"\"",
            "        responses = [",
            "            # self._filename is file without extension",
            "            self.fetch(f\"/app/static/{self._filename}\"),",
            "            # self._js_filename is file with '.js' extension",
            "            self.fetch(f\"/app/static/{self._js_filename}\"),",
            "            # self._symlink_inside_directory is symlink to",
            "            # self._tmpfile (inside static directory)",
            "            self.fetch(f\"/app/static/{self._symlink_inside_directory}\"),",
            "        ]",
            "        for r in responses:",
            "            assert r.headers[\"Content-Type\"] == \"text/plain\"",
            "            assert r.headers[\"X-Content-Type-Options\"] == \"nosniff\"",
            "            assert r.code == 200",
            "",
            "    def test_static_png_image_200(self):",
            "        \"\"\"Files with extensions listed in app_static_file_handler.py",
            "        `SAFE_APP_STATIC_FILE_EXTENSIONS` (e.g. png) should have the",
            "        `Content-Type` header based on their extension.",
            "        \"\"\"",
            "        response = self.fetch(f\"/app/static/{self._png_image_filename}\")",
            "",
            "        assert response.code == 200",
            "        assert response.headers[\"Content-Type\"] == \"image/png\"",
            "        assert response.headers[\"X-Content-Type-Options\"] == \"nosniff\"",
            "",
            "    def test_static_webp_image_200(self):",
            "        \"\"\"Files with extensions listed in app_static_file_handler.py",
            "        `SAFE_APP_STATIC_FILE_EXTENSIONS` (e.g. webp) should have the",
            "        `Content-Type` header based on their extension.",
            "        \"\"\"",
            "        response = self.fetch(f\"/app/static/{self._webp_image_filename}\")",
            "",
            "        assert response.code == 200",
            "        assert response.headers[\"Content-Type\"] == \"image/webp\"",
            "        assert response.headers[\"X-Content-Type-Options\"] == \"nosniff\"",
            "",
            "    @patch(\"os.path.getsize\", MagicMock(return_value=MAX_APP_STATIC_FILE_SIZE + 1))",
            "    def test_big_file_404(self):",
            "        \"\"\"Files with size greater than MAX_APP_STATIC_FILE_SIZE should return 404.\"\"\"",
            "        response = self.fetch(f\"/app/static/{self._png_image_filename}\")",
            "        assert response.code == 404",
            "        self.assertEqual(",
            "            b\"<html><title>404: File is too large</title>\"",
            "            b\"<body>404: File is too large</body></html>\",",
            "            response.body,",
            "        )",
            "",
            "    def test_staticfiles_404(self):",
            "        \"\"\"Non-existent files, files outside static directory and symlinks pointing to",
            "        files outside static directory and directories should return 404.",
            "        \"\"\"",
            "        responses = [",
            "            # Access to directory without trailing slash",
            "            self.fetch(\"/app/static\"),",
            "            # Access to non-existent file",
            "            self.fetch(\"/app/static/nonexistent.jpg\"),",
            "        ]",
            "        for r in responses:",
            "            assert r.code == 404",
            "            assert (",
            "                r.body == b\"<html><title>404: Not Found</title>\"",
            "                b\"<body>404: Not Found</body></html>\"",
            "            )",
            "",
            "    def test_staticfiles_403(self):",
            "        \"\"\"files outside static directory and symlinks pointing to",
            "        files outside static directory and directories should return 403.",
            "        \"\"\"",
            "        responses = [",
            "            # Access to directory with trailing slash",
            "            self.fetch(\"/app/static/\"),",
            "            # Access to directory inside static folder without trailing slash",
            "            self.fetch(f\"/app/static/{self._tmp_dir_inside_static_folder.name}\"),",
            "            # Access to directory inside static folder with trailing slash",
            "            self.fetch(f\"/app/static/{self._tmp_dir_inside_static_folder.name}/\"),",
            "            # Access to file outside static directory",
            "            self.fetch(\"/app/static/../test_file_outside_directory.py\"),",
            "            # Access to file outside static directory with same prefix",
            "            self.fetch(",
            "                f\"/app/static/{self._tmpdir.name}_foo/test_file_outside_directory.py\"",
            "            ),",
            "            # Access to symlink outside static directory",
            "            self.fetch(f\"/app/static/{self._symlink_outside_directory}\"),",
            "        ]",
            "        for r in responses:",
            "            assert r.code == 403",
            "            assert (",
            "                r.body == b\"<html><title>403: Forbidden</title>\"",
            "                b\"<body>403: Forbidden</body></html>\"",
            "            )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "154": [
                "AppStaticFileHandlerTest",
                "test_staticfiles_404"
            ],
            "155": [
                "AppStaticFileHandlerTest",
                "test_staticfiles_404"
            ],
            "158": [
                "AppStaticFileHandlerTest",
                "test_staticfiles_404"
            ],
            "160": [
                "AppStaticFileHandlerTest",
                "test_staticfiles_404"
            ],
            "161": [
                "AppStaticFileHandlerTest",
                "test_staticfiles_404"
            ]
        },
        "addLocation": [
            "lib.tests.streamlit.web.server.app_static_file_handler_test.AppStaticFileHandlerTest.self",
            "lib.tests.streamlit.web.server.app_static_file_handler_test.AppStaticFileHandlerTest.test_staticfiles_404.responses",
            "src.pyload.core.database.user_database"
        ]
    }
}