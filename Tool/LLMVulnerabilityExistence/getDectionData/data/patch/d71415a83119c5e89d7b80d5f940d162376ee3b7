{
    "planet/auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import pathlib"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+import stat"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import typing"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from typing import Optional"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import httpx"
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " import jwt"
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from . import http"
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from .constants import ENV_API_KEY, PLANET_BASE_URL, SECRET_FILE_PATH"
            },
            "12": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from .exceptions import AuthException"
            },
            "13": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Optional"
            },
            "14": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " LOGGER = logging.getLogger(__name__)"
            },
            "16": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 228,
                "PatchRowcode": " class _SecretFile:"
            },
            "19": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 229,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, path):"
            },
            "21": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.path = path"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+    def __init__(self, path: typing.Union[str, pathlib.Path]):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        self.path = pathlib.Path(path)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        self.permissions = stat.S_IRUSR | stat.S_IWUSR  # user rw"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        # in sdk versions <=2.0.0, secret file was created with the wrong"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        # permissions, fix this automatically as well as catching the unlikely"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        # cases where the permissions get changed externally"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+        self._enforce_permissions()"
            },
            "31": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 239,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "     def write(self, contents: dict):"
            },
            "33": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         try:"
            },
            "34": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 248,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "     def _write(self, contents: dict):"
            },
            "36": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         LOGGER.debug(f'Writing to {self.path}')"
            },
            "37": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with open(self.path, 'w') as fp:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+        def opener(path, flags):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+            return os.open(path, flags, self.permissions)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        with open(self.path, 'w', opener=opener) as fp:"
            },
            "43": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "             fp.write(json.dumps(contents))"
            },
            "44": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 257,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "     def read(self) -> dict:"
            },
            "46": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "         LOGGER.debug(f'Reading from {self.path}')"
            },
            "47": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         with open(self.path, 'r') as fp:"
            },
            "48": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "             contents = json.loads(fp.read())"
            },
            "49": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "         return contents"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+    def _enforce_permissions(self):"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        '''if the file's permissions are not what they should be, fix them'''"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+        try:"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+            # in octal, permissions is the last three bits of the mode"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+            file_permissions = self.path.stat().st_mode & 0o777"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+            if file_permissions != self.permissions:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+                LOGGER.debug("
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+                    f'{self.path} permissions are {oct(file_permissions)}, '"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+                    f'should be {oct(self.permissions)}. Fixing.')"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+                self.path.chmod(self.permissions)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+        except FileNotFoundError:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+            # just skip it if the secret file doesn't exist"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+            pass"
            }
        },
        "frontPatchFile": [
            "# Copyright 2020 Planet Labs, Inc.",
            "# Copyright 2022 Planet Labs PBC.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "'''Manage authentication with Planet APIs'''",
            "from __future__ import annotations  # https://stackoverflow.com/a/33533514",
            "import abc",
            "import json",
            "import logging",
            "import os",
            "import pathlib",
            "import typing",
            "",
            "import httpx",
            "import jwt",
            "",
            "from . import http",
            "from .constants import ENV_API_KEY, PLANET_BASE_URL, SECRET_FILE_PATH",
            "from .exceptions import AuthException",
            "from typing import Optional",
            "",
            "LOGGER = logging.getLogger(__name__)",
            "",
            "BASE_URL = f'{PLANET_BASE_URL}/v0/auth'",
            "",
            "AuthType = httpx.Auth",
            "",
            "",
            "class Auth(metaclass=abc.ABCMeta):",
            "    '''Handle authentication information for use with Planet APIs.'''",
            "",
            "    @staticmethod",
            "    def from_key(key: str) -> AuthType:",
            "        '''Obtain authentication from api key.",
            "",
            "        Parameters:",
            "            key: Planet API key",
            "        '''",
            "        auth = APIKeyAuth(key=key)",
            "        LOGGER.debug('Auth obtained from api key.')",
            "        return auth",
            "",
            "    @staticmethod",
            "    def from_file(",
            "        filename: Optional[typing.Union[str,",
            "                                        pathlib.Path]] = None) -> AuthType:",
            "        '''Create authentication from secret file.",
            "",
            "        The secret file is named `.planet.json` and is stored in the user",
            "        directory. The file has a special format and should have been created",
            "        with `Auth.write()`.",
            "",
            "        Parameters:",
            "            filename: Alternate path for the planet secret file.",
            "",
            "        '''",
            "        filename = filename or SECRET_FILE_PATH",
            "",
            "        try:",
            "            secrets = _SecretFile(filename).read()",
            "            auth = APIKeyAuth.from_dict(secrets)",
            "        except FileNotFoundError:",
            "            raise AuthException(f'File {filename} does not exist.')",
            "        except (KeyError, json.decoder.JSONDecodeError):",
            "            raise AuthException(f'File {filename} is not the correct format.')",
            "",
            "        LOGGER.debug(f'Auth read from secret file {filename}.')",
            "        return auth",
            "",
            "    @staticmethod",
            "    def from_env(variable_name: Optional[str] = None) -> AuthType:",
            "        '''Create authentication from environment variable.",
            "",
            "        Reads the `PL_API_KEY` environment variable",
            "",
            "        Parameters:",
            "            variable_name: Alternate environment variable.",
            "        '''",
            "        variable_name = variable_name or ENV_API_KEY",
            "        api_key = os.getenv(variable_name, '')",
            "        try:",
            "            auth = APIKeyAuth(api_key)",
            "            LOGGER.debug(f'Auth set from environment variable {variable_name}')",
            "        except APIKeyAuthException:",
            "            raise AuthException(",
            "                f'Environment variable {variable_name} either does not exist '",
            "                'or is empty.')",
            "        return auth",
            "",
            "    @staticmethod",
            "    def from_login(email: str,",
            "                   password: str,",
            "                   base_url: Optional[str] = None) -> AuthType:",
            "        '''Create authentication from login email and password.",
            "",
            "        Note: To keep your password secure, the use of `getpass` is",
            "        recommended.",
            "",
            "        Parameters:",
            "            email: Planet account email address.",
            "            password: Planet account password.",
            "            base_url: The base URL to use. Defaults to production",
            "                authentication API base url.",
            "        '''",
            "        cl = AuthClient(base_url=base_url)",
            "        auth_data = cl.login(email, password)",
            "",
            "        api_key = auth_data['api_key']",
            "        auth = APIKeyAuth(api_key)",
            "        LOGGER.debug('Auth set from login email and password')",
            "        return auth",
            "",
            "    @classmethod",
            "    @abc.abstractmethod",
            "    def from_dict(cls, data: dict) -> AuthType:",
            "        pass",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def value(self):",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def to_dict(self) -> dict:",
            "        pass",
            "",
            "    def store(self,",
            "              filename: Optional[typing.Union[str, pathlib.Path]] = None):",
            "        '''Store authentication information in secret file.",
            "",
            "        Parameters:",
            "            filename: Alternate path for the planet secret file.",
            "        '''",
            "        filename = filename or SECRET_FILE_PATH",
            "        secret_file = _SecretFile(filename)",
            "        secret_file.write(self.to_dict())",
            "",
            "",
            "class AuthClient:",
            "",
            "    def __init__(self, base_url: Optional[str] = None):",
            "        \"\"\"",
            "        Parameters:",
            "            base_url: The base URL to use. Defaults to production",
            "                authentication API base url.",
            "        \"\"\"",
            "        self._base_url = base_url or BASE_URL",
            "        if self._base_url.endswith('/'):",
            "            self._base_url = self._base_url[:-1]",
            "",
            "    def login(self, email: str, password: str) -> dict:",
            "        '''Login using email identity and credentials.",
            "",
            "        Note: To keep your password secure, the use of `getpass` is",
            "        recommended.",
            "",
            "        Parameters:",
            "            email: Planet account email address.",
            "            password:  Planet account password.",
            "",
            "        Returns:",
            "             A JSON object containing an `api_key` property with the user's",
            "        API_KEY.",
            "        '''",
            "        url = f'{self._base_url}/login'",
            "        data = {'email': email, 'password': password}",
            "",
            "        sess = http.AuthSession()",
            "        resp = sess.request(url=url, method='POST', json=data)",
            "        return self.decode_response(resp)",
            "",
            "    @staticmethod",
            "    def decode_response(response):",
            "        '''Decode the token JWT'''",
            "        token = response.json()['token']",
            "        return jwt.decode(token, options={'verify_signature': False})",
            "",
            "",
            "class APIKeyAuthException(Exception):",
            "    '''exceptions thrown by APIKeyAuth'''",
            "    pass",
            "",
            "",
            "class APIKeyAuth(httpx.BasicAuth, Auth):",
            "    '''Planet API Key authentication.'''",
            "    DICT_KEY = 'key'",
            "",
            "    def __init__(self, key: str):",
            "        '''Initialize APIKeyAuth.",
            "",
            "        Parameters:",
            "            key: API key.",
            "",
            "        Raises:",
            "            APIKeyException: If API key is None or empty string.",
            "        '''",
            "        if not key:",
            "            raise APIKeyAuthException('API key cannot be empty.')",
            "        self._key = key",
            "        super().__init__(self._key, '')",
            "",
            "    @classmethod",
            "    def from_dict(cls, data: dict) -> APIKeyAuth:",
            "        '''Instantiate APIKeyAuth from a dict.'''",
            "        api_key = data[cls.DICT_KEY]",
            "        return cls(api_key)",
            "",
            "    def to_dict(self):",
            "        '''Represent APIKeyAuth as a dict.'''",
            "        return {self.DICT_KEY: self._key}",
            "",
            "    @property",
            "    def value(self):",
            "        return self._key",
            "",
            "",
            "class _SecretFile:",
            "",
            "    def __init__(self, path):",
            "        self.path = path",
            "",
            "    def write(self, contents: dict):",
            "        try:",
            "            secrets_to_write = self.read()",
            "            secrets_to_write.update(contents)",
            "        except (FileNotFoundError, KeyError, json.decoder.JSONDecodeError):",
            "            secrets_to_write = contents",
            "",
            "        self._write(secrets_to_write)",
            "",
            "    def _write(self, contents: dict):",
            "        LOGGER.debug(f'Writing to {self.path}')",
            "        with open(self.path, 'w') as fp:",
            "            fp.write(json.dumps(contents))",
            "",
            "    def read(self) -> dict:",
            "        LOGGER.debug(f'Reading from {self.path}')",
            "        with open(self.path, 'r') as fp:",
            "            contents = json.loads(fp.read())",
            "        return contents"
        ],
        "afterPatchFile": [
            "# Copyright 2020 Planet Labs, Inc.",
            "# Copyright 2022 Planet Labs PBC.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "'''Manage authentication with Planet APIs'''",
            "from __future__ import annotations  # https://stackoverflow.com/a/33533514",
            "import abc",
            "import json",
            "import logging",
            "import os",
            "import pathlib",
            "import stat",
            "import typing",
            "from typing import Optional",
            "",
            "import httpx",
            "import jwt",
            "",
            "from . import http",
            "from .constants import ENV_API_KEY, PLANET_BASE_URL, SECRET_FILE_PATH",
            "from .exceptions import AuthException",
            "",
            "LOGGER = logging.getLogger(__name__)",
            "",
            "BASE_URL = f'{PLANET_BASE_URL}/v0/auth'",
            "",
            "AuthType = httpx.Auth",
            "",
            "",
            "class Auth(metaclass=abc.ABCMeta):",
            "    '''Handle authentication information for use with Planet APIs.'''",
            "",
            "    @staticmethod",
            "    def from_key(key: str) -> AuthType:",
            "        '''Obtain authentication from api key.",
            "",
            "        Parameters:",
            "            key: Planet API key",
            "        '''",
            "        auth = APIKeyAuth(key=key)",
            "        LOGGER.debug('Auth obtained from api key.')",
            "        return auth",
            "",
            "    @staticmethod",
            "    def from_file(",
            "        filename: Optional[typing.Union[str,",
            "                                        pathlib.Path]] = None) -> AuthType:",
            "        '''Create authentication from secret file.",
            "",
            "        The secret file is named `.planet.json` and is stored in the user",
            "        directory. The file has a special format and should have been created",
            "        with `Auth.write()`.",
            "",
            "        Parameters:",
            "            filename: Alternate path for the planet secret file.",
            "",
            "        '''",
            "        filename = filename or SECRET_FILE_PATH",
            "",
            "        try:",
            "            secrets = _SecretFile(filename).read()",
            "            auth = APIKeyAuth.from_dict(secrets)",
            "        except FileNotFoundError:",
            "            raise AuthException(f'File {filename} does not exist.')",
            "        except (KeyError, json.decoder.JSONDecodeError):",
            "            raise AuthException(f'File {filename} is not the correct format.')",
            "",
            "        LOGGER.debug(f'Auth read from secret file {filename}.')",
            "        return auth",
            "",
            "    @staticmethod",
            "    def from_env(variable_name: Optional[str] = None) -> AuthType:",
            "        '''Create authentication from environment variable.",
            "",
            "        Reads the `PL_API_KEY` environment variable",
            "",
            "        Parameters:",
            "            variable_name: Alternate environment variable.",
            "        '''",
            "        variable_name = variable_name or ENV_API_KEY",
            "        api_key = os.getenv(variable_name, '')",
            "        try:",
            "            auth = APIKeyAuth(api_key)",
            "            LOGGER.debug(f'Auth set from environment variable {variable_name}')",
            "        except APIKeyAuthException:",
            "            raise AuthException(",
            "                f'Environment variable {variable_name} either does not exist '",
            "                'or is empty.')",
            "        return auth",
            "",
            "    @staticmethod",
            "    def from_login(email: str,",
            "                   password: str,",
            "                   base_url: Optional[str] = None) -> AuthType:",
            "        '''Create authentication from login email and password.",
            "",
            "        Note: To keep your password secure, the use of `getpass` is",
            "        recommended.",
            "",
            "        Parameters:",
            "            email: Planet account email address.",
            "            password: Planet account password.",
            "            base_url: The base URL to use. Defaults to production",
            "                authentication API base url.",
            "        '''",
            "        cl = AuthClient(base_url=base_url)",
            "        auth_data = cl.login(email, password)",
            "",
            "        api_key = auth_data['api_key']",
            "        auth = APIKeyAuth(api_key)",
            "        LOGGER.debug('Auth set from login email and password')",
            "        return auth",
            "",
            "    @classmethod",
            "    @abc.abstractmethod",
            "    def from_dict(cls, data: dict) -> AuthType:",
            "        pass",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def value(self):",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def to_dict(self) -> dict:",
            "        pass",
            "",
            "    def store(self,",
            "              filename: Optional[typing.Union[str, pathlib.Path]] = None):",
            "        '''Store authentication information in secret file.",
            "",
            "        Parameters:",
            "            filename: Alternate path for the planet secret file.",
            "        '''",
            "        filename = filename or SECRET_FILE_PATH",
            "        secret_file = _SecretFile(filename)",
            "        secret_file.write(self.to_dict())",
            "",
            "",
            "class AuthClient:",
            "",
            "    def __init__(self, base_url: Optional[str] = None):",
            "        \"\"\"",
            "        Parameters:",
            "            base_url: The base URL to use. Defaults to production",
            "                authentication API base url.",
            "        \"\"\"",
            "        self._base_url = base_url or BASE_URL",
            "        if self._base_url.endswith('/'):",
            "            self._base_url = self._base_url[:-1]",
            "",
            "    def login(self, email: str, password: str) -> dict:",
            "        '''Login using email identity and credentials.",
            "",
            "        Note: To keep your password secure, the use of `getpass` is",
            "        recommended.",
            "",
            "        Parameters:",
            "            email: Planet account email address.",
            "            password:  Planet account password.",
            "",
            "        Returns:",
            "             A JSON object containing an `api_key` property with the user's",
            "        API_KEY.",
            "        '''",
            "        url = f'{self._base_url}/login'",
            "        data = {'email': email, 'password': password}",
            "",
            "        sess = http.AuthSession()",
            "        resp = sess.request(url=url, method='POST', json=data)",
            "        return self.decode_response(resp)",
            "",
            "    @staticmethod",
            "    def decode_response(response):",
            "        '''Decode the token JWT'''",
            "        token = response.json()['token']",
            "        return jwt.decode(token, options={'verify_signature': False})",
            "",
            "",
            "class APIKeyAuthException(Exception):",
            "    '''exceptions thrown by APIKeyAuth'''",
            "    pass",
            "",
            "",
            "class APIKeyAuth(httpx.BasicAuth, Auth):",
            "    '''Planet API Key authentication.'''",
            "    DICT_KEY = 'key'",
            "",
            "    def __init__(self, key: str):",
            "        '''Initialize APIKeyAuth.",
            "",
            "        Parameters:",
            "            key: API key.",
            "",
            "        Raises:",
            "            APIKeyException: If API key is None or empty string.",
            "        '''",
            "        if not key:",
            "            raise APIKeyAuthException('API key cannot be empty.')",
            "        self._key = key",
            "        super().__init__(self._key, '')",
            "",
            "    @classmethod",
            "    def from_dict(cls, data: dict) -> APIKeyAuth:",
            "        '''Instantiate APIKeyAuth from a dict.'''",
            "        api_key = data[cls.DICT_KEY]",
            "        return cls(api_key)",
            "",
            "    def to_dict(self):",
            "        '''Represent APIKeyAuth as a dict.'''",
            "        return {self.DICT_KEY: self._key}",
            "",
            "    @property",
            "    def value(self):",
            "        return self._key",
            "",
            "",
            "class _SecretFile:",
            "",
            "    def __init__(self, path: typing.Union[str, pathlib.Path]):",
            "        self.path = pathlib.Path(path)",
            "",
            "        self.permissions = stat.S_IRUSR | stat.S_IWUSR  # user rw",
            "",
            "        # in sdk versions <=2.0.0, secret file was created with the wrong",
            "        # permissions, fix this automatically as well as catching the unlikely",
            "        # cases where the permissions get changed externally",
            "        self._enforce_permissions()",
            "",
            "    def write(self, contents: dict):",
            "        try:",
            "            secrets_to_write = self.read()",
            "            secrets_to_write.update(contents)",
            "        except (FileNotFoundError, KeyError, json.decoder.JSONDecodeError):",
            "            secrets_to_write = contents",
            "",
            "        self._write(secrets_to_write)",
            "",
            "    def _write(self, contents: dict):",
            "        LOGGER.debug(f'Writing to {self.path}')",
            "",
            "        def opener(path, flags):",
            "            return os.open(path, flags, self.permissions)",
            "",
            "        with open(self.path, 'w', opener=opener) as fp:",
            "            fp.write(json.dumps(contents))",
            "",
            "    def read(self) -> dict:",
            "        LOGGER.debug(f'Reading from {self.path}')",
            "        with open(self.path, 'r') as fp:",
            "            contents = json.loads(fp.read())",
            "        return contents",
            "",
            "    def _enforce_permissions(self):",
            "        '''if the file's permissions are not what they should be, fix them'''",
            "        try:",
            "            # in octal, permissions is the last three bits of the mode",
            "            file_permissions = self.path.stat().st_mode & 0o777",
            "            if file_permissions != self.permissions:",
            "                LOGGER.debug(",
            "                    f'{self.path} permissions are {oct(file_permissions)}, '",
            "                    f'should be {oct(self.permissions)}. Fixing.')",
            "                self.path.chmod(self.permissions)",
            "        except FileNotFoundError:",
            "            # just skip it if the secret file doesn't exist",
            "            pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "30": [],
            "229": [
                "_SecretFile",
                "__init__"
            ],
            "230": [
                "_SecretFile",
                "__init__"
            ],
            "243": [
                "_SecretFile",
                "_write"
            ]
        },
        "addLocation": []
    }
}