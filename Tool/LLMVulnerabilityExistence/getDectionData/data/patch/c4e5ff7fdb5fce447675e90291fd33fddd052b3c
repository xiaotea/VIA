{
    "django/middleware/common.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from django.http import HttpResponsePermanentRedirect"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.urls import is_valid_path"
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.utils.deprecation import MiddlewareMixin"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from django.utils.http import escape_leading_slashes"
            },
            "4": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " class CommonMiddleware(MiddlewareMixin):"
            },
            "7": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         POST, PUT, or PATCH."
            },
            "8": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         new_path = request.get_full_path(force_append_slash=True)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        # Prevent construction of scheme relative urls."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        new_path = escape_leading_slashes(new_path)"
            },
            "12": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         if settings.DEBUG and request.method in ('POST', 'PUT', 'PATCH'):"
            },
            "13": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "             raise RuntimeError("
            },
            "14": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                 \"You called this URL via %(method)s, but the URL doesn't end \""
            }
        },
        "frontPatchFile": [
            "import re",
            "from urllib.parse import urlparse",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import PermissionDenied",
            "from django.core.mail import mail_managers",
            "from django.http import HttpResponsePermanentRedirect",
            "from django.urls import is_valid_path",
            "from django.utils.deprecation import MiddlewareMixin",
            "",
            "",
            "class CommonMiddleware(MiddlewareMixin):",
            "    \"\"\"",
            "    \"Common\" middleware for taking care of some basic operations:",
            "",
            "        - Forbid access to User-Agents in settings.DISALLOWED_USER_AGENTS",
            "",
            "        - URL rewriting: Based on the APPEND_SLASH and PREPEND_WWW settings,",
            "          append missing slashes and/or prepends missing \"www.\"s.",
            "",
            "            - If APPEND_SLASH is set and the initial URL doesn't end with a",
            "              slash, and it is not found in urlpatterns, form a new URL by",
            "              appending a slash at the end. If this new URL is found in",
            "              urlpatterns, return an HTTP redirect to this new URL; otherwise",
            "              process the initial URL as usual.",
            "",
            "          This behavior can be customized by subclassing CommonMiddleware and",
            "          overriding the response_redirect_class attribute.",
            "    \"\"\"",
            "",
            "    response_redirect_class = HttpResponsePermanentRedirect",
            "",
            "    def process_request(self, request):",
            "        \"\"\"",
            "        Check for denied User-Agents and rewrite the URL based on",
            "        settings.APPEND_SLASH and settings.PREPEND_WWW",
            "        \"\"\"",
            "",
            "        # Check for denied User-Agents",
            "        if 'HTTP_USER_AGENT' in request.META:",
            "            for user_agent_regex in settings.DISALLOWED_USER_AGENTS:",
            "                if user_agent_regex.search(request.META['HTTP_USER_AGENT']):",
            "                    raise PermissionDenied('Forbidden user agent')",
            "",
            "        # Check for a redirect based on settings.PREPEND_WWW",
            "        host = request.get_host()",
            "        must_prepend = settings.PREPEND_WWW and host and not host.startswith('www.')",
            "        redirect_url = ('%s://www.%s' % (request.scheme, host)) if must_prepend else ''",
            "",
            "        # Check if a slash should be appended",
            "        if self.should_redirect_with_slash(request):",
            "            path = self.get_full_path_with_slash(request)",
            "        else:",
            "            path = request.get_full_path()",
            "",
            "        # Return a redirect if necessary",
            "        if redirect_url or path != request.get_full_path():",
            "            redirect_url += path",
            "            return self.response_redirect_class(redirect_url)",
            "",
            "    def should_redirect_with_slash(self, request):",
            "        \"\"\"",
            "        Return True if settings.APPEND_SLASH is True and appending a slash to",
            "        the request path turns an invalid path into a valid one.",
            "        \"\"\"",
            "        if settings.APPEND_SLASH and not request.path_info.endswith('/'):",
            "            urlconf = getattr(request, 'urlconf', None)",
            "            return (",
            "                not is_valid_path(request.path_info, urlconf) and",
            "                is_valid_path('%s/' % request.path_info, urlconf)",
            "            )",
            "        return False",
            "",
            "    def get_full_path_with_slash(self, request):",
            "        \"\"\"",
            "        Return the full path of the request with a trailing slash appended.",
            "",
            "        Raise a RuntimeError if settings.DEBUG is True and request.method is",
            "        POST, PUT, or PATCH.",
            "        \"\"\"",
            "        new_path = request.get_full_path(force_append_slash=True)",
            "        if settings.DEBUG and request.method in ('POST', 'PUT', 'PATCH'):",
            "            raise RuntimeError(",
            "                \"You called this URL via %(method)s, but the URL doesn't end \"",
            "                \"in a slash and you have APPEND_SLASH set. Django can't \"",
            "                \"redirect to the slash URL while maintaining %(method)s data. \"",
            "                \"Change your form to point to %(url)s (note the trailing \"",
            "                \"slash), or set APPEND_SLASH=False in your Django settings.\" % {",
            "                    'method': request.method,",
            "                    'url': request.get_host() + new_path,",
            "                }",
            "            )",
            "        return new_path",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        When the status code of the response is 404, it may redirect to a path",
            "        with an appended slash if should_redirect_with_slash() returns True.",
            "        \"\"\"",
            "        # If the given URL is \"Not Found\", then check if we should redirect to",
            "        # a path with a slash appended.",
            "        if response.status_code == 404:",
            "            if self.should_redirect_with_slash(request):",
            "                return self.response_redirect_class(self.get_full_path_with_slash(request))",
            "",
            "        # Add the Content-Length header to non-streaming responses if not",
            "        # already set.",
            "        if not response.streaming and not response.has_header('Content-Length'):",
            "            response['Content-Length'] = str(len(response.content))",
            "",
            "        return response",
            "",
            "",
            "class BrokenLinkEmailsMiddleware(MiddlewareMixin):",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"Send broken link emails for relevant 404 NOT FOUND responses.\"\"\"",
            "        if response.status_code == 404 and not settings.DEBUG:",
            "            domain = request.get_host()",
            "            path = request.get_full_path()",
            "            referer = request.META.get('HTTP_REFERER', '')",
            "",
            "            if not self.is_ignorable_request(request, path, domain, referer):",
            "                ua = request.META.get('HTTP_USER_AGENT', '<none>')",
            "                ip = request.META.get('REMOTE_ADDR', '<none>')",
            "                mail_managers(",
            "                    \"Broken %slink on %s\" % (",
            "                        ('INTERNAL ' if self.is_internal_request(domain, referer) else ''),",
            "                        domain",
            "                    ),",
            "                    \"Referrer: %s\\nRequested URL: %s\\nUser agent: %s\\n\"",
            "                    \"IP address: %s\\n\" % (referer, path, ua, ip),",
            "                    fail_silently=True,",
            "                )",
            "        return response",
            "",
            "    def is_internal_request(self, domain, referer):",
            "        \"\"\"",
            "        Return True if the referring URL is the same domain as the current",
            "        request.",
            "        \"\"\"",
            "        # Different subdomains are treated as different domains.",
            "        return bool(re.match(\"^https?://%s/\" % re.escape(domain), referer))",
            "",
            "    def is_ignorable_request(self, request, uri, domain, referer):",
            "        \"\"\"",
            "        Return True if the given request *shouldn't* notify the site managers",
            "        according to project settings or in situations outlined by the inline",
            "        comments.",
            "        \"\"\"",
            "        # The referer is empty.",
            "        if not referer:",
            "            return True",
            "",
            "        # APPEND_SLASH is enabled and the referer is equal to the current URL",
            "        # without a trailing slash indicating an internal redirect.",
            "        if settings.APPEND_SLASH and uri.endswith('/') and referer == uri[:-1]:",
            "            return True",
            "",
            "        # A '?' in referer is identified as a search engine source.",
            "        if not self.is_internal_request(domain, referer) and '?' in referer:",
            "            return True",
            "",
            "        # The referer is equal to the current URL, ignoring the scheme (assumed",
            "        # to be a poorly implemented bot).",
            "        parsed_referer = urlparse(referer)",
            "        if parsed_referer.netloc in ['', domain] and parsed_referer.path == uri:",
            "            return True",
            "",
            "        return any(pattern.search(uri) for pattern in settings.IGNORABLE_404_URLS)"
        ],
        "afterPatchFile": [
            "import re",
            "from urllib.parse import urlparse",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import PermissionDenied",
            "from django.core.mail import mail_managers",
            "from django.http import HttpResponsePermanentRedirect",
            "from django.urls import is_valid_path",
            "from django.utils.deprecation import MiddlewareMixin",
            "from django.utils.http import escape_leading_slashes",
            "",
            "",
            "class CommonMiddleware(MiddlewareMixin):",
            "    \"\"\"",
            "    \"Common\" middleware for taking care of some basic operations:",
            "",
            "        - Forbid access to User-Agents in settings.DISALLOWED_USER_AGENTS",
            "",
            "        - URL rewriting: Based on the APPEND_SLASH and PREPEND_WWW settings,",
            "          append missing slashes and/or prepends missing \"www.\"s.",
            "",
            "            - If APPEND_SLASH is set and the initial URL doesn't end with a",
            "              slash, and it is not found in urlpatterns, form a new URL by",
            "              appending a slash at the end. If this new URL is found in",
            "              urlpatterns, return an HTTP redirect to this new URL; otherwise",
            "              process the initial URL as usual.",
            "",
            "          This behavior can be customized by subclassing CommonMiddleware and",
            "          overriding the response_redirect_class attribute.",
            "    \"\"\"",
            "",
            "    response_redirect_class = HttpResponsePermanentRedirect",
            "",
            "    def process_request(self, request):",
            "        \"\"\"",
            "        Check for denied User-Agents and rewrite the URL based on",
            "        settings.APPEND_SLASH and settings.PREPEND_WWW",
            "        \"\"\"",
            "",
            "        # Check for denied User-Agents",
            "        if 'HTTP_USER_AGENT' in request.META:",
            "            for user_agent_regex in settings.DISALLOWED_USER_AGENTS:",
            "                if user_agent_regex.search(request.META['HTTP_USER_AGENT']):",
            "                    raise PermissionDenied('Forbidden user agent')",
            "",
            "        # Check for a redirect based on settings.PREPEND_WWW",
            "        host = request.get_host()",
            "        must_prepend = settings.PREPEND_WWW and host and not host.startswith('www.')",
            "        redirect_url = ('%s://www.%s' % (request.scheme, host)) if must_prepend else ''",
            "",
            "        # Check if a slash should be appended",
            "        if self.should_redirect_with_slash(request):",
            "            path = self.get_full_path_with_slash(request)",
            "        else:",
            "            path = request.get_full_path()",
            "",
            "        # Return a redirect if necessary",
            "        if redirect_url or path != request.get_full_path():",
            "            redirect_url += path",
            "            return self.response_redirect_class(redirect_url)",
            "",
            "    def should_redirect_with_slash(self, request):",
            "        \"\"\"",
            "        Return True if settings.APPEND_SLASH is True and appending a slash to",
            "        the request path turns an invalid path into a valid one.",
            "        \"\"\"",
            "        if settings.APPEND_SLASH and not request.path_info.endswith('/'):",
            "            urlconf = getattr(request, 'urlconf', None)",
            "            return (",
            "                not is_valid_path(request.path_info, urlconf) and",
            "                is_valid_path('%s/' % request.path_info, urlconf)",
            "            )",
            "        return False",
            "",
            "    def get_full_path_with_slash(self, request):",
            "        \"\"\"",
            "        Return the full path of the request with a trailing slash appended.",
            "",
            "        Raise a RuntimeError if settings.DEBUG is True and request.method is",
            "        POST, PUT, or PATCH.",
            "        \"\"\"",
            "        new_path = request.get_full_path(force_append_slash=True)",
            "        # Prevent construction of scheme relative urls.",
            "        new_path = escape_leading_slashes(new_path)",
            "        if settings.DEBUG and request.method in ('POST', 'PUT', 'PATCH'):",
            "            raise RuntimeError(",
            "                \"You called this URL via %(method)s, but the URL doesn't end \"",
            "                \"in a slash and you have APPEND_SLASH set. Django can't \"",
            "                \"redirect to the slash URL while maintaining %(method)s data. \"",
            "                \"Change your form to point to %(url)s (note the trailing \"",
            "                \"slash), or set APPEND_SLASH=False in your Django settings.\" % {",
            "                    'method': request.method,",
            "                    'url': request.get_host() + new_path,",
            "                }",
            "            )",
            "        return new_path",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        When the status code of the response is 404, it may redirect to a path",
            "        with an appended slash if should_redirect_with_slash() returns True.",
            "        \"\"\"",
            "        # If the given URL is \"Not Found\", then check if we should redirect to",
            "        # a path with a slash appended.",
            "        if response.status_code == 404:",
            "            if self.should_redirect_with_slash(request):",
            "                return self.response_redirect_class(self.get_full_path_with_slash(request))",
            "",
            "        # Add the Content-Length header to non-streaming responses if not",
            "        # already set.",
            "        if not response.streaming and not response.has_header('Content-Length'):",
            "            response['Content-Length'] = str(len(response.content))",
            "",
            "        return response",
            "",
            "",
            "class BrokenLinkEmailsMiddleware(MiddlewareMixin):",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"Send broken link emails for relevant 404 NOT FOUND responses.\"\"\"",
            "        if response.status_code == 404 and not settings.DEBUG:",
            "            domain = request.get_host()",
            "            path = request.get_full_path()",
            "            referer = request.META.get('HTTP_REFERER', '')",
            "",
            "            if not self.is_ignorable_request(request, path, domain, referer):",
            "                ua = request.META.get('HTTP_USER_AGENT', '<none>')",
            "                ip = request.META.get('REMOTE_ADDR', '<none>')",
            "                mail_managers(",
            "                    \"Broken %slink on %s\" % (",
            "                        ('INTERNAL ' if self.is_internal_request(domain, referer) else ''),",
            "                        domain",
            "                    ),",
            "                    \"Referrer: %s\\nRequested URL: %s\\nUser agent: %s\\n\"",
            "                    \"IP address: %s\\n\" % (referer, path, ua, ip),",
            "                    fail_silently=True,",
            "                )",
            "        return response",
            "",
            "    def is_internal_request(self, domain, referer):",
            "        \"\"\"",
            "        Return True if the referring URL is the same domain as the current",
            "        request.",
            "        \"\"\"",
            "        # Different subdomains are treated as different domains.",
            "        return bool(re.match(\"^https?://%s/\" % re.escape(domain), referer))",
            "",
            "    def is_ignorable_request(self, request, uri, domain, referer):",
            "        \"\"\"",
            "        Return True if the given request *shouldn't* notify the site managers",
            "        according to project settings or in situations outlined by the inline",
            "        comments.",
            "        \"\"\"",
            "        # The referer is empty.",
            "        if not referer:",
            "            return True",
            "",
            "        # APPEND_SLASH is enabled and the referer is equal to the current URL",
            "        # without a trailing slash indicating an internal redirect.",
            "        if settings.APPEND_SLASH and uri.endswith('/') and referer == uri[:-1]:",
            "            return True",
            "",
            "        # A '?' in referer is identified as a search engine source.",
            "        if not self.is_internal_request(domain, referer) and '?' in referer:",
            "            return True",
            "",
            "        # The referer is equal to the current URL, ignoring the scheme (assumed",
            "        # to be a poorly implemented bot).",
            "        parsed_referer = urlparse(referer)",
            "        if parsed_referer.netloc in ['', domain] and parsed_referer.path == uri:",
            "            return True",
            "",
            "        return any(pattern.search(uri) for pattern in settings.IGNORABLE_404_URLS)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tensorflow.python.ops.image_ops_test.RGBToHSVTest",
            "django.middleware.common.CommonMiddleware.process_response",
            "django.middleware.common.CommonMiddleware.process_request"
        ]
    },
    "django/urls/resolvers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from django.core.exceptions import ImproperlyConfigured"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from django.utils.datastructures import MultiValueDict"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from django.utils.functional import cached_property"
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.http import RFC3986_SUBDELIMS"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from django.utils.http import RFC3986_SUBDELIMS, escape_leading_slashes"
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from django.utils.regex_helper import normalize"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from django.utils.translation import get_language"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 592,
                "PatchRowcode": "                     # safe characters from `pchar` definition of RFC 3986"
            },
            "9": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 593,
                "PatchRowcode": "                     url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')"
            },
            "10": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 594,
                "PatchRowcode": "                     # Don't allow construction of scheme relative urls."
            },
            "11": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if url.startswith('//'):"
            },
            "12": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        url = '/%%2F%s' % url[2:]"
            },
            "13": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return url"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 595,
                "PatchRowcode": "+                    return escape_leading_slashes(url)"
            },
            "15": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": 596,
                "PatchRowcode": "         # lookup_view can be URL name or callable, but callables are not"
            },
            "16": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": 597,
                "PatchRowcode": "         # friendly in error messages."
            },
            "17": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": 598,
                "PatchRowcode": "         m = getattr(lookup_view, '__module__', None)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "This module converts requested URLs to callback view functions.",
            "",
            "URLResolver is the main class here. Its resolve() method takes a URL (as",
            "a string) and returns a ResolverMatch object which provides access to all",
            "attributes of the resolved URL match.",
            "\"\"\"",
            "import functools",
            "import re",
            "import threading",
            "from importlib import import_module",
            "from urllib.parse import quote",
            "",
            "from django.conf import settings",
            "from django.core.checks import Warning",
            "from django.core.checks.urls import check_resolver",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.functional import cached_property",
            "from django.utils.http import RFC3986_SUBDELIMS",
            "from django.utils.regex_helper import normalize",
            "from django.utils.translation import get_language",
            "",
            "from .converters import get_converter",
            "from .exceptions import NoReverseMatch, Resolver404",
            "from .utils import get_callable",
            "",
            "",
            "class ResolverMatch:",
            "    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None):",
            "        self.func = func",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "        self.url_name = url_name",
            "",
            "        # If a URLRegexResolver doesn't have a namespace or app_name, it passes",
            "        # in an empty value.",
            "        self.app_names = [x for x in app_names if x] if app_names else []",
            "        self.app_name = ':'.join(self.app_names)",
            "        self.namespaces = [x for x in namespaces if x] if namespaces else []",
            "        self.namespace = ':'.join(self.namespaces)",
            "",
            "        if not hasattr(func, '__name__'):",
            "            # A class-based view",
            "            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__",
            "        else:",
            "            # A function-based view",
            "            self._func_path = func.__module__ + '.' + func.__name__",
            "",
            "        view_path = url_name or self._func_path",
            "        self.view_name = ':'.join(self.namespaces + [view_path])",
            "",
            "    def __getitem__(self, index):",
            "        return (self.func, self.args, self.kwargs)[index]",
            "",
            "    def __repr__(self):",
            "        return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s)\" % (",
            "            self._func_path, self.args, self.kwargs, self.url_name,",
            "            self.app_names, self.namespaces,",
            "        )",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def get_resolver(urlconf=None):",
            "    if urlconf is None:",
            "        urlconf = settings.ROOT_URLCONF",
            "    return URLResolver(RegexPattern(r'^/'), urlconf)",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def get_ns_resolver(ns_pattern, resolver, converters):",
            "    # Build a namespaced resolver for the given parent URLconf pattern.",
            "    # This makes it possible to have captured parameters in the parent",
            "    # URLconf pattern.",
            "    pattern = RegexPattern(ns_pattern)",
            "    pattern.converters = dict(converters)",
            "    ns_resolver = URLResolver(pattern, resolver.url_patterns)",
            "    return URLResolver(RegexPattern(r'^/'), [ns_resolver])",
            "",
            "",
            "class LocaleRegexDescriptor:",
            "    def __init__(self, attr):",
            "        self.attr = attr",
            "",
            "    def __get__(self, instance, cls=None):",
            "        \"\"\"",
            "        Return a compiled regular expression based on the active language.",
            "        \"\"\"",
            "        if instance is None:",
            "            return self",
            "        # As a performance optimization, if the given regex string is a regular",
            "        # string (not a lazily-translated string proxy), compile it once and",
            "        # avoid per-language compilation.",
            "        pattern = getattr(instance, self.attr)",
            "        if isinstance(pattern, str):",
            "            instance.__dict__['regex'] = instance._compile(pattern)",
            "            return instance.__dict__['regex']",
            "        language_code = get_language()",
            "        if language_code not in instance._regex_dict:",
            "            instance._regex_dict[language_code] = instance._compile(str(pattern))",
            "        return instance._regex_dict[language_code]",
            "",
            "",
            "class CheckURLMixin:",
            "    def describe(self):",
            "        \"\"\"",
            "        Format the URL pattern for display in warning messages.",
            "        \"\"\"",
            "        description = \"'{}'\".format(self)",
            "        if self.name:",
            "            description += \" [name='{}']\".format(self.name)",
            "        return description",
            "",
            "    def _check_pattern_startswith_slash(self):",
            "        \"\"\"",
            "        Check that the pattern does not begin with a forward slash.",
            "        \"\"\"",
            "        regex_pattern = self.regex.pattern",
            "        if not settings.APPEND_SLASH:",
            "            # Skip check as it can be useful to start a URL pattern with a slash",
            "            # when APPEND_SLASH=False.",
            "            return []",
            "        if regex_pattern.startswith(('/', '^/', '^\\\\/')) and not regex_pattern.endswith('/'):",
            "            warning = Warning(",
            "                \"Your URL pattern {} has a route beginning with a '/'. Remove this \"",
            "                \"slash as it is unnecessary. If this pattern is targeted in an \"",
            "                \"include(), ensure the include() pattern has a trailing '/'.\".format(",
            "                    self.describe()",
            "                ),",
            "                id=\"urls.W002\",",
            "            )",
            "            return [warning]",
            "        else:",
            "            return []",
            "",
            "",
            "class RegexPattern(CheckURLMixin):",
            "    regex = LocaleRegexDescriptor('_regex')",
            "",
            "    def __init__(self, regex, name=None, is_endpoint=False):",
            "        self._regex = regex",
            "        self._regex_dict = {}",
            "        self._is_endpoint = is_endpoint",
            "        self.name = name",
            "        self.converters = {}",
            "",
            "    def match(self, path):",
            "        match = self.regex.search(path)",
            "        if match:",
            "            # If there are any named groups, use those as kwargs, ignoring",
            "            # non-named groups. Otherwise, pass all non-named arguments as",
            "            # positional arguments.",
            "            kwargs = match.groupdict()",
            "            args = () if kwargs else match.groups()",
            "            return path[match.end():], args, kwargs",
            "        return None",
            "",
            "    def check(self):",
            "        warnings = []",
            "        warnings.extend(self._check_pattern_startswith_slash())",
            "        if not self._is_endpoint:",
            "            warnings.extend(self._check_include_trailing_dollar())",
            "        return warnings",
            "",
            "    def _check_include_trailing_dollar(self):",
            "        regex_pattern = self.regex.pattern",
            "        if regex_pattern.endswith('$') and not regex_pattern.endswith(r'\\$'):",
            "            return [Warning(",
            "                \"Your URL pattern {} uses include with a route ending with a '$'. \"",
            "                \"Remove the dollar from the route to avoid problems including \"",
            "                \"URLs.\".format(self.describe()),",
            "                id='urls.W001',",
            "            )]",
            "        else:",
            "            return []",
            "",
            "    def _compile(self, regex):",
            "        \"\"\"Compile and return the given regular expression.\"\"\"",
            "        try:",
            "            return re.compile(regex)",
            "        except re.error as e:",
            "            raise ImproperlyConfigured(",
            "                '\"%s\" is not a valid regular expression: %s' % (regex, e)",
            "            )",
            "",
            "    def __str__(self):",
            "        return str(self._regex)",
            "",
            "",
            "_PATH_PARAMETER_COMPONENT_RE = re.compile(",
            "    r'<(?:(?P<converter>[^>:]+):)?(?P<parameter>\\w+)>'",
            ")",
            "",
            "",
            "def _route_to_regex(route, is_endpoint=False):",
            "    \"\"\"",
            "    Convert a path pattern into a regular expression. Return the regular",
            "    expression and a dictionary mapping the capture names to the converters.",
            "    For example, 'foo/<int:pk>' returns '^foo\\\\/(?P<pk>[0-9]+)'",
            "    and {'pk': <django.urls.converters.IntConverter>}.",
            "    \"\"\"",
            "    original_route = route",
            "    parts = ['^']",
            "    converters = {}",
            "    while True:",
            "        match = _PATH_PARAMETER_COMPONENT_RE.search(route)",
            "        if not match:",
            "            parts.append(re.escape(route))",
            "            break",
            "        parts.append(re.escape(route[:match.start()]))",
            "        route = route[match.end():]",
            "        parameter = match.group('parameter')",
            "        if not parameter.isidentifier():",
            "            raise ImproperlyConfigured(",
            "                \"URL route '%s' uses parameter name %r which isn't a valid \"",
            "                \"Python identifier.\" % (original_route, parameter)",
            "            )",
            "        raw_converter = match.group('converter')",
            "        if raw_converter is None:",
            "            # If a converter isn't specified, the default is `str`.",
            "            raw_converter = 'str'",
            "        try:",
            "            converter = get_converter(raw_converter)",
            "        except KeyError as e:",
            "            raise ImproperlyConfigured(",
            "                \"URL route '%s' uses invalid converter %s.\" % (original_route, e)",
            "            )",
            "        converters[parameter] = converter",
            "        parts.append('(?P<' + parameter + '>' + converter.regex + ')')",
            "    if is_endpoint:",
            "        parts.append('$')",
            "    return ''.join(parts), converters",
            "",
            "",
            "class RoutePattern(CheckURLMixin):",
            "    regex = LocaleRegexDescriptor('_route')",
            "",
            "    def __init__(self, route, name=None, is_endpoint=False):",
            "        self._route = route",
            "        self._regex_dict = {}",
            "        self._is_endpoint = is_endpoint",
            "        self.name = name",
            "        self.converters = _route_to_regex(str(route), is_endpoint)[1]",
            "",
            "    def match(self, path):",
            "        match = self.regex.search(path)",
            "        if match:",
            "            # RoutePattern doesn't allow non-named groups so args are ignored.",
            "            kwargs = match.groupdict()",
            "            for key, value in kwargs.items():",
            "                converter = self.converters[key]",
            "                try:",
            "                    kwargs[key] = converter.to_python(value)",
            "                except ValueError:",
            "                    return None",
            "            return path[match.end():], (), kwargs",
            "        return None",
            "",
            "    def check(self):",
            "        warnings = self._check_pattern_startswith_slash()",
            "        route = self._route",
            "        if '(?P<' in route or route.startswith('^') or route.endswith('$'):",
            "            warnings.append(Warning(",
            "                \"Your URL pattern {} has a route that contains '(?P<', begins \"",
            "                \"with a '^', or ends with a '$'. This was likely an oversight \"",
            "                \"when migrating to django.urls.path().\".format(self.describe()),",
            "                id='2_0.W001',",
            "            ))",
            "        return warnings",
            "",
            "    def _compile(self, route):",
            "        return re.compile(_route_to_regex(route, self._is_endpoint)[0])",
            "",
            "    def __str__(self):",
            "        return str(self._route)",
            "",
            "",
            "class LocalePrefixPattern:",
            "    def __init__(self, prefix_default_language=True):",
            "        self.prefix_default_language = prefix_default_language",
            "        self.converters = {}",
            "",
            "    @property",
            "    def regex(self):",
            "        # This is only used by reverse() and cached in _reverse_dict.",
            "        return re.compile(self.language_prefix)",
            "",
            "    @property",
            "    def language_prefix(self):",
            "        language_code = get_language() or settings.LANGUAGE_CODE",
            "        if language_code == settings.LANGUAGE_CODE and not self.prefix_default_language:",
            "            return ''",
            "        else:",
            "            return '%s/' % language_code",
            "",
            "    def match(self, path):",
            "        language_prefix = self.language_prefix",
            "        if path.startswith(language_prefix):",
            "            return path[len(language_prefix):], (), {}",
            "        return None",
            "",
            "    def check(self):",
            "        return []",
            "",
            "    def describe(self):",
            "        return \"'{}'\".format(self)",
            "",
            "    def __str__(self):",
            "        return self.language_prefix",
            "",
            "",
            "class URLPattern:",
            "    def __init__(self, pattern, callback, default_args=None, name=None):",
            "        self.pattern = pattern",
            "        self.callback = callback  # the view",
            "        self.default_args = default_args or {}",
            "        self.name = name",
            "",
            "    def __repr__(self):",
            "        return '<%s %s>' % (self.__class__.__name__, self.pattern.describe())",
            "",
            "    def check(self):",
            "        warnings = self._check_pattern_name()",
            "        warnings.extend(self.pattern.check())",
            "        return warnings",
            "",
            "    def _check_pattern_name(self):",
            "        \"\"\"",
            "        Check that the pattern name does not contain a colon.",
            "        \"\"\"",
            "        if self.pattern.name is not None and \":\" in self.pattern.name:",
            "            warning = Warning(",
            "                \"Your URL pattern {} has a name including a ':'. Remove the colon, to \"",
            "                \"avoid ambiguous namespace references.\".format(self.pattern.describe()),",
            "                id=\"urls.W003\",",
            "            )",
            "            return [warning]",
            "        else:",
            "            return []",
            "",
            "    def resolve(self, path):",
            "        match = self.pattern.match(path)",
            "        if match:",
            "            new_path, args, kwargs = match",
            "            # Pass any extra_kwargs as **kwargs.",
            "            kwargs.update(self.default_args)",
            "            return ResolverMatch(self.callback, args, kwargs, self.pattern.name)",
            "",
            "    @cached_property",
            "    def lookup_str(self):",
            "        \"\"\"",
            "        A string that identifies the view (e.g. 'path.to.view_function' or",
            "        'path.to.ClassBasedView').",
            "        \"\"\"",
            "        callback = self.callback",
            "        if isinstance(callback, functools.partial):",
            "            callback = callback.func",
            "        if not hasattr(callback, '__name__'):",
            "            return callback.__module__ + \".\" + callback.__class__.__name__",
            "        return callback.__module__ + \".\" + callback.__qualname__",
            "",
            "",
            "class URLResolver:",
            "    def __init__(self, pattern, urlconf_name, default_kwargs=None, app_name=None, namespace=None):",
            "        self.pattern = pattern",
            "        # urlconf_name is the dotted Python path to the module defining",
            "        # urlpatterns. It may also be an object with an urlpatterns attribute",
            "        # or urlpatterns itself.",
            "        self.urlconf_name = urlconf_name",
            "        self.callback = None",
            "        self.default_kwargs = default_kwargs or {}",
            "        self.namespace = namespace",
            "        self.app_name = app_name",
            "        self._reverse_dict = {}",
            "        self._namespace_dict = {}",
            "        self._app_dict = {}",
            "        # set of dotted paths to all functions and classes that are used in",
            "        # urlpatterns",
            "        self._callback_strs = set()",
            "        self._populated = False",
            "        self._local = threading.local()",
            "",
            "    def __repr__(self):",
            "        if isinstance(self.urlconf_name, list) and self.urlconf_name:",
            "            # Don't bother to output the whole list, it can be huge",
            "            urlconf_repr = '<%s list>' % self.urlconf_name[0].__class__.__name__",
            "        else:",
            "            urlconf_repr = repr(self.urlconf_name)",
            "        return '<%s %s (%s:%s) %s>' % (",
            "            self.__class__.__name__, urlconf_repr, self.app_name,",
            "            self.namespace, self.pattern.describe(),",
            "        )",
            "",
            "    def check(self):",
            "        warnings = []",
            "        for pattern in self.url_patterns:",
            "            warnings.extend(check_resolver(pattern))",
            "        return warnings or self.pattern.check()",
            "",
            "    def _populate(self):",
            "        # Short-circuit if called recursively in this thread to prevent",
            "        # infinite recursion. Concurrent threads may call this at the same",
            "        # time and will need to continue, so set 'populating' on a",
            "        # thread-local variable.",
            "        if getattr(self._local, 'populating', False):",
            "            return",
            "        try:",
            "            self._local.populating = True",
            "            lookups = MultiValueDict()",
            "            namespaces = {}",
            "            apps = {}",
            "            language_code = get_language()",
            "            for url_pattern in reversed(self.url_patterns):",
            "                p_pattern = url_pattern.pattern.regex.pattern",
            "                if p_pattern.startswith('^'):",
            "                    p_pattern = p_pattern[1:]",
            "                if isinstance(url_pattern, URLPattern):",
            "                    self._callback_strs.add(url_pattern.lookup_str)",
            "                    bits = normalize(url_pattern.pattern.regex.pattern)",
            "                    lookups.appendlist(",
            "                        url_pattern.callback,",
            "                        (bits, p_pattern, url_pattern.default_args, url_pattern.pattern.converters)",
            "                    )",
            "                    if url_pattern.name is not None:",
            "                        lookups.appendlist(",
            "                            url_pattern.name,",
            "                            (bits, p_pattern, url_pattern.default_args, url_pattern.pattern.converters)",
            "                        )",
            "                else:  # url_pattern is a URLResolver.",
            "                    url_pattern._populate()",
            "                    if url_pattern.app_name:",
            "                        apps.setdefault(url_pattern.app_name, []).append(url_pattern.namespace)",
            "                        namespaces[url_pattern.namespace] = (p_pattern, url_pattern)",
            "                    else:",
            "                        for name in url_pattern.reverse_dict:",
            "                            for matches, pat, defaults, converters in url_pattern.reverse_dict.getlist(name):",
            "                                new_matches = normalize(p_pattern + pat)",
            "                                lookups.appendlist(",
            "                                    name,",
            "                                    (",
            "                                        new_matches,",
            "                                        p_pattern + pat,",
            "                                        {**defaults, **url_pattern.default_kwargs},",
            "                                        {**self.pattern.converters, **url_pattern.pattern.converters, **converters}",
            "                                    )",
            "                                )",
            "                        for namespace, (prefix, sub_pattern) in url_pattern.namespace_dict.items():",
            "                            namespaces[namespace] = (p_pattern + prefix, sub_pattern)",
            "                        for app_name, namespace_list in url_pattern.app_dict.items():",
            "                            apps.setdefault(app_name, []).extend(namespace_list)",
            "                    self._callback_strs.update(url_pattern._callback_strs)",
            "            self._namespace_dict[language_code] = namespaces",
            "            self._app_dict[language_code] = apps",
            "            self._reverse_dict[language_code] = lookups",
            "            self._populated = True",
            "        finally:",
            "            self._local.populating = False",
            "",
            "    @property",
            "    def reverse_dict(self):",
            "        language_code = get_language()",
            "        if language_code not in self._reverse_dict:",
            "            self._populate()",
            "        return self._reverse_dict[language_code]",
            "",
            "    @property",
            "    def namespace_dict(self):",
            "        language_code = get_language()",
            "        if language_code not in self._namespace_dict:",
            "            self._populate()",
            "        return self._namespace_dict[language_code]",
            "",
            "    @property",
            "    def app_dict(self):",
            "        language_code = get_language()",
            "        if language_code not in self._app_dict:",
            "            self._populate()",
            "        return self._app_dict[language_code]",
            "",
            "    def _is_callback(self, name):",
            "        if not self._populated:",
            "            self._populate()",
            "        return name in self._callback_strs",
            "",
            "    def resolve(self, path):",
            "        path = str(path)  # path may be a reverse_lazy object",
            "        tried = []",
            "        match = self.pattern.match(path)",
            "        if match:",
            "            new_path, args, kwargs = match",
            "            for pattern in self.url_patterns:",
            "                try:",
            "                    sub_match = pattern.resolve(new_path)",
            "                except Resolver404 as e:",
            "                    sub_tried = e.args[0].get('tried')",
            "                    if sub_tried is not None:",
            "                        tried.extend([pattern] + t for t in sub_tried)",
            "                    else:",
            "                        tried.append([pattern])",
            "                else:",
            "                    if sub_match:",
            "                        # Merge captured arguments in match with submatch",
            "                        sub_match_dict = {**kwargs, **self.default_kwargs}",
            "                        # Update the sub_match_dict with the kwargs from the sub_match.",
            "                        sub_match_dict.update(sub_match.kwargs)",
            "                        # If there are *any* named groups, ignore all non-named groups.",
            "                        # Otherwise, pass all non-named arguments as positional arguments.",
            "                        sub_match_args = sub_match.args",
            "                        if not sub_match_dict:",
            "                            sub_match_args = args + sub_match.args",
            "                        return ResolverMatch(",
            "                            sub_match.func,",
            "                            sub_match_args,",
            "                            sub_match_dict,",
            "                            sub_match.url_name,",
            "                            [self.app_name] + sub_match.app_names,",
            "                            [self.namespace] + sub_match.namespaces,",
            "                        )",
            "                    tried.append([pattern])",
            "            raise Resolver404({'tried': tried, 'path': new_path})",
            "        raise Resolver404({'path': path})",
            "",
            "    @cached_property",
            "    def urlconf_module(self):",
            "        if isinstance(self.urlconf_name, str):",
            "            return import_module(self.urlconf_name)",
            "        else:",
            "            return self.urlconf_name",
            "",
            "    @cached_property",
            "    def url_patterns(self):",
            "        # urlconf_module might be a valid set of patterns, so we default to it",
            "        patterns = getattr(self.urlconf_module, \"urlpatterns\", self.urlconf_module)",
            "        try:",
            "            iter(patterns)",
            "        except TypeError:",
            "            msg = (",
            "                \"The included URLconf '{name}' does not appear to have any \"",
            "                \"patterns in it. If you see valid patterns in the file then \"",
            "                \"the issue is probably caused by a circular import.\"",
            "            )",
            "            raise ImproperlyConfigured(msg.format(name=self.urlconf_name))",
            "        return patterns",
            "",
            "    def resolve_error_handler(self, view_type):",
            "        callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)",
            "        if not callback:",
            "            # No handler specified in file; use lazy import, since",
            "            # django.conf.urls imports this file.",
            "            from django.conf import urls",
            "            callback = getattr(urls, 'handler%s' % view_type)",
            "        return get_callable(callback), {}",
            "",
            "    def reverse(self, lookup_view, *args, **kwargs):",
            "        return self._reverse_with_prefix(lookup_view, '', *args, **kwargs)",
            "",
            "    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):",
            "        if args and kwargs:",
            "            raise ValueError(\"Don't mix *args and **kwargs in call to reverse()!\")",
            "",
            "        if not self._populated:",
            "            self._populate()",
            "",
            "        possibilities = self.reverse_dict.getlist(lookup_view)",
            "",
            "        for possibility, pattern, defaults, converters in possibilities:",
            "            for result, params in possibility:",
            "                if args:",
            "                    if len(args) != len(params):",
            "                        continue",
            "                    candidate_subs = dict(zip(params, args))",
            "                else:",
            "                    if set(kwargs).symmetric_difference(params).difference(defaults):",
            "                        continue",
            "                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):",
            "                        continue",
            "                    candidate_subs = kwargs",
            "                # Convert the candidate subs to text using Converter.to_url().",
            "                text_candidate_subs = {}",
            "                for k, v in candidate_subs.items():",
            "                    if k in converters:",
            "                        text_candidate_subs[k] = converters[k].to_url(v)",
            "                    else:",
            "                        text_candidate_subs[k] = str(v)",
            "                # WSGI provides decoded URLs, without %xx escapes, and the URL",
            "                # resolver operates on such URLs. First substitute arguments",
            "                # without quoting to build a decoded URL and look for a match.",
            "                # Then, if we have a match, redo the substitution with quoted",
            "                # arguments in order to return a properly encoded URL.",
            "                candidate_pat = _prefix.replace('%', '%%') + result",
            "                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):",
            "                    # safe characters from `pchar` definition of RFC 3986",
            "                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')",
            "                    # Don't allow construction of scheme relative urls.",
            "                    if url.startswith('//'):",
            "                        url = '/%%2F%s' % url[2:]",
            "                    return url",
            "        # lookup_view can be URL name or callable, but callables are not",
            "        # friendly in error messages.",
            "        m = getattr(lookup_view, '__module__', None)",
            "        n = getattr(lookup_view, '__name__', None)",
            "        if m is not None and n is not None:",
            "            lookup_view_s = \"%s.%s\" % (m, n)",
            "        else:",
            "            lookup_view_s = lookup_view",
            "",
            "        patterns = [pattern for (_, pattern, _, _) in possibilities]",
            "        if patterns:",
            "            if args:",
            "                arg_msg = \"arguments '%s'\" % (args,)",
            "            elif kwargs:",
            "                arg_msg = \"keyword arguments '%s'\" % (kwargs,)",
            "            else:",
            "                arg_msg = \"no arguments\"",
            "            msg = (",
            "                \"Reverse for '%s' with %s not found. %d pattern(s) tried: %s\" %",
            "                (lookup_view_s, arg_msg, len(patterns), patterns)",
            "            )",
            "        else:",
            "            msg = (",
            "                \"Reverse for '%(view)s' not found. '%(view)s' is not \"",
            "                \"a valid view function or pattern name.\" % {'view': lookup_view_s}",
            "            )",
            "        raise NoReverseMatch(msg)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "This module converts requested URLs to callback view functions.",
            "",
            "URLResolver is the main class here. Its resolve() method takes a URL (as",
            "a string) and returns a ResolverMatch object which provides access to all",
            "attributes of the resolved URL match.",
            "\"\"\"",
            "import functools",
            "import re",
            "import threading",
            "from importlib import import_module",
            "from urllib.parse import quote",
            "",
            "from django.conf import settings",
            "from django.core.checks import Warning",
            "from django.core.checks.urls import check_resolver",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.functional import cached_property",
            "from django.utils.http import RFC3986_SUBDELIMS, escape_leading_slashes",
            "from django.utils.regex_helper import normalize",
            "from django.utils.translation import get_language",
            "",
            "from .converters import get_converter",
            "from .exceptions import NoReverseMatch, Resolver404",
            "from .utils import get_callable",
            "",
            "",
            "class ResolverMatch:",
            "    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None):",
            "        self.func = func",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "        self.url_name = url_name",
            "",
            "        # If a URLRegexResolver doesn't have a namespace or app_name, it passes",
            "        # in an empty value.",
            "        self.app_names = [x for x in app_names if x] if app_names else []",
            "        self.app_name = ':'.join(self.app_names)",
            "        self.namespaces = [x for x in namespaces if x] if namespaces else []",
            "        self.namespace = ':'.join(self.namespaces)",
            "",
            "        if not hasattr(func, '__name__'):",
            "            # A class-based view",
            "            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__",
            "        else:",
            "            # A function-based view",
            "            self._func_path = func.__module__ + '.' + func.__name__",
            "",
            "        view_path = url_name or self._func_path",
            "        self.view_name = ':'.join(self.namespaces + [view_path])",
            "",
            "    def __getitem__(self, index):",
            "        return (self.func, self.args, self.kwargs)[index]",
            "",
            "    def __repr__(self):",
            "        return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s)\" % (",
            "            self._func_path, self.args, self.kwargs, self.url_name,",
            "            self.app_names, self.namespaces,",
            "        )",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def get_resolver(urlconf=None):",
            "    if urlconf is None:",
            "        urlconf = settings.ROOT_URLCONF",
            "    return URLResolver(RegexPattern(r'^/'), urlconf)",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def get_ns_resolver(ns_pattern, resolver, converters):",
            "    # Build a namespaced resolver for the given parent URLconf pattern.",
            "    # This makes it possible to have captured parameters in the parent",
            "    # URLconf pattern.",
            "    pattern = RegexPattern(ns_pattern)",
            "    pattern.converters = dict(converters)",
            "    ns_resolver = URLResolver(pattern, resolver.url_patterns)",
            "    return URLResolver(RegexPattern(r'^/'), [ns_resolver])",
            "",
            "",
            "class LocaleRegexDescriptor:",
            "    def __init__(self, attr):",
            "        self.attr = attr",
            "",
            "    def __get__(self, instance, cls=None):",
            "        \"\"\"",
            "        Return a compiled regular expression based on the active language.",
            "        \"\"\"",
            "        if instance is None:",
            "            return self",
            "        # As a performance optimization, if the given regex string is a regular",
            "        # string (not a lazily-translated string proxy), compile it once and",
            "        # avoid per-language compilation.",
            "        pattern = getattr(instance, self.attr)",
            "        if isinstance(pattern, str):",
            "            instance.__dict__['regex'] = instance._compile(pattern)",
            "            return instance.__dict__['regex']",
            "        language_code = get_language()",
            "        if language_code not in instance._regex_dict:",
            "            instance._regex_dict[language_code] = instance._compile(str(pattern))",
            "        return instance._regex_dict[language_code]",
            "",
            "",
            "class CheckURLMixin:",
            "    def describe(self):",
            "        \"\"\"",
            "        Format the URL pattern for display in warning messages.",
            "        \"\"\"",
            "        description = \"'{}'\".format(self)",
            "        if self.name:",
            "            description += \" [name='{}']\".format(self.name)",
            "        return description",
            "",
            "    def _check_pattern_startswith_slash(self):",
            "        \"\"\"",
            "        Check that the pattern does not begin with a forward slash.",
            "        \"\"\"",
            "        regex_pattern = self.regex.pattern",
            "        if not settings.APPEND_SLASH:",
            "            # Skip check as it can be useful to start a URL pattern with a slash",
            "            # when APPEND_SLASH=False.",
            "            return []",
            "        if regex_pattern.startswith(('/', '^/', '^\\\\/')) and not regex_pattern.endswith('/'):",
            "            warning = Warning(",
            "                \"Your URL pattern {} has a route beginning with a '/'. Remove this \"",
            "                \"slash as it is unnecessary. If this pattern is targeted in an \"",
            "                \"include(), ensure the include() pattern has a trailing '/'.\".format(",
            "                    self.describe()",
            "                ),",
            "                id=\"urls.W002\",",
            "            )",
            "            return [warning]",
            "        else:",
            "            return []",
            "",
            "",
            "class RegexPattern(CheckURLMixin):",
            "    regex = LocaleRegexDescriptor('_regex')",
            "",
            "    def __init__(self, regex, name=None, is_endpoint=False):",
            "        self._regex = regex",
            "        self._regex_dict = {}",
            "        self._is_endpoint = is_endpoint",
            "        self.name = name",
            "        self.converters = {}",
            "",
            "    def match(self, path):",
            "        match = self.regex.search(path)",
            "        if match:",
            "            # If there are any named groups, use those as kwargs, ignoring",
            "            # non-named groups. Otherwise, pass all non-named arguments as",
            "            # positional arguments.",
            "            kwargs = match.groupdict()",
            "            args = () if kwargs else match.groups()",
            "            return path[match.end():], args, kwargs",
            "        return None",
            "",
            "    def check(self):",
            "        warnings = []",
            "        warnings.extend(self._check_pattern_startswith_slash())",
            "        if not self._is_endpoint:",
            "            warnings.extend(self._check_include_trailing_dollar())",
            "        return warnings",
            "",
            "    def _check_include_trailing_dollar(self):",
            "        regex_pattern = self.regex.pattern",
            "        if regex_pattern.endswith('$') and not regex_pattern.endswith(r'\\$'):",
            "            return [Warning(",
            "                \"Your URL pattern {} uses include with a route ending with a '$'. \"",
            "                \"Remove the dollar from the route to avoid problems including \"",
            "                \"URLs.\".format(self.describe()),",
            "                id='urls.W001',",
            "            )]",
            "        else:",
            "            return []",
            "",
            "    def _compile(self, regex):",
            "        \"\"\"Compile and return the given regular expression.\"\"\"",
            "        try:",
            "            return re.compile(regex)",
            "        except re.error as e:",
            "            raise ImproperlyConfigured(",
            "                '\"%s\" is not a valid regular expression: %s' % (regex, e)",
            "            )",
            "",
            "    def __str__(self):",
            "        return str(self._regex)",
            "",
            "",
            "_PATH_PARAMETER_COMPONENT_RE = re.compile(",
            "    r'<(?:(?P<converter>[^>:]+):)?(?P<parameter>\\w+)>'",
            ")",
            "",
            "",
            "def _route_to_regex(route, is_endpoint=False):",
            "    \"\"\"",
            "    Convert a path pattern into a regular expression. Return the regular",
            "    expression and a dictionary mapping the capture names to the converters.",
            "    For example, 'foo/<int:pk>' returns '^foo\\\\/(?P<pk>[0-9]+)'",
            "    and {'pk': <django.urls.converters.IntConverter>}.",
            "    \"\"\"",
            "    original_route = route",
            "    parts = ['^']",
            "    converters = {}",
            "    while True:",
            "        match = _PATH_PARAMETER_COMPONENT_RE.search(route)",
            "        if not match:",
            "            parts.append(re.escape(route))",
            "            break",
            "        parts.append(re.escape(route[:match.start()]))",
            "        route = route[match.end():]",
            "        parameter = match.group('parameter')",
            "        if not parameter.isidentifier():",
            "            raise ImproperlyConfigured(",
            "                \"URL route '%s' uses parameter name %r which isn't a valid \"",
            "                \"Python identifier.\" % (original_route, parameter)",
            "            )",
            "        raw_converter = match.group('converter')",
            "        if raw_converter is None:",
            "            # If a converter isn't specified, the default is `str`.",
            "            raw_converter = 'str'",
            "        try:",
            "            converter = get_converter(raw_converter)",
            "        except KeyError as e:",
            "            raise ImproperlyConfigured(",
            "                \"URL route '%s' uses invalid converter %s.\" % (original_route, e)",
            "            )",
            "        converters[parameter] = converter",
            "        parts.append('(?P<' + parameter + '>' + converter.regex + ')')",
            "    if is_endpoint:",
            "        parts.append('$')",
            "    return ''.join(parts), converters",
            "",
            "",
            "class RoutePattern(CheckURLMixin):",
            "    regex = LocaleRegexDescriptor('_route')",
            "",
            "    def __init__(self, route, name=None, is_endpoint=False):",
            "        self._route = route",
            "        self._regex_dict = {}",
            "        self._is_endpoint = is_endpoint",
            "        self.name = name",
            "        self.converters = _route_to_regex(str(route), is_endpoint)[1]",
            "",
            "    def match(self, path):",
            "        match = self.regex.search(path)",
            "        if match:",
            "            # RoutePattern doesn't allow non-named groups so args are ignored.",
            "            kwargs = match.groupdict()",
            "            for key, value in kwargs.items():",
            "                converter = self.converters[key]",
            "                try:",
            "                    kwargs[key] = converter.to_python(value)",
            "                except ValueError:",
            "                    return None",
            "            return path[match.end():], (), kwargs",
            "        return None",
            "",
            "    def check(self):",
            "        warnings = self._check_pattern_startswith_slash()",
            "        route = self._route",
            "        if '(?P<' in route or route.startswith('^') or route.endswith('$'):",
            "            warnings.append(Warning(",
            "                \"Your URL pattern {} has a route that contains '(?P<', begins \"",
            "                \"with a '^', or ends with a '$'. This was likely an oversight \"",
            "                \"when migrating to django.urls.path().\".format(self.describe()),",
            "                id='2_0.W001',",
            "            ))",
            "        return warnings",
            "",
            "    def _compile(self, route):",
            "        return re.compile(_route_to_regex(route, self._is_endpoint)[0])",
            "",
            "    def __str__(self):",
            "        return str(self._route)",
            "",
            "",
            "class LocalePrefixPattern:",
            "    def __init__(self, prefix_default_language=True):",
            "        self.prefix_default_language = prefix_default_language",
            "        self.converters = {}",
            "",
            "    @property",
            "    def regex(self):",
            "        # This is only used by reverse() and cached in _reverse_dict.",
            "        return re.compile(self.language_prefix)",
            "",
            "    @property",
            "    def language_prefix(self):",
            "        language_code = get_language() or settings.LANGUAGE_CODE",
            "        if language_code == settings.LANGUAGE_CODE and not self.prefix_default_language:",
            "            return ''",
            "        else:",
            "            return '%s/' % language_code",
            "",
            "    def match(self, path):",
            "        language_prefix = self.language_prefix",
            "        if path.startswith(language_prefix):",
            "            return path[len(language_prefix):], (), {}",
            "        return None",
            "",
            "    def check(self):",
            "        return []",
            "",
            "    def describe(self):",
            "        return \"'{}'\".format(self)",
            "",
            "    def __str__(self):",
            "        return self.language_prefix",
            "",
            "",
            "class URLPattern:",
            "    def __init__(self, pattern, callback, default_args=None, name=None):",
            "        self.pattern = pattern",
            "        self.callback = callback  # the view",
            "        self.default_args = default_args or {}",
            "        self.name = name",
            "",
            "    def __repr__(self):",
            "        return '<%s %s>' % (self.__class__.__name__, self.pattern.describe())",
            "",
            "    def check(self):",
            "        warnings = self._check_pattern_name()",
            "        warnings.extend(self.pattern.check())",
            "        return warnings",
            "",
            "    def _check_pattern_name(self):",
            "        \"\"\"",
            "        Check that the pattern name does not contain a colon.",
            "        \"\"\"",
            "        if self.pattern.name is not None and \":\" in self.pattern.name:",
            "            warning = Warning(",
            "                \"Your URL pattern {} has a name including a ':'. Remove the colon, to \"",
            "                \"avoid ambiguous namespace references.\".format(self.pattern.describe()),",
            "                id=\"urls.W003\",",
            "            )",
            "            return [warning]",
            "        else:",
            "            return []",
            "",
            "    def resolve(self, path):",
            "        match = self.pattern.match(path)",
            "        if match:",
            "            new_path, args, kwargs = match",
            "            # Pass any extra_kwargs as **kwargs.",
            "            kwargs.update(self.default_args)",
            "            return ResolverMatch(self.callback, args, kwargs, self.pattern.name)",
            "",
            "    @cached_property",
            "    def lookup_str(self):",
            "        \"\"\"",
            "        A string that identifies the view (e.g. 'path.to.view_function' or",
            "        'path.to.ClassBasedView').",
            "        \"\"\"",
            "        callback = self.callback",
            "        if isinstance(callback, functools.partial):",
            "            callback = callback.func",
            "        if not hasattr(callback, '__name__'):",
            "            return callback.__module__ + \".\" + callback.__class__.__name__",
            "        return callback.__module__ + \".\" + callback.__qualname__",
            "",
            "",
            "class URLResolver:",
            "    def __init__(self, pattern, urlconf_name, default_kwargs=None, app_name=None, namespace=None):",
            "        self.pattern = pattern",
            "        # urlconf_name is the dotted Python path to the module defining",
            "        # urlpatterns. It may also be an object with an urlpatterns attribute",
            "        # or urlpatterns itself.",
            "        self.urlconf_name = urlconf_name",
            "        self.callback = None",
            "        self.default_kwargs = default_kwargs or {}",
            "        self.namespace = namespace",
            "        self.app_name = app_name",
            "        self._reverse_dict = {}",
            "        self._namespace_dict = {}",
            "        self._app_dict = {}",
            "        # set of dotted paths to all functions and classes that are used in",
            "        # urlpatterns",
            "        self._callback_strs = set()",
            "        self._populated = False",
            "        self._local = threading.local()",
            "",
            "    def __repr__(self):",
            "        if isinstance(self.urlconf_name, list) and self.urlconf_name:",
            "            # Don't bother to output the whole list, it can be huge",
            "            urlconf_repr = '<%s list>' % self.urlconf_name[0].__class__.__name__",
            "        else:",
            "            urlconf_repr = repr(self.urlconf_name)",
            "        return '<%s %s (%s:%s) %s>' % (",
            "            self.__class__.__name__, urlconf_repr, self.app_name,",
            "            self.namespace, self.pattern.describe(),",
            "        )",
            "",
            "    def check(self):",
            "        warnings = []",
            "        for pattern in self.url_patterns:",
            "            warnings.extend(check_resolver(pattern))",
            "        return warnings or self.pattern.check()",
            "",
            "    def _populate(self):",
            "        # Short-circuit if called recursively in this thread to prevent",
            "        # infinite recursion. Concurrent threads may call this at the same",
            "        # time and will need to continue, so set 'populating' on a",
            "        # thread-local variable.",
            "        if getattr(self._local, 'populating', False):",
            "            return",
            "        try:",
            "            self._local.populating = True",
            "            lookups = MultiValueDict()",
            "            namespaces = {}",
            "            apps = {}",
            "            language_code = get_language()",
            "            for url_pattern in reversed(self.url_patterns):",
            "                p_pattern = url_pattern.pattern.regex.pattern",
            "                if p_pattern.startswith('^'):",
            "                    p_pattern = p_pattern[1:]",
            "                if isinstance(url_pattern, URLPattern):",
            "                    self._callback_strs.add(url_pattern.lookup_str)",
            "                    bits = normalize(url_pattern.pattern.regex.pattern)",
            "                    lookups.appendlist(",
            "                        url_pattern.callback,",
            "                        (bits, p_pattern, url_pattern.default_args, url_pattern.pattern.converters)",
            "                    )",
            "                    if url_pattern.name is not None:",
            "                        lookups.appendlist(",
            "                            url_pattern.name,",
            "                            (bits, p_pattern, url_pattern.default_args, url_pattern.pattern.converters)",
            "                        )",
            "                else:  # url_pattern is a URLResolver.",
            "                    url_pattern._populate()",
            "                    if url_pattern.app_name:",
            "                        apps.setdefault(url_pattern.app_name, []).append(url_pattern.namespace)",
            "                        namespaces[url_pattern.namespace] = (p_pattern, url_pattern)",
            "                    else:",
            "                        for name in url_pattern.reverse_dict:",
            "                            for matches, pat, defaults, converters in url_pattern.reverse_dict.getlist(name):",
            "                                new_matches = normalize(p_pattern + pat)",
            "                                lookups.appendlist(",
            "                                    name,",
            "                                    (",
            "                                        new_matches,",
            "                                        p_pattern + pat,",
            "                                        {**defaults, **url_pattern.default_kwargs},",
            "                                        {**self.pattern.converters, **url_pattern.pattern.converters, **converters}",
            "                                    )",
            "                                )",
            "                        for namespace, (prefix, sub_pattern) in url_pattern.namespace_dict.items():",
            "                            namespaces[namespace] = (p_pattern + prefix, sub_pattern)",
            "                        for app_name, namespace_list in url_pattern.app_dict.items():",
            "                            apps.setdefault(app_name, []).extend(namespace_list)",
            "                    self._callback_strs.update(url_pattern._callback_strs)",
            "            self._namespace_dict[language_code] = namespaces",
            "            self._app_dict[language_code] = apps",
            "            self._reverse_dict[language_code] = lookups",
            "            self._populated = True",
            "        finally:",
            "            self._local.populating = False",
            "",
            "    @property",
            "    def reverse_dict(self):",
            "        language_code = get_language()",
            "        if language_code not in self._reverse_dict:",
            "            self._populate()",
            "        return self._reverse_dict[language_code]",
            "",
            "    @property",
            "    def namespace_dict(self):",
            "        language_code = get_language()",
            "        if language_code not in self._namespace_dict:",
            "            self._populate()",
            "        return self._namespace_dict[language_code]",
            "",
            "    @property",
            "    def app_dict(self):",
            "        language_code = get_language()",
            "        if language_code not in self._app_dict:",
            "            self._populate()",
            "        return self._app_dict[language_code]",
            "",
            "    def _is_callback(self, name):",
            "        if not self._populated:",
            "            self._populate()",
            "        return name in self._callback_strs",
            "",
            "    def resolve(self, path):",
            "        path = str(path)  # path may be a reverse_lazy object",
            "        tried = []",
            "        match = self.pattern.match(path)",
            "        if match:",
            "            new_path, args, kwargs = match",
            "            for pattern in self.url_patterns:",
            "                try:",
            "                    sub_match = pattern.resolve(new_path)",
            "                except Resolver404 as e:",
            "                    sub_tried = e.args[0].get('tried')",
            "                    if sub_tried is not None:",
            "                        tried.extend([pattern] + t for t in sub_tried)",
            "                    else:",
            "                        tried.append([pattern])",
            "                else:",
            "                    if sub_match:",
            "                        # Merge captured arguments in match with submatch",
            "                        sub_match_dict = {**kwargs, **self.default_kwargs}",
            "                        # Update the sub_match_dict with the kwargs from the sub_match.",
            "                        sub_match_dict.update(sub_match.kwargs)",
            "                        # If there are *any* named groups, ignore all non-named groups.",
            "                        # Otherwise, pass all non-named arguments as positional arguments.",
            "                        sub_match_args = sub_match.args",
            "                        if not sub_match_dict:",
            "                            sub_match_args = args + sub_match.args",
            "                        return ResolverMatch(",
            "                            sub_match.func,",
            "                            sub_match_args,",
            "                            sub_match_dict,",
            "                            sub_match.url_name,",
            "                            [self.app_name] + sub_match.app_names,",
            "                            [self.namespace] + sub_match.namespaces,",
            "                        )",
            "                    tried.append([pattern])",
            "            raise Resolver404({'tried': tried, 'path': new_path})",
            "        raise Resolver404({'path': path})",
            "",
            "    @cached_property",
            "    def urlconf_module(self):",
            "        if isinstance(self.urlconf_name, str):",
            "            return import_module(self.urlconf_name)",
            "        else:",
            "            return self.urlconf_name",
            "",
            "    @cached_property",
            "    def url_patterns(self):",
            "        # urlconf_module might be a valid set of patterns, so we default to it",
            "        patterns = getattr(self.urlconf_module, \"urlpatterns\", self.urlconf_module)",
            "        try:",
            "            iter(patterns)",
            "        except TypeError:",
            "            msg = (",
            "                \"The included URLconf '{name}' does not appear to have any \"",
            "                \"patterns in it. If you see valid patterns in the file then \"",
            "                \"the issue is probably caused by a circular import.\"",
            "            )",
            "            raise ImproperlyConfigured(msg.format(name=self.urlconf_name))",
            "        return patterns",
            "",
            "    def resolve_error_handler(self, view_type):",
            "        callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)",
            "        if not callback:",
            "            # No handler specified in file; use lazy import, since",
            "            # django.conf.urls imports this file.",
            "            from django.conf import urls",
            "            callback = getattr(urls, 'handler%s' % view_type)",
            "        return get_callable(callback), {}",
            "",
            "    def reverse(self, lookup_view, *args, **kwargs):",
            "        return self._reverse_with_prefix(lookup_view, '', *args, **kwargs)",
            "",
            "    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):",
            "        if args and kwargs:",
            "            raise ValueError(\"Don't mix *args and **kwargs in call to reverse()!\")",
            "",
            "        if not self._populated:",
            "            self._populate()",
            "",
            "        possibilities = self.reverse_dict.getlist(lookup_view)",
            "",
            "        for possibility, pattern, defaults, converters in possibilities:",
            "            for result, params in possibility:",
            "                if args:",
            "                    if len(args) != len(params):",
            "                        continue",
            "                    candidate_subs = dict(zip(params, args))",
            "                else:",
            "                    if set(kwargs).symmetric_difference(params).difference(defaults):",
            "                        continue",
            "                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):",
            "                        continue",
            "                    candidate_subs = kwargs",
            "                # Convert the candidate subs to text using Converter.to_url().",
            "                text_candidate_subs = {}",
            "                for k, v in candidate_subs.items():",
            "                    if k in converters:",
            "                        text_candidate_subs[k] = converters[k].to_url(v)",
            "                    else:",
            "                        text_candidate_subs[k] = str(v)",
            "                # WSGI provides decoded URLs, without %xx escapes, and the URL",
            "                # resolver operates on such URLs. First substitute arguments",
            "                # without quoting to build a decoded URL and look for a match.",
            "                # Then, if we have a match, redo the substitution with quoted",
            "                # arguments in order to return a properly encoded URL.",
            "                candidate_pat = _prefix.replace('%', '%%') + result",
            "                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):",
            "                    # safe characters from `pchar` definition of RFC 3986",
            "                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')",
            "                    # Don't allow construction of scheme relative urls.",
            "                    return escape_leading_slashes(url)",
            "        # lookup_view can be URL name or callable, but callables are not",
            "        # friendly in error messages.",
            "        m = getattr(lookup_view, '__module__', None)",
            "        n = getattr(lookup_view, '__name__', None)",
            "        if m is not None and n is not None:",
            "            lookup_view_s = \"%s.%s\" % (m, n)",
            "        else:",
            "            lookup_view_s = lookup_view",
            "",
            "        patterns = [pattern for (_, pattern, _, _) in possibilities]",
            "        if patterns:",
            "            if args:",
            "                arg_msg = \"arguments '%s'\" % (args,)",
            "            elif kwargs:",
            "                arg_msg = \"keyword arguments '%s'\" % (kwargs,)",
            "            else:",
            "                arg_msg = \"no arguments\"",
            "            msg = (",
            "                \"Reverse for '%s' with %s not found. %d pattern(s) tried: %s\" %",
            "                (lookup_view_s, arg_msg, len(patterns), patterns)",
            "            )",
            "        else:",
            "            msg = (",
            "                \"Reverse for '%(view)s' not found. '%(view)s' is not \"",
            "                \"a valid view function or pattern name.\" % {'view': lookup_view_s}",
            "            )",
            "        raise NoReverseMatch(msg)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": [],
            "595": [
                "URLResolver",
                "_reverse_with_prefix"
            ],
            "596": [
                "URLResolver",
                "_reverse_with_prefix"
            ],
            "597": [
                "URLResolver",
                "_reverse_with_prefix"
            ]
        },
        "addLocation": []
    },
    "django/utils/http.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "             value = unquote(value, encoding=encoding, errors=errors)"
            },
            "1": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "             r.append((name, value))"
            },
            "2": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "     return r"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 436,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+def escape_leading_slashes(url):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+    \"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+    If redirecting to an absolute path (two leading slashes), a slash must be"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+    escaped to prevent browsers from handling the path as schemaless and"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+    redirecting to another host."
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+    \"\"\""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+    if url.startswith('//'):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+        url = '/%2F{}'.format(url[2:])"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+    return url"
            }
        },
        "frontPatchFile": [
            "import base64",
            "import calendar",
            "import datetime",
            "import re",
            "import unicodedata",
            "import warnings",
            "from binascii import Error as BinasciiError",
            "from email.utils import formatdate",
            "from urllib.parse import (",
            "    ParseResult, SplitResult, _coerce_args, _splitnetloc, _splitparams, quote,",
            "    quote_plus, scheme_chars, unquote, unquote_plus,",
            "    urlencode as original_urlencode, uses_params,",
            ")",
            "",
            "from django.core.exceptions import TooManyFieldsSent",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.deprecation import RemovedInDjango30Warning",
            "from django.utils.encoding import force_bytes",
            "from django.utils.functional import keep_lazy_text",
            "",
            "# based on RFC 7232, Appendix C",
            "ETAG_MATCH = re.compile(r'''",
            "    \\A(      # start of string and capture group",
            "    (?:W/)?  # optional weak indicator",
            "    \"        # opening quote",
            "    [^\"]*    # any sequence of non-quote characters",
            "    \"        # end quote",
            "    )\\Z      # end of string and capture group",
            "''', re.X)",
            "",
            "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()",
            "__D = r'(?P<day>\\d{2})'",
            "__D2 = r'(?P<day>[ \\d]\\d)'",
            "__M = r'(?P<mon>\\w{3})'",
            "__Y = r'(?P<year>\\d{4})'",
            "__Y2 = r'(?P<year>\\d{2})'",
            "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'",
            "RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))",
            "RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))",
            "ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))",
            "",
            "RFC3986_GENDELIMS = \":/?#[]@\"",
            "RFC3986_SUBDELIMS = \"!$&'()*+,;=\"",
            "",
            "FIELDS_MATCH = re.compile('[&;]')",
            "",
            "",
            "@keep_lazy_text",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A legacy compatibility wrapper to Python's urllib.parse.quote() function.",
            "    (was used for unicode handling on Python 2)",
            "    \"\"\"",
            "    return quote(url, safe)",
            "",
            "",
            "@keep_lazy_text",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A legacy compatibility wrapper to Python's urllib.parse.quote_plus()",
            "    function. (was used for unicode handling on Python 2)",
            "    \"\"\"",
            "    return quote_plus(url, safe)",
            "",
            "",
            "@keep_lazy_text",
            "def urlunquote(quoted_url):",
            "    \"\"\"",
            "    A legacy compatibility wrapper to Python's urllib.parse.unquote() function.",
            "    (was used for unicode handling on Python 2)",
            "    \"\"\"",
            "    return unquote(quoted_url)",
            "",
            "",
            "@keep_lazy_text",
            "def urlunquote_plus(quoted_url):",
            "    \"\"\"",
            "    A legacy compatibility wrapper to Python's urllib.parse.unquote_plus()",
            "    function. (was used for unicode handling on Python 2)",
            "    \"\"\"",
            "    return unquote_plus(quoted_url)",
            "",
            "",
            "def urlencode(query, doseq=False):",
            "    \"\"\"",
            "    A version of Python's urllib.parse.urlencode() function that can operate on",
            "    MultiValueDict and non-string values.",
            "    \"\"\"",
            "    if isinstance(query, MultiValueDict):",
            "        query = query.lists()",
            "    elif hasattr(query, 'items'):",
            "        query = query.items()",
            "    query_params = []",
            "    for key, value in query:",
            "        if isinstance(value, (str, bytes)):",
            "            query_val = value",
            "        else:",
            "            try:",
            "                iter(value)",
            "            except TypeError:",
            "                query_val = value",
            "            else:",
            "                # Consume generators and iterators, even when doseq=True, to",
            "                # work around https://bugs.python.org/issue31706.",
            "                query_val = [",
            "                    item if isinstance(item, bytes) else str(item)",
            "                    for item in value",
            "                ]",
            "        query_params.append((key, query_val))",
            "    return original_urlencode(query_params, doseq)",
            "",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Format the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    `epoch_seconds` is a floating point number expressed in seconds since the",
            "    epoch, in UTC - such as that outputted by time.time(). If set to None, it",
            "    defaults to the current time.",
            "",
            "    Output a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    warnings.warn(",
            "        'cookie_date() is deprecated in favor of http_date(), which follows '",
            "        'the format of the latest RFC.',",
            "        RemovedInDjango30Warning, stacklevel=2,",
            "    )",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Format the time to match the RFC1123 date format as specified by HTTP",
            "    RFC7231 section 7.1.1.1.",
            "",
            "    `epoch_seconds` is a floating point number expressed in seconds since the",
            "    epoch, in UTC - such as that outputted by time.time(). If set to None, it",
            "    defaults to the current time.",
            "",
            "    Output a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    return formatdate(epoch_seconds, usegmt=True)",
            "",
            "",
            "def parse_http_date(date):",
            "    \"\"\"",
            "    Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.",
            "",
            "    The three formats allowed by the RFC are accepted, even if only the first",
            "    one is still in widespread use.",
            "",
            "    Return an integer expressed in seconds since the epoch, in UTC.",
            "    \"\"\"",
            "    # email.utils.parsedate() does the job for RFC1123 dates; unfortunately",
            "    # RFC7231 makes it mandatory to support RFC850 dates too. So we roll",
            "    # our own RFC-compliant parsing.",
            "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:",
            "        m = regex.match(date)",
            "        if m is not None:",
            "            break",
            "    else:",
            "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)",
            "    try:",
            "        year = int(m.group('year'))",
            "        if year < 100:",
            "            if year < 70:",
            "                year += 2000",
            "            else:",
            "                year += 1900",
            "        month = MONTHS.index(m.group('mon').lower()) + 1",
            "        day = int(m.group('day'))",
            "        hour = int(m.group('hour'))",
            "        min = int(m.group('min'))",
            "        sec = int(m.group('sec'))",
            "        result = datetime.datetime(year, month, day, hour, min, sec)",
            "        return calendar.timegm(result.utctimetuple())",
            "    except Exception as exc:",
            "        raise ValueError(\"%r is not a valid date\" % date) from exc",
            "",
            "",
            "def parse_http_date_safe(date):",
            "    \"\"\"",
            "    Same as parse_http_date, but return None if the input is invalid.",
            "    \"\"\"",
            "    try:",
            "        return parse_http_date(date)",
            "    except Exception:",
            "        pass",
            "",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Convert a base 36 string to an int. Raise ValueError if the input won't fit",
            "    into an int.",
            "    \"\"\"",
            "    # To prevent overconsumption of server resources, reject any",
            "    # base36 string that is longer than 13 base36 digits (13 digits",
            "    # is sufficient to base36-encode any 64-bit integer)",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return int(s, 36)",
            "",
            "",
            "def int_to_base36(i):",
            "    \"\"\"Convert an integer to a base36 string.\"\"\"",
            "    char_set = '0123456789abcdefghijklmnopqrstuvwxyz'",
            "    if i < 0:",
            "        raise ValueError(\"Negative base36 conversion input.\")",
            "    if i < 36:",
            "        return char_set[i]",
            "    b36 = ''",
            "    while i != 0:",
            "        i, n = divmod(i, 36)",
            "        b36 = char_set[n] + b36",
            "    return b36",
            "",
            "",
            "def urlsafe_base64_encode(s):",
            "    \"\"\"",
            "    Encode a bytestring in base64 for use in URLs. Strip any trailing equal",
            "    signs.",
            "    \"\"\"",
            "    return base64.urlsafe_b64encode(s).rstrip(b'\\n=')",
            "",
            "",
            "def urlsafe_base64_decode(s):",
            "    \"\"\"",
            "    Decode a base64 encoded string. Add back any trailing equal signs that",
            "    might have been stripped.",
            "    \"\"\"",
            "    s = force_bytes(s)",
            "    try:",
            "        return base64.urlsafe_b64decode(s.ljust(len(s) + len(s) % 4, b'='))",
            "    except (LookupError, BinasciiError) as e:",
            "        raise ValueError(e)",
            "",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parse a string of ETags given in an If-None-Match or If-Match header as",
            "    defined by RFC 7232. Return a list of quoted ETags, or ['*'] if all ETags",
            "    should be matched.",
            "    \"\"\"",
            "    if etag_str.strip() == '*':",
            "        return ['*']",
            "    else:",
            "        # Parse each ETag individually, and return any that are valid.",
            "        etag_matches = (ETAG_MATCH.match(etag.strip()) for etag in etag_str.split(','))",
            "        return [match.group(1) for match in etag_matches if match]",
            "",
            "",
            "def quote_etag(etag_str):",
            "    \"\"\"",
            "    If the provided string is already a quoted ETag, return it. Otherwise, wrap",
            "    the string in quotes, making it a strong ETag.",
            "    \"\"\"",
            "    if ETAG_MATCH.match(etag_str):",
            "        return etag_str",
            "    else:",
            "        return '\"%s\"' % etag_str",
            "",
            "",
            "def is_same_domain(host, pattern):",
            "    \"\"\"",
            "    Return ``True`` if the host is either an exact match or a match",
            "    to the wildcard pattern.",
            "",
            "    Any pattern beginning with a period matches a domain and all of its",
            "    subdomains. (e.g. ``.example.com`` matches ``example.com`` and",
            "    ``foo.example.com``). Anything else is an exact string match.",
            "    \"\"\"",
            "    if not pattern:",
            "        return False",
            "",
            "    pattern = pattern.lower()",
            "    return (",
            "        pattern[0] == '.' and (host.endswith(pattern) or host == pattern[1:]) or",
            "        pattern == host",
            "    )",
            "",
            "",
            "def is_safe_url(url, allowed_hosts, require_https=False):",
            "    \"\"\"",
            "    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to",
            "    a different host and uses a safe scheme).",
            "",
            "    Always return ``False`` on an empty url.",
            "",
            "    If ``require_https`` is ``True``, only 'https' will be considered a valid",
            "    scheme, as opposed to 'http' and 'https' with the default, ``False``.",
            "    \"\"\"",
            "    if url is not None:",
            "        url = url.strip()",
            "    if not url:",
            "        return False",
            "    if allowed_hosts is None:",
            "        allowed_hosts = set()",
            "    # Chrome treats \\ completely as / in paths but it could be part of some",
            "    # basic auth credentials so we need to check both URLs.",
            "    return (_is_safe_url(url, allowed_hosts, require_https=require_https) and",
            "            _is_safe_url(url.replace('\\\\', '/'), allowed_hosts, require_https=require_https))",
            "",
            "",
            "# Copied from urllib.parse.urlparse() but uses fixed urlsplit() function.",
            "def _urlparse(url, scheme='', allow_fragments=True):",
            "    \"\"\"Parse a URL into 6 components:",
            "    <scheme>://<netloc>/<path>;<params>?<query>#<fragment>",
            "    Return a 6-tuple: (scheme, netloc, path, params, query, fragment).",
            "    Note that we don't break the components up in smaller bits",
            "    (e.g. netloc is a single string) and we don't expand % escapes.\"\"\"",
            "    url, scheme, _coerce_result = _coerce_args(url, scheme)",
            "    splitresult = _urlsplit(url, scheme, allow_fragments)",
            "    scheme, netloc, url, query, fragment = splitresult",
            "    if scheme in uses_params and ';' in url:",
            "        url, params = _splitparams(url)",
            "    else:",
            "        params = ''",
            "    result = ParseResult(scheme, netloc, url, params, query, fragment)",
            "    return _coerce_result(result)",
            "",
            "",
            "# Copied from urllib.parse.urlsplit() with",
            "# https://github.com/python/cpython/pull/661 applied.",
            "def _urlsplit(url, scheme='', allow_fragments=True):",
            "    \"\"\"Parse a URL into 5 components:",
            "    <scheme>://<netloc>/<path>?<query>#<fragment>",
            "    Return a 5-tuple: (scheme, netloc, path, query, fragment).",
            "    Note that we don't break the components up in smaller bits",
            "    (e.g. netloc is a single string) and we don't expand % escapes.\"\"\"",
            "    url, scheme, _coerce_result = _coerce_args(url, scheme)",
            "    netloc = query = fragment = ''",
            "    i = url.find(':')",
            "    if i > 0:",
            "        for c in url[:i]:",
            "            if c not in scheme_chars:",
            "                break",
            "        else:",
            "            scheme, url = url[:i].lower(), url[i + 1:]",
            "",
            "    if url[:2] == '//':",
            "        netloc, url = _splitnetloc(url, 2)",
            "        if (('[' in netloc and ']' not in netloc) or",
            "                (']' in netloc and '[' not in netloc)):",
            "            raise ValueError(\"Invalid IPv6 URL\")",
            "    if allow_fragments and '#' in url:",
            "        url, fragment = url.split('#', 1)",
            "    if '?' in url:",
            "        url, query = url.split('?', 1)",
            "    v = SplitResult(scheme, netloc, url, query, fragment)",
            "    return _coerce_result(v)",
            "",
            "",
            "def _is_safe_url(url, allowed_hosts, require_https=False):",
            "    # Chrome considers any URL with more than two slashes to be absolute, but",
            "    # urlparse is not so flexible. Treat any url with three slashes as unsafe.",
            "    if url.startswith('///'):",
            "        return False",
            "    try:",
            "        url_info = _urlparse(url)",
            "    except ValueError:  # e.g. invalid IPv6 addresses",
            "        return False",
            "    # Forbid URLs like http:///example.com - with a scheme, but without a hostname.",
            "    # In that URL, example.com is not the hostname but, a path component. However,",
            "    # Chrome will still consider example.com to be the hostname, so we must not",
            "    # allow this syntax.",
            "    if not url_info.netloc and url_info.scheme:",
            "        return False",
            "    # Forbid URLs that start with control characters. Some browsers (like",
            "    # Chrome) ignore quite a few control characters at the start of a",
            "    # URL and might consider the URL as scheme relative.",
            "    if unicodedata.category(url[0])[0] == 'C':",
            "        return False",
            "    scheme = url_info.scheme",
            "    # Consider URLs without a scheme (e.g. //example.com/p) to be http.",
            "    if not url_info.scheme and url_info.netloc:",
            "        scheme = 'http'",
            "    valid_schemes = ['https'] if require_https else ['http', 'https']",
            "    return ((not url_info.netloc or url_info.netloc in allowed_hosts) and",
            "            (not scheme or scheme in valid_schemes))",
            "",
            "",
            "def limited_parse_qsl(qs, keep_blank_values=False, encoding='utf-8',",
            "                      errors='replace', fields_limit=None):",
            "    \"\"\"",
            "    Return a list of key/value tuples parsed from query string.",
            "",
            "    Copied from urlparse with an additional \"fields_limit\" argument.",
            "    Copyright (C) 2013 Python Software Foundation (see LICENSE.python).",
            "",
            "    Arguments:",
            "",
            "    qs: percent-encoded query string to be parsed",
            "",
            "    keep_blank_values: flag indicating whether blank values in",
            "        percent-encoded queries should be treated as blank strings. A",
            "        true value indicates that blanks should be retained as blank",
            "        strings. The default false value indicates that blank values",
            "        are to be ignored and treated as if they were  not included.",
            "",
            "    encoding and errors: specify how to decode percent-encoded sequences",
            "        into Unicode characters, as accepted by the bytes.decode() method.",
            "",
            "    fields_limit: maximum number of fields parsed or an exception",
            "        is raised. None means no limit and is the default.",
            "    \"\"\"",
            "    if fields_limit:",
            "        pairs = FIELDS_MATCH.split(qs, fields_limit)",
            "        if len(pairs) > fields_limit:",
            "            raise TooManyFieldsSent(",
            "                'The number of GET/POST parameters exceeded '",
            "                'settings.DATA_UPLOAD_MAX_NUMBER_FIELDS.'",
            "            )",
            "    else:",
            "        pairs = FIELDS_MATCH.split(qs)",
            "    r = []",
            "    for name_value in pairs:",
            "        if not name_value:",
            "            continue",
            "        nv = name_value.split('=', 1)",
            "        if len(nv) != 2:",
            "            # Handle case of a control-name with no equal sign",
            "            if keep_blank_values:",
            "                nv.append('')",
            "            else:",
            "                continue",
            "        if nv[1] or keep_blank_values:",
            "            name = nv[0].replace('+', ' ')",
            "            name = unquote(name, encoding=encoding, errors=errors)",
            "            value = nv[1].replace('+', ' ')",
            "            value = unquote(value, encoding=encoding, errors=errors)",
            "            r.append((name, value))",
            "    return r"
        ],
        "afterPatchFile": [
            "import base64",
            "import calendar",
            "import datetime",
            "import re",
            "import unicodedata",
            "import warnings",
            "from binascii import Error as BinasciiError",
            "from email.utils import formatdate",
            "from urllib.parse import (",
            "    ParseResult, SplitResult, _coerce_args, _splitnetloc, _splitparams, quote,",
            "    quote_plus, scheme_chars, unquote, unquote_plus,",
            "    urlencode as original_urlencode, uses_params,",
            ")",
            "",
            "from django.core.exceptions import TooManyFieldsSent",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.deprecation import RemovedInDjango30Warning",
            "from django.utils.encoding import force_bytes",
            "from django.utils.functional import keep_lazy_text",
            "",
            "# based on RFC 7232, Appendix C",
            "ETAG_MATCH = re.compile(r'''",
            "    \\A(      # start of string and capture group",
            "    (?:W/)?  # optional weak indicator",
            "    \"        # opening quote",
            "    [^\"]*    # any sequence of non-quote characters",
            "    \"        # end quote",
            "    )\\Z      # end of string and capture group",
            "''', re.X)",
            "",
            "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()",
            "__D = r'(?P<day>\\d{2})'",
            "__D2 = r'(?P<day>[ \\d]\\d)'",
            "__M = r'(?P<mon>\\w{3})'",
            "__Y = r'(?P<year>\\d{4})'",
            "__Y2 = r'(?P<year>\\d{2})'",
            "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'",
            "RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))",
            "RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))",
            "ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))",
            "",
            "RFC3986_GENDELIMS = \":/?#[]@\"",
            "RFC3986_SUBDELIMS = \"!$&'()*+,;=\"",
            "",
            "FIELDS_MATCH = re.compile('[&;]')",
            "",
            "",
            "@keep_lazy_text",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A legacy compatibility wrapper to Python's urllib.parse.quote() function.",
            "    (was used for unicode handling on Python 2)",
            "    \"\"\"",
            "    return quote(url, safe)",
            "",
            "",
            "@keep_lazy_text",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A legacy compatibility wrapper to Python's urllib.parse.quote_plus()",
            "    function. (was used for unicode handling on Python 2)",
            "    \"\"\"",
            "    return quote_plus(url, safe)",
            "",
            "",
            "@keep_lazy_text",
            "def urlunquote(quoted_url):",
            "    \"\"\"",
            "    A legacy compatibility wrapper to Python's urllib.parse.unquote() function.",
            "    (was used for unicode handling on Python 2)",
            "    \"\"\"",
            "    return unquote(quoted_url)",
            "",
            "",
            "@keep_lazy_text",
            "def urlunquote_plus(quoted_url):",
            "    \"\"\"",
            "    A legacy compatibility wrapper to Python's urllib.parse.unquote_plus()",
            "    function. (was used for unicode handling on Python 2)",
            "    \"\"\"",
            "    return unquote_plus(quoted_url)",
            "",
            "",
            "def urlencode(query, doseq=False):",
            "    \"\"\"",
            "    A version of Python's urllib.parse.urlencode() function that can operate on",
            "    MultiValueDict and non-string values.",
            "    \"\"\"",
            "    if isinstance(query, MultiValueDict):",
            "        query = query.lists()",
            "    elif hasattr(query, 'items'):",
            "        query = query.items()",
            "    query_params = []",
            "    for key, value in query:",
            "        if isinstance(value, (str, bytes)):",
            "            query_val = value",
            "        else:",
            "            try:",
            "                iter(value)",
            "            except TypeError:",
            "                query_val = value",
            "            else:",
            "                # Consume generators and iterators, even when doseq=True, to",
            "                # work around https://bugs.python.org/issue31706.",
            "                query_val = [",
            "                    item if isinstance(item, bytes) else str(item)",
            "                    for item in value",
            "                ]",
            "        query_params.append((key, query_val))",
            "    return original_urlencode(query_params, doseq)",
            "",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Format the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    `epoch_seconds` is a floating point number expressed in seconds since the",
            "    epoch, in UTC - such as that outputted by time.time(). If set to None, it",
            "    defaults to the current time.",
            "",
            "    Output a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    warnings.warn(",
            "        'cookie_date() is deprecated in favor of http_date(), which follows '",
            "        'the format of the latest RFC.',",
            "        RemovedInDjango30Warning, stacklevel=2,",
            "    )",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Format the time to match the RFC1123 date format as specified by HTTP",
            "    RFC7231 section 7.1.1.1.",
            "",
            "    `epoch_seconds` is a floating point number expressed in seconds since the",
            "    epoch, in UTC - such as that outputted by time.time(). If set to None, it",
            "    defaults to the current time.",
            "",
            "    Output a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    return formatdate(epoch_seconds, usegmt=True)",
            "",
            "",
            "def parse_http_date(date):",
            "    \"\"\"",
            "    Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.",
            "",
            "    The three formats allowed by the RFC are accepted, even if only the first",
            "    one is still in widespread use.",
            "",
            "    Return an integer expressed in seconds since the epoch, in UTC.",
            "    \"\"\"",
            "    # email.utils.parsedate() does the job for RFC1123 dates; unfortunately",
            "    # RFC7231 makes it mandatory to support RFC850 dates too. So we roll",
            "    # our own RFC-compliant parsing.",
            "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:",
            "        m = regex.match(date)",
            "        if m is not None:",
            "            break",
            "    else:",
            "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)",
            "    try:",
            "        year = int(m.group('year'))",
            "        if year < 100:",
            "            if year < 70:",
            "                year += 2000",
            "            else:",
            "                year += 1900",
            "        month = MONTHS.index(m.group('mon').lower()) + 1",
            "        day = int(m.group('day'))",
            "        hour = int(m.group('hour'))",
            "        min = int(m.group('min'))",
            "        sec = int(m.group('sec'))",
            "        result = datetime.datetime(year, month, day, hour, min, sec)",
            "        return calendar.timegm(result.utctimetuple())",
            "    except Exception as exc:",
            "        raise ValueError(\"%r is not a valid date\" % date) from exc",
            "",
            "",
            "def parse_http_date_safe(date):",
            "    \"\"\"",
            "    Same as parse_http_date, but return None if the input is invalid.",
            "    \"\"\"",
            "    try:",
            "        return parse_http_date(date)",
            "    except Exception:",
            "        pass",
            "",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Convert a base 36 string to an int. Raise ValueError if the input won't fit",
            "    into an int.",
            "    \"\"\"",
            "    # To prevent overconsumption of server resources, reject any",
            "    # base36 string that is longer than 13 base36 digits (13 digits",
            "    # is sufficient to base36-encode any 64-bit integer)",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return int(s, 36)",
            "",
            "",
            "def int_to_base36(i):",
            "    \"\"\"Convert an integer to a base36 string.\"\"\"",
            "    char_set = '0123456789abcdefghijklmnopqrstuvwxyz'",
            "    if i < 0:",
            "        raise ValueError(\"Negative base36 conversion input.\")",
            "    if i < 36:",
            "        return char_set[i]",
            "    b36 = ''",
            "    while i != 0:",
            "        i, n = divmod(i, 36)",
            "        b36 = char_set[n] + b36",
            "    return b36",
            "",
            "",
            "def urlsafe_base64_encode(s):",
            "    \"\"\"",
            "    Encode a bytestring in base64 for use in URLs. Strip any trailing equal",
            "    signs.",
            "    \"\"\"",
            "    return base64.urlsafe_b64encode(s).rstrip(b'\\n=')",
            "",
            "",
            "def urlsafe_base64_decode(s):",
            "    \"\"\"",
            "    Decode a base64 encoded string. Add back any trailing equal signs that",
            "    might have been stripped.",
            "    \"\"\"",
            "    s = force_bytes(s)",
            "    try:",
            "        return base64.urlsafe_b64decode(s.ljust(len(s) + len(s) % 4, b'='))",
            "    except (LookupError, BinasciiError) as e:",
            "        raise ValueError(e)",
            "",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parse a string of ETags given in an If-None-Match or If-Match header as",
            "    defined by RFC 7232. Return a list of quoted ETags, or ['*'] if all ETags",
            "    should be matched.",
            "    \"\"\"",
            "    if etag_str.strip() == '*':",
            "        return ['*']",
            "    else:",
            "        # Parse each ETag individually, and return any that are valid.",
            "        etag_matches = (ETAG_MATCH.match(etag.strip()) for etag in etag_str.split(','))",
            "        return [match.group(1) for match in etag_matches if match]",
            "",
            "",
            "def quote_etag(etag_str):",
            "    \"\"\"",
            "    If the provided string is already a quoted ETag, return it. Otherwise, wrap",
            "    the string in quotes, making it a strong ETag.",
            "    \"\"\"",
            "    if ETAG_MATCH.match(etag_str):",
            "        return etag_str",
            "    else:",
            "        return '\"%s\"' % etag_str",
            "",
            "",
            "def is_same_domain(host, pattern):",
            "    \"\"\"",
            "    Return ``True`` if the host is either an exact match or a match",
            "    to the wildcard pattern.",
            "",
            "    Any pattern beginning with a period matches a domain and all of its",
            "    subdomains. (e.g. ``.example.com`` matches ``example.com`` and",
            "    ``foo.example.com``). Anything else is an exact string match.",
            "    \"\"\"",
            "    if not pattern:",
            "        return False",
            "",
            "    pattern = pattern.lower()",
            "    return (",
            "        pattern[0] == '.' and (host.endswith(pattern) or host == pattern[1:]) or",
            "        pattern == host",
            "    )",
            "",
            "",
            "def is_safe_url(url, allowed_hosts, require_https=False):",
            "    \"\"\"",
            "    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to",
            "    a different host and uses a safe scheme).",
            "",
            "    Always return ``False`` on an empty url.",
            "",
            "    If ``require_https`` is ``True``, only 'https' will be considered a valid",
            "    scheme, as opposed to 'http' and 'https' with the default, ``False``.",
            "    \"\"\"",
            "    if url is not None:",
            "        url = url.strip()",
            "    if not url:",
            "        return False",
            "    if allowed_hosts is None:",
            "        allowed_hosts = set()",
            "    # Chrome treats \\ completely as / in paths but it could be part of some",
            "    # basic auth credentials so we need to check both URLs.",
            "    return (_is_safe_url(url, allowed_hosts, require_https=require_https) and",
            "            _is_safe_url(url.replace('\\\\', '/'), allowed_hosts, require_https=require_https))",
            "",
            "",
            "# Copied from urllib.parse.urlparse() but uses fixed urlsplit() function.",
            "def _urlparse(url, scheme='', allow_fragments=True):",
            "    \"\"\"Parse a URL into 6 components:",
            "    <scheme>://<netloc>/<path>;<params>?<query>#<fragment>",
            "    Return a 6-tuple: (scheme, netloc, path, params, query, fragment).",
            "    Note that we don't break the components up in smaller bits",
            "    (e.g. netloc is a single string) and we don't expand % escapes.\"\"\"",
            "    url, scheme, _coerce_result = _coerce_args(url, scheme)",
            "    splitresult = _urlsplit(url, scheme, allow_fragments)",
            "    scheme, netloc, url, query, fragment = splitresult",
            "    if scheme in uses_params and ';' in url:",
            "        url, params = _splitparams(url)",
            "    else:",
            "        params = ''",
            "    result = ParseResult(scheme, netloc, url, params, query, fragment)",
            "    return _coerce_result(result)",
            "",
            "",
            "# Copied from urllib.parse.urlsplit() with",
            "# https://github.com/python/cpython/pull/661 applied.",
            "def _urlsplit(url, scheme='', allow_fragments=True):",
            "    \"\"\"Parse a URL into 5 components:",
            "    <scheme>://<netloc>/<path>?<query>#<fragment>",
            "    Return a 5-tuple: (scheme, netloc, path, query, fragment).",
            "    Note that we don't break the components up in smaller bits",
            "    (e.g. netloc is a single string) and we don't expand % escapes.\"\"\"",
            "    url, scheme, _coerce_result = _coerce_args(url, scheme)",
            "    netloc = query = fragment = ''",
            "    i = url.find(':')",
            "    if i > 0:",
            "        for c in url[:i]:",
            "            if c not in scheme_chars:",
            "                break",
            "        else:",
            "            scheme, url = url[:i].lower(), url[i + 1:]",
            "",
            "    if url[:2] == '//':",
            "        netloc, url = _splitnetloc(url, 2)",
            "        if (('[' in netloc and ']' not in netloc) or",
            "                (']' in netloc and '[' not in netloc)):",
            "            raise ValueError(\"Invalid IPv6 URL\")",
            "    if allow_fragments and '#' in url:",
            "        url, fragment = url.split('#', 1)",
            "    if '?' in url:",
            "        url, query = url.split('?', 1)",
            "    v = SplitResult(scheme, netloc, url, query, fragment)",
            "    return _coerce_result(v)",
            "",
            "",
            "def _is_safe_url(url, allowed_hosts, require_https=False):",
            "    # Chrome considers any URL with more than two slashes to be absolute, but",
            "    # urlparse is not so flexible. Treat any url with three slashes as unsafe.",
            "    if url.startswith('///'):",
            "        return False",
            "    try:",
            "        url_info = _urlparse(url)",
            "    except ValueError:  # e.g. invalid IPv6 addresses",
            "        return False",
            "    # Forbid URLs like http:///example.com - with a scheme, but without a hostname.",
            "    # In that URL, example.com is not the hostname but, a path component. However,",
            "    # Chrome will still consider example.com to be the hostname, so we must not",
            "    # allow this syntax.",
            "    if not url_info.netloc and url_info.scheme:",
            "        return False",
            "    # Forbid URLs that start with control characters. Some browsers (like",
            "    # Chrome) ignore quite a few control characters at the start of a",
            "    # URL and might consider the URL as scheme relative.",
            "    if unicodedata.category(url[0])[0] == 'C':",
            "        return False",
            "    scheme = url_info.scheme",
            "    # Consider URLs without a scheme (e.g. //example.com/p) to be http.",
            "    if not url_info.scheme and url_info.netloc:",
            "        scheme = 'http'",
            "    valid_schemes = ['https'] if require_https else ['http', 'https']",
            "    return ((not url_info.netloc or url_info.netloc in allowed_hosts) and",
            "            (not scheme or scheme in valid_schemes))",
            "",
            "",
            "def limited_parse_qsl(qs, keep_blank_values=False, encoding='utf-8',",
            "                      errors='replace', fields_limit=None):",
            "    \"\"\"",
            "    Return a list of key/value tuples parsed from query string.",
            "",
            "    Copied from urlparse with an additional \"fields_limit\" argument.",
            "    Copyright (C) 2013 Python Software Foundation (see LICENSE.python).",
            "",
            "    Arguments:",
            "",
            "    qs: percent-encoded query string to be parsed",
            "",
            "    keep_blank_values: flag indicating whether blank values in",
            "        percent-encoded queries should be treated as blank strings. A",
            "        true value indicates that blanks should be retained as blank",
            "        strings. The default false value indicates that blank values",
            "        are to be ignored and treated as if they were  not included.",
            "",
            "    encoding and errors: specify how to decode percent-encoded sequences",
            "        into Unicode characters, as accepted by the bytes.decode() method.",
            "",
            "    fields_limit: maximum number of fields parsed or an exception",
            "        is raised. None means no limit and is the default.",
            "    \"\"\"",
            "    if fields_limit:",
            "        pairs = FIELDS_MATCH.split(qs, fields_limit)",
            "        if len(pairs) > fields_limit:",
            "            raise TooManyFieldsSent(",
            "                'The number of GET/POST parameters exceeded '",
            "                'settings.DATA_UPLOAD_MAX_NUMBER_FIELDS.'",
            "            )",
            "    else:",
            "        pairs = FIELDS_MATCH.split(qs)",
            "    r = []",
            "    for name_value in pairs:",
            "        if not name_value:",
            "            continue",
            "        nv = name_value.split('=', 1)",
            "        if len(nv) != 2:",
            "            # Handle case of a control-name with no equal sign",
            "            if keep_blank_values:",
            "                nv.append('')",
            "            else:",
            "                continue",
            "        if nv[1] or keep_blank_values:",
            "            name = nv[0].replace('+', ' ')",
            "            name = unquote(name, encoding=encoding, errors=errors)",
            "            value = nv[1].replace('+', ' ')",
            "            value = unquote(value, encoding=encoding, errors=errors)",
            "            r.append((name, value))",
            "    return r",
            "",
            "",
            "def escape_leading_slashes(url):",
            "    \"\"\"",
            "    If redirecting to an absolute path (two leading slashes), a slash must be",
            "    escaped to prevent browsers from handling the path as schemaless and",
            "    redirecting to another host.",
            "    \"\"\"",
            "    if url.startswith('//'):",
            "        url = '/%2F{}'.format(url[2:])",
            "    return url"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tensorflow.python.ops.image_ops_test.RGBToHSVTest"
        ]
    }
}