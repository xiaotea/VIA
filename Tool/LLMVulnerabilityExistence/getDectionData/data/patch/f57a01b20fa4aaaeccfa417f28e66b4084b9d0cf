{
    "feedgen/entry.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": "     feedgen.entry"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": "     ~~~~~~~~~~~~~"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :copyright: 2013, Lars Kiesow <lkiesow@uos.de>"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+    :copyright: 2013-2020, Lars Kiesow <lkiesow@uos.de>"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     :license: FreeBSD and LGPL, see license.* for more details."
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " '''"
            },
            "8": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import dateutil.parser"
            },
            "9": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import dateutil.tz"
            },
            "10": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import warnings"
            },
            "11": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lxml import etree"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from lxml.etree import CDATA  # nosec - adding CDATA entry is safe"
            },
            "14": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from feedgen.compat import string_types"
            },
            "16": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from feedgen.util import ensure_format, formatRFC2822"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from feedgen.util import ensure_format, formatRFC2822, xml_fromstring, xml_elem"
            },
            "18": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " def _add_text_elm(entry, data, name):"
            },
            "21": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     \"\"\"Add a text subelement to an entry\"\"\""
            },
            "22": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     if not data:"
            },
            "23": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         return"
            },
            "24": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elm = etree.SubElement(entry, name)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    elm = xml_elem(name, entry)"
            },
            "27": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     type_ = data.get('type')"
            },
            "28": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     if data.get('src'):"
            },
            "29": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         if name != 'content':"
            },
            "30": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     elif data.get(name):"
            },
            "31": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         # Surround xhtml with a div tag, parse it and embed it"
            },
            "32": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         if type_ == 'xhtml':"
            },
            "33": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elm.append(etree.fromstring("
            },
            "34": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                '<div xmlns=\"http://www.w3.org/1999/xhtml\">' +"
            },
            "35": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                data.get(name) + '</div>'))"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            xhtml = '<div xmlns=\"http://www.w3.org/1999/xhtml\">' \\"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+                    + data.get(name) + '</div>'"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+            elm.append(xml_fromstring(xhtml))"
            },
            "39": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         elif type_ == 'CDATA':"
            },
            "40": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elm.text = etree.CDATA("
            },
            "41": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    data.get(name))"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+            elm.text = CDATA(data.get(name))"
            },
            "43": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         # Parse XML and embed it"
            },
            "44": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         elif type_ and (type_.endswith('/xml') or type_.endswith('+xml')):"
            },
            "45": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elm.append(etree.fromstring("
            },
            "46": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                data[name]))"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            elm.append(xml_fromstring(data[name]))"
            },
            "48": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         # Embed the text in escaped form"
            },
            "49": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         elif not type_ or type_.startswith('text') or type_ == 'html':"
            },
            "50": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             elm.text = data.get(name)"
            },
            "51": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def atom_entry(self, extensions=True):"
            },
            "53": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         '''Create an ATOM entry and return it.'''"
            },
            "54": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        entry = etree.Element('entry')"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        entry = xml_elem('entry')"
            },
            "56": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         if not (self.__atom_id and self.__atom_title and self.__atom_updated):"
            },
            "57": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "             raise ValueError('Required fields not set')"
            },
            "58": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        id = etree.SubElement(entry, 'id')"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        id = xml_elem('id', entry)"
            },
            "60": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         id.text = self.__atom_id"
            },
            "61": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        title = etree.SubElement(entry, 'title')"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+        title = xml_elem('title', entry)"
            },
            "63": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         title.text = self.__atom_title"
            },
            "64": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        updated = etree.SubElement(entry, 'updated')"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        updated = xml_elem('updated', entry)"
            },
            "66": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         updated.text = self.__atom_updated.isoformat()"
            },
            "67": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         # An entry must contain an alternate link if there is no content"
            },
            "69": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "             # Atom requires a name. Skip elements without."
            },
            "70": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "             if not a.get('name'):"
            },
            "71": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "                 continue"
            },
            "72": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            author = etree.SubElement(entry, 'author')"
            },
            "73": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            name = etree.SubElement(author, 'name')"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+            author = xml_elem('author', entry)"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+            name = xml_elem('name', author)"
            },
            "76": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "             name.text = a.get('name')"
            },
            "77": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "             if a.get('email'):"
            },
            "78": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                email = etree.SubElement(author, 'email')"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+                email = xml_elem('email', author)"
            },
            "80": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                 email.text = a.get('email')"
            },
            "81": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "             if a.get('uri'):"
            },
            "82": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                uri = etree.SubElement(author, 'uri')"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+                uri = xml_elem('uri', author)"
            },
            "84": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "                 uri.text = a.get('uri')"
            },
            "85": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         _add_text_elm(entry, self.__atom_content, 'content')"
            },
            "87": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " "
            },
            "88": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         for l in self.__atom_link or []:"
            },
            "89": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            link = etree.SubElement(entry, 'link', href=l['href'])"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+            link = xml_elem('link', entry, href=l['href'])"
            },
            "91": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "             if l.get('rel'):"
            },
            "92": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "                 link.attrib['rel'] = l['rel']"
            },
            "93": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             if l.get('type'):"
            },
            "94": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         _add_text_elm(entry, self.__atom_summary, 'summary')"
            },
            "95": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "96": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         for c in self.__atom_category or []:"
            },
            "97": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cat = etree.SubElement(entry, 'category', term=c['term'])"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            cat = xml_elem('category', entry, term=c['term'])"
            },
            "99": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "             if c.get('scheme'):"
            },
            "100": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "                 cat.attrib['scheme'] = c['scheme']"
            },
            "101": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "             if c.get('label'):"
            },
            "102": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "             # Atom requires a name. Skip elements without."
            },
            "103": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "             if not c.get('name'):"
            },
            "104": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "                 continue"
            },
            "105": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            contrib = etree.SubElement(entry, 'contributor')"
            },
            "106": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            name = etree.SubElement(contrib, 'name')"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            contrib = xml_elem('contributor', entry)"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            name = xml_elem('name', contrib)"
            },
            "109": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "             name.text = c.get('name')"
            },
            "110": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             if c.get('email'):"
            },
            "111": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                email = etree.SubElement(contrib, 'email')"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+                email = xml_elem('email', contrib)"
            },
            "113": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "                 email.text = c.get('email')"
            },
            "114": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "             if c.get('uri'):"
            },
            "115": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                uri = etree.SubElement(contrib, 'uri')"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+                uri = xml_elem('uri', contrib)"
            },
            "117": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "                 uri.text = c.get('uri')"
            },
            "118": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " "
            },
            "119": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         if self.__atom_published:"
            },
            "120": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            published = etree.SubElement(entry, 'published')"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+            published = xml_elem('published', entry)"
            },
            "122": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "             published.text = self.__atom_published.isoformat()"
            },
            "123": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "124": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         if self.__atom_rights:"
            },
            "125": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            rights = etree.SubElement(entry, 'rights')"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+            rights = xml_elem('rights', entry)"
            },
            "127": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "             rights.text = self.__atom_rights"
            },
            "128": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "129": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         if self.__atom_source:"
            },
            "130": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            source = etree.SubElement(entry, 'source')"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+            source = xml_elem('source', entry)"
            },
            "132": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "             if self.__atom_source.get('title'):"
            },
            "133": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                source_title = etree.SubElement(source, 'title')"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+                source_title = xml_elem('title', source)"
            },
            "135": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "                 source_title.text = self.__atom_source['title']"
            },
            "136": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "             if self.__atom_source.get('link'):"
            },
            "137": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                etree.SubElement(source, 'link',"
            },
            "138": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                 href=self.__atom_source['link'])"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                xml_elem('link', source, href=self.__atom_source['link'])"
            },
            "140": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " "
            },
            "141": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "         if extensions:"
            },
            "142": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "             for ext in self.__extensions.values() or []:"
            },
            "143": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 198,
                "PatchRowcode": " "
            },
            "144": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "     def rss_entry(self, extensions=True):"
            },
            "145": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         '''Create a RSS item and return it.'''"
            },
            "146": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        entry = etree.Element('item')"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        entry = xml_elem('item')"
            },
            "148": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         if not (self.__rss_title or"
            },
            "149": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "                 self.__rss_description or"
            },
            "150": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "                 self.__rss_content):"
            },
            "151": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "             raise ValueError('Required fields not set')"
            },
            "152": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "         if self.__rss_title:"
            },
            "153": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            title = etree.SubElement(entry, 'title')"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+            title = xml_elem('title', entry)"
            },
            "155": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "             title.text = self.__rss_title"
            },
            "156": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         if self.__rss_link:"
            },
            "157": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            link = etree.SubElement(entry, 'link')"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+            link = xml_elem('link', entry)"
            },
            "159": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "             link.text = self.__rss_link"
            },
            "160": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "         if self.__rss_description and self.__rss_content:"
            },
            "161": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            description = etree.SubElement(entry, 'description')"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+            description = xml_elem('description', entry)"
            },
            "163": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "             description.text = self.__rss_description"
            },
            "164": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "             XMLNS_CONTENT = 'http://purl.org/rss/1.0/modules/content/'"
            },
            "165": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            content = etree.SubElement(entry, '{%s}encoded' % XMLNS_CONTENT)"
            },
            "166": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            content.text = etree.CDATA(self.__rss_content['content']) \\"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            content = xml_elem('{%s}encoded' % XMLNS_CONTENT, entry)"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            content.text = CDATA(self.__rss_content['content']) \\"
            },
            "169": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "                 if self.__rss_content.get('type', '') == 'CDATA' \\"
            },
            "170": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "                 else self.__rss_content['content']"
            },
            "171": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "         elif self.__rss_description:"
            },
            "172": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            description = etree.SubElement(entry, 'description')"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            description = xml_elem('description', entry)"
            },
            "174": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "             description.text = self.__rss_description"
            },
            "175": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "         elif self.__rss_content:"
            },
            "176": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            description = etree.SubElement(entry, 'description')"
            },
            "177": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            description.text = etree.CDATA(self.__rss_content['content']) \\"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            description = xml_elem('description', entry)"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            description.text = CDATA(self.__rss_content['content']) \\"
            },
            "180": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "                 if self.__rss_content.get('type', '') == 'CDATA' \\"
            },
            "181": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "                 else self.__rss_content['content']"
            },
            "182": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "         for a in self.__rss_author or []:"
            },
            "183": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            author = etree.SubElement(entry, 'author')"
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+            author = xml_elem('author', entry)"
            },
            "185": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "             author.text = a"
            },
            "186": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         if self.__rss_guid.get('guid'):"
            },
            "187": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            guid = etree.SubElement(entry, 'guid')"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            guid = xml_elem('guid', entry)"
            },
            "189": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "             guid.text = self.__rss_guid['guid']"
            },
            "190": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "             permaLink = str(self.__rss_guid.get('permalink', False)).lower()"
            },
            "191": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "             guid.attrib['isPermaLink'] = permaLink"
            },
            "192": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         for cat in self.__rss_category or []:"
            },
            "193": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            category = etree.SubElement(entry, 'category')"
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+            category = xml_elem('category', entry)"
            },
            "195": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "             category.text = cat['value']"
            },
            "196": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "             if cat.get('domain'):"
            },
            "197": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "                 category.attrib['domain'] = cat['domain']"
            },
            "198": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         if self.__rss_comments:"
            },
            "199": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            comments = etree.SubElement(entry, 'comments')"
            },
            "200": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+            comments = xml_elem('comments', entry)"
            },
            "201": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "             comments.text = self.__rss_comments"
            },
            "202": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         if self.__rss_enclosure:"
            },
            "203": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            enclosure = etree.SubElement(entry, 'enclosure')"
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+            enclosure = xml_elem('enclosure', entry)"
            },
            "205": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "             enclosure.attrib['url'] = self.__rss_enclosure['url']"
            },
            "206": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "             enclosure.attrib['length'] = self.__rss_enclosure['length']"
            },
            "207": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "             enclosure.attrib['type'] = self.__rss_enclosure['type']"
            },
            "208": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         if self.__rss_pubDate:"
            },
            "209": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            pubDate = etree.SubElement(entry, 'pubDate')"
            },
            "210": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+            pubDate = xml_elem('pubDate', entry)"
            },
            "211": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "             pubDate.text = formatRFC2822(self.__rss_pubDate)"
            },
            "212": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         if self.__rss_source:"
            },
            "213": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            source = etree.SubElement(entry, 'source',"
            },
            "214": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                      url=self.__rss_source['url'])"
            },
            "215": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+            source = xml_elem('source', entry, url=self.__rss_source['url'])"
            },
            "216": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "             source.text = self.__rss_source['title']"
            },
            "217": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 255,
                "PatchRowcode": " "
            },
            "218": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         if extensions:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "    feedgen.entry",
            "    ~~~~~~~~~~~~~",
            "",
            "    :copyright: 2013, Lars Kiesow <lkiesow@uos.de>",
            "",
            "    :license: FreeBSD and LGPL, see license.* for more details.",
            "'''",
            "",
            "from datetime import datetime",
            "",
            "import dateutil.parser",
            "import dateutil.tz",
            "import warnings",
            "from lxml import etree",
            "",
            "from feedgen.compat import string_types",
            "from feedgen.util import ensure_format, formatRFC2822",
            "",
            "",
            "def _add_text_elm(entry, data, name):",
            "    \"\"\"Add a text subelement to an entry\"\"\"",
            "    if not data:",
            "        return",
            "",
            "    elm = etree.SubElement(entry, name)",
            "    type_ = data.get('type')",
            "    if data.get('src'):",
            "        if name != 'content':",
            "            raise ValueError(\"Only the 'content' element of an entry can \"",
            "                             \"contain a 'src' attribute\")",
            "        elm.attrib['src'] = data['src']",
            "    elif data.get(name):",
            "        # Surround xhtml with a div tag, parse it and embed it",
            "        if type_ == 'xhtml':",
            "            elm.append(etree.fromstring(",
            "                '<div xmlns=\"http://www.w3.org/1999/xhtml\">' +",
            "                data.get(name) + '</div>'))",
            "        elif type_ == 'CDATA':",
            "            elm.text = etree.CDATA(",
            "                    data.get(name))",
            "        # Parse XML and embed it",
            "        elif type_ and (type_.endswith('/xml') or type_.endswith('+xml')):",
            "            elm.append(etree.fromstring(",
            "                data[name]))",
            "        # Embed the text in escaped form",
            "        elif not type_ or type_.startswith('text') or type_ == 'html':",
            "            elm.text = data.get(name)",
            "        # Everything else should be included base64 encoded",
            "        else:",
            "            raise NotImplementedError(",
            "                'base64 encoded {} is not supported at the moment. '",
            "                'Pull requests adding support are welcome.'.format(name)",
            "            )",
            "    # Add type description of the content",
            "    if type_:",
            "        elm.attrib['type'] = type_",
            "",
            "",
            "class FeedEntry(object):",
            "    '''FeedEntry call representing an ATOM feeds entry node or an RSS feeds item",
            "    node.",
            "    '''",
            "",
            "    def __init__(self):",
            "        # ATOM",
            "        # required",
            "        self.__atom_id = None",
            "        self.__atom_title = None",
            "        self.__atom_updated = datetime.now(dateutil.tz.tzutc())",
            "",
            "        # recommended",
            "        self.__atom_author = None",
            "        self.__atom_content = None",
            "        self.__atom_link = None",
            "        self.__atom_summary = None",
            "",
            "        # optional",
            "        self.__atom_category = None",
            "        self.__atom_contributor = None",
            "        self.__atom_published = None",
            "        self.__atom_source = None",
            "        self.__atom_rights = None",
            "",
            "        # RSS",
            "        self.__rss_author = None",
            "        self.__rss_category = None",
            "        self.__rss_comments = None",
            "        self.__rss_description = None",
            "        self.__rss_content = None",
            "        self.__rss_enclosure = None",
            "        self.__rss_guid = {}",
            "        self.__rss_link = None",
            "        self.__rss_pubDate = None",
            "        self.__rss_source = None",
            "        self.__rss_title = None",
            "",
            "        # Extension list:",
            "        self.__extensions = {}",
            "        self.__extensions_register = {}",
            "",
            "    def atom_entry(self, extensions=True):",
            "        '''Create an ATOM entry and return it.'''",
            "        entry = etree.Element('entry')",
            "        if not (self.__atom_id and self.__atom_title and self.__atom_updated):",
            "            raise ValueError('Required fields not set')",
            "        id = etree.SubElement(entry, 'id')",
            "        id.text = self.__atom_id",
            "        title = etree.SubElement(entry, 'title')",
            "        title.text = self.__atom_title",
            "        updated = etree.SubElement(entry, 'updated')",
            "        updated.text = self.__atom_updated.isoformat()",
            "",
            "        # An entry must contain an alternate link if there is no content",
            "        # element.",
            "        if not self.__atom_content:",
            "            links = self.__atom_link or []",
            "            if not [l for l in links if l.get('rel') == 'alternate']:",
            "                raise ValueError('Entry must contain an alternate link or ' +",
            "                                 'a content element.')",
            "",
            "        # Add author elements",
            "        for a in self.__atom_author or []:",
            "            # Atom requires a name. Skip elements without.",
            "            if not a.get('name'):",
            "                continue",
            "            author = etree.SubElement(entry, 'author')",
            "            name = etree.SubElement(author, 'name')",
            "            name.text = a.get('name')",
            "            if a.get('email'):",
            "                email = etree.SubElement(author, 'email')",
            "                email.text = a.get('email')",
            "            if a.get('uri'):",
            "                uri = etree.SubElement(author, 'uri')",
            "                uri.text = a.get('uri')",
            "",
            "        _add_text_elm(entry, self.__atom_content, 'content')",
            "",
            "        for l in self.__atom_link or []:",
            "            link = etree.SubElement(entry, 'link', href=l['href'])",
            "            if l.get('rel'):",
            "                link.attrib['rel'] = l['rel']",
            "            if l.get('type'):",
            "                link.attrib['type'] = l['type']",
            "            if l.get('hreflang'):",
            "                link.attrib['hreflang'] = l['hreflang']",
            "            if l.get('title'):",
            "                link.attrib['title'] = l['title']",
            "            if l.get('length'):",
            "                link.attrib['length'] = l['length']",
            "",
            "        _add_text_elm(entry, self.__atom_summary, 'summary')",
            "",
            "        for c in self.__atom_category or []:",
            "            cat = etree.SubElement(entry, 'category', term=c['term'])",
            "            if c.get('scheme'):",
            "                cat.attrib['scheme'] = c['scheme']",
            "            if c.get('label'):",
            "                cat.attrib['label'] = c['label']",
            "",
            "        # Add author elements",
            "        for c in self.__atom_contributor or []:",
            "            # Atom requires a name. Skip elements without.",
            "            if not c.get('name'):",
            "                continue",
            "            contrib = etree.SubElement(entry, 'contributor')",
            "            name = etree.SubElement(contrib, 'name')",
            "            name.text = c.get('name')",
            "            if c.get('email'):",
            "                email = etree.SubElement(contrib, 'email')",
            "                email.text = c.get('email')",
            "            if c.get('uri'):",
            "                uri = etree.SubElement(contrib, 'uri')",
            "                uri.text = c.get('uri')",
            "",
            "        if self.__atom_published:",
            "            published = etree.SubElement(entry, 'published')",
            "            published.text = self.__atom_published.isoformat()",
            "",
            "        if self.__atom_rights:",
            "            rights = etree.SubElement(entry, 'rights')",
            "            rights.text = self.__atom_rights",
            "",
            "        if self.__atom_source:",
            "            source = etree.SubElement(entry, 'source')",
            "            if self.__atom_source.get('title'):",
            "                source_title = etree.SubElement(source, 'title')",
            "                source_title.text = self.__atom_source['title']",
            "            if self.__atom_source.get('link'):",
            "                etree.SubElement(source, 'link',",
            "                                 href=self.__atom_source['link'])",
            "",
            "        if extensions:",
            "            for ext in self.__extensions.values() or []:",
            "                if ext.get('atom'):",
            "                    ext['inst'].extend_atom(entry)",
            "",
            "        return entry",
            "",
            "    def rss_entry(self, extensions=True):",
            "        '''Create a RSS item and return it.'''",
            "        entry = etree.Element('item')",
            "        if not (self.__rss_title or",
            "                self.__rss_description or",
            "                self.__rss_content):",
            "            raise ValueError('Required fields not set')",
            "        if self.__rss_title:",
            "            title = etree.SubElement(entry, 'title')",
            "            title.text = self.__rss_title",
            "        if self.__rss_link:",
            "            link = etree.SubElement(entry, 'link')",
            "            link.text = self.__rss_link",
            "        if self.__rss_description and self.__rss_content:",
            "            description = etree.SubElement(entry, 'description')",
            "            description.text = self.__rss_description",
            "            XMLNS_CONTENT = 'http://purl.org/rss/1.0/modules/content/'",
            "            content = etree.SubElement(entry, '{%s}encoded' % XMLNS_CONTENT)",
            "            content.text = etree.CDATA(self.__rss_content['content']) \\",
            "                if self.__rss_content.get('type', '') == 'CDATA' \\",
            "                else self.__rss_content['content']",
            "        elif self.__rss_description:",
            "            description = etree.SubElement(entry, 'description')",
            "            description.text = self.__rss_description",
            "        elif self.__rss_content:",
            "            description = etree.SubElement(entry, 'description')",
            "            description.text = etree.CDATA(self.__rss_content['content']) \\",
            "                if self.__rss_content.get('type', '') == 'CDATA' \\",
            "                else self.__rss_content['content']",
            "        for a in self.__rss_author or []:",
            "            author = etree.SubElement(entry, 'author')",
            "            author.text = a",
            "        if self.__rss_guid.get('guid'):",
            "            guid = etree.SubElement(entry, 'guid')",
            "            guid.text = self.__rss_guid['guid']",
            "            permaLink = str(self.__rss_guid.get('permalink', False)).lower()",
            "            guid.attrib['isPermaLink'] = permaLink",
            "        for cat in self.__rss_category or []:",
            "            category = etree.SubElement(entry, 'category')",
            "            category.text = cat['value']",
            "            if cat.get('domain'):",
            "                category.attrib['domain'] = cat['domain']",
            "        if self.__rss_comments:",
            "            comments = etree.SubElement(entry, 'comments')",
            "            comments.text = self.__rss_comments",
            "        if self.__rss_enclosure:",
            "            enclosure = etree.SubElement(entry, 'enclosure')",
            "            enclosure.attrib['url'] = self.__rss_enclosure['url']",
            "            enclosure.attrib['length'] = self.__rss_enclosure['length']",
            "            enclosure.attrib['type'] = self.__rss_enclosure['type']",
            "        if self.__rss_pubDate:",
            "            pubDate = etree.SubElement(entry, 'pubDate')",
            "            pubDate.text = formatRFC2822(self.__rss_pubDate)",
            "        if self.__rss_source:",
            "            source = etree.SubElement(entry, 'source',",
            "                                      url=self.__rss_source['url'])",
            "            source.text = self.__rss_source['title']",
            "",
            "        if extensions:",
            "            for ext in self.__extensions.values() or []:",
            "                if ext.get('rss'):",
            "                    ext['inst'].extend_rss(entry)",
            "",
            "        return entry",
            "",
            "    def title(self, title=None):",
            "        '''Get or set the title value of the entry. It should contain a human",
            "        readable title for the entry. Title is mandatory for both ATOM and RSS",
            "        and should not be blank.",
            "",
            "        :param title: The new title of the entry.",
            "        :returns: The entriess title.",
            "        '''",
            "        if title is not None:",
            "            self.__atom_title = title",
            "            self.__rss_title = title",
            "        return self.__atom_title",
            "",
            "    def id(self, id=None):",
            "        '''Get or set the entry id which identifies the entry using a",
            "        universally unique and permanent URI. Two entries in a feed can have",
            "        the same value for id if they represent the same entry at different",
            "        points in time. This method will also set rss:guid with permalink set",
            "        to False. Id is mandatory for an ATOM entry.",
            "",
            "        :param id: New Id of the entry.",
            "        :returns: Id of the entry.",
            "        '''",
            "        if id is not None:",
            "            self.__atom_id = id",
            "            self.__rss_guid = {'guid': id, 'permalink': False}",
            "        return self.__atom_id",
            "",
            "    def guid(self, guid=None, permalink=False):",
            "        '''Get or set the entries guid which is a string that uniquely",
            "        identifies the item. This will also set atom:id.",
            "",
            "        :param guid: Id of the entry.",
            "        :param permalink: If this is a permanent identifier for this item",
            "        :returns: Id and permalink setting of the entry.",
            "        '''",
            "        if guid is not None:",
            "            self.__atom_id = guid",
            "            self.__rss_guid = {'guid': guid, 'permalink': permalink}",
            "        return self.__rss_guid",
            "",
            "    def updated(self, updated=None):",
            "        '''Set or get the updated value which indicates the last time the entry",
            "        was modified in a significant way.",
            "",
            "        The value can either be a string which will automatically be parsed or",
            "        a datetime.datetime object. In any case it is necessary that the value",
            "        include timezone information.",
            "",
            "        :param updated: The modification date.",
            "        :returns: Modification date as datetime.datetime",
            "        '''",
            "        if updated is not None:",
            "            if isinstance(updated, string_types):",
            "                updated = dateutil.parser.parse(updated)",
            "            if not isinstance(updated, datetime):",
            "                raise ValueError('Invalid datetime format')",
            "            if updated.tzinfo is None:",
            "                raise ValueError('Datetime object has no timezone info')",
            "            self.__atom_updated = updated",
            "            self.__rss_lastBuildDate = updated",
            "",
            "        return self.__atom_updated",
            "",
            "    def author(self, author=None, replace=False, **kwargs):",
            "        '''Get or set author data. An author element is a dict containing a",
            "        name, an email address and a uri. Name is mandatory for ATOM, email is",
            "        mandatory for RSS.",
            "",
            "        This method can be called with:",
            "        - the fields of an author as keyword arguments",
            "        - the fields of an author as a dictionary",
            "        - a list of dictionaries containing the author fields",
            "",
            "        An author has the following fields:",
            "        - *name* conveys a human-readable name for the person.",
            "        - *uri* contains a home page for the person.",
            "        - *email* contains an email address for the person.",
            "",
            "        :param author:  Dict or list of dicts with author data.",
            "        :param replace: Add or replace old data.",
            "",
            "        Example::",
            "",
            "            >>> author({'name':'John Doe', 'email':'jdoe@example.com'})",
            "            [{'name':'John Doe','email':'jdoe@example.com'}]",
            "",
            "            >>> author([{'name': 'Mr. X'}, {'name': 'Max'}])",
            "            [{'name':'John Doe','email':'jdoe@example.com'},",
            "                    {'name':'John Doe'}, {'name':'Max'}]",
            "",
            "            >>> author(name='John Doe', email='jdoe@example.com', replace=True)",
            "            [{'name':'John Doe','email':'jdoe@example.com'}]",
            "",
            "        '''",
            "        if author is None and kwargs:",
            "            author = kwargs",
            "        if author is not None:",
            "            if replace or self.__atom_author is None:",
            "                self.__atom_author = []",
            "            self.__atom_author += ensure_format(author,",
            "                                                set(['name', 'email', 'uri']),",
            "                                                set())",
            "            self.__rss_author = []",
            "            for a in self.__atom_author:",
            "                if a.get('email'):",
            "                    if a.get('name'):",
            "                        self.__rss_author.append('%(email)s (%(name)s)' % a)",
            "                    else:",
            "                        self.__rss_author.append('%(email)s' % a)",
            "        return self.__atom_author",
            "",
            "    def content(self, content=None, src=None, type=None):",
            "        '''Get or set the content of the entry which contains or links to the",
            "        complete content of the entry. Content must be provided for ATOM",
            "        entries if there is no alternate link, and should be provided if there",
            "        is no summary. If the content is set (not linked) it will also set",
            "        rss:description.",
            "",
            "        :param content: The content of the feed entry.",
            "        :param src: Link to the entries content.",
            "        :param type: If type is CDATA content would not be escaped.",
            "        :returns: Content element of the entry.",
            "        '''",
            "        if src is not None:",
            "            self.__atom_content = {'src': src}",
            "        elif content is not None:",
            "            self.__atom_content = {'content': content}",
            "            self.__rss_content = {'content': content}",
            "            if type is not None:",
            "                self.__atom_content['type'] = type",
            "                self.__rss_content['type'] = type",
            "        return self.__atom_content",
            "",
            "    def link(self, link=None, replace=False, **kwargs):",
            "        '''Get or set link data. An link element is a dict with the fields",
            "        href, rel, type, hreflang, title, and length. Href is mandatory for",
            "        ATOM.",
            "",
            "        This method can be called with:",
            "        - the fields of a link as keyword arguments",
            "        - the fields of a link as a dictionary",
            "        - a list of dictionaries containing the link fields",
            "",
            "        A link has the following fields:",
            "",
            "        - *href* is the URI of the referenced resource (typically a Web page)",
            "        - *rel* contains a single link relationship type. It can be a full URI,",
            "          or one of the following predefined values (default=alternate):",
            "",
            "            - *alternate* an alternate representation of the entry or feed, for",
            "              example a permalink to the html version of the entry, or the",
            "              front page of the weblog.",
            "            - *enclosure* a related resource which is potentially large in size",
            "              and might require special handling, for example an audio or video",
            "              recording.",
            "            - *related* an document related to the entry or feed.",
            "            - *self* the feed itself.",
            "            - *via* the source of the information provided in the entry.",
            "",
            "        - *type* indicates the media type of the resource.",
            "        - *hreflang* indicates the language of the referenced resource.",
            "        - *title* human readable information about the link, typically for",
            "          display purposes.",
            "        - *length* the length of the resource, in bytes.",
            "",
            "        RSS only supports one link with nothing but a URL. So for the RSS link",
            "        element the last link with rel=alternate is used.",
            "",
            "        RSS also supports one enclusure element per entry which is covered by",
            "        the link element in ATOM feed entries. So for the RSS enclusure element",
            "        the last link with rel=enclosure is used.",
            "",
            "        :param link:    Dict or list of dicts with data.",
            "        :param replace: Add or replace old data.",
            "        :returns: List of link data.",
            "        '''",
            "        if link is None and kwargs:",
            "            link = kwargs",
            "        if link is not None:",
            "            if replace or self.__atom_link is None:",
            "                self.__atom_link = []",
            "            self.__atom_link += ensure_format(",
            "                link,",
            "                set(['href', 'rel', 'type', 'hreflang', 'title', 'length']),",
            "                set(['href']),",
            "                {'rel': ['alternate', 'enclosure', 'related', 'self', 'via']},",
            "                {'rel': 'alternate'})",
            "            # RSS only needs one URL. We use the first link for RSS:",
            "            for l in self.__atom_link:",
            "                if l.get('rel') == 'alternate':",
            "                    self.__rss_link = l['href']",
            "                elif l.get('rel') == 'enclosure':",
            "                    self.__rss_enclosure = {'url': l['href']}",
            "                    self.__rss_enclosure['type'] = l.get('type')",
            "                    self.__rss_enclosure['length'] = l.get('length') or '0'",
            "        # return the set with more information (atom)",
            "        return self.__atom_link",
            "",
            "    def summary(self, summary=None, type=None):",
            "        '''Get or set the summary element of an entry which conveys a short",
            "        summary, abstract, or excerpt of the entry. Summary is an ATOM only",
            "        element and should be provided if there either is no content provided",
            "        for the entry, or that content is not inline (i.e., contains a src",
            "        attribute), or if the content is encoded in base64.  This method will",
            "        also set the rss:description field if it wasn't previously set or",
            "        contains the old value of summary.",
            "",
            "        :param summary: Summary of the entries contents.",
            "        :returns: Summary of the entries contents.",
            "        '''",
            "        if summary is not None:",
            "            # Replace the RSS description with the summary if it was the",
            "            # summary before. Not if it is the description.",
            "            if not self.__rss_description or (",
            "                self.__atom_summary and",
            "                self.__rss_description == self.__atom_summary.get(\"summary\")",
            "            ):",
            "                self.__rss_description = summary",
            "",
            "            self.__atom_summary = {'summary': summary}",
            "            if type is not None:",
            "                self.__atom_summary['type'] = type",
            "        return self.__atom_summary",
            "",
            "    def description(self, description=None, isSummary=False):",
            "        '''Get or set the description value which is the item synopsis.",
            "        Description is an RSS only element. For ATOM feeds it is split in",
            "        summary and content. The isSummary parameter can be used to control",
            "        which ATOM value is set when setting description.",
            "",
            "        :param description: Description of the entry.",
            "        :param isSummary: If the description should be used as content or",
            "                          summary.",
            "        :returns: The entries description.",
            "        '''",
            "        if description is not None:",
            "            self.__rss_description = description",
            "            if isSummary:",
            "                self.__atom_summary = description",
            "            else:",
            "                self.__atom_content = {'content': description}",
            "        return self.__rss_description",
            "",
            "    def category(self, category=None, replace=False, **kwargs):",
            "        '''Get or set categories that the entry belongs to.",
            "",
            "        This method can be called with:",
            "        - the fields of a category as keyword arguments",
            "        - the fields of a category as a dictionary",
            "        - a list of dictionaries containing the category fields",
            "",
            "        A categories has the following fields:",
            "        - *term* identifies the category",
            "        - *scheme* identifies the categorization scheme via a URI.",
            "        - *label* provides a human-readable label for display",
            "",
            "        If a label is present it is used for the RSS feeds. Otherwise the term",
            "        is used. The scheme is used for the domain attribute in RSS.",
            "",
            "        :param category:    Dict or list of dicts with data.",
            "        :param replace: Add or replace old data.",
            "        :returns: List of category data.",
            "        '''",
            "        if category is None and kwargs:",
            "            category = kwargs",
            "        if category is not None:",
            "            if replace or self.__atom_category is None:",
            "                self.__atom_category = []",
            "            self.__atom_category += ensure_format(",
            "                    category,",
            "                    set(['term', 'scheme', 'label']),",
            "                    set(['term']))",
            "            # Map the ATOM categories to RSS categories. Use the atom:label as",
            "            # name or if not present the atom:term. The atom:scheme is the",
            "            # rss:domain.",
            "            self.__rss_category = []",
            "            for cat in self.__atom_category:",
            "                rss_cat = {}",
            "                rss_cat['value'] = cat.get('label', cat['term'])",
            "                if cat.get('scheme'):",
            "                    rss_cat['domain'] = cat['scheme']",
            "                self.__rss_category.append(rss_cat)",
            "        return self.__atom_category",
            "",
            "    def contributor(self, contributor=None, replace=False, **kwargs):",
            "        '''Get or set the contributor data of the feed. This is an ATOM only",
            "        value.",
            "",
            "        This method can be called with:",
            "        - the fields of an contributor as keyword arguments",
            "        - the fields of an contributor as a dictionary",
            "        - a list of dictionaries containing the contributor fields",
            "",
            "        An contributor has the following fields:",
            "        - *name* conveys a human-readable name for the person.",
            "        - *uri* contains a home page for the person.",
            "        - *email* contains an email address for the person.",
            "",
            "        :param contributor: Dictionary or list of dictionaries with contributor",
            "                            data.",
            "        :param replace: Add or replace old data.",
            "        :returns: List of contributors as dictionaries.",
            "        '''",
            "        if contributor is None and kwargs:",
            "            contributor = kwargs",
            "        if contributor is not None:",
            "            if replace or self.__atom_contributor is None:",
            "                self.__atom_contributor = []",
            "            self.__atom_contributor += ensure_format(",
            "                    contributor, set(['name', 'email', 'uri']), set(['name']))",
            "        return self.__atom_contributor",
            "",
            "    def published(self, published=None):",
            "        '''Set or get the published value which contains the time of the initial",
            "        creation or first availability of the entry.",
            "",
            "        The value can either be a string which will automatically be parsed or",
            "        a datetime.datetime object. In any case it is necessary that the value",
            "        include timezone information.",
            "",
            "        :param published: The creation date.",
            "        :returns: Creation date as datetime.datetime",
            "        '''",
            "        if published is not None:",
            "            if isinstance(published, string_types):",
            "                published = dateutil.parser.parse(published)",
            "            if not isinstance(published, datetime):",
            "                raise ValueError('Invalid datetime format')",
            "            if published.tzinfo is None:",
            "                raise ValueError('Datetime object has no timezone info')",
            "            self.__atom_published = published",
            "            self.__rss_pubDate = published",
            "",
            "        return self.__atom_published",
            "",
            "    def pubDate(self, pubDate=None):",
            "        '''Get or set the pubDate of the entry which indicates when the entry",
            "        was published. This method is just another name for the published(...)",
            "        method.",
            "        '''",
            "        return self.published(pubDate)",
            "",
            "    def pubdate(self, pubDate=None):",
            "        '''Get or set the pubDate of the entry which indicates when the entry",
            "        was published. This method is just another name for the published(...)",
            "        method.",
            "",
            "        pubdate(\u2026) is deprecated and may be removed in feedgen \u2265 0.8. Use",
            "        pubDate(\u2026) instead.",
            "        '''",
            "        warnings.warn('pubdate(\u2026) is deprecated and may be removed in feedgen '",
            "                      '\u2265 0.8. Use pubDate(\u2026) instead.')",
            "        return self.published(pubDate)",
            "",
            "    def rights(self, rights=None):",
            "        '''Get or set the rights value of the entry which conveys information",
            "        about rights, e.g. copyrights, held in and over the entry. This ATOM",
            "        value will also set rss:copyright.",
            "",
            "        :param rights: Rights information of the feed.",
            "        :returns: Rights information of the feed.",
            "        '''",
            "        if rights is not None:",
            "            self.__atom_rights = rights",
            "        return self.__atom_rights",
            "",
            "    def comments(self, comments=None):",
            "        '''Get or set the value of comments which is the URL of the comments",
            "        page for the item. This is a RSS only value.",
            "",
            "        :param comments: URL to the comments page.",
            "        :returns: URL to the comments page.",
            "        '''",
            "        if comments is not None:",
            "            self.__rss_comments = comments",
            "        return self.__rss_comments",
            "",
            "    def source(self, url=None, title=None):",
            "        '''Get or set the source for the current feed entry.",
            "",
            "        Note that ATOM feeds support a lot more sub elements than title and URL",
            "        (which is what RSS supports) but these are currently not supported.",
            "        Patches are welcome.",
            "",
            "        :param url: Link to the source.",
            "        :param title: Title of the linked resource",
            "        :returns: Source element as dictionaries.",
            "        '''",
            "        if url is not None and title is not None:",
            "            self.__rss_source = {'url': url, 'title': title}",
            "            self.__atom_source = {'link': url, 'title': title}",
            "        return self.__rss_source",
            "",
            "    def enclosure(self, url=None, length=None, type=None):",
            "        '''Get or set the value of enclosure which describes a media object",
            "        that is attached to the item. This is a RSS only value which is",
            "        represented by link(rel=enclosure) in ATOM. ATOM feeds can furthermore",
            "        contain several enclosures while RSS may contain only one. That is why",
            "        this method, if repeatedly called, will add more than one enclosures to",
            "        the feed.  However, only the last one is used for RSS.",
            "",
            "        :param url: URL of the media object.",
            "        :param length: Size of the media in bytes.",
            "        :param type: Mimetype of the linked media.",
            "        :returns: Data of the enclosure element.",
            "        '''",
            "        if url is not None:",
            "            self.link(href=url, rel='enclosure', type=type, length=length)",
            "        return self.__rss_enclosure",
            "",
            "    def ttl(self, ttl=None):",
            "        '''Get or set the ttl value. It is an RSS only element. ttl stands for",
            "        time to live. It's a number of minutes that indicates how long a",
            "        channel can be cached before refreshing from the source.",
            "",
            "        :param ttl: Integer value representing the time to live.",
            "        :returns: Time to live of of the entry.",
            "        '''",
            "        if ttl is not None:",
            "            self.__rss_ttl = int(ttl)",
            "        return self.__rss_ttl",
            "",
            "    def load_extension(self, name, atom=True, rss=True):",
            "        '''Load a specific extension by name.",
            "",
            "        :param name: Name of the extension to load.",
            "        :param atom: If the extension should be used for ATOM feeds.",
            "        :param rss: If the extension should be used for RSS feeds.",
            "        '''",
            "        # Check loaded extensions",
            "        if not isinstance(self.__extensions, dict):",
            "            self.__extensions = {}",
            "        if name in self.__extensions.keys():",
            "            raise ImportError('Extension already loaded')",
            "",
            "        # Load extension",
            "        extname = name[0].upper() + name[1:] + 'EntryExtension'",
            "        try:",
            "            supmod = __import__('feedgen.ext.%s_entry' % name)",
            "            extmod = getattr(supmod.ext, name + '_entry')",
            "        except ImportError:",
            "            # Use FeedExtension module instead",
            "            supmod = __import__('feedgen.ext.%s' % name)",
            "            extmod = getattr(supmod.ext, name)",
            "        ext = getattr(extmod, extname)",
            "        self.register_extension(name, ext, atom, rss)",
            "",
            "    def register_extension(self, namespace, extension_class_entry=None,",
            "                           atom=True, rss=True):",
            "        '''Register a specific extension by classes to a namespace.",
            "",
            "        :param namespace: namespace for the extension",
            "        :param extension_class_entry: Class of the entry extension to load.",
            "        :param atom: If the extension should be used for ATOM feeds.",
            "        :param rss: If the extension should be used for RSS feeds.",
            "        '''",
            "        # Check loaded extensions",
            "        # `load_extension` ignores the \"Extension\" suffix.",
            "        if not isinstance(self.__extensions, dict):",
            "            self.__extensions = {}",
            "        if namespace in self.__extensions.keys():",
            "            raise ImportError('Extension already loaded')",
            "        if not extension_class_entry:",
            "            raise ImportError('No extension class')",
            "",
            "        extinst = extension_class_entry()",
            "        setattr(self, namespace, extinst)",
            "",
            "        # `load_extension` registry",
            "        self.__extensions[namespace] = {",
            "                'inst': extinst,",
            "                'extension_class_entry': extension_class_entry,",
            "                'atom': atom,",
            "                'rss': rss",
            "                }"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "    feedgen.entry",
            "    ~~~~~~~~~~~~~",
            "",
            "    :copyright: 2013-2020, Lars Kiesow <lkiesow@uos.de>",
            "",
            "    :license: FreeBSD and LGPL, see license.* for more details.",
            "'''",
            "",
            "from datetime import datetime",
            "",
            "import dateutil.parser",
            "import dateutil.tz",
            "import warnings",
            "",
            "from lxml.etree import CDATA  # nosec - adding CDATA entry is safe",
            "",
            "from feedgen.compat import string_types",
            "from feedgen.util import ensure_format, formatRFC2822, xml_fromstring, xml_elem",
            "",
            "",
            "def _add_text_elm(entry, data, name):",
            "    \"\"\"Add a text subelement to an entry\"\"\"",
            "    if not data:",
            "        return",
            "",
            "    elm = xml_elem(name, entry)",
            "    type_ = data.get('type')",
            "    if data.get('src'):",
            "        if name != 'content':",
            "            raise ValueError(\"Only the 'content' element of an entry can \"",
            "                             \"contain a 'src' attribute\")",
            "        elm.attrib['src'] = data['src']",
            "    elif data.get(name):",
            "        # Surround xhtml with a div tag, parse it and embed it",
            "        if type_ == 'xhtml':",
            "            xhtml = '<div xmlns=\"http://www.w3.org/1999/xhtml\">' \\",
            "                    + data.get(name) + '</div>'",
            "            elm.append(xml_fromstring(xhtml))",
            "        elif type_ == 'CDATA':",
            "            elm.text = CDATA(data.get(name))",
            "        # Parse XML and embed it",
            "        elif type_ and (type_.endswith('/xml') or type_.endswith('+xml')):",
            "            elm.append(xml_fromstring(data[name]))",
            "        # Embed the text in escaped form",
            "        elif not type_ or type_.startswith('text') or type_ == 'html':",
            "            elm.text = data.get(name)",
            "        # Everything else should be included base64 encoded",
            "        else:",
            "            raise NotImplementedError(",
            "                'base64 encoded {} is not supported at the moment. '",
            "                'Pull requests adding support are welcome.'.format(name)",
            "            )",
            "    # Add type description of the content",
            "    if type_:",
            "        elm.attrib['type'] = type_",
            "",
            "",
            "class FeedEntry(object):",
            "    '''FeedEntry call representing an ATOM feeds entry node or an RSS feeds item",
            "    node.",
            "    '''",
            "",
            "    def __init__(self):",
            "        # ATOM",
            "        # required",
            "        self.__atom_id = None",
            "        self.__atom_title = None",
            "        self.__atom_updated = datetime.now(dateutil.tz.tzutc())",
            "",
            "        # recommended",
            "        self.__atom_author = None",
            "        self.__atom_content = None",
            "        self.__atom_link = None",
            "        self.__atom_summary = None",
            "",
            "        # optional",
            "        self.__atom_category = None",
            "        self.__atom_contributor = None",
            "        self.__atom_published = None",
            "        self.__atom_source = None",
            "        self.__atom_rights = None",
            "",
            "        # RSS",
            "        self.__rss_author = None",
            "        self.__rss_category = None",
            "        self.__rss_comments = None",
            "        self.__rss_description = None",
            "        self.__rss_content = None",
            "        self.__rss_enclosure = None",
            "        self.__rss_guid = {}",
            "        self.__rss_link = None",
            "        self.__rss_pubDate = None",
            "        self.__rss_source = None",
            "        self.__rss_title = None",
            "",
            "        # Extension list:",
            "        self.__extensions = {}",
            "        self.__extensions_register = {}",
            "",
            "    def atom_entry(self, extensions=True):",
            "        '''Create an ATOM entry and return it.'''",
            "        entry = xml_elem('entry')",
            "        if not (self.__atom_id and self.__atom_title and self.__atom_updated):",
            "            raise ValueError('Required fields not set')",
            "        id = xml_elem('id', entry)",
            "        id.text = self.__atom_id",
            "        title = xml_elem('title', entry)",
            "        title.text = self.__atom_title",
            "        updated = xml_elem('updated', entry)",
            "        updated.text = self.__atom_updated.isoformat()",
            "",
            "        # An entry must contain an alternate link if there is no content",
            "        # element.",
            "        if not self.__atom_content:",
            "            links = self.__atom_link or []",
            "            if not [l for l in links if l.get('rel') == 'alternate']:",
            "                raise ValueError('Entry must contain an alternate link or ' +",
            "                                 'a content element.')",
            "",
            "        # Add author elements",
            "        for a in self.__atom_author or []:",
            "            # Atom requires a name. Skip elements without.",
            "            if not a.get('name'):",
            "                continue",
            "            author = xml_elem('author', entry)",
            "            name = xml_elem('name', author)",
            "            name.text = a.get('name')",
            "            if a.get('email'):",
            "                email = xml_elem('email', author)",
            "                email.text = a.get('email')",
            "            if a.get('uri'):",
            "                uri = xml_elem('uri', author)",
            "                uri.text = a.get('uri')",
            "",
            "        _add_text_elm(entry, self.__atom_content, 'content')",
            "",
            "        for l in self.__atom_link or []:",
            "            link = xml_elem('link', entry, href=l['href'])",
            "            if l.get('rel'):",
            "                link.attrib['rel'] = l['rel']",
            "            if l.get('type'):",
            "                link.attrib['type'] = l['type']",
            "            if l.get('hreflang'):",
            "                link.attrib['hreflang'] = l['hreflang']",
            "            if l.get('title'):",
            "                link.attrib['title'] = l['title']",
            "            if l.get('length'):",
            "                link.attrib['length'] = l['length']",
            "",
            "        _add_text_elm(entry, self.__atom_summary, 'summary')",
            "",
            "        for c in self.__atom_category or []:",
            "            cat = xml_elem('category', entry, term=c['term'])",
            "            if c.get('scheme'):",
            "                cat.attrib['scheme'] = c['scheme']",
            "            if c.get('label'):",
            "                cat.attrib['label'] = c['label']",
            "",
            "        # Add author elements",
            "        for c in self.__atom_contributor or []:",
            "            # Atom requires a name. Skip elements without.",
            "            if not c.get('name'):",
            "                continue",
            "            contrib = xml_elem('contributor', entry)",
            "            name = xml_elem('name', contrib)",
            "            name.text = c.get('name')",
            "            if c.get('email'):",
            "                email = xml_elem('email', contrib)",
            "                email.text = c.get('email')",
            "            if c.get('uri'):",
            "                uri = xml_elem('uri', contrib)",
            "                uri.text = c.get('uri')",
            "",
            "        if self.__atom_published:",
            "            published = xml_elem('published', entry)",
            "            published.text = self.__atom_published.isoformat()",
            "",
            "        if self.__atom_rights:",
            "            rights = xml_elem('rights', entry)",
            "            rights.text = self.__atom_rights",
            "",
            "        if self.__atom_source:",
            "            source = xml_elem('source', entry)",
            "            if self.__atom_source.get('title'):",
            "                source_title = xml_elem('title', source)",
            "                source_title.text = self.__atom_source['title']",
            "            if self.__atom_source.get('link'):",
            "                xml_elem('link', source, href=self.__atom_source['link'])",
            "",
            "        if extensions:",
            "            for ext in self.__extensions.values() or []:",
            "                if ext.get('atom'):",
            "                    ext['inst'].extend_atom(entry)",
            "",
            "        return entry",
            "",
            "    def rss_entry(self, extensions=True):",
            "        '''Create a RSS item and return it.'''",
            "        entry = xml_elem('item')",
            "        if not (self.__rss_title or",
            "                self.__rss_description or",
            "                self.__rss_content):",
            "            raise ValueError('Required fields not set')",
            "        if self.__rss_title:",
            "            title = xml_elem('title', entry)",
            "            title.text = self.__rss_title",
            "        if self.__rss_link:",
            "            link = xml_elem('link', entry)",
            "            link.text = self.__rss_link",
            "        if self.__rss_description and self.__rss_content:",
            "            description = xml_elem('description', entry)",
            "            description.text = self.__rss_description",
            "            XMLNS_CONTENT = 'http://purl.org/rss/1.0/modules/content/'",
            "            content = xml_elem('{%s}encoded' % XMLNS_CONTENT, entry)",
            "            content.text = CDATA(self.__rss_content['content']) \\",
            "                if self.__rss_content.get('type', '') == 'CDATA' \\",
            "                else self.__rss_content['content']",
            "        elif self.__rss_description:",
            "            description = xml_elem('description', entry)",
            "            description.text = self.__rss_description",
            "        elif self.__rss_content:",
            "            description = xml_elem('description', entry)",
            "            description.text = CDATA(self.__rss_content['content']) \\",
            "                if self.__rss_content.get('type', '') == 'CDATA' \\",
            "                else self.__rss_content['content']",
            "        for a in self.__rss_author or []:",
            "            author = xml_elem('author', entry)",
            "            author.text = a",
            "        if self.__rss_guid.get('guid'):",
            "            guid = xml_elem('guid', entry)",
            "            guid.text = self.__rss_guid['guid']",
            "            permaLink = str(self.__rss_guid.get('permalink', False)).lower()",
            "            guid.attrib['isPermaLink'] = permaLink",
            "        for cat in self.__rss_category or []:",
            "            category = xml_elem('category', entry)",
            "            category.text = cat['value']",
            "            if cat.get('domain'):",
            "                category.attrib['domain'] = cat['domain']",
            "        if self.__rss_comments:",
            "            comments = xml_elem('comments', entry)",
            "            comments.text = self.__rss_comments",
            "        if self.__rss_enclosure:",
            "            enclosure = xml_elem('enclosure', entry)",
            "            enclosure.attrib['url'] = self.__rss_enclosure['url']",
            "            enclosure.attrib['length'] = self.__rss_enclosure['length']",
            "            enclosure.attrib['type'] = self.__rss_enclosure['type']",
            "        if self.__rss_pubDate:",
            "            pubDate = xml_elem('pubDate', entry)",
            "            pubDate.text = formatRFC2822(self.__rss_pubDate)",
            "        if self.__rss_source:",
            "            source = xml_elem('source', entry, url=self.__rss_source['url'])",
            "            source.text = self.__rss_source['title']",
            "",
            "        if extensions:",
            "            for ext in self.__extensions.values() or []:",
            "                if ext.get('rss'):",
            "                    ext['inst'].extend_rss(entry)",
            "",
            "        return entry",
            "",
            "    def title(self, title=None):",
            "        '''Get or set the title value of the entry. It should contain a human",
            "        readable title for the entry. Title is mandatory for both ATOM and RSS",
            "        and should not be blank.",
            "",
            "        :param title: The new title of the entry.",
            "        :returns: The entriess title.",
            "        '''",
            "        if title is not None:",
            "            self.__atom_title = title",
            "            self.__rss_title = title",
            "        return self.__atom_title",
            "",
            "    def id(self, id=None):",
            "        '''Get or set the entry id which identifies the entry using a",
            "        universally unique and permanent URI. Two entries in a feed can have",
            "        the same value for id if they represent the same entry at different",
            "        points in time. This method will also set rss:guid with permalink set",
            "        to False. Id is mandatory for an ATOM entry.",
            "",
            "        :param id: New Id of the entry.",
            "        :returns: Id of the entry.",
            "        '''",
            "        if id is not None:",
            "            self.__atom_id = id",
            "            self.__rss_guid = {'guid': id, 'permalink': False}",
            "        return self.__atom_id",
            "",
            "    def guid(self, guid=None, permalink=False):",
            "        '''Get or set the entries guid which is a string that uniquely",
            "        identifies the item. This will also set atom:id.",
            "",
            "        :param guid: Id of the entry.",
            "        :param permalink: If this is a permanent identifier for this item",
            "        :returns: Id and permalink setting of the entry.",
            "        '''",
            "        if guid is not None:",
            "            self.__atom_id = guid",
            "            self.__rss_guid = {'guid': guid, 'permalink': permalink}",
            "        return self.__rss_guid",
            "",
            "    def updated(self, updated=None):",
            "        '''Set or get the updated value which indicates the last time the entry",
            "        was modified in a significant way.",
            "",
            "        The value can either be a string which will automatically be parsed or",
            "        a datetime.datetime object. In any case it is necessary that the value",
            "        include timezone information.",
            "",
            "        :param updated: The modification date.",
            "        :returns: Modification date as datetime.datetime",
            "        '''",
            "        if updated is not None:",
            "            if isinstance(updated, string_types):",
            "                updated = dateutil.parser.parse(updated)",
            "            if not isinstance(updated, datetime):",
            "                raise ValueError('Invalid datetime format')",
            "            if updated.tzinfo is None:",
            "                raise ValueError('Datetime object has no timezone info')",
            "            self.__atom_updated = updated",
            "            self.__rss_lastBuildDate = updated",
            "",
            "        return self.__atom_updated",
            "",
            "    def author(self, author=None, replace=False, **kwargs):",
            "        '''Get or set author data. An author element is a dict containing a",
            "        name, an email address and a uri. Name is mandatory for ATOM, email is",
            "        mandatory for RSS.",
            "",
            "        This method can be called with:",
            "        - the fields of an author as keyword arguments",
            "        - the fields of an author as a dictionary",
            "        - a list of dictionaries containing the author fields",
            "",
            "        An author has the following fields:",
            "        - *name* conveys a human-readable name for the person.",
            "        - *uri* contains a home page for the person.",
            "        - *email* contains an email address for the person.",
            "",
            "        :param author:  Dict or list of dicts with author data.",
            "        :param replace: Add or replace old data.",
            "",
            "        Example::",
            "",
            "            >>> author({'name':'John Doe', 'email':'jdoe@example.com'})",
            "            [{'name':'John Doe','email':'jdoe@example.com'}]",
            "",
            "            >>> author([{'name': 'Mr. X'}, {'name': 'Max'}])",
            "            [{'name':'John Doe','email':'jdoe@example.com'},",
            "                    {'name':'John Doe'}, {'name':'Max'}]",
            "",
            "            >>> author(name='John Doe', email='jdoe@example.com', replace=True)",
            "            [{'name':'John Doe','email':'jdoe@example.com'}]",
            "",
            "        '''",
            "        if author is None and kwargs:",
            "            author = kwargs",
            "        if author is not None:",
            "            if replace or self.__atom_author is None:",
            "                self.__atom_author = []",
            "            self.__atom_author += ensure_format(author,",
            "                                                set(['name', 'email', 'uri']),",
            "                                                set())",
            "            self.__rss_author = []",
            "            for a in self.__atom_author:",
            "                if a.get('email'):",
            "                    if a.get('name'):",
            "                        self.__rss_author.append('%(email)s (%(name)s)' % a)",
            "                    else:",
            "                        self.__rss_author.append('%(email)s' % a)",
            "        return self.__atom_author",
            "",
            "    def content(self, content=None, src=None, type=None):",
            "        '''Get or set the content of the entry which contains or links to the",
            "        complete content of the entry. Content must be provided for ATOM",
            "        entries if there is no alternate link, and should be provided if there",
            "        is no summary. If the content is set (not linked) it will also set",
            "        rss:description.",
            "",
            "        :param content: The content of the feed entry.",
            "        :param src: Link to the entries content.",
            "        :param type: If type is CDATA content would not be escaped.",
            "        :returns: Content element of the entry.",
            "        '''",
            "        if src is not None:",
            "            self.__atom_content = {'src': src}",
            "        elif content is not None:",
            "            self.__atom_content = {'content': content}",
            "            self.__rss_content = {'content': content}",
            "            if type is not None:",
            "                self.__atom_content['type'] = type",
            "                self.__rss_content['type'] = type",
            "        return self.__atom_content",
            "",
            "    def link(self, link=None, replace=False, **kwargs):",
            "        '''Get or set link data. An link element is a dict with the fields",
            "        href, rel, type, hreflang, title, and length. Href is mandatory for",
            "        ATOM.",
            "",
            "        This method can be called with:",
            "        - the fields of a link as keyword arguments",
            "        - the fields of a link as a dictionary",
            "        - a list of dictionaries containing the link fields",
            "",
            "        A link has the following fields:",
            "",
            "        - *href* is the URI of the referenced resource (typically a Web page)",
            "        - *rel* contains a single link relationship type. It can be a full URI,",
            "          or one of the following predefined values (default=alternate):",
            "",
            "            - *alternate* an alternate representation of the entry or feed, for",
            "              example a permalink to the html version of the entry, or the",
            "              front page of the weblog.",
            "            - *enclosure* a related resource which is potentially large in size",
            "              and might require special handling, for example an audio or video",
            "              recording.",
            "            - *related* an document related to the entry or feed.",
            "            - *self* the feed itself.",
            "            - *via* the source of the information provided in the entry.",
            "",
            "        - *type* indicates the media type of the resource.",
            "        - *hreflang* indicates the language of the referenced resource.",
            "        - *title* human readable information about the link, typically for",
            "          display purposes.",
            "        - *length* the length of the resource, in bytes.",
            "",
            "        RSS only supports one link with nothing but a URL. So for the RSS link",
            "        element the last link with rel=alternate is used.",
            "",
            "        RSS also supports one enclusure element per entry which is covered by",
            "        the link element in ATOM feed entries. So for the RSS enclusure element",
            "        the last link with rel=enclosure is used.",
            "",
            "        :param link:    Dict or list of dicts with data.",
            "        :param replace: Add or replace old data.",
            "        :returns: List of link data.",
            "        '''",
            "        if link is None and kwargs:",
            "            link = kwargs",
            "        if link is not None:",
            "            if replace or self.__atom_link is None:",
            "                self.__atom_link = []",
            "            self.__atom_link += ensure_format(",
            "                link,",
            "                set(['href', 'rel', 'type', 'hreflang', 'title', 'length']),",
            "                set(['href']),",
            "                {'rel': ['alternate', 'enclosure', 'related', 'self', 'via']},",
            "                {'rel': 'alternate'})",
            "            # RSS only needs one URL. We use the first link for RSS:",
            "            for l in self.__atom_link:",
            "                if l.get('rel') == 'alternate':",
            "                    self.__rss_link = l['href']",
            "                elif l.get('rel') == 'enclosure':",
            "                    self.__rss_enclosure = {'url': l['href']}",
            "                    self.__rss_enclosure['type'] = l.get('type')",
            "                    self.__rss_enclosure['length'] = l.get('length') or '0'",
            "        # return the set with more information (atom)",
            "        return self.__atom_link",
            "",
            "    def summary(self, summary=None, type=None):",
            "        '''Get or set the summary element of an entry which conveys a short",
            "        summary, abstract, or excerpt of the entry. Summary is an ATOM only",
            "        element and should be provided if there either is no content provided",
            "        for the entry, or that content is not inline (i.e., contains a src",
            "        attribute), or if the content is encoded in base64.  This method will",
            "        also set the rss:description field if it wasn't previously set or",
            "        contains the old value of summary.",
            "",
            "        :param summary: Summary of the entries contents.",
            "        :returns: Summary of the entries contents.",
            "        '''",
            "        if summary is not None:",
            "            # Replace the RSS description with the summary if it was the",
            "            # summary before. Not if it is the description.",
            "            if not self.__rss_description or (",
            "                self.__atom_summary and",
            "                self.__rss_description == self.__atom_summary.get(\"summary\")",
            "            ):",
            "                self.__rss_description = summary",
            "",
            "            self.__atom_summary = {'summary': summary}",
            "            if type is not None:",
            "                self.__atom_summary['type'] = type",
            "        return self.__atom_summary",
            "",
            "    def description(self, description=None, isSummary=False):",
            "        '''Get or set the description value which is the item synopsis.",
            "        Description is an RSS only element. For ATOM feeds it is split in",
            "        summary and content. The isSummary parameter can be used to control",
            "        which ATOM value is set when setting description.",
            "",
            "        :param description: Description of the entry.",
            "        :param isSummary: If the description should be used as content or",
            "                          summary.",
            "        :returns: The entries description.",
            "        '''",
            "        if description is not None:",
            "            self.__rss_description = description",
            "            if isSummary:",
            "                self.__atom_summary = description",
            "            else:",
            "                self.__atom_content = {'content': description}",
            "        return self.__rss_description",
            "",
            "    def category(self, category=None, replace=False, **kwargs):",
            "        '''Get or set categories that the entry belongs to.",
            "",
            "        This method can be called with:",
            "        - the fields of a category as keyword arguments",
            "        - the fields of a category as a dictionary",
            "        - a list of dictionaries containing the category fields",
            "",
            "        A categories has the following fields:",
            "        - *term* identifies the category",
            "        - *scheme* identifies the categorization scheme via a URI.",
            "        - *label* provides a human-readable label for display",
            "",
            "        If a label is present it is used for the RSS feeds. Otherwise the term",
            "        is used. The scheme is used for the domain attribute in RSS.",
            "",
            "        :param category:    Dict or list of dicts with data.",
            "        :param replace: Add or replace old data.",
            "        :returns: List of category data.",
            "        '''",
            "        if category is None and kwargs:",
            "            category = kwargs",
            "        if category is not None:",
            "            if replace or self.__atom_category is None:",
            "                self.__atom_category = []",
            "            self.__atom_category += ensure_format(",
            "                    category,",
            "                    set(['term', 'scheme', 'label']),",
            "                    set(['term']))",
            "            # Map the ATOM categories to RSS categories. Use the atom:label as",
            "            # name or if not present the atom:term. The atom:scheme is the",
            "            # rss:domain.",
            "            self.__rss_category = []",
            "            for cat in self.__atom_category:",
            "                rss_cat = {}",
            "                rss_cat['value'] = cat.get('label', cat['term'])",
            "                if cat.get('scheme'):",
            "                    rss_cat['domain'] = cat['scheme']",
            "                self.__rss_category.append(rss_cat)",
            "        return self.__atom_category",
            "",
            "    def contributor(self, contributor=None, replace=False, **kwargs):",
            "        '''Get or set the contributor data of the feed. This is an ATOM only",
            "        value.",
            "",
            "        This method can be called with:",
            "        - the fields of an contributor as keyword arguments",
            "        - the fields of an contributor as a dictionary",
            "        - a list of dictionaries containing the contributor fields",
            "",
            "        An contributor has the following fields:",
            "        - *name* conveys a human-readable name for the person.",
            "        - *uri* contains a home page for the person.",
            "        - *email* contains an email address for the person.",
            "",
            "        :param contributor: Dictionary or list of dictionaries with contributor",
            "                            data.",
            "        :param replace: Add or replace old data.",
            "        :returns: List of contributors as dictionaries.",
            "        '''",
            "        if contributor is None and kwargs:",
            "            contributor = kwargs",
            "        if contributor is not None:",
            "            if replace or self.__atom_contributor is None:",
            "                self.__atom_contributor = []",
            "            self.__atom_contributor += ensure_format(",
            "                    contributor, set(['name', 'email', 'uri']), set(['name']))",
            "        return self.__atom_contributor",
            "",
            "    def published(self, published=None):",
            "        '''Set or get the published value which contains the time of the initial",
            "        creation or first availability of the entry.",
            "",
            "        The value can either be a string which will automatically be parsed or",
            "        a datetime.datetime object. In any case it is necessary that the value",
            "        include timezone information.",
            "",
            "        :param published: The creation date.",
            "        :returns: Creation date as datetime.datetime",
            "        '''",
            "        if published is not None:",
            "            if isinstance(published, string_types):",
            "                published = dateutil.parser.parse(published)",
            "            if not isinstance(published, datetime):",
            "                raise ValueError('Invalid datetime format')",
            "            if published.tzinfo is None:",
            "                raise ValueError('Datetime object has no timezone info')",
            "            self.__atom_published = published",
            "            self.__rss_pubDate = published",
            "",
            "        return self.__atom_published",
            "",
            "    def pubDate(self, pubDate=None):",
            "        '''Get or set the pubDate of the entry which indicates when the entry",
            "        was published. This method is just another name for the published(...)",
            "        method.",
            "        '''",
            "        return self.published(pubDate)",
            "",
            "    def pubdate(self, pubDate=None):",
            "        '''Get or set the pubDate of the entry which indicates when the entry",
            "        was published. This method is just another name for the published(...)",
            "        method.",
            "",
            "        pubdate(\u2026) is deprecated and may be removed in feedgen \u2265 0.8. Use",
            "        pubDate(\u2026) instead.",
            "        '''",
            "        warnings.warn('pubdate(\u2026) is deprecated and may be removed in feedgen '",
            "                      '\u2265 0.8. Use pubDate(\u2026) instead.')",
            "        return self.published(pubDate)",
            "",
            "    def rights(self, rights=None):",
            "        '''Get or set the rights value of the entry which conveys information",
            "        about rights, e.g. copyrights, held in and over the entry. This ATOM",
            "        value will also set rss:copyright.",
            "",
            "        :param rights: Rights information of the feed.",
            "        :returns: Rights information of the feed.",
            "        '''",
            "        if rights is not None:",
            "            self.__atom_rights = rights",
            "        return self.__atom_rights",
            "",
            "    def comments(self, comments=None):",
            "        '''Get or set the value of comments which is the URL of the comments",
            "        page for the item. This is a RSS only value.",
            "",
            "        :param comments: URL to the comments page.",
            "        :returns: URL to the comments page.",
            "        '''",
            "        if comments is not None:",
            "            self.__rss_comments = comments",
            "        return self.__rss_comments",
            "",
            "    def source(self, url=None, title=None):",
            "        '''Get or set the source for the current feed entry.",
            "",
            "        Note that ATOM feeds support a lot more sub elements than title and URL",
            "        (which is what RSS supports) but these are currently not supported.",
            "        Patches are welcome.",
            "",
            "        :param url: Link to the source.",
            "        :param title: Title of the linked resource",
            "        :returns: Source element as dictionaries.",
            "        '''",
            "        if url is not None and title is not None:",
            "            self.__rss_source = {'url': url, 'title': title}",
            "            self.__atom_source = {'link': url, 'title': title}",
            "        return self.__rss_source",
            "",
            "    def enclosure(self, url=None, length=None, type=None):",
            "        '''Get or set the value of enclosure which describes a media object",
            "        that is attached to the item. This is a RSS only value which is",
            "        represented by link(rel=enclosure) in ATOM. ATOM feeds can furthermore",
            "        contain several enclosures while RSS may contain only one. That is why",
            "        this method, if repeatedly called, will add more than one enclosures to",
            "        the feed.  However, only the last one is used for RSS.",
            "",
            "        :param url: URL of the media object.",
            "        :param length: Size of the media in bytes.",
            "        :param type: Mimetype of the linked media.",
            "        :returns: Data of the enclosure element.",
            "        '''",
            "        if url is not None:",
            "            self.link(href=url, rel='enclosure', type=type, length=length)",
            "        return self.__rss_enclosure",
            "",
            "    def ttl(self, ttl=None):",
            "        '''Get or set the ttl value. It is an RSS only element. ttl stands for",
            "        time to live. It's a number of minutes that indicates how long a",
            "        channel can be cached before refreshing from the source.",
            "",
            "        :param ttl: Integer value representing the time to live.",
            "        :returns: Time to live of of the entry.",
            "        '''",
            "        if ttl is not None:",
            "            self.__rss_ttl = int(ttl)",
            "        return self.__rss_ttl",
            "",
            "    def load_extension(self, name, atom=True, rss=True):",
            "        '''Load a specific extension by name.",
            "",
            "        :param name: Name of the extension to load.",
            "        :param atom: If the extension should be used for ATOM feeds.",
            "        :param rss: If the extension should be used for RSS feeds.",
            "        '''",
            "        # Check loaded extensions",
            "        if not isinstance(self.__extensions, dict):",
            "            self.__extensions = {}",
            "        if name in self.__extensions.keys():",
            "            raise ImportError('Extension already loaded')",
            "",
            "        # Load extension",
            "        extname = name[0].upper() + name[1:] + 'EntryExtension'",
            "        try:",
            "            supmod = __import__('feedgen.ext.%s_entry' % name)",
            "            extmod = getattr(supmod.ext, name + '_entry')",
            "        except ImportError:",
            "            # Use FeedExtension module instead",
            "            supmod = __import__('feedgen.ext.%s' % name)",
            "            extmod = getattr(supmod.ext, name)",
            "        ext = getattr(extmod, extname)",
            "        self.register_extension(name, ext, atom, rss)",
            "",
            "    def register_extension(self, namespace, extension_class_entry=None,",
            "                           atom=True, rss=True):",
            "        '''Register a specific extension by classes to a namespace.",
            "",
            "        :param namespace: namespace for the extension",
            "        :param extension_class_entry: Class of the entry extension to load.",
            "        :param atom: If the extension should be used for ATOM feeds.",
            "        :param rss: If the extension should be used for RSS feeds.",
            "        '''",
            "        # Check loaded extensions",
            "        # `load_extension` ignores the \"Extension\" suffix.",
            "        if not isinstance(self.__extensions, dict):",
            "            self.__extensions = {}",
            "        if namespace in self.__extensions.keys():",
            "            raise ImportError('Extension already loaded')",
            "        if not extension_class_entry:",
            "            raise ImportError('No extension class')",
            "",
            "        extinst = extension_class_entry()",
            "        setattr(self, namespace, extinst)",
            "",
            "        # `load_extension` registry",
            "        self.__extensions[namespace] = {",
            "                'inst': extinst,",
            "                'extension_class_entry': extension_class_entry,",
            "                'atom': atom,",
            "                'rss': rss",
            "                }"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "16": [],
            "19": [],
            "27": [
                "_add_text_elm"
            ],
            "37": [
                "_add_text_elm"
            ],
            "38": [
                "_add_text_elm"
            ],
            "39": [
                "_add_text_elm"
            ],
            "41": [
                "_add_text_elm"
            ],
            "42": [
                "_add_text_elm"
            ],
            "45": [
                "_add_text_elm"
            ],
            "46": [
                "_add_text_elm"
            ],
            "105": [
                "FeedEntry",
                "atom_entry"
            ],
            "108": [
                "FeedEntry",
                "atom_entry"
            ],
            "110": [
                "FeedEntry",
                "atom_entry"
            ],
            "112": [
                "FeedEntry",
                "atom_entry"
            ],
            "128": [
                "FeedEntry",
                "atom_entry"
            ],
            "129": [
                "FeedEntry",
                "atom_entry"
            ],
            "132": [
                "FeedEntry",
                "atom_entry"
            ],
            "135": [
                "FeedEntry",
                "atom_entry"
            ],
            "141": [
                "FeedEntry",
                "atom_entry"
            ],
            "156": [
                "FeedEntry",
                "atom_entry"
            ],
            "167": [
                "FeedEntry",
                "atom_entry"
            ],
            "168": [
                "FeedEntry",
                "atom_entry"
            ],
            "171": [
                "FeedEntry",
                "atom_entry"
            ],
            "174": [
                "FeedEntry",
                "atom_entry"
            ],
            "178": [
                "FeedEntry",
                "atom_entry"
            ],
            "182": [
                "FeedEntry",
                "atom_entry"
            ],
            "186": [
                "FeedEntry",
                "atom_entry"
            ],
            "188": [
                "FeedEntry",
                "atom_entry"
            ],
            "191": [
                "FeedEntry",
                "atom_entry"
            ],
            "192": [
                "FeedEntry",
                "atom_entry"
            ],
            "203": [
                "FeedEntry",
                "rss_entry"
            ],
            "209": [
                "FeedEntry",
                "rss_entry"
            ],
            "212": [
                "FeedEntry",
                "rss_entry"
            ],
            "215": [
                "FeedEntry",
                "rss_entry"
            ],
            "218": [
                "FeedEntry",
                "rss_entry"
            ],
            "219": [
                "FeedEntry",
                "rss_entry"
            ],
            "223": [
                "FeedEntry",
                "rss_entry"
            ],
            "226": [
                "FeedEntry",
                "rss_entry"
            ],
            "227": [
                "FeedEntry",
                "rss_entry"
            ],
            "231": [
                "FeedEntry",
                "rss_entry"
            ],
            "234": [
                "FeedEntry",
                "rss_entry"
            ],
            "239": [
                "FeedEntry",
                "rss_entry"
            ],
            "244": [
                "FeedEntry",
                "rss_entry"
            ],
            "247": [
                "FeedEntry",
                "rss_entry"
            ],
            "252": [
                "FeedEntry",
                "rss_entry"
            ],
            "255": [
                "FeedEntry",
                "rss_entry"
            ],
            "256": [
                "FeedEntry",
                "rss_entry"
            ]
        },
        "addLocation": []
    },
    "feedgen/ext/dc.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     :license: FreeBSD and LGPL, see license.* for more details."
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " '''"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lxml import etree"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from feedgen.ext.base import BaseExtension"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from feedgen.util import xml_elem"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " class DcBaseExtension(BaseExtension):"
            },
            "10": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     def extend_ns(self):"
            },
            "11": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         return {'dc': 'http://purl.org/dc/elements/1.1/'}"
            },
            "12": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _extend_xml(self, xml_elem):"
            },
            "14": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        '''Extend xml_elem with set DC fields."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    def _extend_xml(self, xml_element):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        '''Extend xml_element with set DC fields."
            },
            "17": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param xml_elem: etree element"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        :param xml_element: etree element"
            },
            "20": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         '''"
            },
            "21": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         DCELEMENTS_NS = 'http://purl.org/dc/elements/1.1/'"
            },
            "22": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "                      'identifier']:"
            },
            "24": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             if hasattr(self, '_dcelem_%s' % elem):"
            },
            "25": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "                 for val in getattr(self, '_dcelem_%s' % elem) or []:"
            },
            "26": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    node = etree.SubElement(xml_elem,"
            },
            "27": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                            '{%s}%s' % (DCELEMENTS_NS, elem))"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                    node = xml_elem('{%s}%s' % (DCELEMENTS_NS, elem),"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                                    xml_element)"
            },
            "30": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "                     node.text = val"
            },
            "31": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     def extend_atom(self, atom_feed):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "    feedgen.ext.dc",
            "    ~~~~~~~~~~~~~~~~~~~",
            "",
            "    Extends the FeedGenerator to add Dubline Core Elements to the feeds.",
            "",
            "    Descriptions partly taken from",
            "    http://dublincore.org/documents/dcmi-terms/#elements-coverage",
            "",
            "    :copyright: 2013-2017, Lars Kiesow <lkiesow@uos.de>",
            "",
            "    :license: FreeBSD and LGPL, see license.* for more details.",
            "'''",
            "",
            "from lxml import etree",
            "",
            "from feedgen.ext.base import BaseExtension",
            "",
            "",
            "class DcBaseExtension(BaseExtension):",
            "    '''Dublin Core Elements extension for podcasts.",
            "    '''",
            "",
            "    def __init__(self):",
            "        # http://dublincore.org/documents/usageguide/elements.shtml",
            "        # http://dublincore.org/documents/dces/",
            "        # http://dublincore.org/documents/dcmi-terms/",
            "        self._dcelem_contributor = None",
            "        self._dcelem_coverage = None",
            "        self._dcelem_creator = None",
            "        self._dcelem_date = None",
            "        self._dcelem_description = None",
            "        self._dcelem_format = None",
            "        self._dcelem_identifier = None",
            "        self._dcelem_language = None",
            "        self._dcelem_publisher = None",
            "        self._dcelem_relation = None",
            "        self._dcelem_rights = None",
            "        self._dcelem_source = None",
            "        self._dcelem_subject = None",
            "        self._dcelem_title = None",
            "        self._dcelem_type = None",
            "",
            "    def extend_ns(self):",
            "        return {'dc': 'http://purl.org/dc/elements/1.1/'}",
            "",
            "    def _extend_xml(self, xml_elem):",
            "        '''Extend xml_elem with set DC fields.",
            "",
            "        :param xml_elem: etree element",
            "        '''",
            "        DCELEMENTS_NS = 'http://purl.org/dc/elements/1.1/'",
            "",
            "        for elem in ['contributor', 'coverage', 'creator', 'date',",
            "                     'description', 'language', 'publisher', 'relation',",
            "                     'rights', 'source', 'subject', 'title', 'type', 'format',",
            "                     'identifier']:",
            "            if hasattr(self, '_dcelem_%s' % elem):",
            "                for val in getattr(self, '_dcelem_%s' % elem) or []:",
            "                    node = etree.SubElement(xml_elem,",
            "                                            '{%s}%s' % (DCELEMENTS_NS, elem))",
            "                    node.text = val",
            "",
            "    def extend_atom(self, atom_feed):",
            "        '''Extend an Atom feed with the set DC fields.",
            "",
            "        :param atom_feed: The feed root element",
            "        :returns: The feed root element",
            "        '''",
            "",
            "        self._extend_xml(atom_feed)",
            "",
            "        return atom_feed",
            "",
            "    def extend_rss(self, rss_feed):",
            "        '''Extend a RSS feed with the set DC fields.",
            "",
            "        :param rss_feed: The feed root element",
            "        :returns: The feed root element.",
            "        '''",
            "        channel = rss_feed[0]",
            "        self._extend_xml(channel)",
            "",
            "        return rss_feed",
            "",
            "    def dc_contributor(self, contributor=None, replace=False):",
            "        '''Get or set the dc:contributor which is an entity responsible for",
            "        making contributions to the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-contributor",
            "",
            "        :param contributor: Contributor or list of contributors.",
            "        :param replace: Replace alredy set contributors (deault: False).",
            "        :returns: List of contributors.",
            "        '''",
            "        if contributor is not None:",
            "            if not isinstance(contributor, list):",
            "                contributor = [contributor]",
            "            if replace or not self._dcelem_contributor:",
            "                self._dcelem_contributor = []",
            "            self._dcelem_contributor += contributor",
            "        return self._dcelem_contributor",
            "",
            "    def dc_coverage(self, coverage=None, replace=True):",
            "        '''Get or set the dc:coverage which indicated the spatial or temporal",
            "        topic of the resource, the spatial applicability of the resource, or",
            "        the jurisdiction under which the resource is relevant.",
            "",
            "        Spatial topic and spatial applicability may be a named place or a",
            "        location specified by its geographic coordinates. Temporal topic may be",
            "        a named period, date, or date range. A jurisdiction may be a named",
            "        administrative entity or a geographic place to which the resource",
            "        applies. Recommended best practice is to use a controlled vocabulary",
            "        such as the Thesaurus of Geographic Names [TGN]. Where appropriate,",
            "        named places or time periods can be used in preference to numeric",
            "        identifiers such as sets of coordinates or date ranges.",
            "",
            "        References:",
            "        [TGN] http://www.getty.edu/research/tools/vocabulary/tgn/index.html",
            "",
            "        :param coverage: Coverage of the feed.",
            "        :param replace: Replace already set coverage (default: True).",
            "        :returns: Coverage of the feed.",
            "        '''",
            "        if coverage is not None:",
            "            if not isinstance(coverage, list):",
            "                coverage = [coverage]",
            "            if replace or not self._dcelem_coverage:",
            "                self._dcelem_coverage = []",
            "            self._dcelem_coverage = coverage",
            "        return self._dcelem_coverage",
            "",
            "    def dc_creator(self, creator=None, replace=False):",
            "        '''Get or set the dc:creator which is an entity primarily responsible",
            "        for making the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-creator",
            "",
            "        :param creator: Creator or list of creators.",
            "        :param replace: Replace alredy set creators (deault: False).",
            "        :returns: List of creators.",
            "        '''",
            "        if creator is not None:",
            "            if not isinstance(creator, list):",
            "                creator = [creator]",
            "            if replace or not self._dcelem_creator:",
            "                self._dcelem_creator = []",
            "            self._dcelem_creator += creator",
            "        return self._dcelem_creator",
            "",
            "    def dc_date(self, date=None, replace=True):",
            "        '''Get or set the dc:date which describes a point or period of time",
            "        associated with an event in the lifecycle of the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-date",
            "",
            "        :param date: Date or list of dates.",
            "        :param replace: Replace alredy set dates (deault: True).",
            "        :returns: List of dates.",
            "        '''",
            "        if date is not None:",
            "            if not isinstance(date, list):",
            "                date = [date]",
            "            if replace or not self._dcelem_date:",
            "                self._dcelem_date = []",
            "            self._dcelem_date += date",
            "        return self._dcelem_date",
            "",
            "    def dc_description(self, description=None, replace=True):",
            "        '''Get or set the dc:description which is an account of the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-description",
            "",
            "        :param description: Description or list of descriptions.",
            "        :param replace: Replace alredy set descriptions (deault: True).",
            "        :returns: List of descriptions.",
            "        '''",
            "        if description is not None:",
            "            if not isinstance(description, list):",
            "                description = [description]",
            "            if replace or not self._dcelem_description:",
            "                self._dcelem_description = []",
            "            self._dcelem_description += description",
            "        return self._dcelem_description",
            "",
            "    def dc_format(self, format=None, replace=True):",
            "        '''Get or set the dc:format which describes the file format, physical",
            "        medium, or dimensions of the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-format",
            "",
            "        :param format: Format of the resource or list of formats.",
            "        :param replace: Replace alredy set format (deault: True).",
            "        :returns: Format of the resource.",
            "        '''",
            "        if format is not None:",
            "            if not isinstance(format, list):",
            "                format = [format]",
            "            if replace or not self._dcelem_format:",
            "                self._dcelem_format = []",
            "            self._dcelem_format += format",
            "        return self._dcelem_format",
            "",
            "    def dc_identifier(self, identifier=None, replace=True):",
            "        '''Get or set the dc:identifier which should be an unambiguous",
            "        reference to the resource within a given context.",
            "",
            "        For more inidentifierion see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-identifier",
            "",
            "        :param identifier: Identifier of the resource or list of identifiers.",
            "        :param replace: Replace alredy set identifier (deault: True).",
            "        :returns: Identifiers of the resource.",
            "        '''",
            "        if identifier is not None:",
            "            if not isinstance(identifier, list):",
            "                identifier = [identifier]",
            "            if replace or not self._dcelem_identifier:",
            "                self._dcelem_identifier = []",
            "            self._dcelem_identifier += identifier",
            "        return self._dcelem_identifier",
            "",
            "    def dc_language(self, language=None, replace=True):",
            "        '''Get or set the dc:language which describes a language of the",
            "        resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-language",
            "",
            "        :param language: Language or list of languages.",
            "        :param replace: Replace alredy set languages (deault: True).",
            "        :returns: List of languages.",
            "        '''",
            "        if language is not None:",
            "            if not isinstance(language, list):",
            "                language = [language]",
            "            if replace or not self._dcelem_language:",
            "                self._dcelem_language = []",
            "            self._dcelem_language += language",
            "        return self._dcelem_language",
            "",
            "    def dc_publisher(self, publisher=None, replace=False):",
            "        '''Get or set the dc:publisher which is an entity responsible for",
            "        making the resource available.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-publisher",
            "",
            "        :param publisher: Publisher or list of publishers.",
            "        :param replace: Replace alredy set publishers (deault: False).",
            "        :returns: List of publishers.",
            "        '''",
            "        if publisher is not None:",
            "            if not isinstance(publisher, list):",
            "                publisher = [publisher]",
            "            if replace or not self._dcelem_publisher:",
            "                self._dcelem_publisher = []",
            "            self._dcelem_publisher += publisher",
            "        return self._dcelem_publisher",
            "",
            "    def dc_relation(self, relation=None, replace=False):",
            "        '''Get or set the dc:relation which describes a related resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-relation",
            "",
            "        :param relation: Relation or list of relations.",
            "        :param replace: Replace alredy set relations (deault: False).",
            "        :returns: List of relations.",
            "        '''",
            "        if relation is not None:",
            "            if not isinstance(relation, list):",
            "                relation = [relation]",
            "            if replace or not self._dcelem_relation:",
            "                self._dcelem_relation = []",
            "            self._dcelem_relation += relation",
            "        return self._dcelem_relation",
            "",
            "    def dc_rights(self, rights=None, replace=False):",
            "        '''Get or set the dc:rights which may contain information about rights",
            "        held in and over the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-rights",
            "",
            "        :param rights: Rights information or list of rights information.",
            "        :param replace: Replace alredy set rightss (deault: False).",
            "        :returns: List of rights information.",
            "        '''",
            "        if rights is not None:",
            "            if not isinstance(rights, list):",
            "                rights = [rights]",
            "            if replace or not self._dcelem_rights:",
            "                self._dcelem_rights = []",
            "            self._dcelem_rights += rights",
            "        return self._dcelem_rights",
            "",
            "    def dc_source(self, source=None, replace=False):",
            "        '''Get or set the dc:source which is a related resource from which the",
            "        described resource is derived.",
            "",
            "        The described resource may be derived from the related resource in",
            "        whole or in part. Recommended best practice is to identify the related",
            "        resource by means of a string conforming to a formal identification",
            "        system.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-source",
            "",
            "        :param source: Source or list of sources.",
            "        :param replace: Replace alredy set sources (deault: False).",
            "        :returns: List of sources.",
            "        '''",
            "        if source is not None:",
            "            if not isinstance(source, list):",
            "                source = [source]",
            "            if replace or not self._dcelem_source:",
            "                self._dcelem_source = []",
            "            self._dcelem_source += source",
            "        return self._dcelem_source",
            "",
            "    def dc_subject(self, subject=None, replace=False):",
            "        '''Get or set the dc:subject which describes the topic of the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-subject",
            "",
            "        :param subject: Subject or list of subjects.",
            "        :param replace: Replace alredy set subjects (deault: False).",
            "        :returns: List of subjects.",
            "        '''",
            "        if subject is not None:",
            "            if not isinstance(subject, list):",
            "                subject = [subject]",
            "            if replace or not self._dcelem_subject:",
            "                self._dcelem_subject = []",
            "            self._dcelem_subject += subject",
            "        return self._dcelem_subject",
            "",
            "    def dc_title(self, title=None, replace=True):",
            "        '''Get or set the dc:title which is a name given to the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-title",
            "",
            "        :param title: Title or list of titles.",
            "        :param replace: Replace alredy set titles (deault: False).",
            "        :returns: List of titles.",
            "        '''",
            "        if title is not None:",
            "            if not isinstance(title, list):",
            "                title = [title]",
            "            if replace or not self._dcelem_title:",
            "                self._dcelem_title = []",
            "            self._dcelem_title += title",
            "        return self._dcelem_title",
            "",
            "    def dc_type(self, type=None, replace=False):",
            "        '''Get or set the dc:type which describes the nature or genre of the",
            "        resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-type",
            "",
            "        :param type: Type or list of types.",
            "        :param replace: Replace alredy set types (deault: False).",
            "        :returns: List of types.",
            "        '''",
            "        if type is not None:",
            "            if not isinstance(type, list):",
            "                type = [type]",
            "            if replace or not self._dcelem_type:",
            "                self._dcelem_type = []",
            "            self._dcelem_type += type",
            "        return self._dcelem_type",
            "",
            "",
            "class DcExtension(DcBaseExtension):",
            "    '''Dublin Core Elements extension for podcasts.",
            "    '''",
            "",
            "",
            "class DcEntryExtension(DcBaseExtension):",
            "    '''Dublin Core Elements extension for podcasts.",
            "    '''",
            "    def extend_atom(self, entry):",
            "        '''Add dc elements to an atom item. Alters the item itself.",
            "",
            "        :param entry: An atom entry element.",
            "        :returns: The entry element.",
            "        '''",
            "        self._extend_xml(entry)",
            "        return entry",
            "",
            "    def extend_rss(self, item):",
            "        '''Add dc elements to a RSS item. Alters the item itself.",
            "",
            "        :param item: A RSS item element.",
            "        :returns: The item element.",
            "        '''",
            "        self._extend_xml(item)",
            "        return item"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "    feedgen.ext.dc",
            "    ~~~~~~~~~~~~~~~~~~~",
            "",
            "    Extends the FeedGenerator to add Dubline Core Elements to the feeds.",
            "",
            "    Descriptions partly taken from",
            "    http://dublincore.org/documents/dcmi-terms/#elements-coverage",
            "",
            "    :copyright: 2013-2017, Lars Kiesow <lkiesow@uos.de>",
            "",
            "    :license: FreeBSD and LGPL, see license.* for more details.",
            "'''",
            "",
            "from feedgen.ext.base import BaseExtension",
            "from feedgen.util import xml_elem",
            "",
            "",
            "class DcBaseExtension(BaseExtension):",
            "    '''Dublin Core Elements extension for podcasts.",
            "    '''",
            "",
            "    def __init__(self):",
            "        # http://dublincore.org/documents/usageguide/elements.shtml",
            "        # http://dublincore.org/documents/dces/",
            "        # http://dublincore.org/documents/dcmi-terms/",
            "        self._dcelem_contributor = None",
            "        self._dcelem_coverage = None",
            "        self._dcelem_creator = None",
            "        self._dcelem_date = None",
            "        self._dcelem_description = None",
            "        self._dcelem_format = None",
            "        self._dcelem_identifier = None",
            "        self._dcelem_language = None",
            "        self._dcelem_publisher = None",
            "        self._dcelem_relation = None",
            "        self._dcelem_rights = None",
            "        self._dcelem_source = None",
            "        self._dcelem_subject = None",
            "        self._dcelem_title = None",
            "        self._dcelem_type = None",
            "",
            "    def extend_ns(self):",
            "        return {'dc': 'http://purl.org/dc/elements/1.1/'}",
            "",
            "    def _extend_xml(self, xml_element):",
            "        '''Extend xml_element with set DC fields.",
            "",
            "        :param xml_element: etree element",
            "        '''",
            "        DCELEMENTS_NS = 'http://purl.org/dc/elements/1.1/'",
            "",
            "        for elem in ['contributor', 'coverage', 'creator', 'date',",
            "                     'description', 'language', 'publisher', 'relation',",
            "                     'rights', 'source', 'subject', 'title', 'type', 'format',",
            "                     'identifier']:",
            "            if hasattr(self, '_dcelem_%s' % elem):",
            "                for val in getattr(self, '_dcelem_%s' % elem) or []:",
            "                    node = xml_elem('{%s}%s' % (DCELEMENTS_NS, elem),",
            "                                    xml_element)",
            "                    node.text = val",
            "",
            "    def extend_atom(self, atom_feed):",
            "        '''Extend an Atom feed with the set DC fields.",
            "",
            "        :param atom_feed: The feed root element",
            "        :returns: The feed root element",
            "        '''",
            "",
            "        self._extend_xml(atom_feed)",
            "",
            "        return atom_feed",
            "",
            "    def extend_rss(self, rss_feed):",
            "        '''Extend a RSS feed with the set DC fields.",
            "",
            "        :param rss_feed: The feed root element",
            "        :returns: The feed root element.",
            "        '''",
            "        channel = rss_feed[0]",
            "        self._extend_xml(channel)",
            "",
            "        return rss_feed",
            "",
            "    def dc_contributor(self, contributor=None, replace=False):",
            "        '''Get or set the dc:contributor which is an entity responsible for",
            "        making contributions to the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-contributor",
            "",
            "        :param contributor: Contributor or list of contributors.",
            "        :param replace: Replace alredy set contributors (deault: False).",
            "        :returns: List of contributors.",
            "        '''",
            "        if contributor is not None:",
            "            if not isinstance(contributor, list):",
            "                contributor = [contributor]",
            "            if replace or not self._dcelem_contributor:",
            "                self._dcelem_contributor = []",
            "            self._dcelem_contributor += contributor",
            "        return self._dcelem_contributor",
            "",
            "    def dc_coverage(self, coverage=None, replace=True):",
            "        '''Get or set the dc:coverage which indicated the spatial or temporal",
            "        topic of the resource, the spatial applicability of the resource, or",
            "        the jurisdiction under which the resource is relevant.",
            "",
            "        Spatial topic and spatial applicability may be a named place or a",
            "        location specified by its geographic coordinates. Temporal topic may be",
            "        a named period, date, or date range. A jurisdiction may be a named",
            "        administrative entity or a geographic place to which the resource",
            "        applies. Recommended best practice is to use a controlled vocabulary",
            "        such as the Thesaurus of Geographic Names [TGN]. Where appropriate,",
            "        named places or time periods can be used in preference to numeric",
            "        identifiers such as sets of coordinates or date ranges.",
            "",
            "        References:",
            "        [TGN] http://www.getty.edu/research/tools/vocabulary/tgn/index.html",
            "",
            "        :param coverage: Coverage of the feed.",
            "        :param replace: Replace already set coverage (default: True).",
            "        :returns: Coverage of the feed.",
            "        '''",
            "        if coverage is not None:",
            "            if not isinstance(coverage, list):",
            "                coverage = [coverage]",
            "            if replace or not self._dcelem_coverage:",
            "                self._dcelem_coverage = []",
            "            self._dcelem_coverage = coverage",
            "        return self._dcelem_coverage",
            "",
            "    def dc_creator(self, creator=None, replace=False):",
            "        '''Get or set the dc:creator which is an entity primarily responsible",
            "        for making the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-creator",
            "",
            "        :param creator: Creator or list of creators.",
            "        :param replace: Replace alredy set creators (deault: False).",
            "        :returns: List of creators.",
            "        '''",
            "        if creator is not None:",
            "            if not isinstance(creator, list):",
            "                creator = [creator]",
            "            if replace or not self._dcelem_creator:",
            "                self._dcelem_creator = []",
            "            self._dcelem_creator += creator",
            "        return self._dcelem_creator",
            "",
            "    def dc_date(self, date=None, replace=True):",
            "        '''Get or set the dc:date which describes a point or period of time",
            "        associated with an event in the lifecycle of the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-date",
            "",
            "        :param date: Date or list of dates.",
            "        :param replace: Replace alredy set dates (deault: True).",
            "        :returns: List of dates.",
            "        '''",
            "        if date is not None:",
            "            if not isinstance(date, list):",
            "                date = [date]",
            "            if replace or not self._dcelem_date:",
            "                self._dcelem_date = []",
            "            self._dcelem_date += date",
            "        return self._dcelem_date",
            "",
            "    def dc_description(self, description=None, replace=True):",
            "        '''Get or set the dc:description which is an account of the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-description",
            "",
            "        :param description: Description or list of descriptions.",
            "        :param replace: Replace alredy set descriptions (deault: True).",
            "        :returns: List of descriptions.",
            "        '''",
            "        if description is not None:",
            "            if not isinstance(description, list):",
            "                description = [description]",
            "            if replace or not self._dcelem_description:",
            "                self._dcelem_description = []",
            "            self._dcelem_description += description",
            "        return self._dcelem_description",
            "",
            "    def dc_format(self, format=None, replace=True):",
            "        '''Get or set the dc:format which describes the file format, physical",
            "        medium, or dimensions of the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-format",
            "",
            "        :param format: Format of the resource or list of formats.",
            "        :param replace: Replace alredy set format (deault: True).",
            "        :returns: Format of the resource.",
            "        '''",
            "        if format is not None:",
            "            if not isinstance(format, list):",
            "                format = [format]",
            "            if replace or not self._dcelem_format:",
            "                self._dcelem_format = []",
            "            self._dcelem_format += format",
            "        return self._dcelem_format",
            "",
            "    def dc_identifier(self, identifier=None, replace=True):",
            "        '''Get or set the dc:identifier which should be an unambiguous",
            "        reference to the resource within a given context.",
            "",
            "        For more inidentifierion see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-identifier",
            "",
            "        :param identifier: Identifier of the resource or list of identifiers.",
            "        :param replace: Replace alredy set identifier (deault: True).",
            "        :returns: Identifiers of the resource.",
            "        '''",
            "        if identifier is not None:",
            "            if not isinstance(identifier, list):",
            "                identifier = [identifier]",
            "            if replace or not self._dcelem_identifier:",
            "                self._dcelem_identifier = []",
            "            self._dcelem_identifier += identifier",
            "        return self._dcelem_identifier",
            "",
            "    def dc_language(self, language=None, replace=True):",
            "        '''Get or set the dc:language which describes a language of the",
            "        resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-language",
            "",
            "        :param language: Language or list of languages.",
            "        :param replace: Replace alredy set languages (deault: True).",
            "        :returns: List of languages.",
            "        '''",
            "        if language is not None:",
            "            if not isinstance(language, list):",
            "                language = [language]",
            "            if replace or not self._dcelem_language:",
            "                self._dcelem_language = []",
            "            self._dcelem_language += language",
            "        return self._dcelem_language",
            "",
            "    def dc_publisher(self, publisher=None, replace=False):",
            "        '''Get or set the dc:publisher which is an entity responsible for",
            "        making the resource available.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-publisher",
            "",
            "        :param publisher: Publisher or list of publishers.",
            "        :param replace: Replace alredy set publishers (deault: False).",
            "        :returns: List of publishers.",
            "        '''",
            "        if publisher is not None:",
            "            if not isinstance(publisher, list):",
            "                publisher = [publisher]",
            "            if replace or not self._dcelem_publisher:",
            "                self._dcelem_publisher = []",
            "            self._dcelem_publisher += publisher",
            "        return self._dcelem_publisher",
            "",
            "    def dc_relation(self, relation=None, replace=False):",
            "        '''Get or set the dc:relation which describes a related resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-relation",
            "",
            "        :param relation: Relation or list of relations.",
            "        :param replace: Replace alredy set relations (deault: False).",
            "        :returns: List of relations.",
            "        '''",
            "        if relation is not None:",
            "            if not isinstance(relation, list):",
            "                relation = [relation]",
            "            if replace or not self._dcelem_relation:",
            "                self._dcelem_relation = []",
            "            self._dcelem_relation += relation",
            "        return self._dcelem_relation",
            "",
            "    def dc_rights(self, rights=None, replace=False):",
            "        '''Get or set the dc:rights which may contain information about rights",
            "        held in and over the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-rights",
            "",
            "        :param rights: Rights information or list of rights information.",
            "        :param replace: Replace alredy set rightss (deault: False).",
            "        :returns: List of rights information.",
            "        '''",
            "        if rights is not None:",
            "            if not isinstance(rights, list):",
            "                rights = [rights]",
            "            if replace or not self._dcelem_rights:",
            "                self._dcelem_rights = []",
            "            self._dcelem_rights += rights",
            "        return self._dcelem_rights",
            "",
            "    def dc_source(self, source=None, replace=False):",
            "        '''Get or set the dc:source which is a related resource from which the",
            "        described resource is derived.",
            "",
            "        The described resource may be derived from the related resource in",
            "        whole or in part. Recommended best practice is to identify the related",
            "        resource by means of a string conforming to a formal identification",
            "        system.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-source",
            "",
            "        :param source: Source or list of sources.",
            "        :param replace: Replace alredy set sources (deault: False).",
            "        :returns: List of sources.",
            "        '''",
            "        if source is not None:",
            "            if not isinstance(source, list):",
            "                source = [source]",
            "            if replace or not self._dcelem_source:",
            "                self._dcelem_source = []",
            "            self._dcelem_source += source",
            "        return self._dcelem_source",
            "",
            "    def dc_subject(self, subject=None, replace=False):",
            "        '''Get or set the dc:subject which describes the topic of the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-subject",
            "",
            "        :param subject: Subject or list of subjects.",
            "        :param replace: Replace alredy set subjects (deault: False).",
            "        :returns: List of subjects.",
            "        '''",
            "        if subject is not None:",
            "            if not isinstance(subject, list):",
            "                subject = [subject]",
            "            if replace or not self._dcelem_subject:",
            "                self._dcelem_subject = []",
            "            self._dcelem_subject += subject",
            "        return self._dcelem_subject",
            "",
            "    def dc_title(self, title=None, replace=True):",
            "        '''Get or set the dc:title which is a name given to the resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-title",
            "",
            "        :param title: Title or list of titles.",
            "        :param replace: Replace alredy set titles (deault: False).",
            "        :returns: List of titles.",
            "        '''",
            "        if title is not None:",
            "            if not isinstance(title, list):",
            "                title = [title]",
            "            if replace or not self._dcelem_title:",
            "                self._dcelem_title = []",
            "            self._dcelem_title += title",
            "        return self._dcelem_title",
            "",
            "    def dc_type(self, type=None, replace=False):",
            "        '''Get or set the dc:type which describes the nature or genre of the",
            "        resource.",
            "",
            "        For more information see:",
            "        http://dublincore.org/documents/dcmi-terms/#elements-type",
            "",
            "        :param type: Type or list of types.",
            "        :param replace: Replace alredy set types (deault: False).",
            "        :returns: List of types.",
            "        '''",
            "        if type is not None:",
            "            if not isinstance(type, list):",
            "                type = [type]",
            "            if replace or not self._dcelem_type:",
            "                self._dcelem_type = []",
            "            self._dcelem_type += type",
            "        return self._dcelem_type",
            "",
            "",
            "class DcExtension(DcBaseExtension):",
            "    '''Dublin Core Elements extension for podcasts.",
            "    '''",
            "",
            "",
            "class DcEntryExtension(DcBaseExtension):",
            "    '''Dublin Core Elements extension for podcasts.",
            "    '''",
            "    def extend_atom(self, entry):",
            "        '''Add dc elements to an atom item. Alters the item itself.",
            "",
            "        :param entry: An atom entry element.",
            "        :returns: The entry element.",
            "        '''",
            "        self._extend_xml(entry)",
            "        return entry",
            "",
            "    def extend_rss(self, item):",
            "        '''Add dc elements to a RSS item. Alters the item itself.",
            "",
            "        :param item: A RSS item element.",
            "        :returns: The item element.",
            "        '''",
            "        self._extend_xml(item)",
            "        return item"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": [],
            "17": [],
            "48": [
                "DcBaseExtension",
                "_extend_xml"
            ],
            "49": [
                "DcBaseExtension",
                "_extend_xml"
            ],
            "51": [
                "DcBaseExtension",
                "_extend_xml"
            ],
            "61": [
                "DcBaseExtension",
                "_extend_xml"
            ],
            "62": [
                "DcBaseExtension",
                "_extend_xml"
            ]
        },
        "addLocation": []
    },
    "feedgen/ext/geo_entry.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import numbers"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import warnings"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lxml import etree"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from feedgen.ext.base import BaseEntryExtension"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from feedgen.util import xml_elem"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " class GeoRSSPolygonInteriorWarning(Warning):"
            },
            "9": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         GEO_NS = 'http://www.georss.org/georss'"
            },
            "10": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         if self.__point:"
            },
            "12": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            point = etree.SubElement(entry, '{%s}point' % GEO_NS)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            point = xml_elem('{%s}point' % GEO_NS, entry)"
            },
            "14": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "             point.text = self.__point"
            },
            "15": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         if self.__line:"
            },
            "17": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            line = etree.SubElement(entry, '{%s}line' % GEO_NS)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+            line = xml_elem('{%s}line' % GEO_NS, entry)"
            },
            "19": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "             line.text = self.__line"
            },
            "20": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         if self.__polygon:"
            },
            "22": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            polygon = etree.SubElement(entry, '{%s}polygon' % GEO_NS)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            polygon = xml_elem('{%s}polygon' % GEO_NS, entry)"
            },
            "24": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "             polygon.text = self.__polygon"
            },
            "25": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         if self.__box:"
            },
            "27": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            box = etree.SubElement(entry, '{%s}box' % GEO_NS)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            box = xml_elem('{%s}box' % GEO_NS, entry)"
            },
            "29": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "             box.text = self.__box"
            },
            "30": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         if self.__featuretypetag:"
            },
            "32": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            featuretypetag = etree.SubElement("
            },
            "33": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                entry,"
            },
            "34": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                '{%s}featuretypetag' % GEO_NS"
            },
            "35": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            featuretypetag = xml_elem('{%s}featuretypetag' % GEO_NS, entry)"
            },
            "37": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "             featuretypetag.text = self.__featuretypetag"
            },
            "38": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         if self.__relationshiptag:"
            },
            "40": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            relationshiptag = etree.SubElement("
            },
            "41": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                entry,"
            },
            "42": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                '{%s}relationshiptag' % GEO_NS"
            },
            "43": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            relationshiptag = xml_elem('{%s}relationshiptag' % GEO_NS, entry)"
            },
            "45": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             relationshiptag.text = self.__relationshiptag"
            },
            "46": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         if self.__featurename:"
            },
            "48": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            featurename = etree.SubElement(entry, '{%s}featurename' % GEO_NS)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+            featurename = xml_elem('{%s}featurename' % GEO_NS, entry)"
            },
            "50": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "             featurename.text = self.__featurename"
            },
            "51": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         if self.__elev:"
            },
            "53": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elevation = etree.SubElement(entry, '{%s}elev' % GEO_NS)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            elevation = xml_elem('{%s}elev' % GEO_NS, entry)"
            },
            "55": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "             elevation.text = str(self.__elev)"
            },
            "56": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         if self.__floor:"
            },
            "58": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            floor = etree.SubElement(entry, '{%s}floor' % GEO_NS)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            floor = xml_elem('{%s}floor' % GEO_NS, entry)"
            },
            "60": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "             floor.text = str(self.__floor)"
            },
            "61": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         if self.__radius:"
            },
            "63": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            radius = etree.SubElement(entry, '{%s}radius' % GEO_NS)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            radius = xml_elem('{%s}radius' % GEO_NS, entry)"
            },
            "65": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             radius.text = str(self.__radius)"
            },
            "66": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         return entry"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "    feedgen.ext.geo_entry",
            "    ~~~~~~~~~~~~~~~~~~~",
            "",
            "    Extends the FeedGenerator to produce Simple GeoRSS feeds.",
            "",
            "    :copyright: 2017, Bob Breznak <bob.breznak@gmail.com>",
            "",
            "    :license: FreeBSD and LGPL, see license.* for more details.",
            "'''",
            "import numbers",
            "import warnings",
            "",
            "from lxml import etree",
            "from feedgen.ext.base import BaseEntryExtension",
            "",
            "",
            "class GeoRSSPolygonInteriorWarning(Warning):",
            "    \"\"\"",
            "    Simple placeholder for warning about ignored polygon interiors.",
            "",
            "    Stores the original geom on a ``geom`` attribute (if required warnings are",
            "    raised as errors).",
            "    \"\"\"",
            "",
            "    def __init__(self, geom, *args, **kwargs):",
            "        self.geom = geom",
            "        super(GeoRSSPolygonInteriorWarning, self).__init__(*args, **kwargs)",
            "",
            "    def __str__(self):",
            "        return '{:d} interiors of polygon ignored'.format(",
            "            len(self.geom.__geo_interface__['coordinates']) - 1",
            "        )  # ignore exterior in count",
            "",
            "",
            "class GeoRSSGeometryError(ValueError):",
            "    \"\"\"",
            "    Subclass of ValueError for a GeoRSS geometry error",
            "",
            "    Only some geometries are supported in Simple GeoRSS, so if not raise an",
            "    error. Offending geometry is stored on the ``geom`` attribute.",
            "    \"\"\"",
            "",
            "    def __init__(self, geom, *args, **kwargs):",
            "        self.geom = geom",
            "        super(GeoRSSGeometryError, self).__init__(*args, **kwargs)",
            "",
            "    def __str__(self):",
            "        msg = \"Geometry of type '{}' not in Point, Linestring or Polygon\"",
            "        return msg.format(",
            "            self.geom.__geo_interface__['type']",
            "        )",
            "",
            "",
            "class GeoEntryExtension(BaseEntryExtension):",
            "    '''FeedEntry extension for Simple GeoRSS.",
            "    '''",
            "",
            "    def __init__(self):",
            "        '''Simple GeoRSS tag'''",
            "        # geometries",
            "        self.__point = None",
            "        self.__line = None",
            "        self.__polygon = None",
            "        self.__box = None",
            "",
            "        # additional properties",
            "        self.__featuretypetag = None",
            "        self.__relationshiptag = None",
            "        self.__featurename = None",
            "",
            "        # elevation",
            "        self.__elev = None",
            "        self.__floor = None",
            "",
            "        # radius",
            "        self.__radius = None",
            "",
            "    def extend_file(self, entry):",
            "        '''Add additional fields to an RSS item.",
            "",
            "        :param feed: The RSS item XML element to use.",
            "        '''",
            "",
            "        GEO_NS = 'http://www.georss.org/georss'",
            "",
            "        if self.__point:",
            "            point = etree.SubElement(entry, '{%s}point' % GEO_NS)",
            "            point.text = self.__point",
            "",
            "        if self.__line:",
            "            line = etree.SubElement(entry, '{%s}line' % GEO_NS)",
            "            line.text = self.__line",
            "",
            "        if self.__polygon:",
            "            polygon = etree.SubElement(entry, '{%s}polygon' % GEO_NS)",
            "            polygon.text = self.__polygon",
            "",
            "        if self.__box:",
            "            box = etree.SubElement(entry, '{%s}box' % GEO_NS)",
            "            box.text = self.__box",
            "",
            "        if self.__featuretypetag:",
            "            featuretypetag = etree.SubElement(",
            "                entry,",
            "                '{%s}featuretypetag' % GEO_NS",
            "            )",
            "            featuretypetag.text = self.__featuretypetag",
            "",
            "        if self.__relationshiptag:",
            "            relationshiptag = etree.SubElement(",
            "                entry,",
            "                '{%s}relationshiptag' % GEO_NS",
            "            )",
            "            relationshiptag.text = self.__relationshiptag",
            "",
            "        if self.__featurename:",
            "            featurename = etree.SubElement(entry, '{%s}featurename' % GEO_NS)",
            "            featurename.text = self.__featurename",
            "",
            "        if self.__elev:",
            "            elevation = etree.SubElement(entry, '{%s}elev' % GEO_NS)",
            "            elevation.text = str(self.__elev)",
            "",
            "        if self.__floor:",
            "            floor = etree.SubElement(entry, '{%s}floor' % GEO_NS)",
            "            floor.text = str(self.__floor)",
            "",
            "        if self.__radius:",
            "            radius = etree.SubElement(entry, '{%s}radius' % GEO_NS)",
            "            radius.text = str(self.__radius)",
            "",
            "        return entry",
            "",
            "    def extend_rss(self, entry):",
            "        return self.extend_file(entry)",
            "",
            "    def extend_atom(self, entry):",
            "        return self.extend_file(entry)",
            "",
            "    def point(self, point=None):",
            "        '''Get or set the georss:point of the entry.",
            "",
            "        :param point: The GeoRSS formatted point (i.e. \"42.36 -71.05\")",
            "        :returns: The current georss:point of the entry.",
            "        '''",
            "",
            "        if point is not None:",
            "            self.__point = point",
            "",
            "        return self.__point",
            "",
            "    def line(self, line=None):",
            "        '''Get or set the georss:line of the entry",
            "",
            "        :param point: The GeoRSS formatted line (i.e. \"45.256 -110.45 46.46",
            "                      -109.48 43.84 -109.86\")",
            "        :return: The current georss:line of the entry",
            "        '''",
            "        if line is not None:",
            "            self.__line = line",
            "",
            "        return self.__line",
            "",
            "    def polygon(self, polygon=None):",
            "        '''Get or set the georss:polygon of the entry",
            "",
            "        :param polygon: The GeoRSS formatted polygon (i.e. \"45.256 -110.45",
            "                        46.46 -109.48 43.84 -109.86 45.256 -110.45\")",
            "        :return: The current georss:polygon of the entry",
            "        '''",
            "        if polygon is not None:",
            "            self.__polygon = polygon",
            "",
            "        return self.__polygon",
            "",
            "    def box(self, box=None):",
            "        '''",
            "        Get or set the georss:box of the entry",
            "",
            "        :param box: The GeoRSS formatted box (i.e. \"42.943 -71.032 43.039",
            "                    -69.856\")",
            "        :return: The current georss:box of the entry",
            "        '''",
            "        if box is not None:",
            "            self.__box = box",
            "",
            "        return self.__box",
            "",
            "    def featuretypetag(self, featuretypetag=None):",
            "        '''",
            "        Get or set the georss:featuretypetag of the entry",
            "",
            "        :param featuretypetag: The GeoRSS feaaturertyptag (e.g. \"city\")",
            "        :return: The current georss:featurertypetag",
            "        '''",
            "        if featuretypetag is not None:",
            "            self.__featuretypetag = featuretypetag",
            "",
            "        return self.__featuretypetag",
            "",
            "    def relationshiptag(self, relationshiptag=None):",
            "        '''",
            "        Get or set the georss:relationshiptag of the entry",
            "",
            "        :param relationshiptag: The GeoRSS relationshiptag (e.g.",
            "                                \"is-centred-at\")",
            "        :return: the current georss:relationshiptag",
            "        '''",
            "        if relationshiptag is not None:",
            "            self.__relationshiptag = relationshiptag",
            "",
            "        return self.__relationshiptag",
            "",
            "    def featurename(self, featurename=None):",
            "        '''",
            "        Get or set the georss:featurename of the entry",
            "",
            "        :param featuretypetag: The GeoRSS featurename (e.g. \"Footscray\")",
            "        :return: the current georss:featurename",
            "        '''",
            "        if featurename is not None:",
            "            self.__featurename = featurename",
            "",
            "        return self.__featurename",
            "",
            "    def elev(self, elev=None):",
            "        '''",
            "        Get or set the georss:elev of the entry",
            "",
            "        :param elev: The GeoRSS elevation (e.g. 100.3)",
            "        :type elev: numbers.Number",
            "        :return: the current georss:elev",
            "        '''",
            "        if elev is not None:",
            "            if not isinstance(elev, numbers.Number):",
            "                raise ValueError(\"elev tag must be numeric: {}\".format(elev))",
            "",
            "            self.__elev = elev",
            "",
            "        return self.__elev",
            "",
            "    def floor(self, floor=None):",
            "        '''",
            "        Get or set the georss:floor of the entry",
            "",
            "        :param floor: The GeoRSS floor (e.g. 4)",
            "        :type floor: int",
            "        :return: the current georss:floor",
            "        '''",
            "        if floor is not None:",
            "            if not isinstance(floor, int):",
            "                raise ValueError(\"floor tag must be int: {}\".format(floor))",
            "",
            "            self.__floor = floor",
            "",
            "        return self.__floor",
            "",
            "    def radius(self, radius=None):",
            "        '''",
            "        Get or set the georss:radius of the entry",
            "",
            "        :param radius: The GeoRSS radius (e.g. 100.3)",
            "        :type radius: numbers.Number",
            "        :return: the current georss:radius",
            "        '''",
            "        if radius is not None:",
            "            if not isinstance(radius, numbers.Number):",
            "                raise ValueError(",
            "                    \"radius tag must be numeric: {}\".format(radius)",
            "                )",
            "",
            "            self.__radius = radius",
            "",
            "        return self.__radius",
            "",
            "    def geom_from_geo_interface(self, geom):",
            "        '''",
            "        Generate a georss geometry from some Python object with a",
            "        ``__geo_interface__`` property (see the `geo_interface specification by",
            "        Sean Gillies`_geointerface )",
            "",
            "        Note only a subset of GeoJSON (see `geojson.org`_geojson ) can be",
            "        easily converted to GeoRSS:",
            "",
            "        - Point",
            "        - LineString",
            "        - Polygon (if there are holes / donuts in the polygons a warning will",
            "          be generaated",
            "",
            "        Other GeoJson types will raise a ``ValueError``.",
            "",
            "        .. note:: The geometry is assumed to be x, y as longitude, latitude in",
            "           the WGS84 projection.",
            "",
            "        .. _geointerface: https://gist.github.com/sgillies/2217756",
            "        .. _geojson: https://geojson.org/",
            "",
            "        :param geom: Geometry object with a __geo_interface__ property",
            "        :return: the formatted GeoRSS geometry",
            "        '''",
            "        geojson = geom.__geo_interface__",
            "",
            "        if geojson['type'] not in ('Point', 'LineString', 'Polygon'):",
            "            raise GeoRSSGeometryError(geom)",
            "",
            "        if geojson['type'] == 'Point':",
            "",
            "            coords = '{:f} {:f}'.format(",
            "                geojson['coordinates'][1],  # latitude is y",
            "                geojson['coordinates'][0]",
            "            )",
            "            return self.point(coords)",
            "",
            "        elif geojson['type'] == 'LineString':",
            "",
            "            coords = ' '.join(",
            "                '{:f} {:f}'.format(vertex[1], vertex[0])",
            "                for vertex in",
            "                geojson['coordinates']",
            "            )",
            "            return self.line(coords)",
            "",
            "        elif geojson['type'] == 'Polygon':",
            "",
            "            if len(geojson['coordinates']) > 1:",
            "                warnings.warn(GeoRSSPolygonInteriorWarning(geom))",
            "",
            "            coords = ' '.join(",
            "                '{:f} {:f}'.format(vertex[1], vertex[0])",
            "                for vertex in",
            "                geojson['coordinates'][0]",
            "            )",
            "            return self.polygon(coords)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "    feedgen.ext.geo_entry",
            "    ~~~~~~~~~~~~~~~~~~~",
            "",
            "    Extends the FeedGenerator to produce Simple GeoRSS feeds.",
            "",
            "    :copyright: 2017, Bob Breznak <bob.breznak@gmail.com>",
            "",
            "    :license: FreeBSD and LGPL, see license.* for more details.",
            "'''",
            "import numbers",
            "import warnings",
            "",
            "from feedgen.ext.base import BaseEntryExtension",
            "from feedgen.util import xml_elem",
            "",
            "",
            "class GeoRSSPolygonInteriorWarning(Warning):",
            "    \"\"\"",
            "    Simple placeholder for warning about ignored polygon interiors.",
            "",
            "    Stores the original geom on a ``geom`` attribute (if required warnings are",
            "    raised as errors).",
            "    \"\"\"",
            "",
            "    def __init__(self, geom, *args, **kwargs):",
            "        self.geom = geom",
            "        super(GeoRSSPolygonInteriorWarning, self).__init__(*args, **kwargs)",
            "",
            "    def __str__(self):",
            "        return '{:d} interiors of polygon ignored'.format(",
            "            len(self.geom.__geo_interface__['coordinates']) - 1",
            "        )  # ignore exterior in count",
            "",
            "",
            "class GeoRSSGeometryError(ValueError):",
            "    \"\"\"",
            "    Subclass of ValueError for a GeoRSS geometry error",
            "",
            "    Only some geometries are supported in Simple GeoRSS, so if not raise an",
            "    error. Offending geometry is stored on the ``geom`` attribute.",
            "    \"\"\"",
            "",
            "    def __init__(self, geom, *args, **kwargs):",
            "        self.geom = geom",
            "        super(GeoRSSGeometryError, self).__init__(*args, **kwargs)",
            "",
            "    def __str__(self):",
            "        msg = \"Geometry of type '{}' not in Point, Linestring or Polygon\"",
            "        return msg.format(",
            "            self.geom.__geo_interface__['type']",
            "        )",
            "",
            "",
            "class GeoEntryExtension(BaseEntryExtension):",
            "    '''FeedEntry extension for Simple GeoRSS.",
            "    '''",
            "",
            "    def __init__(self):",
            "        '''Simple GeoRSS tag'''",
            "        # geometries",
            "        self.__point = None",
            "        self.__line = None",
            "        self.__polygon = None",
            "        self.__box = None",
            "",
            "        # additional properties",
            "        self.__featuretypetag = None",
            "        self.__relationshiptag = None",
            "        self.__featurename = None",
            "",
            "        # elevation",
            "        self.__elev = None",
            "        self.__floor = None",
            "",
            "        # radius",
            "        self.__radius = None",
            "",
            "    def extend_file(self, entry):",
            "        '''Add additional fields to an RSS item.",
            "",
            "        :param feed: The RSS item XML element to use.",
            "        '''",
            "",
            "        GEO_NS = 'http://www.georss.org/georss'",
            "",
            "        if self.__point:",
            "            point = xml_elem('{%s}point' % GEO_NS, entry)",
            "            point.text = self.__point",
            "",
            "        if self.__line:",
            "            line = xml_elem('{%s}line' % GEO_NS, entry)",
            "            line.text = self.__line",
            "",
            "        if self.__polygon:",
            "            polygon = xml_elem('{%s}polygon' % GEO_NS, entry)",
            "            polygon.text = self.__polygon",
            "",
            "        if self.__box:",
            "            box = xml_elem('{%s}box' % GEO_NS, entry)",
            "            box.text = self.__box",
            "",
            "        if self.__featuretypetag:",
            "            featuretypetag = xml_elem('{%s}featuretypetag' % GEO_NS, entry)",
            "            featuretypetag.text = self.__featuretypetag",
            "",
            "        if self.__relationshiptag:",
            "            relationshiptag = xml_elem('{%s}relationshiptag' % GEO_NS, entry)",
            "            relationshiptag.text = self.__relationshiptag",
            "",
            "        if self.__featurename:",
            "            featurename = xml_elem('{%s}featurename' % GEO_NS, entry)",
            "            featurename.text = self.__featurename",
            "",
            "        if self.__elev:",
            "            elevation = xml_elem('{%s}elev' % GEO_NS, entry)",
            "            elevation.text = str(self.__elev)",
            "",
            "        if self.__floor:",
            "            floor = xml_elem('{%s}floor' % GEO_NS, entry)",
            "            floor.text = str(self.__floor)",
            "",
            "        if self.__radius:",
            "            radius = xml_elem('{%s}radius' % GEO_NS, entry)",
            "            radius.text = str(self.__radius)",
            "",
            "        return entry",
            "",
            "    def extend_rss(self, entry):",
            "        return self.extend_file(entry)",
            "",
            "    def extend_atom(self, entry):",
            "        return self.extend_file(entry)",
            "",
            "    def point(self, point=None):",
            "        '''Get or set the georss:point of the entry.",
            "",
            "        :param point: The GeoRSS formatted point (i.e. \"42.36 -71.05\")",
            "        :returns: The current georss:point of the entry.",
            "        '''",
            "",
            "        if point is not None:",
            "            self.__point = point",
            "",
            "        return self.__point",
            "",
            "    def line(self, line=None):",
            "        '''Get or set the georss:line of the entry",
            "",
            "        :param point: The GeoRSS formatted line (i.e. \"45.256 -110.45 46.46",
            "                      -109.48 43.84 -109.86\")",
            "        :return: The current georss:line of the entry",
            "        '''",
            "        if line is not None:",
            "            self.__line = line",
            "",
            "        return self.__line",
            "",
            "    def polygon(self, polygon=None):",
            "        '''Get or set the georss:polygon of the entry",
            "",
            "        :param polygon: The GeoRSS formatted polygon (i.e. \"45.256 -110.45",
            "                        46.46 -109.48 43.84 -109.86 45.256 -110.45\")",
            "        :return: The current georss:polygon of the entry",
            "        '''",
            "        if polygon is not None:",
            "            self.__polygon = polygon",
            "",
            "        return self.__polygon",
            "",
            "    def box(self, box=None):",
            "        '''",
            "        Get or set the georss:box of the entry",
            "",
            "        :param box: The GeoRSS formatted box (i.e. \"42.943 -71.032 43.039",
            "                    -69.856\")",
            "        :return: The current georss:box of the entry",
            "        '''",
            "        if box is not None:",
            "            self.__box = box",
            "",
            "        return self.__box",
            "",
            "    def featuretypetag(self, featuretypetag=None):",
            "        '''",
            "        Get or set the georss:featuretypetag of the entry",
            "",
            "        :param featuretypetag: The GeoRSS feaaturertyptag (e.g. \"city\")",
            "        :return: The current georss:featurertypetag",
            "        '''",
            "        if featuretypetag is not None:",
            "            self.__featuretypetag = featuretypetag",
            "",
            "        return self.__featuretypetag",
            "",
            "    def relationshiptag(self, relationshiptag=None):",
            "        '''",
            "        Get or set the georss:relationshiptag of the entry",
            "",
            "        :param relationshiptag: The GeoRSS relationshiptag (e.g.",
            "                                \"is-centred-at\")",
            "        :return: the current georss:relationshiptag",
            "        '''",
            "        if relationshiptag is not None:",
            "            self.__relationshiptag = relationshiptag",
            "",
            "        return self.__relationshiptag",
            "",
            "    def featurename(self, featurename=None):",
            "        '''",
            "        Get or set the georss:featurename of the entry",
            "",
            "        :param featuretypetag: The GeoRSS featurename (e.g. \"Footscray\")",
            "        :return: the current georss:featurename",
            "        '''",
            "        if featurename is not None:",
            "            self.__featurename = featurename",
            "",
            "        return self.__featurename",
            "",
            "    def elev(self, elev=None):",
            "        '''",
            "        Get or set the georss:elev of the entry",
            "",
            "        :param elev: The GeoRSS elevation (e.g. 100.3)",
            "        :type elev: numbers.Number",
            "        :return: the current georss:elev",
            "        '''",
            "        if elev is not None:",
            "            if not isinstance(elev, numbers.Number):",
            "                raise ValueError(\"elev tag must be numeric: {}\".format(elev))",
            "",
            "            self.__elev = elev",
            "",
            "        return self.__elev",
            "",
            "    def floor(self, floor=None):",
            "        '''",
            "        Get or set the georss:floor of the entry",
            "",
            "        :param floor: The GeoRSS floor (e.g. 4)",
            "        :type floor: int",
            "        :return: the current georss:floor",
            "        '''",
            "        if floor is not None:",
            "            if not isinstance(floor, int):",
            "                raise ValueError(\"floor tag must be int: {}\".format(floor))",
            "",
            "            self.__floor = floor",
            "",
            "        return self.__floor",
            "",
            "    def radius(self, radius=None):",
            "        '''",
            "        Get or set the georss:radius of the entry",
            "",
            "        :param radius: The GeoRSS radius (e.g. 100.3)",
            "        :type radius: numbers.Number",
            "        :return: the current georss:radius",
            "        '''",
            "        if radius is not None:",
            "            if not isinstance(radius, numbers.Number):",
            "                raise ValueError(",
            "                    \"radius tag must be numeric: {}\".format(radius)",
            "                )",
            "",
            "            self.__radius = radius",
            "",
            "        return self.__radius",
            "",
            "    def geom_from_geo_interface(self, geom):",
            "        '''",
            "        Generate a georss geometry from some Python object with a",
            "        ``__geo_interface__`` property (see the `geo_interface specification by",
            "        Sean Gillies`_geointerface )",
            "",
            "        Note only a subset of GeoJSON (see `geojson.org`_geojson ) can be",
            "        easily converted to GeoRSS:",
            "",
            "        - Point",
            "        - LineString",
            "        - Polygon (if there are holes / donuts in the polygons a warning will",
            "          be generaated",
            "",
            "        Other GeoJson types will raise a ``ValueError``.",
            "",
            "        .. note:: The geometry is assumed to be x, y as longitude, latitude in",
            "           the WGS84 projection.",
            "",
            "        .. _geointerface: https://gist.github.com/sgillies/2217756",
            "        .. _geojson: https://geojson.org/",
            "",
            "        :param geom: Geometry object with a __geo_interface__ property",
            "        :return: the formatted GeoRSS geometry",
            "        '''",
            "        geojson = geom.__geo_interface__",
            "",
            "        if geojson['type'] not in ('Point', 'LineString', 'Polygon'):",
            "            raise GeoRSSGeometryError(geom)",
            "",
            "        if geojson['type'] == 'Point':",
            "",
            "            coords = '{:f} {:f}'.format(",
            "                geojson['coordinates'][1],  # latitude is y",
            "                geojson['coordinates'][0]",
            "            )",
            "            return self.point(coords)",
            "",
            "        elif geojson['type'] == 'LineString':",
            "",
            "            coords = ' '.join(",
            "                '{:f} {:f}'.format(vertex[1], vertex[0])",
            "                for vertex in",
            "                geojson['coordinates']",
            "            )",
            "            return self.line(coords)",
            "",
            "        elif geojson['type'] == 'Polygon':",
            "",
            "            if len(geojson['coordinates']) > 1:",
            "                warnings.warn(GeoRSSPolygonInteriorWarning(geom))",
            "",
            "            coords = ' '.join(",
            "                '{:f} {:f}'.format(vertex[1], vertex[0])",
            "                for vertex in",
            "                geojson['coordinates'][0]",
            "            )",
            "            return self.polygon(coords)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "89": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "93": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "97": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "101": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "105": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "106": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "107": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "108": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "112": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "113": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "114": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "115": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "119": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "123": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "127": [
                "GeoEntryExtension",
                "extend_file"
            ],
            "131": [
                "GeoEntryExtension",
                "extend_file"
            ]
        },
        "addLocation": []
    },
    "feedgen/ext/media.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     :license: FreeBSD and LGPL, see license.* for more details."
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " '''"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lxml import etree"
            },
            "4": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from feedgen.ext.base import BaseEntryExtension, BaseExtension"
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from feedgen.util import ensure_format"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from feedgen.util import ensure_format, xml_elem"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " MEDIA_NS = 'http://search.yahoo.com/mrss/'"
            },
            "10": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "             # Define current media:group"
            },
            "12": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "             group = groups.get(media_content.get('group'))"
            },
            "13": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             if group is None:"
            },
            "14": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                group = etree.SubElement(entry, '{%s}group' % MEDIA_NS)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                group = xml_elem('{%s}group' % MEDIA_NS, entry)"
            },
            "16": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "                 groups[media_content.get('group')] = group"
            },
            "17": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             # Add content"
            },
            "18": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            content = etree.SubElement(group, '{%s}content' % MEDIA_NS)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            content = xml_elem('{%s}content' % MEDIA_NS, group)"
            },
            "20": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             for attr in ('url', 'fileSize', 'type', 'medium', 'isDefault',"
            },
            "21": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                          'expression', 'bitrate', 'framerate', 'samplingrate',"
            },
            "22": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                          'channels', 'duration', 'height', 'width', 'lang'):"
            },
            "23": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             # Define current media:group"
            },
            "24": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             group = groups.get(media_thumbnail.get('group'))"
            },
            "25": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             if group is None:"
            },
            "26": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                group = etree.SubElement(entry, '{%s}group' % MEDIA_NS)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                group = xml_elem('{%s}group' % MEDIA_NS, entry)"
            },
            "28": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "                 groups[media_thumbnail.get('group')] = group"
            },
            "29": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             # Add thumbnails"
            },
            "30": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            thumbnail = etree.SubElement(group, '{%s}thumbnail' % MEDIA_NS)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            thumbnail = xml_elem('{%s}thumbnail' % MEDIA_NS, group)"
            },
            "32": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "             for attr in ('url', 'height', 'width', 'time'):"
            },
            "33": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "                 if media_thumbnail.get(attr):"
            },
            "34": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "                     thumbnail.set(attr, media_thumbnail[attr])"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "    feedgen.ext.media",
            "    ~~~~~~~~~~~~~~~~~",
            "",
            "    Extends the feedgen to produce media tags.",
            "",
            "    :copyright: 2013-2017, Lars Kiesow <lkiesow@uos.de>",
            "",
            "    :license: FreeBSD and LGPL, see license.* for more details.",
            "'''",
            "",
            "from lxml import etree",
            "",
            "from feedgen.ext.base import BaseEntryExtension, BaseExtension",
            "from feedgen.util import ensure_format",
            "",
            "MEDIA_NS = 'http://search.yahoo.com/mrss/'",
            "",
            "",
            "class MediaExtension(BaseExtension):",
            "    '''FeedGenerator extension for torrent feeds.",
            "    '''",
            "",
            "    def extend_ns(self):",
            "        return {'media': MEDIA_NS}",
            "",
            "",
            "class MediaEntryExtension(BaseEntryExtension):",
            "    '''FeedEntry extension for media tags.",
            "    '''",
            "",
            "    def __init__(self):",
            "        self.__media_content = []",
            "        self.__media_thumbnail = []",
            "",
            "    def extend_atom(self, entry):",
            "        '''Add additional fields to an RSS item.",
            "",
            "        :param feed: The RSS item XML element to use.",
            "        '''",
            "",
            "        groups = {None: entry}",
            "        for media_content in self.__media_content:",
            "            # Define current media:group",
            "            group = groups.get(media_content.get('group'))",
            "            if group is None:",
            "                group = etree.SubElement(entry, '{%s}group' % MEDIA_NS)",
            "                groups[media_content.get('group')] = group",
            "            # Add content",
            "            content = etree.SubElement(group, '{%s}content' % MEDIA_NS)",
            "            for attr in ('url', 'fileSize', 'type', 'medium', 'isDefault',",
            "                         'expression', 'bitrate', 'framerate', 'samplingrate',",
            "                         'channels', 'duration', 'height', 'width', 'lang'):",
            "                if media_content.get(attr):",
            "                    content.set(attr, media_content[attr])",
            "",
            "        for media_thumbnail in self.__media_thumbnail:",
            "            # Define current media:group",
            "            group = groups.get(media_thumbnail.get('group'))",
            "            if group is None:",
            "                group = etree.SubElement(entry, '{%s}group' % MEDIA_NS)",
            "                groups[media_thumbnail.get('group')] = group",
            "            # Add thumbnails",
            "            thumbnail = etree.SubElement(group, '{%s}thumbnail' % MEDIA_NS)",
            "            for attr in ('url', 'height', 'width', 'time'):",
            "                if media_thumbnail.get(attr):",
            "                    thumbnail.set(attr, media_thumbnail[attr])",
            "",
            "        return entry",
            "",
            "    def extend_rss(self, item):",
            "        return self.extend_atom(item)",
            "",
            "    def content(self, content=None, replace=False, group='default', **kwargs):",
            "        '''Get or set media:content data.",
            "",
            "        This method can be called with:",
            "        - the fields of a media:content as keyword arguments",
            "        - the fields of a media:content as a dictionary",
            "        - a list of dictionaries containing the media:content fields",
            "",
            "        <media:content> is a sub-element of either <item> or <media:group>.",
            "        Media objects that are not the same content should not be included in",
            "        the same <media:group> element. The sequence of these items implies",
            "        the order of presentation. While many of the attributes appear to be",
            "        audio/video specific, this element can be used to publish any type",
            "        of media. It contains 14 attributes, most of which are optional.",
            "",
            "        media:content has the following fields:",
            "        - *url* should specify the direct URL to the media object.",
            "        - *fileSize* number of bytes of the media object.",
            "        - *type* standard MIME type of the object.",
            "        - *medium* type of object (image | audio | video | document |",
            "          executable).",
            "        - *isDefault* determines if this is the default object.",
            "        - *expression* determines if the object is a sample or the full version",
            "          of the object, or even if it is a continuous stream (sample | full |",
            "          nonstop).",
            "        - *bitrate* kilobits per second rate of media.",
            "        - *framerate* number of frames per second for the media object.",
            "        - *samplingrate* number of samples per second taken to create the media",
            "          object. It is expressed in thousands of samples per second (kHz).",
            "        - *channels* number of audio channels in the media object.",
            "        - *duration* number of seconds the media object plays.",
            "        - *height* height of the media object.",
            "        - *width* width of the media object.",
            "        - *lang* is the primary language encapsulated in the media object.",
            "",
            "        :param content: Dictionary or list of dictionaries with content data.",
            "        :param replace: Add or replace old data.",
            "        :param group: Media group to put this content in.",
            "",
            "        :returns: The media content tag.",
            "        '''",
            "        # Handle kwargs",
            "        if content is None and kwargs:",
            "            content = kwargs",
            "        # Handle new data",
            "        if content is not None:",
            "            # Reset data if we want to replace them",
            "            if replace or self.__media_content is None:",
            "                self.__media_content = []",
            "            # Ensure list",
            "            if not isinstance(content, list):",
            "                content = [content]",
            "            # define media group",
            "            for c in content:",
            "                c['group'] = c.get('group', group)",
            "            self.__media_content += ensure_format(",
            "                    content,",
            "                    set(['url', 'fileSize', 'type', 'medium', 'isDefault',",
            "                         'expression', 'bitrate', 'framerate', 'samplingrate',",
            "                         'channels', 'duration', 'height', 'width', 'lang',",
            "                         'group']),",
            "                    set(['url', 'group']))",
            "        return self.__media_content",
            "",
            "    def thumbnail(self, thumbnail=None, replace=False, group='default',",
            "                  **kwargs):",
            "        '''Get or set media:thumbnail data.",
            "",
            "        This method can be called with:",
            "        - the fields of a media:content as keyword arguments",
            "        - the fields of a media:content as a dictionary",
            "        - a list of dictionaries containing the media:content fields",
            "",
            "        Allows particular images to be used as representative images for",
            "        the media object. If multiple thumbnails are included, and time",
            "        coding is not at play, it is assumed that the images are in order",
            "        of importance. It has one required attribute and three optional",
            "        attributes.",
            "",
            "        media:thumbnail has the following fields:",
            "        - *url* should specify the direct URL to the media object.",
            "        - *height* height of the media object.",
            "        - *width* width of the media object.",
            "        - *time* specifies the time offset in relation to the media object.",
            "",
            "        :param thumbnail: Dictionary or list of dictionaries with thumbnail",
            "                          data.",
            "        :param replace: Add or replace old data.",
            "        :param group: Media group to put this content in.",
            "",
            "        :returns: The media thumbnail tag.",
            "        '''",
            "        # Handle kwargs",
            "        if thumbnail is None and kwargs:",
            "            thumbnail = kwargs",
            "        # Handle new data",
            "        if thumbnail is not None:",
            "            # Reset data if we want to replace them",
            "            if replace or self.__media_thumbnail is None:",
            "                self.__media_thumbnail = []",
            "            # Ensure list",
            "            if not isinstance(thumbnail, list):",
            "                thumbnail = [thumbnail]",
            "            # Define media group",
            "            for t in thumbnail:",
            "                t['group'] = t.get('group', group)",
            "            self.__media_thumbnail += ensure_format(",
            "                    thumbnail,",
            "                    set(['url', 'height', 'width', 'time', 'group']),",
            "                    set(['url', 'group']))",
            "        return self.__media_thumbnail"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "    feedgen.ext.media",
            "    ~~~~~~~~~~~~~~~~~",
            "",
            "    Extends the feedgen to produce media tags.",
            "",
            "    :copyright: 2013-2017, Lars Kiesow <lkiesow@uos.de>",
            "",
            "    :license: FreeBSD and LGPL, see license.* for more details.",
            "'''",
            "",
            "from feedgen.ext.base import BaseEntryExtension, BaseExtension",
            "from feedgen.util import ensure_format, xml_elem",
            "",
            "MEDIA_NS = 'http://search.yahoo.com/mrss/'",
            "",
            "",
            "class MediaExtension(BaseExtension):",
            "    '''FeedGenerator extension for torrent feeds.",
            "    '''",
            "",
            "    def extend_ns(self):",
            "        return {'media': MEDIA_NS}",
            "",
            "",
            "class MediaEntryExtension(BaseEntryExtension):",
            "    '''FeedEntry extension for media tags.",
            "    '''",
            "",
            "    def __init__(self):",
            "        self.__media_content = []",
            "        self.__media_thumbnail = []",
            "",
            "    def extend_atom(self, entry):",
            "        '''Add additional fields to an RSS item.",
            "",
            "        :param feed: The RSS item XML element to use.",
            "        '''",
            "",
            "        groups = {None: entry}",
            "        for media_content in self.__media_content:",
            "            # Define current media:group",
            "            group = groups.get(media_content.get('group'))",
            "            if group is None:",
            "                group = xml_elem('{%s}group' % MEDIA_NS, entry)",
            "                groups[media_content.get('group')] = group",
            "            # Add content",
            "            content = xml_elem('{%s}content' % MEDIA_NS, group)",
            "            for attr in ('url', 'fileSize', 'type', 'medium', 'isDefault',",
            "                         'expression', 'bitrate', 'framerate', 'samplingrate',",
            "                         'channels', 'duration', 'height', 'width', 'lang'):",
            "                if media_content.get(attr):",
            "                    content.set(attr, media_content[attr])",
            "",
            "        for media_thumbnail in self.__media_thumbnail:",
            "            # Define current media:group",
            "            group = groups.get(media_thumbnail.get('group'))",
            "            if group is None:",
            "                group = xml_elem('{%s}group' % MEDIA_NS, entry)",
            "                groups[media_thumbnail.get('group')] = group",
            "            # Add thumbnails",
            "            thumbnail = xml_elem('{%s}thumbnail' % MEDIA_NS, group)",
            "            for attr in ('url', 'height', 'width', 'time'):",
            "                if media_thumbnail.get(attr):",
            "                    thumbnail.set(attr, media_thumbnail[attr])",
            "",
            "        return entry",
            "",
            "    def extend_rss(self, item):",
            "        return self.extend_atom(item)",
            "",
            "    def content(self, content=None, replace=False, group='default', **kwargs):",
            "        '''Get or set media:content data.",
            "",
            "        This method can be called with:",
            "        - the fields of a media:content as keyword arguments",
            "        - the fields of a media:content as a dictionary",
            "        - a list of dictionaries containing the media:content fields",
            "",
            "        <media:content> is a sub-element of either <item> or <media:group>.",
            "        Media objects that are not the same content should not be included in",
            "        the same <media:group> element. The sequence of these items implies",
            "        the order of presentation. While many of the attributes appear to be",
            "        audio/video specific, this element can be used to publish any type",
            "        of media. It contains 14 attributes, most of which are optional.",
            "",
            "        media:content has the following fields:",
            "        - *url* should specify the direct URL to the media object.",
            "        - *fileSize* number of bytes of the media object.",
            "        - *type* standard MIME type of the object.",
            "        - *medium* type of object (image | audio | video | document |",
            "          executable).",
            "        - *isDefault* determines if this is the default object.",
            "        - *expression* determines if the object is a sample or the full version",
            "          of the object, or even if it is a continuous stream (sample | full |",
            "          nonstop).",
            "        - *bitrate* kilobits per second rate of media.",
            "        - *framerate* number of frames per second for the media object.",
            "        - *samplingrate* number of samples per second taken to create the media",
            "          object. It is expressed in thousands of samples per second (kHz).",
            "        - *channels* number of audio channels in the media object.",
            "        - *duration* number of seconds the media object plays.",
            "        - *height* height of the media object.",
            "        - *width* width of the media object.",
            "        - *lang* is the primary language encapsulated in the media object.",
            "",
            "        :param content: Dictionary or list of dictionaries with content data.",
            "        :param replace: Add or replace old data.",
            "        :param group: Media group to put this content in.",
            "",
            "        :returns: The media content tag.",
            "        '''",
            "        # Handle kwargs",
            "        if content is None and kwargs:",
            "            content = kwargs",
            "        # Handle new data",
            "        if content is not None:",
            "            # Reset data if we want to replace them",
            "            if replace or self.__media_content is None:",
            "                self.__media_content = []",
            "            # Ensure list",
            "            if not isinstance(content, list):",
            "                content = [content]",
            "            # define media group",
            "            for c in content:",
            "                c['group'] = c.get('group', group)",
            "            self.__media_content += ensure_format(",
            "                    content,",
            "                    set(['url', 'fileSize', 'type', 'medium', 'isDefault',",
            "                         'expression', 'bitrate', 'framerate', 'samplingrate',",
            "                         'channels', 'duration', 'height', 'width', 'lang',",
            "                         'group']),",
            "                    set(['url', 'group']))",
            "        return self.__media_content",
            "",
            "    def thumbnail(self, thumbnail=None, replace=False, group='default',",
            "                  **kwargs):",
            "        '''Get or set media:thumbnail data.",
            "",
            "        This method can be called with:",
            "        - the fields of a media:content as keyword arguments",
            "        - the fields of a media:content as a dictionary",
            "        - a list of dictionaries containing the media:content fields",
            "",
            "        Allows particular images to be used as representative images for",
            "        the media object. If multiple thumbnails are included, and time",
            "        coding is not at play, it is assumed that the images are in order",
            "        of importance. It has one required attribute and three optional",
            "        attributes.",
            "",
            "        media:thumbnail has the following fields:",
            "        - *url* should specify the direct URL to the media object.",
            "        - *height* height of the media object.",
            "        - *width* width of the media object.",
            "        - *time* specifies the time offset in relation to the media object.",
            "",
            "        :param thumbnail: Dictionary or list of dictionaries with thumbnail",
            "                          data.",
            "        :param replace: Add or replace old data.",
            "        :param group: Media group to put this content in.",
            "",
            "        :returns: The media thumbnail tag.",
            "        '''",
            "        # Handle kwargs",
            "        if thumbnail is None and kwargs:",
            "            thumbnail = kwargs",
            "        # Handle new data",
            "        if thumbnail is not None:",
            "            # Reset data if we want to replace them",
            "            if replace or self.__media_thumbnail is None:",
            "                self.__media_thumbnail = []",
            "            # Ensure list",
            "            if not isinstance(thumbnail, list):",
            "                thumbnail = [thumbnail]",
            "            # Define media group",
            "            for t in thumbnail:",
            "                t['group'] = t.get('group', group)",
            "            self.__media_thumbnail += ensure_format(",
            "                    thumbnail,",
            "                    set(['url', 'height', 'width', 'time', 'group']),",
            "                    set(['url', 'group']))",
            "        return self.__media_thumbnail"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [],
            "14": [],
            "16": [],
            "48": [
                "MediaEntryExtension",
                "extend_atom"
            ],
            "51": [
                "MediaEntryExtension",
                "extend_atom"
            ],
            "62": [
                "MediaEntryExtension",
                "extend_atom"
            ],
            "65": [
                "MediaEntryExtension",
                "extend_atom"
            ]
        },
        "addLocation": []
    }
}