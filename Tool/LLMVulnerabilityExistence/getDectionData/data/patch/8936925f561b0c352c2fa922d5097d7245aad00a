{
    "sydent/hs_federation/verifier.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from signedjson.sign import SignatureVerifyException"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from sydent.http.httpclient import FederationHttpClient"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from sydent.util.stringutils import is_valid_hostname"
            },
            "4": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "7": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     pass"
            },
            "8": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+class InvalidServerName(Exception):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    Raised when the provided origin parameter is not a valid hostname (plus optional port)."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    \"\"\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    pass"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " class Verifier(object):"
            },
            "18": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     \"\"\""
            },
            "19": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     Verifies signed json blobs from Matrix Homeservers by finding the"
            },
            "20": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "         if not json_request[\"signatures\"]:"
            },
            "21": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "             raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")"
            },
            "22": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 207,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        if not is_valid_hostname(json_request[\"origin\"]):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+            raise InvalidServerName(\"X-Matrix header's origin parameter must be a valid hostname\")"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         yield self.verifyServerSignedJson(json_request, [origin])"
            },
            "27": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 212,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         logger.info(\"Verified request from HS %s\", origin)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import logging",
            "import time",
            "",
            "from twisted.internet import defer",
            "from unpaddedbase64 import decode_base64",
            "import signedjson.sign",
            "import signedjson.key",
            "from signedjson.sign import SignatureVerifyException",
            "",
            "from sydent.http.httpclient import FederationHttpClient",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NoAuthenticationError(Exception):",
            "    \"\"\"",
            "    Raised when no signature is provided that could be authenticated",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Verifier(object):",
            "    \"\"\"",
            "    Verifies signed json blobs from Matrix Homeservers by finding the",
            "    homeserver's address, contacting it, requesting its keys and",
            "    verifying that the signature on the json blob matches.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        # Cache of server keys. These are cached until the 'valid_until_ts' time",
            "        # in the result.",
            "        self.cache = {",
            "            # server_name: <result from keys query>,",
            "        }",
            "",
            "    @defer.inlineCallbacks",
            "    def _getKeysForServer(self, server_name):",
            "        \"\"\"Get the signing key data from a homeserver.",
            "",
            "        :param server_name: The name of the server to request the keys from.",
            "        :type server_name: unicode",
            "",
            "        :return: The verification keys returned by the server.",
            "        :rtype: twisted.internet.defer.Deferred[dict[unicode, dict[unicode, unicode]]]",
            "        \"\"\"",
            "",
            "        if server_name in self.cache:",
            "            cached = self.cache[server_name]",
            "            now = int(time.time() * 1000)",
            "            if cached['valid_until_ts'] > now:",
            "                defer.returnValue(self.cache[server_name]['verify_keys'])",
            "",
            "        client = FederationHttpClient(self.sydent)",
            "        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name, 1024 * 50)",
            "        if 'verify_keys' not in result:",
            "            raise SignatureVerifyException(\"No key found in response\")",
            "",
            "        if 'valid_until_ts' in result:",
            "            # Don't cache anything without a valid_until_ts or we wouldn't",
            "            # know when to expire it.",
            "            logger.info(\"Got keys for %s: caching until %s\", server_name, result['valid_until_ts'])",
            "            self.cache[server_name] = result",
            "",
            "        defer.returnValue(result['verify_keys'])",
            "",
            "    @defer.inlineCallbacks",
            "    def verifyServerSignedJson(self, signed_json, acceptable_server_names=None):",
            "        \"\"\"Given a signed json object, try to verify any one",
            "        of the signatures on it",
            "",
            "        XXX: This contains a fairly noddy version of the home server",
            "        SRV lookup and signature verification. It does no caching (just",
            "        fetches the signature each time and does not contact any other",
            "        servers to do perspective checks).",
            "",
            "        :param acceptable_server_names: If provided and not None,",
            "        only signatures from servers in this list will be accepted.",
            "        :type acceptable_server_names: list[unicode] or None",
            "",
            "        :return a tuple of the server name and key name that was",
            "        successfully verified.",
            "        :rtype: twisted.internet.defer.Deferred[tuple[unicode]]",
            "",
            "        :raise SignatureVerifyException: The json cannot be verified.",
            "        \"\"\"",
            "        if 'signatures' not in signed_json:",
            "            raise SignatureVerifyException(\"Signature missing\")",
            "        for server_name, sigs in signed_json['signatures'].items():",
            "            if acceptable_server_names is not None:",
            "                if server_name not in acceptable_server_names:",
            "                    continue",
            "",
            "            server_keys = yield self._getKeysForServer(server_name)",
            "            for key_name, sig in sigs.items():",
            "                if key_name in server_keys:",
            "                    if 'key' not in server_keys[key_name]:",
            "                        logger.warn(\"Ignoring key %s with no 'key'\")",
            "                        continue",
            "                    key_bytes = decode_base64(server_keys[key_name]['key'])",
            "                    verify_key = signedjson.key.decode_verify_key_bytes(key_name, key_bytes)",
            "                    logger.info(\"verifying sig from key %r\", key_name)",
            "                    signedjson.sign.verify_signed_json(signed_json, server_name, verify_key)",
            "                    logger.info(\"Verified signature with key %s from %s\", key_name, server_name)",
            "                    defer.returnValue((server_name, key_name))",
            "            logger.warn(",
            "                \"No matching key found for signature block %r in server keys %r\",",
            "                signed_json['signatures'], server_keys,",
            "            )",
            "        logger.warn(",
            "            \"Unable to verify any signatures from block %r. Acceptable server names: %r\",",
            "            signed_json['signatures'], acceptable_server_names,",
            "        )",
            "        raise SignatureVerifyException(\"No matching signature found\")",
            "",
            "    @defer.inlineCallbacks",
            "    def authenticate_request(self, request, content):",
            "        \"\"\"Authenticates a Matrix federation request based on the X-Matrix header",
            "        XXX: Copied largely from synapse",
            "",
            "        :param request: The request object to authenticate",
            "        :type request: twisted.web.server.Request",
            "        :param content: The content of the request, if any",
            "        :type content: bytes or None",
            "",
            "        :return: The origin of the server whose signature was validated",
            "        :rtype: twisted.internet.defer.Deferred[unicode]",
            "        \"\"\"",
            "        json_request = {",
            "            \"method\": request.method,",
            "            \"uri\": request.uri,",
            "            \"destination_is\": self.sydent.server_name,",
            "            \"signatures\": {},",
            "        }",
            "",
            "        if content is not None:",
            "            json_request[\"content\"] = content",
            "",
            "        origin = None",
            "",
            "        def parse_auth_header(header_str):",
            "            \"\"\"",
            "            Extracts a server name, signing key and payload signature from an",
            "            authentication header.",
            "",
            "            :param header_str: The content of the header",
            "            :type header_str: unicode",
            "",
            "            :return: The server name, the signing key, and the payload signature.",
            "            :rtype: tuple[unicode]",
            "            \"\"\"",
            "            try:",
            "                params = header_str.split(u\" \")[1].split(u\",\")",
            "                param_dict = dict(kv.split(u\"=\") for kv in params)",
            "",
            "                def strip_quotes(value):",
            "                    if value.startswith(u\"\\\"\"):",
            "                        return value[1:-1]",
            "                    else:",
            "                        return value",
            "",
            "                origin = strip_quotes(param_dict[\"origin\"])",
            "                key = strip_quotes(param_dict[\"key\"])",
            "                sig = strip_quotes(param_dict[\"sig\"])",
            "                return origin, key, sig",
            "            except Exception:",
            "                raise SignatureVerifyException(\"Malformed Authorization header\")",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(u\"Authorization\")",
            "",
            "        if not auth_headers:",
            "            raise NoAuthenticationError(\"Missing Authorization headers\")",
            "",
            "        for auth in auth_headers:",
            "            if auth.startswith(u\"X-Matrix\"):",
            "                (origin, key, sig) = parse_auth_header(auth)",
            "                json_request[\"origin\"] = origin",
            "                json_request[\"signatures\"].setdefault(origin, {})[key] = sig",
            "",
            "        if not json_request[\"signatures\"]:",
            "            raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")",
            "",
            "        yield self.verifyServerSignedJson(json_request, [origin])",
            "",
            "        logger.info(\"Verified request from HS %s\", origin)",
            "",
            "        defer.returnValue(origin)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import logging",
            "import time",
            "",
            "from twisted.internet import defer",
            "from unpaddedbase64 import decode_base64",
            "import signedjson.sign",
            "import signedjson.key",
            "from signedjson.sign import SignatureVerifyException",
            "",
            "from sydent.http.httpclient import FederationHttpClient",
            "from sydent.util.stringutils import is_valid_hostname",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NoAuthenticationError(Exception):",
            "    \"\"\"",
            "    Raised when no signature is provided that could be authenticated",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class InvalidServerName(Exception):",
            "    \"\"\"",
            "    Raised when the provided origin parameter is not a valid hostname (plus optional port).",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Verifier(object):",
            "    \"\"\"",
            "    Verifies signed json blobs from Matrix Homeservers by finding the",
            "    homeserver's address, contacting it, requesting its keys and",
            "    verifying that the signature on the json blob matches.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        # Cache of server keys. These are cached until the 'valid_until_ts' time",
            "        # in the result.",
            "        self.cache = {",
            "            # server_name: <result from keys query>,",
            "        }",
            "",
            "    @defer.inlineCallbacks",
            "    def _getKeysForServer(self, server_name):",
            "        \"\"\"Get the signing key data from a homeserver.",
            "",
            "        :param server_name: The name of the server to request the keys from.",
            "        :type server_name: unicode",
            "",
            "        :return: The verification keys returned by the server.",
            "        :rtype: twisted.internet.defer.Deferred[dict[unicode, dict[unicode, unicode]]]",
            "        \"\"\"",
            "",
            "        if server_name in self.cache:",
            "            cached = self.cache[server_name]",
            "            now = int(time.time() * 1000)",
            "            if cached['valid_until_ts'] > now:",
            "                defer.returnValue(self.cache[server_name]['verify_keys'])",
            "",
            "        client = FederationHttpClient(self.sydent)",
            "        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name, 1024 * 50)",
            "        if 'verify_keys' not in result:",
            "            raise SignatureVerifyException(\"No key found in response\")",
            "",
            "        if 'valid_until_ts' in result:",
            "            # Don't cache anything without a valid_until_ts or we wouldn't",
            "            # know when to expire it.",
            "            logger.info(\"Got keys for %s: caching until %s\", server_name, result['valid_until_ts'])",
            "            self.cache[server_name] = result",
            "",
            "        defer.returnValue(result['verify_keys'])",
            "",
            "    @defer.inlineCallbacks",
            "    def verifyServerSignedJson(self, signed_json, acceptable_server_names=None):",
            "        \"\"\"Given a signed json object, try to verify any one",
            "        of the signatures on it",
            "",
            "        XXX: This contains a fairly noddy version of the home server",
            "        SRV lookup and signature verification. It does no caching (just",
            "        fetches the signature each time and does not contact any other",
            "        servers to do perspective checks).",
            "",
            "        :param acceptable_server_names: If provided and not None,",
            "        only signatures from servers in this list will be accepted.",
            "        :type acceptable_server_names: list[unicode] or None",
            "",
            "        :return a tuple of the server name and key name that was",
            "        successfully verified.",
            "        :rtype: twisted.internet.defer.Deferred[tuple[unicode]]",
            "",
            "        :raise SignatureVerifyException: The json cannot be verified.",
            "        \"\"\"",
            "        if 'signatures' not in signed_json:",
            "            raise SignatureVerifyException(\"Signature missing\")",
            "        for server_name, sigs in signed_json['signatures'].items():",
            "            if acceptable_server_names is not None:",
            "                if server_name not in acceptable_server_names:",
            "                    continue",
            "",
            "            server_keys = yield self._getKeysForServer(server_name)",
            "            for key_name, sig in sigs.items():",
            "                if key_name in server_keys:",
            "                    if 'key' not in server_keys[key_name]:",
            "                        logger.warn(\"Ignoring key %s with no 'key'\")",
            "                        continue",
            "                    key_bytes = decode_base64(server_keys[key_name]['key'])",
            "                    verify_key = signedjson.key.decode_verify_key_bytes(key_name, key_bytes)",
            "                    logger.info(\"verifying sig from key %r\", key_name)",
            "                    signedjson.sign.verify_signed_json(signed_json, server_name, verify_key)",
            "                    logger.info(\"Verified signature with key %s from %s\", key_name, server_name)",
            "                    defer.returnValue((server_name, key_name))",
            "            logger.warn(",
            "                \"No matching key found for signature block %r in server keys %r\",",
            "                signed_json['signatures'], server_keys,",
            "            )",
            "        logger.warn(",
            "            \"Unable to verify any signatures from block %r. Acceptable server names: %r\",",
            "            signed_json['signatures'], acceptable_server_names,",
            "        )",
            "        raise SignatureVerifyException(\"No matching signature found\")",
            "",
            "    @defer.inlineCallbacks",
            "    def authenticate_request(self, request, content):",
            "        \"\"\"Authenticates a Matrix federation request based on the X-Matrix header",
            "        XXX: Copied largely from synapse",
            "",
            "        :param request: The request object to authenticate",
            "        :type request: twisted.web.server.Request",
            "        :param content: The content of the request, if any",
            "        :type content: bytes or None",
            "",
            "        :return: The origin of the server whose signature was validated",
            "        :rtype: twisted.internet.defer.Deferred[unicode]",
            "        \"\"\"",
            "        json_request = {",
            "            \"method\": request.method,",
            "            \"uri\": request.uri,",
            "            \"destination_is\": self.sydent.server_name,",
            "            \"signatures\": {},",
            "        }",
            "",
            "        if content is not None:",
            "            json_request[\"content\"] = content",
            "",
            "        origin = None",
            "",
            "        def parse_auth_header(header_str):",
            "            \"\"\"",
            "            Extracts a server name, signing key and payload signature from an",
            "            authentication header.",
            "",
            "            :param header_str: The content of the header",
            "            :type header_str: unicode",
            "",
            "            :return: The server name, the signing key, and the payload signature.",
            "            :rtype: tuple[unicode]",
            "            \"\"\"",
            "            try:",
            "                params = header_str.split(u\" \")[1].split(u\",\")",
            "                param_dict = dict(kv.split(u\"=\") for kv in params)",
            "",
            "                def strip_quotes(value):",
            "                    if value.startswith(u\"\\\"\"):",
            "                        return value[1:-1]",
            "                    else:",
            "                        return value",
            "",
            "                origin = strip_quotes(param_dict[\"origin\"])",
            "                key = strip_quotes(param_dict[\"key\"])",
            "                sig = strip_quotes(param_dict[\"sig\"])",
            "                return origin, key, sig",
            "            except Exception:",
            "                raise SignatureVerifyException(\"Malformed Authorization header\")",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(u\"Authorization\")",
            "",
            "        if not auth_headers:",
            "            raise NoAuthenticationError(\"Missing Authorization headers\")",
            "",
            "        for auth in auth_headers:",
            "            if auth.startswith(u\"X-Matrix\"):",
            "                (origin, key, sig) = parse_auth_header(auth)",
            "                json_request[\"origin\"] = origin",
            "                json_request[\"signatures\"].setdefault(origin, {})[key] = sig",
            "",
            "        if not json_request[\"signatures\"]:",
            "            raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")",
            "",
            "        if not is_valid_hostname(json_request[\"origin\"]):",
            "            raise InvalidServerName(\"X-Matrix header's origin parameter must be a valid hostname\")",
            "",
            "        yield self.verifyServerSignedJson(json_request, [origin])",
            "",
            "        logger.info(\"Verified request from HS %s\", origin)",
            "",
            "        defer.returnValue(origin)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "sydent.hs_federation.verifier.Verifier.authenticate_request.json_request",
            "sydent.hs_federation.verifier.Verifier.verifyServerSignedJson.signed_json",
            "sydent.hs_federation.verifier.Verifier.verifyServerSignedJson.acceptable_server_names",
            "web.pgadmin.tools.import_export.create_import_export_job"
        ]
    },
    "sydent/http/servlets/threepidunbindservlet.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import logging"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sydent.hs_federation.verifier import NoAuthenticationError"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from sydent.hs_federation.verifier import NoAuthenticationError, InvalidServerName"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from signedjson.sign import SignatureVerifyException"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from sydent.http.servlets import dict_to_json_bytes"
            },
            "8": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "             # and \"client_secret\" fields, they are trying to prove that they"
            },
            "9": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             # were the original author of the bind. We then check that what"
            },
            "10": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "             # they supply matches and if it does, allow the unbind."
            },
            "11": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            #"
            },
            "13": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             # However if these fields are not supplied, we instead check"
            },
            "14": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "             # whether the request originated from a homeserver, and if so the"
            },
            "15": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             # same homeserver that originally created the bind. We do this by"
            },
            "16": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "                         'error': \"This validation session has not yet been completed\""
            },
            "17": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "                     }))"
            },
            "18": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "                     return"
            },
            "19": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                "
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "                 if s.medium != threepid['medium'] or s.address != threepid['address']:"
            },
            "22": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "                     request.setResponseCode(403)"
            },
            "23": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "                     request.write(dict_to_json_bytes({"
            },
            "24": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "                     request.write(dict_to_json_bytes({'errcode': 'M_FORBIDDEN', 'error': str(ex)}))"
            },
            "25": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "                     request.finish()"
            },
            "26": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "                     return"
            },
            "27": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+                except InvalidServerName as ex:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+                    request.setResponseCode(400)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+                    request.write(dict_to_json_bytes({'errcode': 'M_INVALID_PARAM', 'error': str(ex)}))"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                    request.finish()"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+                    return"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+                except Exception:"
            },
            "34": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "                     logger.exception(\"Exception whilst authenticating unbind request\")"
            },
            "35": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "                     request.setResponseCode(500)"
            },
            "36": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "                     request.write(dict_to_json_bytes({'errcode': 'M_UNKNOWN', 'error': 'Internal Server Error'}))"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import json",
            "import logging",
            "",
            "from sydent.hs_federation.verifier import NoAuthenticationError",
            "from signedjson.sign import SignatureVerifyException",
            "",
            "from sydent.http.servlets import dict_to_json_bytes",
            "from sydent.db.valsession import ThreePidValSessionStore",
            "from sydent.util.stringutils import is_valid_client_secret",
            "from sydent.validators import (",
            "    IncorrectClientSecretException,",
            "    InvalidSessionIdException,",
            "    SessionNotValidatedException,",
            ")",
            "",
            "from twisted.web.resource import Resource",
            "from twisted.web import server",
            "from twisted.internet import defer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ThreePidUnbindServlet(Resource):",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "    def render_POST(self, request):",
            "        self._async_render_POST(request)",
            "        return server.NOT_DONE_YET",
            "",
            "    @defer.inlineCallbacks",
            "    def _async_render_POST(self, request):",
            "        try:",
            "            try:",
            "                # json.loads doesn't allow bytes in Python 3.5",
            "                body = json.loads(request.content.read().decode(\"UTF-8\"))",
            "            except ValueError:",
            "                request.setResponseCode(400)",
            "                request.write(dict_to_json_bytes({'errcode': 'M_BAD_JSON', 'error': 'Malformed JSON'}))",
            "                request.finish()",
            "                return",
            "",
            "            missing = [k for k in (\"threepid\", \"mxid\") if k not in body]",
            "            if len(missing) > 0:",
            "                request.setResponseCode(400)",
            "                msg = \"Missing parameters: \"+(\",\".join(missing))",
            "                request.write(dict_to_json_bytes({'errcode': 'M_MISSING_PARAMS', 'error': msg}))",
            "                request.finish()",
            "                return",
            "",
            "            threepid = body['threepid']",
            "            mxid = body['mxid']",
            "",
            "            if 'medium' not in threepid or 'address' not in threepid:",
            "                request.setResponseCode(400)",
            "                request.write(dict_to_json_bytes({'errcode': 'M_MISSING_PARAMS', 'error': 'Threepid lacks medium / address'}))",
            "                request.finish()",
            "                return",
            "",
            "            # We now check for authentication in two different ways, depending",
            "            # on the contents of the request. If the user has supplied \"sid\"",
            "            # (the Session ID returned by Sydent during the original binding)",
            "            # and \"client_secret\" fields, they are trying to prove that they",
            "            # were the original author of the bind. We then check that what",
            "            # they supply matches and if it does, allow the unbind.",
            "            # ",
            "            # However if these fields are not supplied, we instead check",
            "            # whether the request originated from a homeserver, and if so the",
            "            # same homeserver that originally created the bind. We do this by",
            "            # checking the signature of the request. If it all matches up, we",
            "            # allow the unbind.",
            "            #",
            "            # Only one method of authentication is required.",
            "            if 'sid' in body and 'client_secret' in body:",
            "                sid = body['sid']",
            "                client_secret = body['client_secret']",
            "",
            "                if not is_valid_client_secret(client_secret):",
            "                    request.setResponseCode(400)",
            "                    request.write(dict_to_json_bytes({",
            "                        'errcode': 'M_INVALID_PARAM',",
            "                        'error': 'Invalid client_secret provided'",
            "                    }))",
            "                    request.finish()",
            "                    return",
            "",
            "                valSessionStore = ThreePidValSessionStore(self.sydent)",
            "",
            "                try:",
            "                    s = valSessionStore.getValidatedSession(sid, client_secret)",
            "                except (IncorrectClientSecretException, InvalidSessionIdException):",
            "                    request.setResponseCode(401)",
            "                    request.write(dict_to_json_bytes({",
            "                        'errcode': 'M_NO_VALID_SESSION',",
            "                        'error': \"No valid session was found matching that sid and client secret\"",
            "                    }))",
            "                    request.finish()",
            "                    return",
            "                except SessionNotValidatedException:",
            "                    request.setResponseCode(403)",
            "                    request.write(dict_to_json_bytes({",
            "                        'errcode': 'M_SESSION_NOT_VALIDATED',",
            "                        'error': \"This validation session has not yet been completed\"",
            "                    }))",
            "                    return",
            "                ",
            "                if s.medium != threepid['medium'] or s.address != threepid['address']:",
            "                    request.setResponseCode(403)",
            "                    request.write(dict_to_json_bytes({",
            "                        'errcode': 'M_FORBIDDEN',",
            "                        'error': 'Provided session information does not match medium/address combo',",
            "                    }))",
            "                    request.finish()",
            "                    return",
            "            else:",
            "                try:",
            "                    origin_server_name = yield self.sydent.sig_verifier.authenticate_request(request, body)",
            "                except SignatureVerifyException as ex:",
            "                    request.setResponseCode(401)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_FORBIDDEN', 'error': str(ex)}))",
            "                    request.finish()",
            "                    return",
            "                except NoAuthenticationError as ex:",
            "                    request.setResponseCode(401)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_FORBIDDEN', 'error': str(ex)}))",
            "                    request.finish()",
            "                    return",
            "                except:",
            "                    logger.exception(\"Exception whilst authenticating unbind request\")",
            "                    request.setResponseCode(500)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_UNKNOWN', 'error': 'Internal Server Error'}))",
            "                    request.finish()",
            "                    return",
            "",
            "                if not mxid.endswith(':' + origin_server_name):",
            "                    request.setResponseCode(403)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_FORBIDDEN', 'error': 'Origin server name does not match mxid'}))",
            "                    request.finish()",
            "                    return",
            "",
            "            self.sydent.threepidBinder.removeBinding(threepid, mxid)",
            "",
            "            request.write(dict_to_json_bytes({}))",
            "            request.finish()",
            "        except Exception as ex:",
            "            logger.exception(\"Exception whilst handling unbind\")",
            "            request.setResponseCode(500)",
            "            request.write(dict_to_json_bytes({'errcode': 'M_UNKNOWN', 'error': str(ex)}))",
            "            request.finish()"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import json",
            "import logging",
            "",
            "from sydent.hs_federation.verifier import NoAuthenticationError, InvalidServerName",
            "from signedjson.sign import SignatureVerifyException",
            "",
            "from sydent.http.servlets import dict_to_json_bytes",
            "from sydent.db.valsession import ThreePidValSessionStore",
            "from sydent.util.stringutils import is_valid_client_secret",
            "from sydent.validators import (",
            "    IncorrectClientSecretException,",
            "    InvalidSessionIdException,",
            "    SessionNotValidatedException,",
            ")",
            "",
            "from twisted.web.resource import Resource",
            "from twisted.web import server",
            "from twisted.internet import defer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ThreePidUnbindServlet(Resource):",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "    def render_POST(self, request):",
            "        self._async_render_POST(request)",
            "        return server.NOT_DONE_YET",
            "",
            "    @defer.inlineCallbacks",
            "    def _async_render_POST(self, request):",
            "        try:",
            "            try:",
            "                # json.loads doesn't allow bytes in Python 3.5",
            "                body = json.loads(request.content.read().decode(\"UTF-8\"))",
            "            except ValueError:",
            "                request.setResponseCode(400)",
            "                request.write(dict_to_json_bytes({'errcode': 'M_BAD_JSON', 'error': 'Malformed JSON'}))",
            "                request.finish()",
            "                return",
            "",
            "            missing = [k for k in (\"threepid\", \"mxid\") if k not in body]",
            "            if len(missing) > 0:",
            "                request.setResponseCode(400)",
            "                msg = \"Missing parameters: \"+(\",\".join(missing))",
            "                request.write(dict_to_json_bytes({'errcode': 'M_MISSING_PARAMS', 'error': msg}))",
            "                request.finish()",
            "                return",
            "",
            "            threepid = body['threepid']",
            "            mxid = body['mxid']",
            "",
            "            if 'medium' not in threepid or 'address' not in threepid:",
            "                request.setResponseCode(400)",
            "                request.write(dict_to_json_bytes({'errcode': 'M_MISSING_PARAMS', 'error': 'Threepid lacks medium / address'}))",
            "                request.finish()",
            "                return",
            "",
            "            # We now check for authentication in two different ways, depending",
            "            # on the contents of the request. If the user has supplied \"sid\"",
            "            # (the Session ID returned by Sydent during the original binding)",
            "            # and \"client_secret\" fields, they are trying to prove that they",
            "            # were the original author of the bind. We then check that what",
            "            # they supply matches and if it does, allow the unbind.",
            "            #",
            "            # However if these fields are not supplied, we instead check",
            "            # whether the request originated from a homeserver, and if so the",
            "            # same homeserver that originally created the bind. We do this by",
            "            # checking the signature of the request. If it all matches up, we",
            "            # allow the unbind.",
            "            #",
            "            # Only one method of authentication is required.",
            "            if 'sid' in body and 'client_secret' in body:",
            "                sid = body['sid']",
            "                client_secret = body['client_secret']",
            "",
            "                if not is_valid_client_secret(client_secret):",
            "                    request.setResponseCode(400)",
            "                    request.write(dict_to_json_bytes({",
            "                        'errcode': 'M_INVALID_PARAM',",
            "                        'error': 'Invalid client_secret provided'",
            "                    }))",
            "                    request.finish()",
            "                    return",
            "",
            "                valSessionStore = ThreePidValSessionStore(self.sydent)",
            "",
            "                try:",
            "                    s = valSessionStore.getValidatedSession(sid, client_secret)",
            "                except (IncorrectClientSecretException, InvalidSessionIdException):",
            "                    request.setResponseCode(401)",
            "                    request.write(dict_to_json_bytes({",
            "                        'errcode': 'M_NO_VALID_SESSION',",
            "                        'error': \"No valid session was found matching that sid and client secret\"",
            "                    }))",
            "                    request.finish()",
            "                    return",
            "                except SessionNotValidatedException:",
            "                    request.setResponseCode(403)",
            "                    request.write(dict_to_json_bytes({",
            "                        'errcode': 'M_SESSION_NOT_VALIDATED',",
            "                        'error': \"This validation session has not yet been completed\"",
            "                    }))",
            "                    return",
            "",
            "                if s.medium != threepid['medium'] or s.address != threepid['address']:",
            "                    request.setResponseCode(403)",
            "                    request.write(dict_to_json_bytes({",
            "                        'errcode': 'M_FORBIDDEN',",
            "                        'error': 'Provided session information does not match medium/address combo',",
            "                    }))",
            "                    request.finish()",
            "                    return",
            "            else:",
            "                try:",
            "                    origin_server_name = yield self.sydent.sig_verifier.authenticate_request(request, body)",
            "                except SignatureVerifyException as ex:",
            "                    request.setResponseCode(401)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_FORBIDDEN', 'error': str(ex)}))",
            "                    request.finish()",
            "                    return",
            "                except NoAuthenticationError as ex:",
            "                    request.setResponseCode(401)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_FORBIDDEN', 'error': str(ex)}))",
            "                    request.finish()",
            "                    return",
            "                except InvalidServerName as ex:",
            "                    request.setResponseCode(400)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_INVALID_PARAM', 'error': str(ex)}))",
            "                    request.finish()",
            "                    return",
            "                except Exception:",
            "                    logger.exception(\"Exception whilst authenticating unbind request\")",
            "                    request.setResponseCode(500)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_UNKNOWN', 'error': 'Internal Server Error'}))",
            "                    request.finish()",
            "                    return",
            "",
            "                if not mxid.endswith(':' + origin_server_name):",
            "                    request.setResponseCode(403)",
            "                    request.write(dict_to_json_bytes({'errcode': 'M_FORBIDDEN', 'error': 'Origin server name does not match mxid'}))",
            "                    request.finish()",
            "                    return",
            "",
            "            self.sydent.threepidBinder.removeBinding(threepid, mxid)",
            "",
            "            request.write(dict_to_json_bytes({}))",
            "            request.finish()",
            "        except Exception as ex:",
            "            logger.exception(\"Exception whilst handling unbind\")",
            "            request.setResponseCode(500)",
            "            request.write(dict_to_json_bytes({'errcode': 'M_UNKNOWN', 'error': str(ex)}))",
            "            request.finish()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [],
            "84": [
                "ThreePidUnbindServlet",
                "_async_render_POST"
            ],
            "124": [
                "ThreePidUnbindServlet",
                "_async_render_POST"
            ],
            "146": [
                "ThreePidUnbindServlet",
                "_async_render_POST"
            ]
        },
        "addLocation": []
    },
    "sydent/threepid/bind.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from sydent.threepid import ThreepidAssociation"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+from sydent.util.stringutils import is_valid_hostname"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " from twisted.internet import defer"
            },
            "6": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "8": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         mxid = assoc[\"mxid\"]"
            },
            "10": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         mxid_parts = mxid.split(\":\", 1)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         if len(mxid_parts) != 2:"
            },
            "13": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "             logger.error("
            },
            "14": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "                 \"Can't notify on bind for unparseable mxid %s. Not retrying.\","
            },
            "15": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "                 assoc[\"mxid\"],"
            },
            "16": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "             )"
            },
            "17": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             return"
            },
            "18": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        matrix_server = mxid_parts[1]"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        if not is_valid_hostname(matrix_server):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            logger.error("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+                \"MXID server part '%s' not a valid hostname. Not retrying.\","
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                matrix_server,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            )"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            return"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         post_url = \"matrix://%s/_matrix/federation/v1/3pid/onbind\" % ("
            },
            "29": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mxid_parts[1],"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            matrix_server,"
            },
            "31": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         )"
            },
            "32": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         logger.info(\"Making bind callback to: %s\", post_url)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import collections",
            "import logging",
            "import math",
            "import signedjson.sign",
            "from sydent.db.invite_tokens import JoinTokenStore",
            "",
            "from sydent.db.threepid_associations import LocalAssociationStore",
            "",
            "from sydent.util import time_msec",
            "from sydent.util.hash import sha256_and_url_safe_base64",
            "from sydent.db.hashing_metadata import HashingMetadataStore",
            "from sydent.threepid.signer import Signer",
            "from sydent.http.httpclient import FederationHttpClient",
            "",
            "from sydent.threepid import ThreepidAssociation",
            "",
            "from twisted.internet import defer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ThreepidBinder:",
            "    # the lifetime of a 3pid association",
            "    THREEPID_ASSOCIATION_LIFETIME_MS = 100 * 365 * 24 * 60 * 60 * 1000",
            "",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        self.hashing_store = HashingMetadataStore(sydent)",
            "",
            "    def addBinding(self, medium, address, mxid):",
            "        \"\"\"",
            "        Binds the given 3pid to the given mxid.",
            "",
            "        It's assumed that we have somehow validated that the given user owns",
            "        the given 3pid",
            "",
            "        :param medium: The medium of the 3PID to bind.",
            "        :type medium: unicode",
            "        :param address: The address of the 3PID to bind.",
            "        :type address: unicode",
            "        :param mxid: The MXID to bind the 3PID to.",
            "        :type mxid: unicode",
            "",
            "        :return: The signed association.",
            "        :rtype: dict[str, any]",
            "        \"\"\"",
            "        localAssocStore = LocalAssociationStore(self.sydent)",
            "",
            "        # Fill out the association details",
            "        createdAt = time_msec()",
            "        expires = createdAt + ThreepidBinder.THREEPID_ASSOCIATION_LIFETIME_MS",
            "",
            "        # Hash the medium + address and store that hash for the purposes of",
            "        # later lookups",
            "        str_to_hash = u' '.join(",
            "            [address, medium, self.hashing_store.get_lookup_pepper()],",
            "        )",
            "        lookup_hash = sha256_and_url_safe_base64(str_to_hash)",
            "",
            "        assoc = ThreepidAssociation(",
            "            medium, address, lookup_hash, mxid, createdAt, createdAt, expires,",
            "        )",
            "",
            "        localAssocStore.addOrUpdateAssociation(assoc)",
            "",
            "        self.sydent.pusher.doLocalPush()",
            "",
            "        joinTokenStore = JoinTokenStore(self.sydent)",
            "        pendingJoinTokens = joinTokenStore.getTokens(medium, address)",
            "        invites = []",
            "        for token in pendingJoinTokens:",
            "            token[\"mxid\"] = mxid",
            "            token[\"signed\"] = {",
            "                \"mxid\": mxid,",
            "                \"token\": token[\"token\"],",
            "            }",
            "            token[\"signed\"] = signedjson.sign.sign_json(token[\"signed\"], self.sydent.server_name, self.sydent.keyring.ed25519)",
            "            invites.append(token)",
            "        if invites:",
            "            assoc.extra_fields[\"invites\"] = invites",
            "            joinTokenStore.markTokensAsSent(medium, address)",
            "",
            "        signer = Signer(self.sydent)",
            "        sgassoc = signer.signedThreePidAssociation(assoc)",
            "",
            "        self._notify(sgassoc, 0)",
            "",
            "        return sgassoc",
            "",
            "    def removeBinding(self, threepid, mxid):",
            "        \"\"\"",
            "        Removes the binding between a given 3PID and a given MXID.",
            "",
            "        :param threepid: The 3PID of the binding to remove.",
            "        :type threepid: dict[unicode, unicode]",
            "        :param mxid: The MXID of the binding to remove.",
            "        :type mxid: unicode",
            "        \"\"\"",
            "        localAssocStore = LocalAssociationStore(self.sydent)",
            "        localAssocStore.removeAssociation(threepid, mxid)",
            "        self.sydent.pusher.doLocalPush()",
            "",
            "    @defer.inlineCallbacks",
            "    def _notify(self, assoc, attempt):",
            "        \"\"\"",
            "        Sends data about a new association (and, if necessary, the associated invites)",
            "        to the associated MXID's homeserver.",
            "",
            "        :param assoc: The association to send down to the homeserver.",
            "        :type assoc: dict[str, any]",
            "        :param attempt: The number of previous attempts to send this association.",
            "        :type attempt: int",
            "        \"\"\"",
            "        mxid = assoc[\"mxid\"]",
            "        mxid_parts = mxid.split(\":\", 1)",
            "        if len(mxid_parts) != 2:",
            "            logger.error(",
            "                \"Can't notify on bind for unparseable mxid %s. Not retrying.\",",
            "                assoc[\"mxid\"],",
            "            )",
            "            return",
            "",
            "        post_url = \"matrix://%s/_matrix/federation/v1/3pid/onbind\" % (",
            "            mxid_parts[1],",
            "        )",
            "",
            "        logger.info(\"Making bind callback to: %s\", post_url)",
            "",
            "        # Make a POST to the chosen Synapse server",
            "        http_client = FederationHttpClient(self.sydent)",
            "        try:",
            "            response = yield http_client.post_json_get_nothing(post_url, assoc, {})",
            "        except Exception as e:",
            "            self._notifyErrback(assoc, attempt, e)",
            "            return",
            "",
            "        # If the request failed, try again with exponential backoff",
            "        if response.code != 200:",
            "            self._notifyErrback(",
            "                assoc, attempt, \"Non-OK error code received (%d)\" % response.code",
            "            )",
            "        else:",
            "            logger.info(\"Successfully notified on bind for %s\" % (mxid,))",
            "",
            "            # Skip the deletion step if instructed so by the config.",
            "            if not self.sydent.delete_tokens_on_bind:",
            "                return",
            "",
            "            # Only remove sent tokens when they've been successfully sent.",
            "            try:",
            "                joinTokenStore = JoinTokenStore(self.sydent)",
            "                joinTokenStore.deleteTokens(assoc[\"medium\"], assoc[\"address\"])",
            "                logger.info(",
            "                    \"Successfully deleted invite for %s from the store\",",
            "                    assoc[\"address\"],",
            "                )",
            "            except Exception as e:",
            "                logger.exception(",
            "                    \"Couldn't remove invite for %s from the store\",",
            "                    assoc[\"address\"],",
            "                )",
            "",
            "    def _notifyErrback(self, assoc, attempt, error):",
            "        \"\"\"",
            "        Handles errors when trying to send an association down to a homeserver by",
            "        logging the error and scheduling a new attempt.",
            "",
            "        :param assoc: The association to send down to the homeserver.",
            "        :type assoc: dict[str, any]",
            "        :param attempt: The number of previous attempts to send this association.",
            "        :type attempt: int",
            "        :param error: The error that was raised when trying to send the association.",
            "        :type error: Exception",
            "        \"\"\"",
            "        logger.warning(",
            "            \"Error notifying on bind for %s: %s - rescheduling\", assoc[\"mxid\"], error",
            "        )",
            "        self.sydent.reactor.callLater(",
            "            math.pow(2, attempt), self._notify, assoc, attempt + 1",
            "        )",
            "",
            "    # The below is lovingly ripped off of synapse/http/endpoint.py",
            "",
            "    _Server = collections.namedtuple(\"_Server\", \"priority weight host port\")"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import collections",
            "import logging",
            "import math",
            "import signedjson.sign",
            "from sydent.db.invite_tokens import JoinTokenStore",
            "",
            "from sydent.db.threepid_associations import LocalAssociationStore",
            "",
            "from sydent.util import time_msec",
            "from sydent.util.hash import sha256_and_url_safe_base64",
            "from sydent.db.hashing_metadata import HashingMetadataStore",
            "from sydent.threepid.signer import Signer",
            "from sydent.http.httpclient import FederationHttpClient",
            "",
            "from sydent.threepid import ThreepidAssociation",
            "",
            "from sydent.util.stringutils import is_valid_hostname",
            "",
            "from twisted.internet import defer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ThreepidBinder:",
            "    # the lifetime of a 3pid association",
            "    THREEPID_ASSOCIATION_LIFETIME_MS = 100 * 365 * 24 * 60 * 60 * 1000",
            "",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        self.hashing_store = HashingMetadataStore(sydent)",
            "",
            "    def addBinding(self, medium, address, mxid):",
            "        \"\"\"",
            "        Binds the given 3pid to the given mxid.",
            "",
            "        It's assumed that we have somehow validated that the given user owns",
            "        the given 3pid",
            "",
            "        :param medium: The medium of the 3PID to bind.",
            "        :type medium: unicode",
            "        :param address: The address of the 3PID to bind.",
            "        :type address: unicode",
            "        :param mxid: The MXID to bind the 3PID to.",
            "        :type mxid: unicode",
            "",
            "        :return: The signed association.",
            "        :rtype: dict[str, any]",
            "        \"\"\"",
            "        localAssocStore = LocalAssociationStore(self.sydent)",
            "",
            "        # Fill out the association details",
            "        createdAt = time_msec()",
            "        expires = createdAt + ThreepidBinder.THREEPID_ASSOCIATION_LIFETIME_MS",
            "",
            "        # Hash the medium + address and store that hash for the purposes of",
            "        # later lookups",
            "        str_to_hash = u' '.join(",
            "            [address, medium, self.hashing_store.get_lookup_pepper()],",
            "        )",
            "        lookup_hash = sha256_and_url_safe_base64(str_to_hash)",
            "",
            "        assoc = ThreepidAssociation(",
            "            medium, address, lookup_hash, mxid, createdAt, createdAt, expires,",
            "        )",
            "",
            "        localAssocStore.addOrUpdateAssociation(assoc)",
            "",
            "        self.sydent.pusher.doLocalPush()",
            "",
            "        joinTokenStore = JoinTokenStore(self.sydent)",
            "        pendingJoinTokens = joinTokenStore.getTokens(medium, address)",
            "        invites = []",
            "        for token in pendingJoinTokens:",
            "            token[\"mxid\"] = mxid",
            "            token[\"signed\"] = {",
            "                \"mxid\": mxid,",
            "                \"token\": token[\"token\"],",
            "            }",
            "            token[\"signed\"] = signedjson.sign.sign_json(token[\"signed\"], self.sydent.server_name, self.sydent.keyring.ed25519)",
            "            invites.append(token)",
            "        if invites:",
            "            assoc.extra_fields[\"invites\"] = invites",
            "            joinTokenStore.markTokensAsSent(medium, address)",
            "",
            "        signer = Signer(self.sydent)",
            "        sgassoc = signer.signedThreePidAssociation(assoc)",
            "",
            "        self._notify(sgassoc, 0)",
            "",
            "        return sgassoc",
            "",
            "    def removeBinding(self, threepid, mxid):",
            "        \"\"\"",
            "        Removes the binding between a given 3PID and a given MXID.",
            "",
            "        :param threepid: The 3PID of the binding to remove.",
            "        :type threepid: dict[unicode, unicode]",
            "        :param mxid: The MXID of the binding to remove.",
            "        :type mxid: unicode",
            "        \"\"\"",
            "        localAssocStore = LocalAssociationStore(self.sydent)",
            "        localAssocStore.removeAssociation(threepid, mxid)",
            "        self.sydent.pusher.doLocalPush()",
            "",
            "    @defer.inlineCallbacks",
            "    def _notify(self, assoc, attempt):",
            "        \"\"\"",
            "        Sends data about a new association (and, if necessary, the associated invites)",
            "        to the associated MXID's homeserver.",
            "",
            "        :param assoc: The association to send down to the homeserver.",
            "        :type assoc: dict[str, any]",
            "        :param attempt: The number of previous attempts to send this association.",
            "        :type attempt: int",
            "        \"\"\"",
            "        mxid = assoc[\"mxid\"]",
            "        mxid_parts = mxid.split(\":\", 1)",
            "",
            "        if len(mxid_parts) != 2:",
            "            logger.error(",
            "                \"Can't notify on bind for unparseable mxid %s. Not retrying.\",",
            "                assoc[\"mxid\"],",
            "            )",
            "            return",
            "",
            "        matrix_server = mxid_parts[1]",
            "",
            "        if not is_valid_hostname(matrix_server):",
            "            logger.error(",
            "                \"MXID server part '%s' not a valid hostname. Not retrying.\",",
            "                matrix_server,",
            "            )",
            "            return",
            "",
            "        post_url = \"matrix://%s/_matrix/federation/v1/3pid/onbind\" % (",
            "            matrix_server,",
            "        )",
            "",
            "        logger.info(\"Making bind callback to: %s\", post_url)",
            "",
            "        # Make a POST to the chosen Synapse server",
            "        http_client = FederationHttpClient(self.sydent)",
            "        try:",
            "            response = yield http_client.post_json_get_nothing(post_url, assoc, {})",
            "        except Exception as e:",
            "            self._notifyErrback(assoc, attempt, e)",
            "            return",
            "",
            "        # If the request failed, try again with exponential backoff",
            "        if response.code != 200:",
            "            self._notifyErrback(",
            "                assoc, attempt, \"Non-OK error code received (%d)\" % response.code",
            "            )",
            "        else:",
            "            logger.info(\"Successfully notified on bind for %s\" % (mxid,))",
            "",
            "            # Skip the deletion step if instructed so by the config.",
            "            if not self.sydent.delete_tokens_on_bind:",
            "                return",
            "",
            "            # Only remove sent tokens when they've been successfully sent.",
            "            try:",
            "                joinTokenStore = JoinTokenStore(self.sydent)",
            "                joinTokenStore.deleteTokens(assoc[\"medium\"], assoc[\"address\"])",
            "                logger.info(",
            "                    \"Successfully deleted invite for %s from the store\",",
            "                    assoc[\"address\"],",
            "                )",
            "            except Exception as e:",
            "                logger.exception(",
            "                    \"Couldn't remove invite for %s from the store\",",
            "                    assoc[\"address\"],",
            "                )",
            "",
            "    def _notifyErrback(self, assoc, attempt, error):",
            "        \"\"\"",
            "        Handles errors when trying to send an association down to a homeserver by",
            "        logging the error and scheduling a new attempt.",
            "",
            "        :param assoc: The association to send down to the homeserver.",
            "        :type assoc: dict[str, any]",
            "        :param attempt: The number of previous attempts to send this association.",
            "        :type attempt: int",
            "        :param error: The error that was raised when trying to send the association.",
            "        :type error: Exception",
            "        \"\"\"",
            "        logger.warning(",
            "            \"Error notifying on bind for %s: %s - rescheduling\", assoc[\"mxid\"], error",
            "        )",
            "        self.sydent.reactor.callLater(",
            "            math.pow(2, attempt), self._notify, assoc, attempt + 1",
            "        )",
            "",
            "    # The below is lovingly ripped off of synapse/http/endpoint.py",
            "",
            "    _Server = collections.namedtuple(\"_Server\", \"priority weight host port\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "142": [
                "ThreepidBinder",
                "_notify"
            ]
        },
        "addLocation": [
            "web.pgadmin.tools.import_export.create_import_export_job",
            "sydent.threepid.bind.ThreepidBinder.addBinding"
        ]
    }
}