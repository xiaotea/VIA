{
    "pydantic/networks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "         return cls(__input_value)  # type: ignore[return-value]"
            },
            "1": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 417,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 418,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def _build_pretty_email_regex() -> re.Pattern:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+def _build_pretty_email_regex() -> re.Pattern[str]:"
            },
            "5": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 420,
                "PatchRowcode": "     name_chars = r'[\\w!#$%&\\'*+\\-/=?^_`{|}~]'"
            },
            "6": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": 421,
                "PatchRowcode": "     unquoted_name_group = fr'((?:{name_chars}+\\s+)*{name_chars}+)'"
            },
            "7": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 422,
                "PatchRowcode": "     quoted_name_group = r'\"((?:[^\"]|\\\")+)\"'"
            },
            "8": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    email_group = r'<\\s*(.+)\\s*>'"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+    email_group = r'<\\s*(.{0,254})\\s*>'"
            },
            "10": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 424,
                "PatchRowcode": "     return re.compile(rf'\\s*(?:{unquoted_name_group}|{quoted_name_group})?\\s*{email_group}\\s*')"
            },
            "11": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": 425,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": 426,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 427,
                "PatchRowcode": " pretty_email_regex = _build_pretty_email_regex()"
            },
            "14": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 428,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+MAX_EMAIL_LENGTH = 2048"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 430,
                "PatchRowcode": "+\"\"\"Maximum length for an email."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 431,
                "PatchRowcode": "+A somewhat arbitrary but very generous number compared to what is allowed by most implementations."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 432,
                "PatchRowcode": "+\"\"\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 433,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": 434,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": 435,
                "PatchRowcode": " def validate_email(value: str) -> tuple[str, str]:"
            },
            "22": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "     \"\"\"Email address validation using [email-validator](https://pypi.org/project/email-validator/)."
            },
            "23": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 445,
                "PatchRowcode": "     if email_validator is None:"
            },
            "24": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "         import_email_validator()"
            },
            "25": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 447,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 448,
                "PatchRowcode": "+    if len(value) > MAX_EMAIL_LENGTH:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+        raise PydanticCustomError("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+            'value_error',"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+            'value is not a valid email address: {reason}',"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+            {'reason': f'Length must not exceed {MAX_EMAIL_LENGTH} characters'},"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+        )"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 455,
                "PatchRowcode": "     m = pretty_email_regex.fullmatch(value)"
            },
            "34": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "     name: str | None = None"
            },
            "35": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 457,
                "PatchRowcode": "     if m:"
            }
        },
        "frontPatchFile": [
            "\"\"\"The networks module contains types for common network-related fields.\"\"\"",
            "from __future__ import annotations as _annotations",
            "",
            "import dataclasses as _dataclasses",
            "import re",
            "from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network",
            "from typing import TYPE_CHECKING, Any",
            "",
            "from pydantic_core import MultiHostUrl, PydanticCustomError, Url, core_schema",
            "from typing_extensions import Annotated, TypeAlias",
            "",
            "from ._internal import _annotated_handlers, _fields, _repr, _schema_generation_shared",
            "from ._migration import getattr_migration",
            "from .json_schema import JsonSchemaValue",
            "",
            "if TYPE_CHECKING:",
            "    import email_validator",
            "",
            "    NetworkType: TypeAlias = 'str | bytes | int | tuple[str | bytes | int, str | int]'",
            "",
            "else:",
            "    email_validator = None",
            "",
            "",
            "__all__ = [",
            "    'AnyUrl',",
            "    'AnyHttpUrl',",
            "    'FileUrl',",
            "    'HttpUrl',",
            "    'UrlConstraints',",
            "    'EmailStr',",
            "    'NameEmail',",
            "    'IPvAnyAddress',",
            "    'IPvAnyInterface',",
            "    'IPvAnyNetwork',",
            "    'PostgresDsn',",
            "    'CockroachDsn',",
            "    'AmqpDsn',",
            "    'RedisDsn',",
            "    'MongoDsn',",
            "    'KafkaDsn',",
            "    'validate_email',",
            "    'MySQLDsn',",
            "    'MariaDBDsn',",
            "]",
            "",
            "",
            "@_dataclasses.dataclass",
            "class UrlConstraints(_fields.PydanticMetadata):",
            "    \"\"\"Url constraints.",
            "",
            "    Attributes:",
            "        max_length: The maximum length of the url. Defaults to `None`.",
            "        allowed_schemes: The allowed schemes. Defaults to `None`.",
            "        host_required: Whether the host is required. Defaults to `None`.",
            "        default_host: The default host. Defaults to `None`.",
            "        default_port: The default port. Defaults to `None`.",
            "        default_path: The default path. Defaults to `None`.",
            "    \"\"\"",
            "",
            "    max_length: int | None = None",
            "    allowed_schemes: list[str] | None = None",
            "    host_required: bool | None = None",
            "    default_host: str | None = None",
            "    default_port: int | None = None",
            "    default_path: str | None = None",
            "",
            "    def __hash__(self) -> int:",
            "        return hash(",
            "            (",
            "                self.max_length,",
            "                tuple(self.allowed_schemes) if self.allowed_schemes is not None else None,",
            "                self.host_required,",
            "                self.default_host,",
            "                self.default_port,",
            "                self.default_path,",
            "            )",
            "        )",
            "",
            "",
            "AnyUrl = Url",
            "\"\"\"Base type for all URLs.\"\"\"",
            "AnyHttpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['http', 'https'])]",
            "\"\"\"A type that will accept any http or https URL.\"\"\"",
            "HttpUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['http', 'https'])]",
            "\"\"\"A type that will accept any http or https URL with a max length of 2083 characters.\"\"\"",
            "FileUrl = Annotated[Url, UrlConstraints(allowed_schemes=['file'])]",
            "\"\"\"A type that will accept any file URL.\"\"\"",
            "PostgresDsn = Annotated[",
            "    MultiHostUrl,",
            "    UrlConstraints(",
            "        host_required=True,",
            "        allowed_schemes=[",
            "            'postgres',",
            "            'postgresql',",
            "            'postgresql+asyncpg',",
            "            'postgresql+pg8000',",
            "            'postgresql+psycopg',",
            "            'postgresql+psycopg2',",
            "            'postgresql+psycopg2cffi',",
            "            'postgresql+py-postgresql',",
            "            'postgresql+pygresql',",
            "        ],",
            "    ),",
            "]",
            "\"\"\"A type that will accept any Postgres DSN.\"\"\"",
            "",
            "CockroachDsn = Annotated[",
            "    Url,",
            "    UrlConstraints(",
            "        host_required=True,",
            "        allowed_schemes=[",
            "            'cockroachdb',",
            "            'cockroachdb+psycopg2',",
            "            'cockroachdb+asyncpg',",
            "        ],",
            "    ),",
            "]",
            "\"\"\"A type that will accept any Cockroach DSN.\"\"\"",
            "AmqpDsn = Annotated[Url, UrlConstraints(allowed_schemes=['amqp', 'amqps'])]",
            "\"\"\"A type that will accept any AMQP DSN.\"\"\"",
            "RedisDsn = Annotated[",
            "    Url,",
            "    UrlConstraints(allowed_schemes=['redis', 'rediss'], default_host='localhost', default_port=6379, default_path='/0'),",
            "]",
            "\"\"\"A type that will accept any Redis DSN.\"\"\"",
            "MongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=['mongodb', 'mongodb+srv'], default_port=27017)]",
            "\"\"\"A type that will accept any MongoDB DSN.\"\"\"",
            "KafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=['kafka'], default_host='localhost', default_port=9092)]",
            "\"\"\"A type that will accept any Kafka DSN.\"\"\"",
            "MySQLDsn = Annotated[",
            "    Url,",
            "    UrlConstraints(",
            "        allowed_schemes=[",
            "            'mysql',",
            "            'mysql+mysqlconnector',",
            "            'mysql+aiomysql',",
            "            'mysql+asyncmy',",
            "            'mysql+mysqldb',",
            "            'mysql+pymysql',",
            "            'mysql+cymysql',",
            "            'mysql+pyodbc',",
            "        ],",
            "        default_port=3306,",
            "    ),",
            "]",
            "\"\"\"A type that will accept any MySQL DSN.\"\"\"",
            "MariaDBDsn = Annotated[",
            "    Url,",
            "    UrlConstraints(",
            "        allowed_schemes=['mariadb', 'mariadb+mariadbconnector', 'mariadb+pymysql'],",
            "        default_port=3306,",
            "    ),",
            "]",
            "\"\"\"A type that will accept any MariaDB DSN.\"\"\"",
            "",
            "",
            "def import_email_validator() -> None:",
            "    global email_validator",
            "    try:",
            "        import email_validator",
            "    except ImportError as e:",
            "        raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e",
            "",
            "",
            "if TYPE_CHECKING:",
            "    EmailStr = Annotated[str, ...]",
            "else:",
            "",
            "    class EmailStr:",
            "        \"\"\"",
            "        Info:",
            "            To use this type, you need to install the optional",
            "            [`email-validator`](https://github.com/JoshData/python-email-validator) package:",
            "",
            "            ```bash",
            "            pip install email-validator",
            "            ```",
            "",
            "        Validate email addresses.",
            "",
            "        ```py",
            "        from pydantic import BaseModel, EmailStr",
            "",
            "        class Model(BaseModel):",
            "            email: EmailStr",
            "",
            "        print(Model(email='contact@mail.com'))",
            "        #> email='contact@mail.com'",
            "        ```",
            "        \"\"\"  # noqa: D212",
            "",
            "        @classmethod",
            "        def __get_pydantic_core_schema__(",
            "            cls,",
            "            source: type[Any],",
            "            handler: _annotated_handlers.GetCoreSchemaHandler,",
            "        ) -> core_schema.CoreSchema:",
            "            import_email_validator()",
            "            return core_schema.general_after_validator_function(cls._validate, core_schema.str_schema())",
            "",
            "        @classmethod",
            "        def __get_pydantic_json_schema__(",
            "            cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "        ) -> JsonSchemaValue:",
            "            field_schema = handler(core_schema)",
            "            field_schema.update(type='string', format='email')",
            "            return field_schema",
            "",
            "        @classmethod",
            "        def _validate(cls, __input_value: str, _: core_schema.ValidationInfo) -> str:",
            "            return validate_email(__input_value)[1]",
            "",
            "",
            "class NameEmail(_repr.Representation):",
            "    \"\"\"",
            "    Info:",
            "        To use this type, you need to install the optional",
            "        [`email-validator`](https://github.com/JoshData/python-email-validator) package:",
            "",
            "        ```bash",
            "        pip install email-validator",
            "        ```",
            "",
            "    Validate a name and email address combination, as specified by",
            "    [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4).",
            "",
            "    The `NameEmail` has two properties: `name` and `email`.",
            "    In case the `name` is not provided, it's inferred from the email address.",
            "",
            "    ```py",
            "    from pydantic import BaseModel, NameEmail",
            "",
            "    class User(BaseModel):",
            "        email: NameEmail",
            "",
            "    user = User(email='Fred Bloggs <fred.bloggs@example.com>')",
            "    print(user.email)",
            "    #> Fred Bloggs <fred.bloggs@example.com>",
            "    print(user.email.name)",
            "    #> Fred Bloggs",
            "",
            "    user = User(email='fred.bloggs@example.com')",
            "    print(user.email)",
            "    #> fred.bloggs <fred.bloggs@example.com>",
            "    print(user.email.name)",
            "    #> fred.bloggs",
            "    ```",
            "    \"\"\"  # noqa: D212",
            "",
            "    __slots__ = 'name', 'email'",
            "",
            "    def __init__(self, name: str, email: str):",
            "        self.name = name",
            "        self.email = email",
            "",
            "    def __eq__(self, other: Any) -> bool:",
            "        return isinstance(other, NameEmail) and (self.name, self.email) == (other.name, other.email)",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(",
            "        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "    ) -> JsonSchemaValue:",
            "        field_schema = handler(core_schema)",
            "        field_schema.update(type='string', format='name-email')",
            "        return field_schema",
            "",
            "    @classmethod",
            "    def __get_pydantic_core_schema__(",
            "        cls,",
            "        source: type[Any],",
            "        handler: _annotated_handlers.GetCoreSchemaHandler,",
            "    ) -> core_schema.CoreSchema:",
            "        import_email_validator()",
            "        return core_schema.general_after_validator_function(",
            "            cls._validate,",
            "            core_schema.union_schema(",
            "                [core_schema.is_instance_schema(cls), core_schema.str_schema()],",
            "                custom_error_type='name_email_type',",
            "                custom_error_message='Input is not a valid NameEmail',",
            "            ),",
            "            serialization=core_schema.to_string_ser_schema(),",
            "        )",
            "",
            "    @classmethod",
            "    def _validate(cls, __input_value: NameEmail | str, _: core_schema.ValidationInfo) -> NameEmail:",
            "        if isinstance(__input_value, cls):",
            "            return __input_value",
            "        else:",
            "            name, email = validate_email(__input_value)  # type: ignore[arg-type]",
            "            return cls(name, email)",
            "",
            "    def __str__(self) -> str:",
            "        return f'{self.name} <{self.email}>'",
            "",
            "",
            "class IPvAnyAddress:",
            "    \"\"\"Validate an IPv4 or IPv6 address.\"\"\"",
            "",
            "    __slots__ = ()",
            "",
            "    def __new__(cls, value: Any) -> IPv4Address | IPv6Address:",
            "        \"\"\"Validate an IPv4 or IPv6 address.\"\"\"",
            "        try:",
            "            return IPv4Address(value)",
            "        except ValueError:",
            "            pass",
            "",
            "        try:",
            "            return IPv6Address(value)",
            "        except ValueError:",
            "            raise PydanticCustomError('ip_any_address', 'value is not a valid IPv4 or IPv6 address')",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(",
            "        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "    ) -> JsonSchemaValue:",
            "        field_schema = {}",
            "        field_schema.update(type='string', format='ipvanyaddress')",
            "        return field_schema",
            "",
            "    @classmethod",
            "    def __get_pydantic_core_schema__(",
            "        cls,",
            "        source: type[Any],",
            "        handler: _annotated_handlers.GetCoreSchemaHandler,",
            "    ) -> core_schema.CoreSchema:",
            "        return core_schema.general_plain_validator_function(",
            "            cls._validate, serialization=core_schema.to_string_ser_schema()",
            "        )",
            "",
            "    @classmethod",
            "    def _validate(cls, __input_value: Any, _: core_schema.ValidationInfo) -> IPv4Address | IPv6Address:",
            "        return cls(__input_value)  # type: ignore[return-value]",
            "",
            "",
            "class IPvAnyInterface:",
            "    \"\"\"Validate an IPv4 or IPv6 interface.\"\"\"",
            "",
            "    __slots__ = ()",
            "",
            "    def __new__(cls, value: NetworkType) -> IPv4Interface | IPv6Interface:",
            "        \"\"\"Validate an IPv4 or IPv6 interface.\"\"\"",
            "        try:",
            "            return IPv4Interface(value)",
            "        except ValueError:",
            "            pass",
            "",
            "        try:",
            "            return IPv6Interface(value)",
            "        except ValueError:",
            "            raise PydanticCustomError('ip_any_interface', 'value is not a valid IPv4 or IPv6 interface')",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(",
            "        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "    ) -> JsonSchemaValue:",
            "        field_schema = {}",
            "        field_schema.update(type='string', format='ipvanyinterface')",
            "        return field_schema",
            "",
            "    @classmethod",
            "    def __get_pydantic_core_schema__(",
            "        cls,",
            "        source: type[Any],",
            "        handler: _annotated_handlers.GetCoreSchemaHandler,",
            "    ) -> core_schema.CoreSchema:",
            "        return core_schema.general_plain_validator_function(",
            "            cls._validate, serialization=core_schema.to_string_ser_schema()",
            "        )",
            "",
            "    @classmethod",
            "    def _validate(cls, __input_value: NetworkType, _: core_schema.ValidationInfo) -> IPv4Interface | IPv6Interface:",
            "        return cls(__input_value)  # type: ignore[return-value]",
            "",
            "",
            "class IPvAnyNetwork:",
            "    \"\"\"Validate an IPv4 or IPv6 network.\"\"\"",
            "",
            "    __slots__ = ()",
            "",
            "    def __new__(cls, value: NetworkType) -> IPv4Network | IPv6Network:",
            "        \"\"\"Validate an IPv4 or IPv6 network.\"\"\"",
            "        # Assume IP Network is defined with a default value for `strict` argument.",
            "        # Define your own class if you want to specify network address check strictness.",
            "        try:",
            "            return IPv4Network(value)",
            "        except ValueError:",
            "            pass",
            "",
            "        try:",
            "            return IPv6Network(value)",
            "        except ValueError:",
            "            raise PydanticCustomError('ip_any_network', 'value is not a valid IPv4 or IPv6 network')",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(",
            "        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "    ) -> JsonSchemaValue:",
            "        field_schema = {}",
            "        field_schema.update(type='string', format='ipvanynetwork')",
            "        return field_schema",
            "",
            "    @classmethod",
            "    def __get_pydantic_core_schema__(",
            "        cls,",
            "        source: type[Any],",
            "        handler: _annotated_handlers.GetCoreSchemaHandler,",
            "    ) -> core_schema.CoreSchema:",
            "        return core_schema.general_plain_validator_function(",
            "            cls._validate, serialization=core_schema.to_string_ser_schema()",
            "        )",
            "",
            "    @classmethod",
            "    def _validate(cls, __input_value: NetworkType, _: core_schema.ValidationInfo) -> IPv4Network | IPv6Network:",
            "        return cls(__input_value)  # type: ignore[return-value]",
            "",
            "",
            "def _build_pretty_email_regex() -> re.Pattern:",
            "    name_chars = r'[\\w!#$%&\\'*+\\-/=?^_`{|}~]'",
            "    unquoted_name_group = fr'((?:{name_chars}+\\s+)*{name_chars}+)'",
            "    quoted_name_group = r'\"((?:[^\"]|\\\")+)\"'",
            "    email_group = r'<\\s*(.+)\\s*>'",
            "    return re.compile(rf'\\s*(?:{unquoted_name_group}|{quoted_name_group})?\\s*{email_group}\\s*')",
            "",
            "",
            "pretty_email_regex = _build_pretty_email_regex()",
            "",
            "",
            "def validate_email(value: str) -> tuple[str, str]:",
            "    \"\"\"Email address validation using [email-validator](https://pypi.org/project/email-validator/).",
            "",
            "    Note:",
            "        Note that:",
            "",
            "        * Raw IP address (literal) domain parts are not allowed.",
            "        * `\"John Doe <local_part@domain.com>\"` style \"pretty\" email addresses are processed.",
            "        * Spaces are striped from the beginning and end of addresses, but no error is raised.",
            "    \"\"\"",
            "    if email_validator is None:",
            "        import_email_validator()",
            "",
            "    m = pretty_email_regex.fullmatch(value)",
            "    name: str | None = None",
            "    if m:",
            "        unquoted_name, quoted_name, value = m.groups()",
            "        name = unquoted_name or quoted_name",
            "",
            "    email = value.strip()",
            "",
            "    try:",
            "        parts = email_validator.validate_email(email, check_deliverability=False)",
            "    except email_validator.EmailNotValidError as e:",
            "        raise PydanticCustomError(",
            "            'value_error', 'value is not a valid email address: {reason}', {'reason': str(e.args[0])}",
            "        ) from e",
            "",
            "    email = parts.normalized",
            "    assert email is not None",
            "    name = name or parts.local_part",
            "    return name, email",
            "",
            "",
            "__getattr__ = getattr_migration(__name__)"
        ],
        "afterPatchFile": [
            "\"\"\"The networks module contains types for common network-related fields.\"\"\"",
            "from __future__ import annotations as _annotations",
            "",
            "import dataclasses as _dataclasses",
            "import re",
            "from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network",
            "from typing import TYPE_CHECKING, Any",
            "",
            "from pydantic_core import MultiHostUrl, PydanticCustomError, Url, core_schema",
            "from typing_extensions import Annotated, TypeAlias",
            "",
            "from ._internal import _annotated_handlers, _fields, _repr, _schema_generation_shared",
            "from ._migration import getattr_migration",
            "from .json_schema import JsonSchemaValue",
            "",
            "if TYPE_CHECKING:",
            "    import email_validator",
            "",
            "    NetworkType: TypeAlias = 'str | bytes | int | tuple[str | bytes | int, str | int]'",
            "",
            "else:",
            "    email_validator = None",
            "",
            "",
            "__all__ = [",
            "    'AnyUrl',",
            "    'AnyHttpUrl',",
            "    'FileUrl',",
            "    'HttpUrl',",
            "    'UrlConstraints',",
            "    'EmailStr',",
            "    'NameEmail',",
            "    'IPvAnyAddress',",
            "    'IPvAnyInterface',",
            "    'IPvAnyNetwork',",
            "    'PostgresDsn',",
            "    'CockroachDsn',",
            "    'AmqpDsn',",
            "    'RedisDsn',",
            "    'MongoDsn',",
            "    'KafkaDsn',",
            "    'validate_email',",
            "    'MySQLDsn',",
            "    'MariaDBDsn',",
            "]",
            "",
            "",
            "@_dataclasses.dataclass",
            "class UrlConstraints(_fields.PydanticMetadata):",
            "    \"\"\"Url constraints.",
            "",
            "    Attributes:",
            "        max_length: The maximum length of the url. Defaults to `None`.",
            "        allowed_schemes: The allowed schemes. Defaults to `None`.",
            "        host_required: Whether the host is required. Defaults to `None`.",
            "        default_host: The default host. Defaults to `None`.",
            "        default_port: The default port. Defaults to `None`.",
            "        default_path: The default path. Defaults to `None`.",
            "    \"\"\"",
            "",
            "    max_length: int | None = None",
            "    allowed_schemes: list[str] | None = None",
            "    host_required: bool | None = None",
            "    default_host: str | None = None",
            "    default_port: int | None = None",
            "    default_path: str | None = None",
            "",
            "    def __hash__(self) -> int:",
            "        return hash(",
            "            (",
            "                self.max_length,",
            "                tuple(self.allowed_schemes) if self.allowed_schemes is not None else None,",
            "                self.host_required,",
            "                self.default_host,",
            "                self.default_port,",
            "                self.default_path,",
            "            )",
            "        )",
            "",
            "",
            "AnyUrl = Url",
            "\"\"\"Base type for all URLs.\"\"\"",
            "AnyHttpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['http', 'https'])]",
            "\"\"\"A type that will accept any http or https URL.\"\"\"",
            "HttpUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['http', 'https'])]",
            "\"\"\"A type that will accept any http or https URL with a max length of 2083 characters.\"\"\"",
            "FileUrl = Annotated[Url, UrlConstraints(allowed_schemes=['file'])]",
            "\"\"\"A type that will accept any file URL.\"\"\"",
            "PostgresDsn = Annotated[",
            "    MultiHostUrl,",
            "    UrlConstraints(",
            "        host_required=True,",
            "        allowed_schemes=[",
            "            'postgres',",
            "            'postgresql',",
            "            'postgresql+asyncpg',",
            "            'postgresql+pg8000',",
            "            'postgresql+psycopg',",
            "            'postgresql+psycopg2',",
            "            'postgresql+psycopg2cffi',",
            "            'postgresql+py-postgresql',",
            "            'postgresql+pygresql',",
            "        ],",
            "    ),",
            "]",
            "\"\"\"A type that will accept any Postgres DSN.\"\"\"",
            "",
            "CockroachDsn = Annotated[",
            "    Url,",
            "    UrlConstraints(",
            "        host_required=True,",
            "        allowed_schemes=[",
            "            'cockroachdb',",
            "            'cockroachdb+psycopg2',",
            "            'cockroachdb+asyncpg',",
            "        ],",
            "    ),",
            "]",
            "\"\"\"A type that will accept any Cockroach DSN.\"\"\"",
            "AmqpDsn = Annotated[Url, UrlConstraints(allowed_schemes=['amqp', 'amqps'])]",
            "\"\"\"A type that will accept any AMQP DSN.\"\"\"",
            "RedisDsn = Annotated[",
            "    Url,",
            "    UrlConstraints(allowed_schemes=['redis', 'rediss'], default_host='localhost', default_port=6379, default_path='/0'),",
            "]",
            "\"\"\"A type that will accept any Redis DSN.\"\"\"",
            "MongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=['mongodb', 'mongodb+srv'], default_port=27017)]",
            "\"\"\"A type that will accept any MongoDB DSN.\"\"\"",
            "KafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=['kafka'], default_host='localhost', default_port=9092)]",
            "\"\"\"A type that will accept any Kafka DSN.\"\"\"",
            "MySQLDsn = Annotated[",
            "    Url,",
            "    UrlConstraints(",
            "        allowed_schemes=[",
            "            'mysql',",
            "            'mysql+mysqlconnector',",
            "            'mysql+aiomysql',",
            "            'mysql+asyncmy',",
            "            'mysql+mysqldb',",
            "            'mysql+pymysql',",
            "            'mysql+cymysql',",
            "            'mysql+pyodbc',",
            "        ],",
            "        default_port=3306,",
            "    ),",
            "]",
            "\"\"\"A type that will accept any MySQL DSN.\"\"\"",
            "MariaDBDsn = Annotated[",
            "    Url,",
            "    UrlConstraints(",
            "        allowed_schemes=['mariadb', 'mariadb+mariadbconnector', 'mariadb+pymysql'],",
            "        default_port=3306,",
            "    ),",
            "]",
            "\"\"\"A type that will accept any MariaDB DSN.\"\"\"",
            "",
            "",
            "def import_email_validator() -> None:",
            "    global email_validator",
            "    try:",
            "        import email_validator",
            "    except ImportError as e:",
            "        raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e",
            "",
            "",
            "if TYPE_CHECKING:",
            "    EmailStr = Annotated[str, ...]",
            "else:",
            "",
            "    class EmailStr:",
            "        \"\"\"",
            "        Info:",
            "            To use this type, you need to install the optional",
            "            [`email-validator`](https://github.com/JoshData/python-email-validator) package:",
            "",
            "            ```bash",
            "            pip install email-validator",
            "            ```",
            "",
            "        Validate email addresses.",
            "",
            "        ```py",
            "        from pydantic import BaseModel, EmailStr",
            "",
            "        class Model(BaseModel):",
            "            email: EmailStr",
            "",
            "        print(Model(email='contact@mail.com'))",
            "        #> email='contact@mail.com'",
            "        ```",
            "        \"\"\"  # noqa: D212",
            "",
            "        @classmethod",
            "        def __get_pydantic_core_schema__(",
            "            cls,",
            "            source: type[Any],",
            "            handler: _annotated_handlers.GetCoreSchemaHandler,",
            "        ) -> core_schema.CoreSchema:",
            "            import_email_validator()",
            "            return core_schema.general_after_validator_function(cls._validate, core_schema.str_schema())",
            "",
            "        @classmethod",
            "        def __get_pydantic_json_schema__(",
            "            cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "        ) -> JsonSchemaValue:",
            "            field_schema = handler(core_schema)",
            "            field_schema.update(type='string', format='email')",
            "            return field_schema",
            "",
            "        @classmethod",
            "        def _validate(cls, __input_value: str, _: core_schema.ValidationInfo) -> str:",
            "            return validate_email(__input_value)[1]",
            "",
            "",
            "class NameEmail(_repr.Representation):",
            "    \"\"\"",
            "    Info:",
            "        To use this type, you need to install the optional",
            "        [`email-validator`](https://github.com/JoshData/python-email-validator) package:",
            "",
            "        ```bash",
            "        pip install email-validator",
            "        ```",
            "",
            "    Validate a name and email address combination, as specified by",
            "    [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4).",
            "",
            "    The `NameEmail` has two properties: `name` and `email`.",
            "    In case the `name` is not provided, it's inferred from the email address.",
            "",
            "    ```py",
            "    from pydantic import BaseModel, NameEmail",
            "",
            "    class User(BaseModel):",
            "        email: NameEmail",
            "",
            "    user = User(email='Fred Bloggs <fred.bloggs@example.com>')",
            "    print(user.email)",
            "    #> Fred Bloggs <fred.bloggs@example.com>",
            "    print(user.email.name)",
            "    #> Fred Bloggs",
            "",
            "    user = User(email='fred.bloggs@example.com')",
            "    print(user.email)",
            "    #> fred.bloggs <fred.bloggs@example.com>",
            "    print(user.email.name)",
            "    #> fred.bloggs",
            "    ```",
            "    \"\"\"  # noqa: D212",
            "",
            "    __slots__ = 'name', 'email'",
            "",
            "    def __init__(self, name: str, email: str):",
            "        self.name = name",
            "        self.email = email",
            "",
            "    def __eq__(self, other: Any) -> bool:",
            "        return isinstance(other, NameEmail) and (self.name, self.email) == (other.name, other.email)",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(",
            "        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "    ) -> JsonSchemaValue:",
            "        field_schema = handler(core_schema)",
            "        field_schema.update(type='string', format='name-email')",
            "        return field_schema",
            "",
            "    @classmethod",
            "    def __get_pydantic_core_schema__(",
            "        cls,",
            "        source: type[Any],",
            "        handler: _annotated_handlers.GetCoreSchemaHandler,",
            "    ) -> core_schema.CoreSchema:",
            "        import_email_validator()",
            "        return core_schema.general_after_validator_function(",
            "            cls._validate,",
            "            core_schema.union_schema(",
            "                [core_schema.is_instance_schema(cls), core_schema.str_schema()],",
            "                custom_error_type='name_email_type',",
            "                custom_error_message='Input is not a valid NameEmail',",
            "            ),",
            "            serialization=core_schema.to_string_ser_schema(),",
            "        )",
            "",
            "    @classmethod",
            "    def _validate(cls, __input_value: NameEmail | str, _: core_schema.ValidationInfo) -> NameEmail:",
            "        if isinstance(__input_value, cls):",
            "            return __input_value",
            "        else:",
            "            name, email = validate_email(__input_value)  # type: ignore[arg-type]",
            "            return cls(name, email)",
            "",
            "    def __str__(self) -> str:",
            "        return f'{self.name} <{self.email}>'",
            "",
            "",
            "class IPvAnyAddress:",
            "    \"\"\"Validate an IPv4 or IPv6 address.\"\"\"",
            "",
            "    __slots__ = ()",
            "",
            "    def __new__(cls, value: Any) -> IPv4Address | IPv6Address:",
            "        \"\"\"Validate an IPv4 or IPv6 address.\"\"\"",
            "        try:",
            "            return IPv4Address(value)",
            "        except ValueError:",
            "            pass",
            "",
            "        try:",
            "            return IPv6Address(value)",
            "        except ValueError:",
            "            raise PydanticCustomError('ip_any_address', 'value is not a valid IPv4 or IPv6 address')",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(",
            "        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "    ) -> JsonSchemaValue:",
            "        field_schema = {}",
            "        field_schema.update(type='string', format='ipvanyaddress')",
            "        return field_schema",
            "",
            "    @classmethod",
            "    def __get_pydantic_core_schema__(",
            "        cls,",
            "        source: type[Any],",
            "        handler: _annotated_handlers.GetCoreSchemaHandler,",
            "    ) -> core_schema.CoreSchema:",
            "        return core_schema.general_plain_validator_function(",
            "            cls._validate, serialization=core_schema.to_string_ser_schema()",
            "        )",
            "",
            "    @classmethod",
            "    def _validate(cls, __input_value: Any, _: core_schema.ValidationInfo) -> IPv4Address | IPv6Address:",
            "        return cls(__input_value)  # type: ignore[return-value]",
            "",
            "",
            "class IPvAnyInterface:",
            "    \"\"\"Validate an IPv4 or IPv6 interface.\"\"\"",
            "",
            "    __slots__ = ()",
            "",
            "    def __new__(cls, value: NetworkType) -> IPv4Interface | IPv6Interface:",
            "        \"\"\"Validate an IPv4 or IPv6 interface.\"\"\"",
            "        try:",
            "            return IPv4Interface(value)",
            "        except ValueError:",
            "            pass",
            "",
            "        try:",
            "            return IPv6Interface(value)",
            "        except ValueError:",
            "            raise PydanticCustomError('ip_any_interface', 'value is not a valid IPv4 or IPv6 interface')",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(",
            "        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "    ) -> JsonSchemaValue:",
            "        field_schema = {}",
            "        field_schema.update(type='string', format='ipvanyinterface')",
            "        return field_schema",
            "",
            "    @classmethod",
            "    def __get_pydantic_core_schema__(",
            "        cls,",
            "        source: type[Any],",
            "        handler: _annotated_handlers.GetCoreSchemaHandler,",
            "    ) -> core_schema.CoreSchema:",
            "        return core_schema.general_plain_validator_function(",
            "            cls._validate, serialization=core_schema.to_string_ser_schema()",
            "        )",
            "",
            "    @classmethod",
            "    def _validate(cls, __input_value: NetworkType, _: core_schema.ValidationInfo) -> IPv4Interface | IPv6Interface:",
            "        return cls(__input_value)  # type: ignore[return-value]",
            "",
            "",
            "class IPvAnyNetwork:",
            "    \"\"\"Validate an IPv4 or IPv6 network.\"\"\"",
            "",
            "    __slots__ = ()",
            "",
            "    def __new__(cls, value: NetworkType) -> IPv4Network | IPv6Network:",
            "        \"\"\"Validate an IPv4 or IPv6 network.\"\"\"",
            "        # Assume IP Network is defined with a default value for `strict` argument.",
            "        # Define your own class if you want to specify network address check strictness.",
            "        try:",
            "            return IPv4Network(value)",
            "        except ValueError:",
            "            pass",
            "",
            "        try:",
            "            return IPv6Network(value)",
            "        except ValueError:",
            "            raise PydanticCustomError('ip_any_network', 'value is not a valid IPv4 or IPv6 network')",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(",
            "        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler",
            "    ) -> JsonSchemaValue:",
            "        field_schema = {}",
            "        field_schema.update(type='string', format='ipvanynetwork')",
            "        return field_schema",
            "",
            "    @classmethod",
            "    def __get_pydantic_core_schema__(",
            "        cls,",
            "        source: type[Any],",
            "        handler: _annotated_handlers.GetCoreSchemaHandler,",
            "    ) -> core_schema.CoreSchema:",
            "        return core_schema.general_plain_validator_function(",
            "            cls._validate, serialization=core_schema.to_string_ser_schema()",
            "        )",
            "",
            "    @classmethod",
            "    def _validate(cls, __input_value: NetworkType, _: core_schema.ValidationInfo) -> IPv4Network | IPv6Network:",
            "        return cls(__input_value)  # type: ignore[return-value]",
            "",
            "",
            "def _build_pretty_email_regex() -> re.Pattern[str]:",
            "    name_chars = r'[\\w!#$%&\\'*+\\-/=?^_`{|}~]'",
            "    unquoted_name_group = fr'((?:{name_chars}+\\s+)*{name_chars}+)'",
            "    quoted_name_group = r'\"((?:[^\"]|\\\")+)\"'",
            "    email_group = r'<\\s*(.{0,254})\\s*>'",
            "    return re.compile(rf'\\s*(?:{unquoted_name_group}|{quoted_name_group})?\\s*{email_group}\\s*')",
            "",
            "",
            "pretty_email_regex = _build_pretty_email_regex()",
            "",
            "MAX_EMAIL_LENGTH = 2048",
            "\"\"\"Maximum length for an email.",
            "A somewhat arbitrary but very generous number compared to what is allowed by most implementations.",
            "\"\"\"",
            "",
            "",
            "def validate_email(value: str) -> tuple[str, str]:",
            "    \"\"\"Email address validation using [email-validator](https://pypi.org/project/email-validator/).",
            "",
            "    Note:",
            "        Note that:",
            "",
            "        * Raw IP address (literal) domain parts are not allowed.",
            "        * `\"John Doe <local_part@domain.com>\"` style \"pretty\" email addresses are processed.",
            "        * Spaces are striped from the beginning and end of addresses, but no error is raised.",
            "    \"\"\"",
            "    if email_validator is None:",
            "        import_email_validator()",
            "",
            "    if len(value) > MAX_EMAIL_LENGTH:",
            "        raise PydanticCustomError(",
            "            'value_error',",
            "            'value is not a valid email address: {reason}',",
            "            {'reason': f'Length must not exceed {MAX_EMAIL_LENGTH} characters'},",
            "        )",
            "",
            "    m = pretty_email_regex.fullmatch(value)",
            "    name: str | None = None",
            "    if m:",
            "        unquoted_name, quoted_name, value = m.groups()",
            "        name = unquoted_name or quoted_name",
            "",
            "    email = value.strip()",
            "",
            "    try:",
            "        parts = email_validator.validate_email(email, check_deliverability=False)",
            "    except email_validator.EmailNotValidError as e:",
            "        raise PydanticCustomError(",
            "            'value_error', 'value is not a valid email address: {reason}', {'reason': str(e.args[0])}",
            "        ) from e",
            "",
            "    email = parts.normalized",
            "    assert email is not None",
            "    name = name or parts.local_part",
            "    return name, email",
            "",
            "",
            "__getattr__ = getattr_migration(__name__)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "419": [
                "_build_pretty_email_regex"
            ],
            "423": [
                "_build_pretty_email_regex"
            ]
        },
        "addLocation": []
    }
}