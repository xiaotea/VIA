{
    "lib/ansible/plugins/connections/jail.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " # Based on local.py (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " # and chroot.py     (c) 2013, Maykel Moya <mmoya@speedyrails.com>"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # (c) 2013, Michael Scherer <misc@zarb.org>"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+# (c) 2015, Toshio Kuratomi <tkuratomi@ansible.com>"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " #"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " # This file is part of Ansible"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " #"
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import distutils.spawn"
            },
            "8": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " import traceback"
            },
            "9": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " import os"
            },
            "10": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import shutil"
            },
            "11": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import subprocess"
            },
            "12": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from ansible import errors"
            },
            "13": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from ansible.callbacks import vvv"
            },
            "14": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " import ansible.constants as C"
            },
            "15": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+BUFSIZE = 4096"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " class Connection(object):"
            },
            "19": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ''' Local chroot based connections '''"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    ''' Local BSD Jail based connections '''"
            },
            "21": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     def _search_executable(self, executable):"
            },
            "23": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         cmd = distutils.spawn.find_executable(executable)"
            },
            "24": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         self.port = port"
            },
            "25": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     def connect(self, port=None):"
            },
            "27": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ''' connect to the chroot; nothing to do here '''"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        ''' connect to the jail; nothing to do here '''"
            },
            "29": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        vvv(\"THIS IS A LOCAL CHROOT DIR\", host=self.jail)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        vvv(\"THIS IS A LOCAL JAIL DIR\", host=self.jail)"
            },
            "32": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         return self"
            },
            "34": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "             local_cmd = '%s \"%s\" %s' % (self.jexec_cmd, self.jail, cmd)"
            },
            "36": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         return local_cmd"
            },
            "37": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None):"
            },
            "39": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ''' run a command on the chroot '''"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    def _buffered_exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None, stdin=subprocess.PIPE):"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        ''' run a command on the jail.  This is only needed for implementing"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        put_file() get_file() so that we don't have to read the whole file"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        into memory."
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        compared to exec_command() it looses some niceties like being able to"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        return the process's exit code immediately."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        '''"
            },
            "48": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         if sudoable and self.runner.become and self.runner.become_method not in self.become_methods_supported:"
            },
            "50": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             raise errors.AnsibleError(\"Internal Error: this module does not support running commands via %s\" % self.runner.become_method)"
            },
            "51": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         vvv(\"EXEC %s\" % (local_cmd), host=self.jail)"
            },
            "52": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, basestring),"
            },
            "53": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "                              cwd=self.runner.basedir,"
            },
            "54": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                             stdin=subprocess.PIPE,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+                             stdin=stdin,"
            },
            "56": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)"
            },
            "57": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        return p"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None):"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        ''' run a command on the jail '''"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        p = self._buffered_exec_command(cmd, tmp_path, become_user, sudoable, executable, in_data)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         stdout, stderr = p.communicate()"
            },
            "66": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         return (p.returncode, '', stdout, stderr)"
            },
            "67": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _normalize_path(self, path, prefix):"
            },
            "69": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not path.startswith(os.path.sep):"
            },
            "70": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path = os.path.join(os.path.sep, path)"
            },
            "71": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        normpath = os.path.normpath(path)"
            },
            "72": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return os.path.join(prefix, normpath[1:])"
            },
            "73": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "74": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _copy_file(self, in_path, out_path):"
            },
            "75": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not os.path.exists(in_path):"
            },
            "76": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise errors.AnsibleFileNotFound(\"file or module does not exist: %s\" % in_path)"
            },
            "77": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "78": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            shutil.copyfile(in_path, out_path)"
            },
            "79": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except shutil.Error:"
            },
            "80": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            traceback.print_exc()"
            },
            "81": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise errors.AnsibleError(\"failed to copy: %s and %s are the same\" % (in_path, out_path))"
            },
            "82": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except IOError:"
            },
            "83": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            traceback.print_exc()"
            },
            "84": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)"
            },
            "85": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "86": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     def put_file(self, in_path, out_path):"
            },
            "87": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ''' transfer a file from local to chroot '''"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        ''' transfer a file from local to jail '''"
            },
            "89": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "90": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        out_path = self._normalize_path(out_path, self.get_jail_path())"
            },
            "91": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.jail)"
            },
            "92": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " "
            },
            "93": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._copy_file(in_path, out_path)"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        with open(in_path, 'rb') as in_file:"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+            p = self._buffered_exec_command('dd of=%s' % out_path, None, stdin=in_file)"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+            try:"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+                stdout, stderr = p.communicate()"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            except:"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+                traceback.print_exc()"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+                raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+            if p.returncode != 0:"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+                raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))"
            },
            "103": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "104": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     def fetch_file(self, in_path, out_path):"
            },
            "105": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ''' fetch a file from chroot to local '''"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        ''' fetch a file from jail to local '''"
            },
            "107": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 151,
                "PatchRowcode": " "
            },
            "108": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        in_path = self._normalize_path(in_path, self.get_jail_path())"
            },
            "109": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.jail)"
            },
            "110": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "111": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._copy_file(in_path, out_path)"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        p = self._buffered_exec_command('dd if=%s bs=%s' % (in_path, BUFSIZE), None)"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        with open(out_path, 'wb+') as out_file:"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            try:"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+                for chunk in p.stdout.read(BUFSIZE):"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+                    out_file.write(chunk)"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+            except:"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+                traceback.print_exc()"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+                raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            stdout, stderr = p.communicate()"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            if p.returncode != 0:"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))"
            },
            "125": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "126": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     def close(self):"
            },
            "127": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         ''' terminate the connection; nothing to do here '''"
            }
        },
        "frontPatchFile": [
            "# Based on local.py (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>",
            "# and chroot.py     (c) 2013, Maykel Moya <mmoya@speedyrails.com>",
            "# (c) 2013, Michael Scherer <misc@zarb.org>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import distutils.spawn",
            "import traceback",
            "import os",
            "import shutil",
            "import subprocess",
            "from ansible import errors",
            "from ansible.callbacks import vvv",
            "import ansible.constants as C",
            "",
            "class Connection(object):",
            "    ''' Local chroot based connections '''",
            "",
            "    def _search_executable(self, executable):",
            "        cmd = distutils.spawn.find_executable(executable)",
            "        if not cmd:",
            "            raise errors.AnsibleError(\"%s command not found in PATH\") % executable",
            "        return cmd",
            "",
            "    def list_jails(self):",
            "        p = subprocess.Popen([self.jls_cmd, '-q', 'name'],",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        stdout, stderr = p.communicate()",
            "",
            "        return stdout.split()",
            "",
            "    def get_jail_path(self):",
            "        p = subprocess.Popen([self.jls_cmd, '-j', self.jail, '-q', 'path'],",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        stdout, stderr = p.communicate()",
            "        # remove \\n",
            "        return stdout[:-1]",
            "",
            " ",
            "        ",
            "    def __init__(self, runner, host, port, *args, **kwargs):",
            "        self.jail = host",
            "        self.runner = runner",
            "        self.host = host",
            "        self.has_pipelining = False",
            "        self.become_methods_supported=C.BECOME_METHODS",
            "",
            "        if os.geteuid() != 0:",
            "            raise errors.AnsibleError(\"jail connection requires running as root\")",
            "",
            "        self.jls_cmd = self._search_executable('jls')",
            "        self.jexec_cmd = self._search_executable('jexec')",
            "        ",
            "        if not self.jail in self.list_jails():",
            "            raise errors.AnsibleError(\"incorrect jail name %s\" % self.jail)",
            "",
            "",
            "        self.host = host",
            "        # port is unused, since this is local",
            "        self.port = port",
            "",
            "    def connect(self, port=None):",
            "        ''' connect to the chroot; nothing to do here '''",
            "",
            "        vvv(\"THIS IS A LOCAL CHROOT DIR\", host=self.jail)",
            "",
            "        return self",
            "",
            "    # a modifier",
            "    def _generate_cmd(self, executable, cmd):",
            "        if executable:",
            "            local_cmd = [self.jexec_cmd, self.jail, executable, '-c', cmd]",
            "        else:",
            "            local_cmd = '%s \"%s\" %s' % (self.jexec_cmd, self.jail, cmd)",
            "        return local_cmd",
            "",
            "    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None):",
            "        ''' run a command on the chroot '''",
            "",
            "        if sudoable and self.runner.become and self.runner.become_method not in self.become_methods_supported:",
            "            raise errors.AnsibleError(\"Internal Error: this module does not support running commands via %s\" % self.runner.become_method)",
            "",
            "        if in_data:",
            "            raise errors.AnsibleError(\"Internal Error: this module does not support optimized module pipelining\")",
            "",
            "        # Ignores privilege escalation",
            "        local_cmd = self._generate_cmd(executable, cmd)",
            "",
            "        vvv(\"EXEC %s\" % (local_cmd), host=self.jail)",
            "        p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, basestring),",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        stdout, stderr = p.communicate()",
            "        return (p.returncode, '', stdout, stderr)",
            "",
            "    def _normalize_path(self, path, prefix):",
            "        if not path.startswith(os.path.sep):",
            "            path = os.path.join(os.path.sep, path)",
            "        normpath = os.path.normpath(path)",
            "        return os.path.join(prefix, normpath[1:])",
            "",
            "    def _copy_file(self, in_path, out_path):",
            "        if not os.path.exists(in_path):",
            "            raise errors.AnsibleFileNotFound(\"file or module does not exist: %s\" % in_path)",
            "        try:",
            "            shutil.copyfile(in_path, out_path)",
            "        except shutil.Error:",
            "            traceback.print_exc()",
            "            raise errors.AnsibleError(\"failed to copy: %s and %s are the same\" % (in_path, out_path))",
            "        except IOError:",
            "            traceback.print_exc()",
            "            raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)",
            "",
            "    def put_file(self, in_path, out_path):",
            "        ''' transfer a file from local to chroot '''",
            "",
            "        out_path = self._normalize_path(out_path, self.get_jail_path())",
            "        vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.jail)",
            "",
            "        self._copy_file(in_path, out_path)",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        ''' fetch a file from chroot to local '''",
            "",
            "        in_path = self._normalize_path(in_path, self.get_jail_path())",
            "        vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.jail)",
            "",
            "        self._copy_file(in_path, out_path)",
            "",
            "    def close(self):",
            "        ''' terminate the connection; nothing to do here '''",
            "        pass"
        ],
        "afterPatchFile": [
            "# Based on local.py (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>",
            "# and chroot.py     (c) 2013, Maykel Moya <mmoya@speedyrails.com>",
            "# (c) 2013, Michael Scherer <misc@zarb.org>",
            "# (c) 2015, Toshio Kuratomi <tkuratomi@ansible.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import distutils.spawn",
            "import traceback",
            "import os",
            "import subprocess",
            "from ansible import errors",
            "from ansible.callbacks import vvv",
            "import ansible.constants as C",
            "",
            "BUFSIZE = 4096",
            "",
            "class Connection(object):",
            "    ''' Local BSD Jail based connections '''",
            "",
            "    def _search_executable(self, executable):",
            "        cmd = distutils.spawn.find_executable(executable)",
            "        if not cmd:",
            "            raise errors.AnsibleError(\"%s command not found in PATH\") % executable",
            "        return cmd",
            "",
            "    def list_jails(self):",
            "        p = subprocess.Popen([self.jls_cmd, '-q', 'name'],",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        stdout, stderr = p.communicate()",
            "",
            "        return stdout.split()",
            "",
            "    def get_jail_path(self):",
            "        p = subprocess.Popen([self.jls_cmd, '-j', self.jail, '-q', 'path'],",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        stdout, stderr = p.communicate()",
            "        # remove \\n",
            "        return stdout[:-1]",
            "",
            " ",
            "        ",
            "    def __init__(self, runner, host, port, *args, **kwargs):",
            "        self.jail = host",
            "        self.runner = runner",
            "        self.host = host",
            "        self.has_pipelining = False",
            "        self.become_methods_supported=C.BECOME_METHODS",
            "",
            "        if os.geteuid() != 0:",
            "            raise errors.AnsibleError(\"jail connection requires running as root\")",
            "",
            "        self.jls_cmd = self._search_executable('jls')",
            "        self.jexec_cmd = self._search_executable('jexec')",
            "        ",
            "        if not self.jail in self.list_jails():",
            "            raise errors.AnsibleError(\"incorrect jail name %s\" % self.jail)",
            "",
            "",
            "        self.host = host",
            "        # port is unused, since this is local",
            "        self.port = port",
            "",
            "    def connect(self, port=None):",
            "        ''' connect to the jail; nothing to do here '''",
            "",
            "        vvv(\"THIS IS A LOCAL JAIL DIR\", host=self.jail)",
            "",
            "        return self",
            "",
            "    # a modifier",
            "    def _generate_cmd(self, executable, cmd):",
            "        if executable:",
            "            local_cmd = [self.jexec_cmd, self.jail, executable, '-c', cmd]",
            "        else:",
            "            local_cmd = '%s \"%s\" %s' % (self.jexec_cmd, self.jail, cmd)",
            "        return local_cmd",
            "",
            "    def _buffered_exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None, stdin=subprocess.PIPE):",
            "        ''' run a command on the jail.  This is only needed for implementing",
            "        put_file() get_file() so that we don't have to read the whole file",
            "        into memory.",
            "",
            "        compared to exec_command() it looses some niceties like being able to",
            "        return the process's exit code immediately.",
            "        '''",
            "",
            "        if sudoable and self.runner.become and self.runner.become_method not in self.become_methods_supported:",
            "            raise errors.AnsibleError(\"Internal Error: this module does not support running commands via %s\" % self.runner.become_method)",
            "",
            "        if in_data:",
            "            raise errors.AnsibleError(\"Internal Error: this module does not support optimized module pipelining\")",
            "",
            "        # Ignores privilege escalation",
            "        local_cmd = self._generate_cmd(executable, cmd)",
            "",
            "        vvv(\"EXEC %s\" % (local_cmd), host=self.jail)",
            "        p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, basestring),",
            "                             cwd=self.runner.basedir,",
            "                             stdin=stdin,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        return p",
            "",
            "    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None):",
            "        ''' run a command on the jail '''",
            "",
            "        p = self._buffered_exec_command(cmd, tmp_path, become_user, sudoable, executable, in_data)",
            "",
            "        stdout, stderr = p.communicate()",
            "        return (p.returncode, '', stdout, stderr)",
            "",
            "    def put_file(self, in_path, out_path):",
            "        ''' transfer a file from local to jail '''",
            "",
            "        vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.jail)",
            "",
            "        with open(in_path, 'rb') as in_file:",
            "            p = self._buffered_exec_command('dd of=%s' % out_path, None, stdin=in_file)",
            "            try:",
            "                stdout, stderr = p.communicate()",
            "            except:",
            "                traceback.print_exc()",
            "                raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)",
            "            if p.returncode != 0:",
            "                raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        ''' fetch a file from jail to local '''",
            "",
            "        vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.jail)",
            "",
            "",
            "        p = self._buffered_exec_command('dd if=%s bs=%s' % (in_path, BUFSIZE), None)",
            "",
            "        with open(out_path, 'wb+') as out_file:",
            "            try:",
            "                for chunk in p.stdout.read(BUFSIZE):",
            "                    out_file.write(chunk)",
            "            except:",
            "                traceback.print_exc()",
            "                raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)",
            "            stdout, stderr = p.communicate()",
            "            if p.returncode != 0:",
            "                raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))",
            "",
            "    def close(self):",
            "        ''' terminate the connection; nothing to do here '''",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "25": [],
            "32": [
                "Connection"
            ],
            "84": [
                "Connection",
                "connect"
            ],
            "86": [
                "Connection",
                "connect"
            ],
            "98": [
                "Connection",
                "exec_command"
            ],
            "99": [
                "Connection",
                "exec_command"
            ],
            "113": [
                "Connection",
                "exec_command"
            ],
            "119": [
                "Connection",
                "_normalize_path"
            ],
            "120": [
                "Connection",
                "_normalize_path"
            ],
            "121": [
                "Connection",
                "_normalize_path"
            ],
            "122": [
                "Connection",
                "_normalize_path"
            ],
            "123": [
                "Connection",
                "_normalize_path"
            ],
            "124": [
                "Connection"
            ],
            "125": [
                "Connection",
                "_copy_file"
            ],
            "126": [
                "Connection",
                "_copy_file"
            ],
            "127": [
                "Connection",
                "_copy_file"
            ],
            "128": [
                "Connection",
                "_copy_file"
            ],
            "129": [
                "Connection",
                "_copy_file"
            ],
            "130": [
                "Connection",
                "_copy_file"
            ],
            "131": [
                "Connection",
                "_copy_file"
            ],
            "132": [
                "Connection",
                "_copy_file"
            ],
            "133": [
                "Connection",
                "_copy_file"
            ],
            "134": [
                "Connection",
                "_copy_file"
            ],
            "135": [
                "Connection",
                "_copy_file"
            ],
            "136": [
                "Connection"
            ],
            "138": [
                "Connection",
                "put_file"
            ],
            "140": [
                "Connection",
                "put_file"
            ],
            "143": [
                "Connection",
                "put_file"
            ],
            "146": [
                "Connection",
                "fetch_file"
            ],
            "148": [
                "Connection",
                "fetch_file"
            ],
            "151": [
                "Connection",
                "fetch_file"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/plugins/connections/zone.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " # and chroot.py     (c) 2013, Maykel Moya <mmoya@speedyrails.com>"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # and jail.py       (c) 2013, Michael Scherer <misc@zarb.org>"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " # (c) 2015, Dagobert Michelsen <dam@baltic-online.de>"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+# (c) 2015, Toshio Kuratomi <tkuratomi@ansible.com>"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " #"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " # This file is part of Ansible"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " #"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " import distutils.spawn"
            },
            "8": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " import traceback"
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import os"
            },
            "10": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import shutil"
            },
            "11": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " import subprocess"
            },
            "12": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from subprocess import Popen,PIPE"
            },
            "13": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from ansible import errors"
            },
            "14": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from ansible.callbacks import vvv"
            },
            "15": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " import ansible.constants as C"
            },
            "16": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+BUFSIZE = 4096"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " class Connection(object):"
            },
            "20": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     ''' Local zone based connections '''"
            },
            "21": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "                              cwd=self.runner.basedir,"
            },
            "23": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "                              stdin=subprocess.PIPE,"
            },
            "24": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)"
            },
            "25": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        #stdout, stderr = p.communicate()"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         zones = []"
            },
            "28": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         for l in pipe.stdout.readlines():"
            },
            "29": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "           # 1:work:running:/zones/work:3126dc59-9a07-4829-cde9-a816e4c5040e:native:shared"
            },
            "30": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     # a modifier"
            },
            "31": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     def _generate_cmd(self, executable, cmd):"
            },
            "32": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         if executable:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            ### TODO: Why was \"-c\" removed from here? (vs jail.py)"
            },
            "34": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "             local_cmd = [self.zlogin_cmd, self.zone, executable, cmd]"
            },
            "35": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         else:"
            },
            "36": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "             local_cmd = '%s \"%s\" %s' % (self.zlogin_cmd, self.zone, cmd)"
            },
            "37": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         return local_cmd"
            },
            "38": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 106,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable=None, in_data=None):"
            },
            "40": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ''' run a command on the zone '''"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    def _buffered_exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable=None, in_data=None, stdin=subprocess.PIPE):"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        ''' run a command on the zone.  This is only needed for implementing"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+        put_file() get_file() so that we don't have to read the whole file"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        into memory."
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        compared to exec_command() it looses some niceties like being able to"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        return the process's exit code immediately."
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        '''"
            },
            "49": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         if sudoable and self.runner.become and self.runner.become_method not in self.become_methods_supported:"
            },
            "51": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "             raise errors.AnsibleError(\"Internal Error: this module does not support running commands via %s\" % self.runner.become_method)"
            },
            "52": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "             raise errors.AnsibleError(\"Internal Error: this module does not support optimized module pipelining\")"
            },
            "53": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         # We happily ignore privilege escalation"
            },
            "55": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if executable == '/bin/sh':"
            },
            "56": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-          executable = None"
            },
            "57": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         local_cmd = self._generate_cmd(executable, cmd)"
            },
            "58": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         vvv(\"EXEC %s\" % (local_cmd), host=self.zone)"
            },
            "60": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, basestring),"
            },
            "61": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "                              cwd=self.runner.basedir,"
            },
            "62": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                             stdin=subprocess.PIPE,"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+                             stdin=stdin,"
            },
            "64": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)"
            },
            "65": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        return p"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable=None, in_data=None):"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        ''' run a command on the zone '''"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        ### TODO: Why all the precautions not to specify /bin/sh? (vs jail.py)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        if executable == '/bin/sh':"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+          executable = None"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        p = self._buffered_exec_command(cmd, tmp_path, become_user, sudoable, executable, in_data)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         stdout, stderr = p.communicate()"
            },
            "78": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         return (p.returncode, '', stdout, stderr)"
            },
            "79": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _normalize_path(self, path, prefix):"
            },
            "81": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not path.startswith(os.path.sep):"
            },
            "82": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path = os.path.join(os.path.sep, path)"
            },
            "83": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        normpath = os.path.normpath(path)"
            },
            "84": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return os.path.join(prefix, normpath[1:])"
            },
            "85": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "86": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _copy_file(self, in_path, out_path):"
            },
            "87": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not os.path.exists(in_path):"
            },
            "88": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise errors.AnsibleFileNotFound(\"file or module does not exist: %s\" % in_path)"
            },
            "89": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "90": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            shutil.copyfile(in_path, out_path)"
            },
            "91": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except shutil.Error:"
            },
            "92": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            traceback.print_exc()"
            },
            "93": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise errors.AnsibleError(\"failed to copy: %s and %s are the same\" % (in_path, out_path))"
            },
            "94": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except IOError:"
            },
            "95": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            traceback.print_exc()"
            },
            "96": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)"
            },
            "97": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "98": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     def put_file(self, in_path, out_path):"
            },
            "99": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         ''' transfer a file from local to zone '''"
            },
            "100": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " "
            },
            "101": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        out_path = self._normalize_path(out_path, self.get_zone_path())"
            },
            "102": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.zone)"
            },
            "103": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "104": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._copy_file(in_path, out_path)"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        with open(in_path, 'rb') as in_file:"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            p = self._buffered_exec_command('dd of=%s' % out_path, None, stdin=in_file)"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            try:"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                stdout, stderr = p.communicate()"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            except:"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                traceback.print_exc()"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+                raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+            if p.returncode != 0:"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+                raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))"
            },
            "114": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 159,
                "PatchRowcode": " "
            },
            "115": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "     def fetch_file(self, in_path, out_path):"
            },
            "116": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         ''' fetch a file from zone to local '''"
            },
            "117": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " "
            },
            "118": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        in_path = self._normalize_path(in_path, self.get_zone_path())"
            },
            "119": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.zone)"
            },
            "120": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "121": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._copy_file(in_path, out_path)"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        p = self._buffered_exec_command('dd if=%s bs=%s' % (in_path, BUFSIZE), None)"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        with open(out_path, 'wb+') as out_file:"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            try:"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+                for chunk in p.stdout.read(BUFSIZE):"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+                    out_file.write(chunk)"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+            except:"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+                traceback.print_exc()"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+                raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+            stdout, stderr = p.communicate()"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            if p.returncode != 0:"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+                raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))"
            },
            "135": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " "
            },
            "136": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     def close(self):"
            },
            "137": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         ''' terminate the connection; nothing to do here '''"
            }
        },
        "frontPatchFile": [
            "# Based on local.py (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>",
            "# and chroot.py     (c) 2013, Maykel Moya <mmoya@speedyrails.com>",
            "# and jail.py       (c) 2013, Michael Scherer <misc@zarb.org>",
            "# (c) 2015, Dagobert Michelsen <dam@baltic-online.de>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import distutils.spawn",
            "import traceback",
            "import os",
            "import shutil",
            "import subprocess",
            "from subprocess import Popen,PIPE",
            "from ansible import errors",
            "from ansible.callbacks import vvv",
            "import ansible.constants as C",
            "",
            "class Connection(object):",
            "    ''' Local zone based connections '''",
            "",
            "    def _search_executable(self, executable):",
            "        cmd = distutils.spawn.find_executable(executable)",
            "        if not cmd:",
            "            raise errors.AnsibleError(\"%s command not found in PATH\") % executable",
            "        return cmd",
            "",
            "    def list_zones(self):",
            "        pipe = subprocess.Popen([self.zoneadm_cmd, 'list', '-ip'],",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "        #stdout, stderr = p.communicate()",
            "        zones = []",
            "        for l in pipe.stdout.readlines():",
            "          # 1:work:running:/zones/work:3126dc59-9a07-4829-cde9-a816e4c5040e:native:shared",
            "          s = l.split(':')",
            "          if s[1] != 'global':",
            "            zones.append(s[1])",
            "",
            "        return zones",
            "",
            "    def get_zone_path(self):",
            "        #solaris10vm# zoneadm -z cswbuild list -p         ",
            "        #-:cswbuild:installed:/zones/cswbuild:479f3c4b-d0c6-e97b-cd04-fd58f2c0238e:native:shared",
            "        pipe = subprocess.Popen([self.zoneadm_cmd, '-z', self.zone, 'list', '-p'],",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        #stdout, stderr = p.communicate()",
            "        path = pipe.stdout.readlines()[0].split(':')[3]",
            "        return path + '/root'",
            "        ",
            "    def __init__(self, runner, host, port, *args, **kwargs):",
            "        self.zone = host",
            "        self.runner = runner",
            "        self.host = host",
            "        self.has_pipelining = False",
            "        self.become_methods_supported=C.BECOME_METHODS",
            "",
            "        if os.geteuid() != 0:",
            "            raise errors.AnsibleError(\"zone connection requires running as root\")",
            "",
            "        self.zoneadm_cmd = self._search_executable('zoneadm')",
            "        self.zlogin_cmd = self._search_executable('zlogin')",
            "        ",
            "        if not self.zone in self.list_zones():",
            "            raise errors.AnsibleError(\"incorrect zone name %s\" % self.zone)",
            "",
            "",
            "        self.host = host",
            "        # port is unused, since this is local",
            "        self.port = port",
            "",
            "    def connect(self, port=None):",
            "        ''' connect to the zone; nothing to do here '''",
            "",
            "        vvv(\"THIS IS A LOCAL ZONE DIR\", host=self.zone)",
            "",
            "        return self",
            "",
            "    # a modifier",
            "    def _generate_cmd(self, executable, cmd):",
            "        if executable:",
            "            local_cmd = [self.zlogin_cmd, self.zone, executable, cmd]",
            "        else:",
            "            local_cmd = '%s \"%s\" %s' % (self.zlogin_cmd, self.zone, cmd)",
            "        return local_cmd",
            "",
            "    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable=None, in_data=None):",
            "        ''' run a command on the zone '''",
            "",
            "        if sudoable and self.runner.become and self.runner.become_method not in self.become_methods_supported:",
            "            raise errors.AnsibleError(\"Internal Error: this module does not support running commands via %s\" % self.runner.become_method)",
            "",
            "        if in_data:",
            "            raise errors.AnsibleError(\"Internal Error: this module does not support optimized module pipelining\")",
            "",
            "        # We happily ignore privilege escalation",
            "        if executable == '/bin/sh':",
            "          executable = None",
            "        local_cmd = self._generate_cmd(executable, cmd)",
            "",
            "        vvv(\"EXEC %s\" % (local_cmd), host=self.zone)",
            "        p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, basestring),",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        stdout, stderr = p.communicate()",
            "        return (p.returncode, '', stdout, stderr)",
            "",
            "    def _normalize_path(self, path, prefix):",
            "        if not path.startswith(os.path.sep):",
            "            path = os.path.join(os.path.sep, path)",
            "        normpath = os.path.normpath(path)",
            "        return os.path.join(prefix, normpath[1:])",
            "",
            "    def _copy_file(self, in_path, out_path):",
            "        if not os.path.exists(in_path):",
            "            raise errors.AnsibleFileNotFound(\"file or module does not exist: %s\" % in_path)",
            "        try:",
            "            shutil.copyfile(in_path, out_path)",
            "        except shutil.Error:",
            "            traceback.print_exc()",
            "            raise errors.AnsibleError(\"failed to copy: %s and %s are the same\" % (in_path, out_path))",
            "        except IOError:",
            "            traceback.print_exc()",
            "            raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)",
            "",
            "    def put_file(self, in_path, out_path):",
            "        ''' transfer a file from local to zone '''",
            "",
            "        out_path = self._normalize_path(out_path, self.get_zone_path())",
            "        vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.zone)",
            "",
            "        self._copy_file(in_path, out_path)",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        ''' fetch a file from zone to local '''",
            "",
            "        in_path = self._normalize_path(in_path, self.get_zone_path())",
            "        vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.zone)",
            "",
            "        self._copy_file(in_path, out_path)",
            "",
            "    def close(self):",
            "        ''' terminate the connection; nothing to do here '''",
            "        pass"
        ],
        "afterPatchFile": [
            "# Based on local.py (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>",
            "# and chroot.py     (c) 2013, Maykel Moya <mmoya@speedyrails.com>",
            "# and jail.py       (c) 2013, Michael Scherer <misc@zarb.org>",
            "# (c) 2015, Dagobert Michelsen <dam@baltic-online.de>",
            "# (c) 2015, Toshio Kuratomi <tkuratomi@ansible.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import distutils.spawn",
            "import traceback",
            "import os",
            "import subprocess",
            "from ansible import errors",
            "from ansible.callbacks import vvv",
            "import ansible.constants as C",
            "",
            "BUFSIZE = 4096",
            "",
            "class Connection(object):",
            "    ''' Local zone based connections '''",
            "",
            "    def _search_executable(self, executable):",
            "        cmd = distutils.spawn.find_executable(executable)",
            "        if not cmd:",
            "            raise errors.AnsibleError(\"%s command not found in PATH\") % executable",
            "        return cmd",
            "",
            "    def list_zones(self):",
            "        pipe = subprocess.Popen([self.zoneadm_cmd, 'list', '-ip'],",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        zones = []",
            "        for l in pipe.stdout.readlines():",
            "          # 1:work:running:/zones/work:3126dc59-9a07-4829-cde9-a816e4c5040e:native:shared",
            "          s = l.split(':')",
            "          if s[1] != 'global':",
            "            zones.append(s[1])",
            "",
            "        return zones",
            "",
            "    def get_zone_path(self):",
            "        #solaris10vm# zoneadm -z cswbuild list -p         ",
            "        #-:cswbuild:installed:/zones/cswbuild:479f3c4b-d0c6-e97b-cd04-fd58f2c0238e:native:shared",
            "        pipe = subprocess.Popen([self.zoneadm_cmd, '-z', self.zone, 'list', '-p'],",
            "                             cwd=self.runner.basedir,",
            "                             stdin=subprocess.PIPE,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        #stdout, stderr = p.communicate()",
            "        path = pipe.stdout.readlines()[0].split(':')[3]",
            "        return path + '/root'",
            "        ",
            "    def __init__(self, runner, host, port, *args, **kwargs):",
            "        self.zone = host",
            "        self.runner = runner",
            "        self.host = host",
            "        self.has_pipelining = False",
            "        self.become_methods_supported=C.BECOME_METHODS",
            "",
            "        if os.geteuid() != 0:",
            "            raise errors.AnsibleError(\"zone connection requires running as root\")",
            "",
            "        self.zoneadm_cmd = self._search_executable('zoneadm')",
            "        self.zlogin_cmd = self._search_executable('zlogin')",
            "        ",
            "        if not self.zone in self.list_zones():",
            "            raise errors.AnsibleError(\"incorrect zone name %s\" % self.zone)",
            "",
            "",
            "        self.host = host",
            "        # port is unused, since this is local",
            "        self.port = port",
            "",
            "    def connect(self, port=None):",
            "        ''' connect to the zone; nothing to do here '''",
            "",
            "        vvv(\"THIS IS A LOCAL ZONE DIR\", host=self.zone)",
            "",
            "        return self",
            "",
            "    # a modifier",
            "    def _generate_cmd(self, executable, cmd):",
            "        if executable:",
            "            ### TODO: Why was \"-c\" removed from here? (vs jail.py)",
            "            local_cmd = [self.zlogin_cmd, self.zone, executable, cmd]",
            "        else:",
            "            local_cmd = '%s \"%s\" %s' % (self.zlogin_cmd, self.zone, cmd)",
            "        return local_cmd",
            "",
            "    def _buffered_exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable=None, in_data=None, stdin=subprocess.PIPE):",
            "        ''' run a command on the zone.  This is only needed for implementing",
            "        put_file() get_file() so that we don't have to read the whole file",
            "        into memory.",
            "",
            "        compared to exec_command() it looses some niceties like being able to",
            "        return the process's exit code immediately.",
            "        '''",
            "",
            "        if sudoable and self.runner.become and self.runner.become_method not in self.become_methods_supported:",
            "            raise errors.AnsibleError(\"Internal Error: this module does not support running commands via %s\" % self.runner.become_method)",
            "",
            "        if in_data:",
            "            raise errors.AnsibleError(\"Internal Error: this module does not support optimized module pipelining\")",
            "",
            "        # We happily ignore privilege escalation",
            "        local_cmd = self._generate_cmd(executable, cmd)",
            "",
            "        vvv(\"EXEC %s\" % (local_cmd), host=self.zone)",
            "        p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, basestring),",
            "                             cwd=self.runner.basedir,",
            "                             stdin=stdin,",
            "                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "        return p",
            "",
            "    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable=None, in_data=None):",
            "        ''' run a command on the zone '''",
            "",
            "        ### TODO: Why all the precautions not to specify /bin/sh? (vs jail.py)",
            "        if executable == '/bin/sh':",
            "          executable = None",
            "",
            "        p = self._buffered_exec_command(cmd, tmp_path, become_user, sudoable, executable, in_data)",
            "",
            "        stdout, stderr = p.communicate()",
            "        return (p.returncode, '', stdout, stderr)",
            "",
            "    def put_file(self, in_path, out_path):",
            "        ''' transfer a file from local to zone '''",
            "",
            "        vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.zone)",
            "",
            "        with open(in_path, 'rb') as in_file:",
            "            p = self._buffered_exec_command('dd of=%s' % out_path, None, stdin=in_file)",
            "            try:",
            "                stdout, stderr = p.communicate()",
            "            except:",
            "                traceback.print_exc()",
            "                raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)",
            "            if p.returncode != 0:",
            "                raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        ''' fetch a file from zone to local '''",
            "",
            "        vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.zone)",
            "",
            "",
            "        p = self._buffered_exec_command('dd if=%s bs=%s' % (in_path, BUFSIZE), None)",
            "",
            "        with open(out_path, 'wb+') as out_file:",
            "            try:",
            "                for chunk in p.stdout.read(BUFSIZE):",
            "                    out_file.write(chunk)",
            "            except:",
            "                traceback.print_exc()",
            "                raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)",
            "            stdout, stderr = p.communicate()",
            "            if p.returncode != 0:",
            "                raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))",
            "",
            "    def close(self):",
            "        ''' terminate the connection; nothing to do here '''",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [],
            "28": [],
            "47": [
                "Connection",
                "list_zones"
            ],
            "105": [
                "Connection",
                "exec_command"
            ],
            "106": [
                "Connection",
                "exec_command"
            ],
            "115": [
                "Connection",
                "exec_command"
            ],
            "116": [
                "Connection",
                "exec_command"
            ],
            "122": [
                "Connection",
                "exec_command"
            ],
            "128": [
                "Connection",
                "_normalize_path"
            ],
            "129": [
                "Connection",
                "_normalize_path"
            ],
            "130": [
                "Connection",
                "_normalize_path"
            ],
            "131": [
                "Connection",
                "_normalize_path"
            ],
            "132": [
                "Connection",
                "_normalize_path"
            ],
            "133": [
                "Connection"
            ],
            "134": [
                "Connection",
                "_copy_file"
            ],
            "135": [
                "Connection",
                "_copy_file"
            ],
            "136": [
                "Connection",
                "_copy_file"
            ],
            "137": [
                "Connection",
                "_copy_file"
            ],
            "138": [
                "Connection",
                "_copy_file"
            ],
            "139": [
                "Connection",
                "_copy_file"
            ],
            "140": [
                "Connection",
                "_copy_file"
            ],
            "141": [
                "Connection",
                "_copy_file"
            ],
            "142": [
                "Connection",
                "_copy_file"
            ],
            "143": [
                "Connection",
                "_copy_file"
            ],
            "144": [
                "Connection",
                "_copy_file"
            ],
            "145": [
                "Connection"
            ],
            "149": [
                "Connection",
                "put_file"
            ],
            "152": [
                "Connection",
                "put_file"
            ],
            "157": [
                "Connection",
                "fetch_file"
            ],
            "160": [
                "Connection",
                "fetch_file"
            ]
        },
        "addLocation": []
    }
}