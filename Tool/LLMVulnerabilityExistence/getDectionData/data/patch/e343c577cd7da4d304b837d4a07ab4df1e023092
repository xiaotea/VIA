{
    "thefuck/rules/dirty_untar.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " def side_effect(old_cmd, command):"
            },
            "1": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     with tarfile.TarFile(_tar_file(old_cmd.script_parts)[0]) as archive:"
            },
            "2": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         for file in archive.getnames():"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            if not os.path.abspath(file).startswith(os.getcwd()):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+                # it's unsafe to overwrite files outside of the current directory"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                continue"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             try:"
            },
            "8": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "                 os.remove(file)"
            },
            "9": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             except OSError:"
            }
        },
        "frontPatchFile": [
            "import tarfile",
            "import os",
            "from thefuck.utils import for_app",
            "from thefuck.shells import shell",
            "",
            "",
            "tar_extensions = ('.tar', '.tar.Z', '.tar.bz2', '.tar.gz', '.tar.lz',",
            "                  '.tar.lzma', '.tar.xz', '.taz', '.tb2', '.tbz', '.tbz2',",
            "                  '.tgz', '.tlz', '.txz', '.tz')",
            "",
            "",
            "def _is_tar_extract(cmd):",
            "    if '--extract' in cmd:",
            "        return True",
            "",
            "    cmd = cmd.split()",
            "",
            "    return len(cmd) > 1 and 'x' in cmd[1]",
            "",
            "",
            "def _tar_file(cmd):",
            "    for c in cmd:",
            "        for ext in tar_extensions:",
            "            if c.endswith(ext):",
            "                return (c, c[0:len(c) - len(ext)])",
            "",
            "",
            "@for_app('tar')",
            "def match(command):",
            "    return ('-C' not in command.script",
            "            and _is_tar_extract(command.script)",
            "            and _tar_file(command.script_parts) is not None)",
            "",
            "",
            "def get_new_command(command):",
            "    dir = shell.quote(_tar_file(command.script_parts)[1])",
            "    return shell.and_('mkdir -p {dir}', '{cmd} -C {dir}') \\",
            "        .format(dir=dir, cmd=command.script)",
            "",
            "",
            "def side_effect(old_cmd, command):",
            "    with tarfile.TarFile(_tar_file(old_cmd.script_parts)[0]) as archive:",
            "        for file in archive.getnames():",
            "            try:",
            "                os.remove(file)",
            "            except OSError:",
            "                # does not try to remove directories as we cannot know if they",
            "                # already existed before",
            "                pass"
        ],
        "afterPatchFile": [
            "import tarfile",
            "import os",
            "from thefuck.utils import for_app",
            "from thefuck.shells import shell",
            "",
            "",
            "tar_extensions = ('.tar', '.tar.Z', '.tar.bz2', '.tar.gz', '.tar.lz',",
            "                  '.tar.lzma', '.tar.xz', '.taz', '.tb2', '.tbz', '.tbz2',",
            "                  '.tgz', '.tlz', '.txz', '.tz')",
            "",
            "",
            "def _is_tar_extract(cmd):",
            "    if '--extract' in cmd:",
            "        return True",
            "",
            "    cmd = cmd.split()",
            "",
            "    return len(cmd) > 1 and 'x' in cmd[1]",
            "",
            "",
            "def _tar_file(cmd):",
            "    for c in cmd:",
            "        for ext in tar_extensions:",
            "            if c.endswith(ext):",
            "                return (c, c[0:len(c) - len(ext)])",
            "",
            "",
            "@for_app('tar')",
            "def match(command):",
            "    return ('-C' not in command.script",
            "            and _is_tar_extract(command.script)",
            "            and _tar_file(command.script_parts) is not None)",
            "",
            "",
            "def get_new_command(command):",
            "    dir = shell.quote(_tar_file(command.script_parts)[1])",
            "    return shell.and_('mkdir -p {dir}', '{cmd} -C {dir}') \\",
            "        .format(dir=dir, cmd=command.script)",
            "",
            "",
            "def side_effect(old_cmd, command):",
            "    with tarfile.TarFile(_tar_file(old_cmd.script_parts)[0]) as archive:",
            "        for file in archive.getnames():",
            "            if not os.path.abspath(file).startswith(os.getcwd()):",
            "                # it's unsafe to overwrite files outside of the current directory",
            "                continue",
            "",
            "            try:",
            "                os.remove(file)",
            "            except OSError:",
            "                # does not try to remove directories as we cannot know if they",
            "                # already existed before",
            "                pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs"
        ]
    },
    "thefuck/rules/dirty_unzip.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " def side_effect(old_cmd, command):"
            },
            "1": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     with zipfile.ZipFile(_zip_file(old_cmd), 'r') as archive:"
            },
            "2": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         for file in archive.namelist():"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            if not os.path.abspath(file).startswith(os.getcwd()):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                # it's unsafe to overwrite files outside of the current directory"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                continue"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "             try:"
            },
            "8": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "                 os.remove(file)"
            },
            "9": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "             except OSError:"
            }
        },
        "frontPatchFile": [
            "import os",
            "import zipfile",
            "from thefuck.utils import for_app",
            "from thefuck.shells import shell",
            "",
            "",
            "def _is_bad_zip(file):",
            "    try:",
            "        with zipfile.ZipFile(file, 'r') as archive:",
            "            return len(archive.namelist()) > 1",
            "    except Exception:",
            "        return False",
            "",
            "",
            "def _zip_file(command):",
            "    # unzip works that way:",
            "    # unzip [-flags] file[.zip] [file(s) ...] [-x file(s) ...]",
            "    #                ^          ^ files to unzip from the archive",
            "    #                archive to unzip",
            "    for c in command.script_parts[1:]:",
            "        if not c.startswith('-'):",
            "            if c.endswith('.zip'):",
            "                return c",
            "            else:",
            "                return u'{}.zip'.format(c)",
            "",
            "",
            "@for_app('unzip')",
            "def match(command):",
            "    if '-d' in command.script:",
            "        return False",
            "",
            "    zip_file = _zip_file(command)",
            "    if zip_file:",
            "        return _is_bad_zip(zip_file)",
            "    else:",
            "        return False",
            "",
            "",
            "def get_new_command(command):",
            "    return u'{} -d {}'.format(",
            "        command.script, shell.quote(_zip_file(command)[:-4]))",
            "",
            "",
            "def side_effect(old_cmd, command):",
            "    with zipfile.ZipFile(_zip_file(old_cmd), 'r') as archive:",
            "        for file in archive.namelist():",
            "            try:",
            "                os.remove(file)",
            "            except OSError:",
            "                # does not try to remove directories as we cannot know if they",
            "                # already existed before",
            "                pass",
            "",
            "",
            "requires_output = False"
        ],
        "afterPatchFile": [
            "import os",
            "import zipfile",
            "from thefuck.utils import for_app",
            "from thefuck.shells import shell",
            "",
            "",
            "def _is_bad_zip(file):",
            "    try:",
            "        with zipfile.ZipFile(file, 'r') as archive:",
            "            return len(archive.namelist()) > 1",
            "    except Exception:",
            "        return False",
            "",
            "",
            "def _zip_file(command):",
            "    # unzip works that way:",
            "    # unzip [-flags] file[.zip] [file(s) ...] [-x file(s) ...]",
            "    #                ^          ^ files to unzip from the archive",
            "    #                archive to unzip",
            "    for c in command.script_parts[1:]:",
            "        if not c.startswith('-'):",
            "            if c.endswith('.zip'):",
            "                return c",
            "            else:",
            "                return u'{}.zip'.format(c)",
            "",
            "",
            "@for_app('unzip')",
            "def match(command):",
            "    if '-d' in command.script:",
            "        return False",
            "",
            "    zip_file = _zip_file(command)",
            "    if zip_file:",
            "        return _is_bad_zip(zip_file)",
            "    else:",
            "        return False",
            "",
            "",
            "def get_new_command(command):",
            "    return u'{} -d {}'.format(",
            "        command.script, shell.quote(_zip_file(command)[:-4]))",
            "",
            "",
            "def side_effect(old_cmd, command):",
            "    with zipfile.ZipFile(_zip_file(old_cmd), 'r') as archive:",
            "        for file in archive.namelist():",
            "            if not os.path.abspath(file).startswith(os.getcwd()):",
            "                # it's unsafe to overwrite files outside of the current directory",
            "                continue",
            "",
            "            try:",
            "                os.remove(file)",
            "            except OSError:",
            "                # does not try to remove directories as we cannot know if they",
            "                # already existed before",
            "                pass",
            "",
            "",
            "requires_output = False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs"
        ]
    }
}