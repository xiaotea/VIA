{
    "lib/ansible/module_utils/identity/keycloak/keycloak.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         auth_keycloak_url=dict(type='str', aliases=['url'], required=True),"
            },
            "1": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         auth_client_id=dict(type='str', default='admin-cli'),"
            },
            "2": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         auth_realm=dict(type='str', required=True),"
            },
            "3": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        auth_client_secret=dict(type='str', default=None),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        auth_client_secret=dict(type='str', default=None, no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         auth_username=dict(type='str', aliases=['username'], required=True),"
            },
            "6": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         auth_password=dict(type='str', aliases=['password'], required=True, no_log=True),"
            },
            "7": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         validate_certs=dict(type='bool', default=True)"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2017, Eike Frost <ei@kefro.st>",
            "#",
            "# This code is part of Ansible, but is an independent component.",
            "# This particular file snippet, and this file snippet only, is BSD licensed.",
            "# Modules you write using this snippet, which is embedded dynamically by Ansible",
            "# still belong to the author of the module, and may assign their own license",
            "# to the complete work.",
            "#",
            "# Redistribution and use in source and binary forms, with or without modification,",
            "# are permitted provided that the following conditions are met:",
            "#",
            "#    * Redistributions of source code must retain the above copyright",
            "#      notice, this list of conditions and the following disclaimer.",
            "#    * Redistributions in binary form must reproduce the above copyright notice,",
            "#      this list of conditions and the following disclaimer in the documentation",
            "#      and/or other materials provided with the distribution.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND",
            "# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.",
            "# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,",
            "# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
            "# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT",
            "# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE",
            "# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "import json",
            "",
            "from ansible.module_utils.urls import open_url",
            "from ansible.module_utils.six.moves.urllib.parse import urlencode",
            "from ansible.module_utils.six.moves.urllib.error import HTTPError",
            "",
            "URL_TOKEN = \"{url}/realms/{realm}/protocol/openid-connect/token\"",
            "URL_CLIENT = \"{url}/admin/realms/{realm}/clients/{id}\"",
            "URL_CLIENTS = \"{url}/admin/realms/{realm}/clients\"",
            "URL_CLIENT_ROLES = \"{url}/admin/realms/{realm}/clients/{id}/roles\"",
            "URL_REALM_ROLES = \"{url}/admin/realms/{realm}/roles\"",
            "",
            "URL_CLIENTTEMPLATE = \"{url}/admin/realms/{realm}/client-templates/{id}\"",
            "URL_CLIENTTEMPLATES = \"{url}/admin/realms/{realm}/client-templates\"",
            "URL_GROUPS = \"{url}/admin/realms/{realm}/groups\"",
            "URL_GROUP = \"{url}/admin/realms/{realm}/groups/{groupid}\"",
            "",
            "",
            "def keycloak_argument_spec():",
            "    \"\"\"",
            "    Returns argument_spec of options common to keycloak_*-modules",
            "",
            "    :return: argument_spec dict",
            "    \"\"\"",
            "    return dict(",
            "        auth_keycloak_url=dict(type='str', aliases=['url'], required=True),",
            "        auth_client_id=dict(type='str', default='admin-cli'),",
            "        auth_realm=dict(type='str', required=True),",
            "        auth_client_secret=dict(type='str', default=None),",
            "        auth_username=dict(type='str', aliases=['username'], required=True),",
            "        auth_password=dict(type='str', aliases=['password'], required=True, no_log=True),",
            "        validate_certs=dict(type='bool', default=True)",
            "    )",
            "",
            "",
            "def camel(words):",
            "    return words.split('_')[0] + ''.join(x.capitalize() or '_' for x in words.split('_')[1:])",
            "",
            "",
            "class KeycloakError(Exception):",
            "    pass",
            "",
            "",
            "def get_token(base_url, validate_certs, auth_realm, client_id,",
            "              auth_username, auth_password, client_secret):",
            "    auth_url = URL_TOKEN.format(url=base_url, realm=auth_realm)",
            "    temp_payload = {",
            "        'grant_type': 'password',",
            "        'client_id': client_id,",
            "        'client_secret': client_secret,",
            "        'username': auth_username,",
            "        'password': auth_password,",
            "    }",
            "    # Remove empty items, for instance missing client_secret",
            "    payload = dict(",
            "        (k, v) for k, v in temp_payload.items() if v is not None)",
            "    try:",
            "        r = json.load(open_url(auth_url, method='POST',",
            "                               validate_certs=validate_certs,",
            "                               data=urlencode(payload)))",
            "    except ValueError as e:",
            "        raise KeycloakError(",
            "            'API returned invalid JSON when trying to obtain access token from %s: %s'",
            "            % (auth_url, str(e)))",
            "    except Exception as e:",
            "        raise KeycloakError('Could not obtain access token from %s: %s'",
            "                            % (auth_url, str(e)))",
            "",
            "    try:",
            "        return {",
            "            'Authorization': 'Bearer ' + r['access_token'],",
            "            'Content-Type': 'application/json'",
            "        }",
            "    except KeyError:",
            "        raise KeycloakError(",
            "            'Could not obtain access token from %s' % auth_url)",
            "",
            "",
            "class KeycloakAPI(object):",
            "    \"\"\" Keycloak API access; Keycloak uses OAuth 2.0 to protect its API, an access token for which",
            "        is obtained through OpenID connect",
            "    \"\"\"",
            "    def __init__(self, module, connection_header):",
            "        self.module = module",
            "        self.baseurl = self.module.params.get('auth_keycloak_url')",
            "        self.validate_certs = self.module.params.get('validate_certs')",
            "        self.restheaders = connection_header",
            "",
            "    def get_clients(self, realm='master', filter=None):",
            "        \"\"\" Obtains client representations for clients in a realm",
            "",
            "        :param realm: realm to be queried",
            "        :param filter: if defined, only the client with clientId specified in the filter is returned",
            "        :return: list of dicts of client representations",
            "        \"\"\"",
            "        clientlist_url = URL_CLIENTS.format(url=self.baseurl, realm=realm)",
            "        if filter is not None:",
            "            clientlist_url += '?clientId=%s' % filter",
            "",
            "        try:",
            "            return json.load(open_url(clientlist_url, method='GET', headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "        except ValueError as e:",
            "            self.module.fail_json(msg='API returned incorrect JSON when trying to obtain list of clients for realm %s: %s'",
            "                                      % (realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not obtain list of clients for realm %s: %s'",
            "                                      % (realm, str(e)))",
            "",
            "    def get_client_by_clientid(self, client_id, realm='master'):",
            "        \"\"\" Get client representation by clientId",
            "        :param client_id: The clientId to be queried",
            "        :param realm: realm from which to obtain the client representation",
            "        :return: dict with a client representation or None if none matching exist",
            "        \"\"\"",
            "        r = self.get_clients(realm=realm, filter=client_id)",
            "        if len(r) > 0:",
            "            return r[0]",
            "        else:",
            "            return None",
            "",
            "    def get_client_by_id(self, id, realm='master'):",
            "        \"\"\" Obtain client representation by id",
            "",
            "        :param id: id (not clientId) of client to be queried",
            "        :param realm: client from this realm",
            "        :return: dict of client representation or None if none matching exist",
            "        \"\"\"",
            "        client_url = URL_CLIENT.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return json.load(open_url(client_url, method='GET', headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "",
            "        except HTTPError as e:",
            "            if e.code == 404:",
            "                return None",
            "            else:",
            "                self.module.fail_json(msg='Could not obtain client %s for realm %s: %s'",
            "                                          % (id, realm, str(e)))",
            "        except ValueError as e:",
            "            self.module.fail_json(msg='API returned incorrect JSON when trying to obtain client %s for realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not obtain client %s for realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def get_client_id(self, client_id, realm='master'):",
            "        \"\"\" Obtain id of client by client_id",
            "",
            "        :param client_id: client_id of client to be queried",
            "        :param realm: client template from this realm",
            "        :return: id of client (usually a UUID)",
            "        \"\"\"",
            "        result = self.get_client_by_clientid(client_id, realm)",
            "        if isinstance(result, dict) and 'id' in result:",
            "            return result['id']",
            "        else:",
            "            return None",
            "",
            "    def update_client(self, id, clientrep, realm=\"master\"):",
            "        \"\"\" Update an existing client",
            "        :param id: id (not clientId) of client to be updated in Keycloak",
            "        :param clientrep: corresponding (partial/full) client representation with updates",
            "        :param realm: realm the client is in",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        client_url = URL_CLIENT.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return open_url(client_url, method='PUT', headers=self.restheaders,",
            "                            data=json.dumps(clientrep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not update client %s in realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def create_client(self, clientrep, realm=\"master\"):",
            "        \"\"\" Create a client in keycloak",
            "        :param clientrep: Client representation of client to be created. Must at least contain field clientId",
            "        :param realm: realm for client to be created",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        client_url = URL_CLIENTS.format(url=self.baseurl, realm=realm)",
            "",
            "        try:",
            "            return open_url(client_url, method='POST', headers=self.restheaders,",
            "                            data=json.dumps(clientrep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not create client %s in realm %s: %s'",
            "                                      % (clientrep['clientId'], realm, str(e)))",
            "",
            "    def delete_client(self, id, realm=\"master\"):",
            "        \"\"\" Delete a client from Keycloak",
            "",
            "        :param id: id (not clientId) of client to be deleted",
            "        :param realm: realm of client to be deleted",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        client_url = URL_CLIENT.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return open_url(client_url, method='DELETE', headers=self.restheaders,",
            "                            validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not delete client %s in realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def get_client_templates(self, realm='master'):",
            "        \"\"\" Obtains client template representations for client templates in a realm",
            "",
            "        :param realm: realm to be queried",
            "        :return: list of dicts of client representations",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATES.format(url=self.baseurl, realm=realm)",
            "",
            "        try:",
            "            return json.load(open_url(url, method='GET', headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "        except ValueError as e:",
            "            self.module.fail_json(msg='API returned incorrect JSON when trying to obtain list of client templates for realm %s: %s'",
            "                                      % (realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not obtain list of client templates for realm %s: %s'",
            "                                      % (realm, str(e)))",
            "",
            "    def get_client_template_by_id(self, id, realm='master'):",
            "        \"\"\" Obtain client template representation by id",
            "",
            "        :param id: id (not name) of client template to be queried",
            "        :param realm: client template from this realm",
            "        :return: dict of client template representation or None if none matching exist",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATE.format(url=self.baseurl, id=id, realm=realm)",
            "",
            "        try:",
            "            return json.load(open_url(url, method='GET', headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "        except ValueError as e:",
            "            self.module.fail_json(msg='API returned incorrect JSON when trying to obtain client templates %s for realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not obtain client template %s for realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def get_client_template_by_name(self, name, realm='master'):",
            "        \"\"\" Obtain client template representation by name",
            "",
            "        :param name: name of client template to be queried",
            "        :param realm: client template from this realm",
            "        :return: dict of client template representation or None if none matching exist",
            "        \"\"\"",
            "        result = self.get_client_templates(realm)",
            "        if isinstance(result, list):",
            "            result = [x for x in result if x['name'] == name]",
            "            if len(result) > 0:",
            "                return result[0]",
            "        return None",
            "",
            "    def get_client_template_id(self, name, realm='master'):",
            "        \"\"\" Obtain client template id by name",
            "",
            "        :param name: name of client template to be queried",
            "        :param realm: client template from this realm",
            "        :return: client template id (usually a UUID)",
            "        \"\"\"",
            "        result = self.get_client_template_by_name(name, realm)",
            "        if isinstance(result, dict) and 'id' in result:",
            "            return result['id']",
            "        else:",
            "            return None",
            "",
            "    def update_client_template(self, id, clienttrep, realm=\"master\"):",
            "        \"\"\" Update an existing client template",
            "        :param id: id (not name) of client template to be updated in Keycloak",
            "        :param clienttrep: corresponding (partial/full) client template representation with updates",
            "        :param realm: realm the client template is in",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATE.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return open_url(url, method='PUT', headers=self.restheaders,",
            "                            data=json.dumps(clienttrep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not update client template %s in realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def create_client_template(self, clienttrep, realm=\"master\"):",
            "        \"\"\" Create a client in keycloak",
            "        :param clienttrep: Client template representation of client template to be created. Must at least contain field name",
            "        :param realm: realm for client template to be created in",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATES.format(url=self.baseurl, realm=realm)",
            "",
            "        try:",
            "            return open_url(url, method='POST', headers=self.restheaders,",
            "                            data=json.dumps(clienttrep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not create client template %s in realm %s: %s'",
            "                                      % (clienttrep['clientId'], realm, str(e)))",
            "",
            "    def delete_client_template(self, id, realm=\"master\"):",
            "        \"\"\" Delete a client template from Keycloak",
            "",
            "        :param id: id (not name) of client to be deleted",
            "        :param realm: realm of client template to be deleted",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATE.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return open_url(url, method='DELETE', headers=self.restheaders,",
            "                            validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not delete client template %s in realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def get_groups(self, realm=\"master\"):",
            "        \"\"\" Fetch the name and ID of all groups on the Keycloak server.",
            "",
            "        To fetch the full data of the group, make a subsequent call to",
            "        get_group_by_groupid, passing in the ID of the group you wish to return.",
            "",
            "        :param realm: Return the groups of this realm (default \"master\").",
            "        \"\"\"",
            "        groups_url = URL_GROUPS.format(url=self.baseurl, realm=realm)",
            "        try:",
            "            return json.load(open_url(groups_url, method=\"GET\", headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Could not fetch list of groups in realm %s: %s\"",
            "                                      % (realm, str(e)))",
            "",
            "    def get_group_by_groupid(self, gid, realm=\"master\"):",
            "        \"\"\" Fetch a keycloak group from the provided realm using the group's unique ID.",
            "",
            "        If the group does not exist, None is returned.",
            "",
            "        gid is a UUID provided by the Keycloak API",
            "        :param gid: UUID of the group to be returned",
            "        :param realm: Realm in which the group resides; default 'master'.",
            "        \"\"\"",
            "        groups_url = URL_GROUP.format(url=self.baseurl, realm=realm, groupid=gid)",
            "        try:",
            "            return json.load(open_url(groups_url, method=\"GET\", headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "",
            "        except HTTPError as e:",
            "            if e.code == 404:",
            "                return None",
            "            else:",
            "                self.module.fail_json(msg=\"Could not fetch group %s in realm %s: %s\"",
            "                                          % (gid, realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Could not fetch group %s in realm %s: %s\"",
            "                                      % (gid, realm, str(e)))",
            "",
            "    def get_group_by_name(self, name, realm=\"master\"):",
            "        \"\"\" Fetch a keycloak group within a realm based on its name.",
            "",
            "        The Keycloak API does not allow filtering of the Groups resource by name.",
            "        As a result, this method first retrieves the entire list of groups - name and ID -",
            "        then performs a second query to fetch the group.",
            "",
            "        If the group does not exist, None is returned.",
            "        :param name: Name of the group to fetch.",
            "        :param realm: Realm in which the group resides; default 'master'",
            "        \"\"\"",
            "        groups_url = URL_GROUPS.format(url=self.baseurl, realm=realm)",
            "        try:",
            "            all_groups = self.get_groups(realm=realm)",
            "",
            "            for group in all_groups:",
            "                if group['name'] == name:",
            "                    return self.get_group_by_groupid(group['id'], realm=realm)",
            "",
            "            return None",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Could not fetch group %s in realm %s: %s\"",
            "                                      % (name, realm, str(e)))",
            "",
            "    def create_group(self, grouprep, realm=\"master\"):",
            "        \"\"\" Create a Keycloak group.",
            "",
            "        :param grouprep: a GroupRepresentation of the group to be created. Must contain at minimum the field name.",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        groups_url = URL_GROUPS.format(url=self.baseurl, realm=realm)",
            "        try:",
            "            return open_url(groups_url, method='POST', headers=self.restheaders,",
            "                            data=json.dumps(grouprep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Could not create group %s in realm %s: %s\"",
            "                                      % (grouprep['name'], realm, str(e)))",
            "",
            "    def update_group(self, grouprep, realm=\"master\"):",
            "        \"\"\" Update an existing group.",
            "",
            "        :param grouprep: A GroupRepresentation of the updated group.",
            "        :return HTTPResponse object on success",
            "        \"\"\"",
            "        group_url = URL_GROUP.format(url=self.baseurl, realm=realm, groupid=grouprep['id'])",
            "",
            "        try:",
            "            return open_url(group_url, method='PUT', headers=self.restheaders,",
            "                            data=json.dumps(grouprep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not update group %s in realm %s: %s'",
            "                                      % (grouprep['name'], realm, str(e)))",
            "",
            "    def delete_group(self, name=None, groupid=None, realm=\"master\"):",
            "        \"\"\" Delete a group. One of name or groupid must be provided.",
            "",
            "        Providing the group ID is preferred as it avoids a second lookup to",
            "        convert a group name to an ID.",
            "",
            "        :param name: The name of the group. A lookup will be performed to retrieve the group ID.",
            "        :param groupid: The ID of the group (preferred to name).",
            "        :param realm: The realm in which this group resides, default \"master\".",
            "        \"\"\"",
            "",
            "        if groupid is None and name is None:",
            "            # prefer an exception since this is almost certainly a programming error in the module itself.",
            "            raise Exception(\"Unable to delete group - one of group ID or name must be provided.\")",
            "",
            "        # only lookup the name if groupid isn't provided.",
            "        # in the case that both are provided, prefer the ID, since it's one",
            "        # less lookup.",
            "        if groupid is None and name is not None:",
            "            for group in self.get_groups(realm=realm):",
            "                if group['name'] == name:",
            "                    groupid = group['id']",
            "                    break",
            "",
            "        # if the group doesn't exist - no problem, nothing to delete.",
            "        if groupid is None:",
            "            return None",
            "",
            "        # should have a good groupid by here.",
            "        group_url = URL_GROUP.format(realm=realm, groupid=groupid, url=self.baseurl)",
            "        try:",
            "            return open_url(group_url, method='DELETE', headers=self.restheaders,",
            "                            validate_certs=self.validate_certs)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Unable to delete group %s: %s\" % (groupid, str(e)))"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2017, Eike Frost <ei@kefro.st>",
            "#",
            "# This code is part of Ansible, but is an independent component.",
            "# This particular file snippet, and this file snippet only, is BSD licensed.",
            "# Modules you write using this snippet, which is embedded dynamically by Ansible",
            "# still belong to the author of the module, and may assign their own license",
            "# to the complete work.",
            "#",
            "# Redistribution and use in source and binary forms, with or without modification,",
            "# are permitted provided that the following conditions are met:",
            "#",
            "#    * Redistributions of source code must retain the above copyright",
            "#      notice, this list of conditions and the following disclaimer.",
            "#    * Redistributions in binary form must reproduce the above copyright notice,",
            "#      this list of conditions and the following disclaimer in the documentation",
            "#      and/or other materials provided with the distribution.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND",
            "# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.",
            "# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,",
            "# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
            "# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT",
            "# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE",
            "# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "import json",
            "",
            "from ansible.module_utils.urls import open_url",
            "from ansible.module_utils.six.moves.urllib.parse import urlencode",
            "from ansible.module_utils.six.moves.urllib.error import HTTPError",
            "",
            "URL_TOKEN = \"{url}/realms/{realm}/protocol/openid-connect/token\"",
            "URL_CLIENT = \"{url}/admin/realms/{realm}/clients/{id}\"",
            "URL_CLIENTS = \"{url}/admin/realms/{realm}/clients\"",
            "URL_CLIENT_ROLES = \"{url}/admin/realms/{realm}/clients/{id}/roles\"",
            "URL_REALM_ROLES = \"{url}/admin/realms/{realm}/roles\"",
            "",
            "URL_CLIENTTEMPLATE = \"{url}/admin/realms/{realm}/client-templates/{id}\"",
            "URL_CLIENTTEMPLATES = \"{url}/admin/realms/{realm}/client-templates\"",
            "URL_GROUPS = \"{url}/admin/realms/{realm}/groups\"",
            "URL_GROUP = \"{url}/admin/realms/{realm}/groups/{groupid}\"",
            "",
            "",
            "def keycloak_argument_spec():",
            "    \"\"\"",
            "    Returns argument_spec of options common to keycloak_*-modules",
            "",
            "    :return: argument_spec dict",
            "    \"\"\"",
            "    return dict(",
            "        auth_keycloak_url=dict(type='str', aliases=['url'], required=True),",
            "        auth_client_id=dict(type='str', default='admin-cli'),",
            "        auth_realm=dict(type='str', required=True),",
            "        auth_client_secret=dict(type='str', default=None, no_log=True),",
            "        auth_username=dict(type='str', aliases=['username'], required=True),",
            "        auth_password=dict(type='str', aliases=['password'], required=True, no_log=True),",
            "        validate_certs=dict(type='bool', default=True)",
            "    )",
            "",
            "",
            "def camel(words):",
            "    return words.split('_')[0] + ''.join(x.capitalize() or '_' for x in words.split('_')[1:])",
            "",
            "",
            "class KeycloakError(Exception):",
            "    pass",
            "",
            "",
            "def get_token(base_url, validate_certs, auth_realm, client_id,",
            "              auth_username, auth_password, client_secret):",
            "    auth_url = URL_TOKEN.format(url=base_url, realm=auth_realm)",
            "    temp_payload = {",
            "        'grant_type': 'password',",
            "        'client_id': client_id,",
            "        'client_secret': client_secret,",
            "        'username': auth_username,",
            "        'password': auth_password,",
            "    }",
            "    # Remove empty items, for instance missing client_secret",
            "    payload = dict(",
            "        (k, v) for k, v in temp_payload.items() if v is not None)",
            "    try:",
            "        r = json.load(open_url(auth_url, method='POST',",
            "                               validate_certs=validate_certs,",
            "                               data=urlencode(payload)))",
            "    except ValueError as e:",
            "        raise KeycloakError(",
            "            'API returned invalid JSON when trying to obtain access token from %s: %s'",
            "            % (auth_url, str(e)))",
            "    except Exception as e:",
            "        raise KeycloakError('Could not obtain access token from %s: %s'",
            "                            % (auth_url, str(e)))",
            "",
            "    try:",
            "        return {",
            "            'Authorization': 'Bearer ' + r['access_token'],",
            "            'Content-Type': 'application/json'",
            "        }",
            "    except KeyError:",
            "        raise KeycloakError(",
            "            'Could not obtain access token from %s' % auth_url)",
            "",
            "",
            "class KeycloakAPI(object):",
            "    \"\"\" Keycloak API access; Keycloak uses OAuth 2.0 to protect its API, an access token for which",
            "        is obtained through OpenID connect",
            "    \"\"\"",
            "    def __init__(self, module, connection_header):",
            "        self.module = module",
            "        self.baseurl = self.module.params.get('auth_keycloak_url')",
            "        self.validate_certs = self.module.params.get('validate_certs')",
            "        self.restheaders = connection_header",
            "",
            "    def get_clients(self, realm='master', filter=None):",
            "        \"\"\" Obtains client representations for clients in a realm",
            "",
            "        :param realm: realm to be queried",
            "        :param filter: if defined, only the client with clientId specified in the filter is returned",
            "        :return: list of dicts of client representations",
            "        \"\"\"",
            "        clientlist_url = URL_CLIENTS.format(url=self.baseurl, realm=realm)",
            "        if filter is not None:",
            "            clientlist_url += '?clientId=%s' % filter",
            "",
            "        try:",
            "            return json.load(open_url(clientlist_url, method='GET', headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "        except ValueError as e:",
            "            self.module.fail_json(msg='API returned incorrect JSON when trying to obtain list of clients for realm %s: %s'",
            "                                      % (realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not obtain list of clients for realm %s: %s'",
            "                                      % (realm, str(e)))",
            "",
            "    def get_client_by_clientid(self, client_id, realm='master'):",
            "        \"\"\" Get client representation by clientId",
            "        :param client_id: The clientId to be queried",
            "        :param realm: realm from which to obtain the client representation",
            "        :return: dict with a client representation or None if none matching exist",
            "        \"\"\"",
            "        r = self.get_clients(realm=realm, filter=client_id)",
            "        if len(r) > 0:",
            "            return r[0]",
            "        else:",
            "            return None",
            "",
            "    def get_client_by_id(self, id, realm='master'):",
            "        \"\"\" Obtain client representation by id",
            "",
            "        :param id: id (not clientId) of client to be queried",
            "        :param realm: client from this realm",
            "        :return: dict of client representation or None if none matching exist",
            "        \"\"\"",
            "        client_url = URL_CLIENT.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return json.load(open_url(client_url, method='GET', headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "",
            "        except HTTPError as e:",
            "            if e.code == 404:",
            "                return None",
            "            else:",
            "                self.module.fail_json(msg='Could not obtain client %s for realm %s: %s'",
            "                                          % (id, realm, str(e)))",
            "        except ValueError as e:",
            "            self.module.fail_json(msg='API returned incorrect JSON when trying to obtain client %s for realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not obtain client %s for realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def get_client_id(self, client_id, realm='master'):",
            "        \"\"\" Obtain id of client by client_id",
            "",
            "        :param client_id: client_id of client to be queried",
            "        :param realm: client template from this realm",
            "        :return: id of client (usually a UUID)",
            "        \"\"\"",
            "        result = self.get_client_by_clientid(client_id, realm)",
            "        if isinstance(result, dict) and 'id' in result:",
            "            return result['id']",
            "        else:",
            "            return None",
            "",
            "    def update_client(self, id, clientrep, realm=\"master\"):",
            "        \"\"\" Update an existing client",
            "        :param id: id (not clientId) of client to be updated in Keycloak",
            "        :param clientrep: corresponding (partial/full) client representation with updates",
            "        :param realm: realm the client is in",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        client_url = URL_CLIENT.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return open_url(client_url, method='PUT', headers=self.restheaders,",
            "                            data=json.dumps(clientrep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not update client %s in realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def create_client(self, clientrep, realm=\"master\"):",
            "        \"\"\" Create a client in keycloak",
            "        :param clientrep: Client representation of client to be created. Must at least contain field clientId",
            "        :param realm: realm for client to be created",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        client_url = URL_CLIENTS.format(url=self.baseurl, realm=realm)",
            "",
            "        try:",
            "            return open_url(client_url, method='POST', headers=self.restheaders,",
            "                            data=json.dumps(clientrep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not create client %s in realm %s: %s'",
            "                                      % (clientrep['clientId'], realm, str(e)))",
            "",
            "    def delete_client(self, id, realm=\"master\"):",
            "        \"\"\" Delete a client from Keycloak",
            "",
            "        :param id: id (not clientId) of client to be deleted",
            "        :param realm: realm of client to be deleted",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        client_url = URL_CLIENT.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return open_url(client_url, method='DELETE', headers=self.restheaders,",
            "                            validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not delete client %s in realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def get_client_templates(self, realm='master'):",
            "        \"\"\" Obtains client template representations for client templates in a realm",
            "",
            "        :param realm: realm to be queried",
            "        :return: list of dicts of client representations",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATES.format(url=self.baseurl, realm=realm)",
            "",
            "        try:",
            "            return json.load(open_url(url, method='GET', headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "        except ValueError as e:",
            "            self.module.fail_json(msg='API returned incorrect JSON when trying to obtain list of client templates for realm %s: %s'",
            "                                      % (realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not obtain list of client templates for realm %s: %s'",
            "                                      % (realm, str(e)))",
            "",
            "    def get_client_template_by_id(self, id, realm='master'):",
            "        \"\"\" Obtain client template representation by id",
            "",
            "        :param id: id (not name) of client template to be queried",
            "        :param realm: client template from this realm",
            "        :return: dict of client template representation or None if none matching exist",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATE.format(url=self.baseurl, id=id, realm=realm)",
            "",
            "        try:",
            "            return json.load(open_url(url, method='GET', headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "        except ValueError as e:",
            "            self.module.fail_json(msg='API returned incorrect JSON when trying to obtain client templates %s for realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not obtain client template %s for realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def get_client_template_by_name(self, name, realm='master'):",
            "        \"\"\" Obtain client template representation by name",
            "",
            "        :param name: name of client template to be queried",
            "        :param realm: client template from this realm",
            "        :return: dict of client template representation or None if none matching exist",
            "        \"\"\"",
            "        result = self.get_client_templates(realm)",
            "        if isinstance(result, list):",
            "            result = [x for x in result if x['name'] == name]",
            "            if len(result) > 0:",
            "                return result[0]",
            "        return None",
            "",
            "    def get_client_template_id(self, name, realm='master'):",
            "        \"\"\" Obtain client template id by name",
            "",
            "        :param name: name of client template to be queried",
            "        :param realm: client template from this realm",
            "        :return: client template id (usually a UUID)",
            "        \"\"\"",
            "        result = self.get_client_template_by_name(name, realm)",
            "        if isinstance(result, dict) and 'id' in result:",
            "            return result['id']",
            "        else:",
            "            return None",
            "",
            "    def update_client_template(self, id, clienttrep, realm=\"master\"):",
            "        \"\"\" Update an existing client template",
            "        :param id: id (not name) of client template to be updated in Keycloak",
            "        :param clienttrep: corresponding (partial/full) client template representation with updates",
            "        :param realm: realm the client template is in",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATE.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return open_url(url, method='PUT', headers=self.restheaders,",
            "                            data=json.dumps(clienttrep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not update client template %s in realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def create_client_template(self, clienttrep, realm=\"master\"):",
            "        \"\"\" Create a client in keycloak",
            "        :param clienttrep: Client template representation of client template to be created. Must at least contain field name",
            "        :param realm: realm for client template to be created in",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATES.format(url=self.baseurl, realm=realm)",
            "",
            "        try:",
            "            return open_url(url, method='POST', headers=self.restheaders,",
            "                            data=json.dumps(clienttrep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not create client template %s in realm %s: %s'",
            "                                      % (clienttrep['clientId'], realm, str(e)))",
            "",
            "    def delete_client_template(self, id, realm=\"master\"):",
            "        \"\"\" Delete a client template from Keycloak",
            "",
            "        :param id: id (not name) of client to be deleted",
            "        :param realm: realm of client template to be deleted",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        url = URL_CLIENTTEMPLATE.format(url=self.baseurl, realm=realm, id=id)",
            "",
            "        try:",
            "            return open_url(url, method='DELETE', headers=self.restheaders,",
            "                            validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not delete client template %s in realm %s: %s'",
            "                                      % (id, realm, str(e)))",
            "",
            "    def get_groups(self, realm=\"master\"):",
            "        \"\"\" Fetch the name and ID of all groups on the Keycloak server.",
            "",
            "        To fetch the full data of the group, make a subsequent call to",
            "        get_group_by_groupid, passing in the ID of the group you wish to return.",
            "",
            "        :param realm: Return the groups of this realm (default \"master\").",
            "        \"\"\"",
            "        groups_url = URL_GROUPS.format(url=self.baseurl, realm=realm)",
            "        try:",
            "            return json.load(open_url(groups_url, method=\"GET\", headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Could not fetch list of groups in realm %s: %s\"",
            "                                      % (realm, str(e)))",
            "",
            "    def get_group_by_groupid(self, gid, realm=\"master\"):",
            "        \"\"\" Fetch a keycloak group from the provided realm using the group's unique ID.",
            "",
            "        If the group does not exist, None is returned.",
            "",
            "        gid is a UUID provided by the Keycloak API",
            "        :param gid: UUID of the group to be returned",
            "        :param realm: Realm in which the group resides; default 'master'.",
            "        \"\"\"",
            "        groups_url = URL_GROUP.format(url=self.baseurl, realm=realm, groupid=gid)",
            "        try:",
            "            return json.load(open_url(groups_url, method=\"GET\", headers=self.restheaders,",
            "                                      validate_certs=self.validate_certs))",
            "",
            "        except HTTPError as e:",
            "            if e.code == 404:",
            "                return None",
            "            else:",
            "                self.module.fail_json(msg=\"Could not fetch group %s in realm %s: %s\"",
            "                                          % (gid, realm, str(e)))",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Could not fetch group %s in realm %s: %s\"",
            "                                      % (gid, realm, str(e)))",
            "",
            "    def get_group_by_name(self, name, realm=\"master\"):",
            "        \"\"\" Fetch a keycloak group within a realm based on its name.",
            "",
            "        The Keycloak API does not allow filtering of the Groups resource by name.",
            "        As a result, this method first retrieves the entire list of groups - name and ID -",
            "        then performs a second query to fetch the group.",
            "",
            "        If the group does not exist, None is returned.",
            "        :param name: Name of the group to fetch.",
            "        :param realm: Realm in which the group resides; default 'master'",
            "        \"\"\"",
            "        groups_url = URL_GROUPS.format(url=self.baseurl, realm=realm)",
            "        try:",
            "            all_groups = self.get_groups(realm=realm)",
            "",
            "            for group in all_groups:",
            "                if group['name'] == name:",
            "                    return self.get_group_by_groupid(group['id'], realm=realm)",
            "",
            "            return None",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Could not fetch group %s in realm %s: %s\"",
            "                                      % (name, realm, str(e)))",
            "",
            "    def create_group(self, grouprep, realm=\"master\"):",
            "        \"\"\" Create a Keycloak group.",
            "",
            "        :param grouprep: a GroupRepresentation of the group to be created. Must contain at minimum the field name.",
            "        :return: HTTPResponse object on success",
            "        \"\"\"",
            "        groups_url = URL_GROUPS.format(url=self.baseurl, realm=realm)",
            "        try:",
            "            return open_url(groups_url, method='POST', headers=self.restheaders,",
            "                            data=json.dumps(grouprep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Could not create group %s in realm %s: %s\"",
            "                                      % (grouprep['name'], realm, str(e)))",
            "",
            "    def update_group(self, grouprep, realm=\"master\"):",
            "        \"\"\" Update an existing group.",
            "",
            "        :param grouprep: A GroupRepresentation of the updated group.",
            "        :return HTTPResponse object on success",
            "        \"\"\"",
            "        group_url = URL_GROUP.format(url=self.baseurl, realm=realm, groupid=grouprep['id'])",
            "",
            "        try:",
            "            return open_url(group_url, method='PUT', headers=self.restheaders,",
            "                            data=json.dumps(grouprep), validate_certs=self.validate_certs)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Could not update group %s in realm %s: %s'",
            "                                      % (grouprep['name'], realm, str(e)))",
            "",
            "    def delete_group(self, name=None, groupid=None, realm=\"master\"):",
            "        \"\"\" Delete a group. One of name or groupid must be provided.",
            "",
            "        Providing the group ID is preferred as it avoids a second lookup to",
            "        convert a group name to an ID.",
            "",
            "        :param name: The name of the group. A lookup will be performed to retrieve the group ID.",
            "        :param groupid: The ID of the group (preferred to name).",
            "        :param realm: The realm in which this group resides, default \"master\".",
            "        \"\"\"",
            "",
            "        if groupid is None and name is None:",
            "            # prefer an exception since this is almost certainly a programming error in the module itself.",
            "            raise Exception(\"Unable to delete group - one of group ID or name must be provided.\")",
            "",
            "        # only lookup the name if groupid isn't provided.",
            "        # in the case that both are provided, prefer the ID, since it's one",
            "        # less lookup.",
            "        if groupid is None and name is not None:",
            "            for group in self.get_groups(realm=realm):",
            "                if group['name'] == name:",
            "                    groupid = group['id']",
            "                    break",
            "",
            "        # if the group doesn't exist - no problem, nothing to delete.",
            "        if groupid is None:",
            "            return None",
            "",
            "        # should have a good groupid by here.",
            "        group_url = URL_GROUP.format(realm=realm, groupid=groupid, url=self.baseurl)",
            "        try:",
            "            return open_url(group_url, method='DELETE', headers=self.restheaders,",
            "                            validate_certs=self.validate_certs)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg=\"Unable to delete group %s: %s\" % (groupid, str(e)))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "60": [
                "keycloak_argument_spec"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/module_utils/netapp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     return dict("
            },
            "1": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         api_url=dict(required=True, type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         validate_certs=dict(required=False, type='bool', default=True),"
            },
            "3": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        api_key=dict(required=True, type='str'),"
            },
            "4": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        secret_key=dict(required=True, type='str')"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        api_key=dict(required=True, type='str', no_log=True),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        secret_key=dict(required=True, type='str', no_log=True)"
            },
            "7": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     )"
            },
            "8": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# This code is part of Ansible, but is an independent component.",
            "# This particular file snippet, and this file snippet only, is BSD licensed.",
            "# Modules you write using this snippet, which is embedded dynamically by Ansible",
            "# still belong to the author of the module, and may assign their own license",
            "# to the complete work.",
            "#",
            "# Copyright (c) 2017, Sumit Kumar <sumit4@netapp.com>",
            "# Copyright (c) 2017, Michael Price <michael.price@netapp.com>",
            "# All rights reserved.",
            "#",
            "# Redistribution and use in source and binary forms, with or without modification,",
            "# are permitted provided that the following conditions are met:",
            "#",
            "#    * Redistributions of source code must retain the above copyright",
            "#      notice, this list of conditions and the following disclaimer.",
            "#    * Redistributions in binary form must reproduce the above copyright notice,",
            "#      this list of conditions and the following disclaimer in the documentation",
            "#      and/or other materials provided with the distribution.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND",
            "# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.",
            "# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,",
            "# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
            "# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT",
            "# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE",
            "# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
            "",
            "import json",
            "import os",
            "import random",
            "import mimetypes",
            "",
            "from pprint import pformat",
            "from ansible.module_utils import six",
            "from ansible.module_utils.basic import AnsibleModule, missing_required_lib",
            "from ansible.module_utils.six.moves.urllib.error import HTTPError, URLError",
            "from ansible.module_utils.urls import open_url",
            "from ansible.module_utils.api import basic_auth_argument_spec",
            "from ansible.module_utils._text import to_native",
            "",
            "try:",
            "    from ansible.module_utils.ansible_release import __version__ as ansible_version",
            "except ImportError:",
            "    ansible_version = 'unknown'",
            "",
            "try:",
            "    from netapp_lib.api.zapi import zapi",
            "    HAS_NETAPP_LIB = True",
            "except ImportError:",
            "    HAS_NETAPP_LIB = False",
            "",
            "try:",
            "    import requests",
            "    HAS_REQUESTS = True",
            "except ImportError:",
            "    HAS_REQUESTS = False",
            "",
            "import ssl",
            "try:",
            "    from urlparse import urlparse, urlunparse",
            "except ImportError:",
            "    from urllib.parse import urlparse, urlunparse",
            "",
            "",
            "HAS_SF_SDK = False",
            "SF_BYTE_MAP = dict(",
            "    # Management GUI displays 1024 ** 3 as 1.1 GB, thus use 1000.",
            "    bytes=1,",
            "    b=1,",
            "    kb=1000,",
            "    mb=1000 ** 2,",
            "    gb=1000 ** 3,",
            "    tb=1000 ** 4,",
            "    pb=1000 ** 5,",
            "    eb=1000 ** 6,",
            "    zb=1000 ** 7,",
            "    yb=1000 ** 8",
            ")",
            "",
            "POW2_BYTE_MAP = dict(",
            "    # Here, 1 kb = 1024",
            "    bytes=1,",
            "    b=1,",
            "    kb=1024,",
            "    mb=1024 ** 2,",
            "    gb=1024 ** 3,",
            "    tb=1024 ** 4,",
            "    pb=1024 ** 5,",
            "    eb=1024 ** 6,",
            "    zb=1024 ** 7,",
            "    yb=1024 ** 8",
            ")",
            "",
            "try:",
            "    from solidfire.factory import ElementFactory",
            "    from solidfire.custom.models import TimeIntervalFrequency",
            "    from solidfire.models import Schedule, ScheduleInfo",
            "",
            "    HAS_SF_SDK = True",
            "except Exception:",
            "    HAS_SF_SDK = False",
            "",
            "",
            "def has_netapp_lib():",
            "    return HAS_NETAPP_LIB",
            "",
            "",
            "def has_sf_sdk():",
            "    return HAS_SF_SDK",
            "",
            "",
            "def na_ontap_host_argument_spec():",
            "",
            "    return dict(",
            "        hostname=dict(required=True, type='str'),",
            "        username=dict(required=True, type='str', aliases=['user']),",
            "        password=dict(required=True, type='str', aliases=['pass'], no_log=True),",
            "        https=dict(required=False, type='bool', default=False),",
            "        validate_certs=dict(required=False, type='bool', default=True),",
            "        http_port=dict(required=False, type='int'),",
            "        ontapi=dict(required=False, type='int'),",
            "        use_rest=dict(required=False, type='str', default='Auto', choices=['Never', 'Always', 'Auto'])",
            "    )",
            "",
            "",
            "def ontap_sf_host_argument_spec():",
            "",
            "    return dict(",
            "        hostname=dict(required=True, type='str'),",
            "        username=dict(required=True, type='str', aliases=['user']),",
            "        password=dict(required=True, type='str', aliases=['pass'], no_log=True)",
            "    )",
            "",
            "",
            "def aws_cvs_host_argument_spec():",
            "",
            "    return dict(",
            "        api_url=dict(required=True, type='str'),",
            "        validate_certs=dict(required=False, type='bool', default=True),",
            "        api_key=dict(required=True, type='str'),",
            "        secret_key=dict(required=True, type='str')",
            "    )",
            "",
            "",
            "def create_sf_connection(module, port=None):",
            "    hostname = module.params['hostname']",
            "    username = module.params['username']",
            "    password = module.params['password']",
            "",
            "    if HAS_SF_SDK and hostname and username and password:",
            "        try:",
            "            return_val = ElementFactory.create(hostname, username, password, port=port)",
            "            return return_val",
            "        except Exception:",
            "            raise Exception(\"Unable to create SF connection\")",
            "    else:",
            "        module.fail_json(msg=\"the python SolidFire SDK module is required\")",
            "",
            "",
            "def setup_na_ontap_zapi(module, vserver=None):",
            "    hostname = module.params['hostname']",
            "    username = module.params['username']",
            "    password = module.params['password']",
            "    https = module.params['https']",
            "    validate_certs = module.params['validate_certs']",
            "    port = module.params['http_port']",
            "    version = module.params['ontapi']",
            "",
            "    if HAS_NETAPP_LIB:",
            "        # set up zapi",
            "        server = zapi.NaServer(hostname)",
            "        server.set_username(username)",
            "        server.set_password(password)",
            "        if vserver:",
            "            server.set_vserver(vserver)",
            "        if version:",
            "            minor = version",
            "        else:",
            "            minor = 110",
            "        server.set_api_version(major=1, minor=minor)",
            "        # default is HTTP",
            "        if https:",
            "            if port is None:",
            "                port = 443",
            "            transport_type = 'HTTPS'",
            "            # HACK to bypass certificate verification",
            "            if validate_certs is False:",
            "                if not os.environ.get('PYTHONHTTPSVERIFY', '') and getattr(ssl, '_create_unverified_context', None):",
            "                    ssl._create_default_https_context = ssl._create_unverified_context",
            "        else:",
            "            if port is None:",
            "                port = 80",
            "            transport_type = 'HTTP'",
            "        server.set_transport_type(transport_type)",
            "        server.set_port(port)",
            "        server.set_server_type('FILER')",
            "        return server",
            "    else:",
            "        module.fail_json(msg=\"the python NetApp-Lib module is required\")",
            "",
            "",
            "def setup_ontap_zapi(module, vserver=None):",
            "    hostname = module.params['hostname']",
            "    username = module.params['username']",
            "    password = module.params['password']",
            "",
            "    if HAS_NETAPP_LIB:",
            "        # set up zapi",
            "        server = zapi.NaServer(hostname)",
            "        server.set_username(username)",
            "        server.set_password(password)",
            "        if vserver:",
            "            server.set_vserver(vserver)",
            "        # Todo : Replace hard-coded values with configurable parameters.",
            "        server.set_api_version(major=1, minor=110)",
            "        server.set_port(80)",
            "        server.set_server_type('FILER')",
            "        server.set_transport_type('HTTP')",
            "        return server",
            "    else:",
            "        module.fail_json(msg=\"the python NetApp-Lib module is required\")",
            "",
            "",
            "def eseries_host_argument_spec():",
            "    \"\"\"Retrieve a base argument specification common to all NetApp E-Series modules\"\"\"",
            "    argument_spec = basic_auth_argument_spec()",
            "    argument_spec.update(dict(",
            "        api_username=dict(type='str', required=True),",
            "        api_password=dict(type='str', required=True, no_log=True),",
            "        api_url=dict(type='str', required=True),",
            "        ssid=dict(type='str', required=False, default='1'),",
            "        validate_certs=dict(type='bool', required=False, default=True)",
            "    ))",
            "    return argument_spec",
            "",
            "",
            "class NetAppESeriesModule(object):",
            "    \"\"\"Base class for all NetApp E-Series modules.",
            "",
            "    Provides a set of common methods for NetApp E-Series modules, including version checking, mode (proxy, embedded)",
            "    verification, http requests, secure http redirection for embedded web services, and logging setup.",
            "",
            "    Be sure to add the following lines in the module's documentation section:",
            "    extends_documentation_fragment:",
            "        - netapp.eseries",
            "",
            "    :param dict(dict) ansible_options: dictionary of ansible option definitions",
            "    :param str web_services_version: minimally required web services rest api version (default value: \"02.00.0000.0000\")",
            "    :param bool supports_check_mode: whether the module will support the check_mode capabilities (default=False)",
            "    :param list(list) mutually_exclusive: list containing list(s) of mutually exclusive options (optional)",
            "    :param list(list) required_if: list containing list(s) containing the option, the option value, and then",
            "    a list of required options. (optional)",
            "    :param list(list) required_one_of: list containing list(s) of options for which at least one is required. (optional)",
            "    :param list(list) required_together: list containing list(s) of options that are required together. (optional)",
            "    :param bool log_requests: controls whether to log each request (default: True)",
            "    \"\"\"",
            "    DEFAULT_TIMEOUT = 60",
            "    DEFAULT_SECURE_PORT = \"8443\"",
            "    DEFAULT_REST_API_PATH = \"devmgr/v2/\"",
            "    DEFAULT_REST_API_ABOUT_PATH = \"devmgr/utils/about\"",
            "    DEFAULT_HEADERS = {\"Content-Type\": \"application/json\", \"Accept\": \"application/json\",",
            "                       \"netapp-client-type\": \"Ansible-%s\" % ansible_version}",
            "    HTTP_AGENT = \"Ansible / %s\" % ansible_version",
            "    SIZE_UNIT_MAP = dict(bytes=1, b=1, kb=1024, mb=1024**2, gb=1024**3, tb=1024**4,",
            "                         pb=1024**5, eb=1024**6, zb=1024**7, yb=1024**8)",
            "",
            "    def __init__(self, ansible_options, web_services_version=None, supports_check_mode=False,",
            "                 mutually_exclusive=None, required_if=None, required_one_of=None, required_together=None,",
            "                 log_requests=True):",
            "        argument_spec = eseries_host_argument_spec()",
            "        argument_spec.update(ansible_options)",
            "",
            "        self.module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=supports_check_mode,",
            "                                    mutually_exclusive=mutually_exclusive, required_if=required_if,",
            "                                    required_one_of=required_one_of, required_together=required_together)",
            "",
            "        args = self.module.params",
            "        self.web_services_version = web_services_version if web_services_version else \"02.00.0000.0000\"",
            "        self.ssid = args[\"ssid\"]",
            "        self.url = args[\"api_url\"]",
            "        self.log_requests = log_requests",
            "        self.creds = dict(url_username=args[\"api_username\"],",
            "                          url_password=args[\"api_password\"],",
            "                          validate_certs=args[\"validate_certs\"])",
            "",
            "        if not self.url.endswith(\"/\"):",
            "            self.url += \"/\"",
            "",
            "        self.is_embedded_mode = None",
            "        self.is_web_services_valid_cache = None",
            "",
            "    def _check_web_services_version(self):",
            "        \"\"\"Verify proxy or embedded web services meets minimum version required for module.",
            "",
            "        The minimum required web services version is evaluated against version supplied through the web services rest",
            "        api. AnsibleFailJson exception will be raised when the minimum is not met or exceeded.",
            "",
            "        This helper function will update the supplied api url if secure http is not used for embedded web services",
            "",
            "        :raise AnsibleFailJson: raised when the contacted api service does not meet the minimum required version.",
            "        \"\"\"",
            "        if not self.is_web_services_valid_cache:",
            "",
            "            url_parts = urlparse(self.url)",
            "            if not url_parts.scheme or not url_parts.netloc:",
            "                self.module.fail_json(msg=\"Failed to provide valid API URL. Example: https://192.168.1.100:8443/devmgr/v2. URL [%s].\" % self.url)",
            "",
            "            if url_parts.scheme not in [\"http\", \"https\"]:",
            "                self.module.fail_json(msg=\"Protocol must be http or https. URL [%s].\" % self.url)",
            "",
            "            self.url = \"%s://%s/\" % (url_parts.scheme, url_parts.netloc)",
            "            about_url = self.url + self.DEFAULT_REST_API_ABOUT_PATH",
            "            rc, data = request(about_url, timeout=self.DEFAULT_TIMEOUT, headers=self.DEFAULT_HEADERS, ignore_errors=True, **self.creds)",
            "",
            "            if rc != 200:",
            "                self.module.warn(\"Failed to retrieve web services about information! Retrying with secure ports. Array Id [%s].\" % self.ssid)",
            "                self.url = \"https://%s:8443/\" % url_parts.netloc.split(\":\")[0]",
            "                about_url = self.url + self.DEFAULT_REST_API_ABOUT_PATH",
            "                try:",
            "                    rc, data = request(about_url, timeout=self.DEFAULT_TIMEOUT, headers=self.DEFAULT_HEADERS, **self.creds)",
            "                except Exception as error:",
            "                    self.module.fail_json(msg=\"Failed to retrieve the webservices about information! Array Id [%s]. Error [%s].\"",
            "                                              % (self.ssid, to_native(error)))",
            "",
            "            major, minor, other, revision = data[\"version\"].split(\".\")",
            "            minimum_major, minimum_minor, other, minimum_revision = self.web_services_version.split(\".\")",
            "",
            "            if not (major > minimum_major or",
            "                    (major == minimum_major and minor > minimum_minor) or",
            "                    (major == minimum_major and minor == minimum_minor and revision >= minimum_revision)):",
            "                self.module.fail_json(msg=\"Web services version does not meet minimum version required. Current version: [%s].\"",
            "                                          \" Version required: [%s].\" % (data[\"version\"], self.web_services_version))",
            "",
            "            self.module.log(\"Web services rest api version met the minimum required version.\")",
            "            self.is_web_services_valid_cache = True",
            "",
            "    def is_embedded(self):",
            "        \"\"\"Determine whether web services server is the embedded web services.",
            "",
            "        If web services about endpoint fails based on an URLError then the request will be attempted again using",
            "        secure http.",
            "",
            "        :raise AnsibleFailJson: raised when web services about endpoint failed to be contacted.",
            "        :return bool: whether contacted web services is running from storage array (embedded) or from a proxy.",
            "        \"\"\"",
            "        self._check_web_services_version()",
            "",
            "        if self.is_embedded_mode is None:",
            "            about_url = self.url + self.DEFAULT_REST_API_ABOUT_PATH",
            "            try:",
            "                rc, data = request(about_url, timeout=self.DEFAULT_TIMEOUT, headers=self.DEFAULT_HEADERS, **self.creds)",
            "                self.is_embedded_mode = not data[\"runningAsProxy\"]",
            "            except Exception as error:",
            "                self.module.fail_json(msg=\"Failed to retrieve the webservices about information! Array Id [%s]. Error [%s].\"",
            "                                          % (self.ssid, to_native(error)))",
            "",
            "        return self.is_embedded_mode",
            "",
            "    def request(self, path, data=None, method='GET', headers=None, ignore_errors=False):",
            "        \"\"\"Issue an HTTP request to a url, retrieving an optional JSON response.",
            "",
            "        :param str path: web services rest api endpoint path (Example: storage-systems/1/graph). Note that when the",
            "        full url path is specified then that will be used without supplying the protocol, hostname, port and rest path.",
            "        :param data: data required for the request (data may be json or any python structured data)",
            "        :param str method: request method such as GET, POST, DELETE.",
            "        :param dict headers: dictionary containing request headers.",
            "        :param bool ignore_errors: forces the request to ignore any raised exceptions.",
            "        \"\"\"",
            "        self._check_web_services_version()",
            "",
            "        if headers is None:",
            "            headers = self.DEFAULT_HEADERS",
            "",
            "        if not isinstance(data, str) and headers[\"Content-Type\"] == \"application/json\":",
            "            data = json.dumps(data)",
            "",
            "        if path.startswith(\"/\"):",
            "            path = path[1:]",
            "        request_url = self.url + self.DEFAULT_REST_API_PATH + path",
            "",
            "        if self.log_requests or True:",
            "            self.module.log(pformat(dict(url=request_url, data=data, method=method)))",
            "",
            "        return request(url=request_url, data=data, method=method, headers=headers, use_proxy=True, force=False, last_mod_time=None,",
            "                       timeout=self.DEFAULT_TIMEOUT, http_agent=self.HTTP_AGENT, force_basic_auth=True, ignore_errors=ignore_errors, **self.creds)",
            "",
            "",
            "def create_multipart_formdata(files, fields=None, send_8kb=False):",
            "    \"\"\"Create the data for a multipart/form request.",
            "",
            "    :param list(list) files: list of lists each containing (name, filename, path).",
            "    :param list(list) fields: list of lists each containing (key, value).",
            "    :param bool send_8kb: only sends the first 8kb of the files (default: False).",
            "    \"\"\"",
            "    boundary = \"---------------------------\" + \"\".join([str(random.randint(0, 9)) for x in range(27)])",
            "    data_parts = list()",
            "    data = None",
            "",
            "    if six.PY2:  # Generate payload for Python 2",
            "        newline = \"\\r\\n\"",
            "        if fields is not None:",
            "            for key, value in fields:",
            "                data_parts.extend([\"--%s\" % boundary,",
            "                                   'Content-Disposition: form-data; name=\"%s\"' % key,",
            "                                   \"\",",
            "                                   value])",
            "",
            "        for name, filename, path in files:",
            "            with open(path, \"rb\") as fh:",
            "                value = fh.read(8192) if send_8kb else fh.read()",
            "",
            "                data_parts.extend([\"--%s\" % boundary,",
            "                                   'Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (name, filename),",
            "                                   \"Content-Type: %s\" % (mimetypes.guess_type(path)[0] or \"application/octet-stream\"),",
            "                                   \"\",",
            "                                   value])",
            "        data_parts.extend([\"--%s--\" % boundary, \"\"])",
            "        data = newline.join(data_parts)",
            "",
            "    else:",
            "        newline = six.b(\"\\r\\n\")",
            "        if fields is not None:",
            "            for key, value in fields:",
            "                data_parts.extend([six.b(\"--%s\" % boundary),",
            "                                   six.b('Content-Disposition: form-data; name=\"%s\"' % key),",
            "                                   six.b(\"\"),",
            "                                   six.b(value)])",
            "",
            "        for name, filename, path in files:",
            "            with open(path, \"rb\") as fh:",
            "                value = fh.read(8192) if send_8kb else fh.read()",
            "",
            "                data_parts.extend([six.b(\"--%s\" % boundary),",
            "                                   six.b('Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (name, filename)),",
            "                                   six.b(\"Content-Type: %s\" % (mimetypes.guess_type(path)[0] or \"application/octet-stream\")),",
            "                                   six.b(\"\"),",
            "                                   value])",
            "        data_parts.extend([six.b(\"--%s--\" % boundary), b\"\"])",
            "        data = newline.join(data_parts)",
            "",
            "    headers = {",
            "        \"Content-Type\": \"multipart/form-data; boundary=%s\" % boundary,",
            "        \"Content-Length\": str(len(data))}",
            "",
            "    return headers, data",
            "",
            "",
            "def request(url, data=None, headers=None, method='GET', use_proxy=True,",
            "            force=False, last_mod_time=None, timeout=10, validate_certs=True,",
            "            url_username=None, url_password=None, http_agent=None, force_basic_auth=True, ignore_errors=False):",
            "    \"\"\"Issue an HTTP request to a url, retrieving an optional JSON response.\"\"\"",
            "",
            "    if headers is None:",
            "        headers = {\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"}",
            "    headers.update({\"netapp-client-type\": \"Ansible-%s\" % ansible_version})",
            "",
            "    if not http_agent:",
            "        http_agent = \"Ansible / %s\" % ansible_version",
            "",
            "    try:",
            "        r = open_url(url=url, data=data, headers=headers, method=method, use_proxy=use_proxy,",
            "                     force=force, last_mod_time=last_mod_time, timeout=timeout, validate_certs=validate_certs,",
            "                     url_username=url_username, url_password=url_password, http_agent=http_agent,",
            "                     force_basic_auth=force_basic_auth)",
            "    except HTTPError as err:",
            "        r = err.fp",
            "",
            "    try:",
            "        raw_data = r.read()",
            "        if raw_data:",
            "            data = json.loads(raw_data)",
            "        else:",
            "            raw_data = None",
            "    except Exception:",
            "        if ignore_errors:",
            "            pass",
            "        else:",
            "            raise Exception(raw_data)",
            "",
            "    resp_code = r.getcode()",
            "",
            "    if resp_code >= 400 and not ignore_errors:",
            "        raise Exception(resp_code, data)",
            "    else:",
            "        return resp_code, data",
            "",
            "",
            "def ems_log_event(source, server, name=\"Ansible\", id=\"12345\", version=ansible_version,",
            "                  category=\"Information\", event=\"setup\", autosupport=\"false\"):",
            "    ems_log = zapi.NaElement('ems-autosupport-log')",
            "    # Host name invoking the API.",
            "    ems_log.add_new_child(\"computer-name\", name)",
            "    # ID of event. A user defined event-id, range [0..2^32-2].",
            "    ems_log.add_new_child(\"event-id\", id)",
            "    # Name of the application invoking the API.",
            "    ems_log.add_new_child(\"event-source\", source)",
            "    # Version of application invoking the API.",
            "    ems_log.add_new_child(\"app-version\", version)",
            "    # Application defined category of the event.",
            "    ems_log.add_new_child(\"category\", category)",
            "    # Description of event to log. An application defined message to log.",
            "    ems_log.add_new_child(\"event-description\", event)",
            "    ems_log.add_new_child(\"log-level\", \"6\")",
            "    ems_log.add_new_child(\"auto-support\", autosupport)",
            "    server.invoke_successfully(ems_log, True)",
            "",
            "",
            "def get_cserver_zapi(server):",
            "    vserver_info = zapi.NaElement('vserver-get-iter')",
            "    query_details = zapi.NaElement.create_node_with_children('vserver-info', **{'vserver-type': 'admin'})",
            "    query = zapi.NaElement('query')",
            "    query.add_child_elem(query_details)",
            "    vserver_info.add_child_elem(query)",
            "    result = server.invoke_successfully(vserver_info,",
            "                                        enable_tunneling=False)",
            "    attribute_list = result.get_child_by_name('attributes-list')",
            "    vserver_list = attribute_list.get_child_by_name('vserver-info')",
            "    return vserver_list.get_child_content('vserver-name')",
            "",
            "",
            "def get_cserver(connection, is_rest=False):",
            "    if not is_rest:",
            "        return get_cserver_zapi(connection)",
            "",
            "    params = {'fields': 'type'}",
            "    api = \"private/cli/vserver\"",
            "    json, error = connection.get(api, params)",
            "    if json is None or error is not None:",
            "        # exit if there is an error or no data",
            "        return None",
            "    vservers = json.get('records')",
            "    if vservers is not None:",
            "        for vserver in vservers:",
            "            if vserver['type'] == 'admin':     # cluster admin",
            "                return vserver['vserver']",
            "        if len(vservers) == 1:                  # assume vserver admin",
            "            return vservers[0]['vserver']",
            "",
            "    return None",
            "",
            "",
            "class OntapRestAPI(object):",
            "    def __init__(self, module, timeout=60):",
            "        self.module = module",
            "        self.username = self.module.params['username']",
            "        self.password = self.module.params['password']",
            "        self.hostname = self.module.params['hostname']",
            "        self.use_rest = self.module.params['use_rest']",
            "        self.verify = self.module.params['validate_certs']",
            "        self.timeout = timeout",
            "        self.url = 'https://' + self.hostname + '/api/'",
            "        self.errors = list()",
            "        self.debug_logs = list()",
            "        self.check_required_library()",
            "",
            "    def check_required_library(self):",
            "        if not HAS_REQUESTS:",
            "            self.module.fail_json(msg=missing_required_lib('requests'))",
            "",
            "    def send_request(self, method, api, params, json=None, return_status_code=False):",
            "        ''' send http request and process reponse, including error conditions '''",
            "        url = self.url + api",
            "        status_code = None",
            "        content = None",
            "        json_dict = None",
            "        json_error = None",
            "        error_details = None",
            "",
            "        def get_json(response):",
            "            ''' extract json, and error message if present '''",
            "            try:",
            "                json = response.json()",
            "            except ValueError:",
            "                return None, None",
            "            error = json.get('error')",
            "            return json, error",
            "",
            "        try:",
            "            response = requests.request(method, url, verify=self.verify, auth=(self.username, self.password), params=params, timeout=self.timeout, json=json)",
            "            content = response.content  # for debug purposes",
            "            status_code = response.status_code",
            "            # If the response was successful, no Exception will be raised",
            "            response.raise_for_status()",
            "            json_dict, json_error = get_json(response)",
            "        except requests.exceptions.HTTPError as err:",
            "            __, json_error = get_json(response)",
            "            if json_error is None:",
            "                self.log_error(status_code, 'HTTP error: %s' % err)",
            "                error_details = str(err)",
            "            # If an error was reported in the json payload, it is handled below",
            "        except requests.exceptions.ConnectionError as err:",
            "            self.log_error(status_code, 'Connection error: %s' % err)",
            "            error_details = str(err)",
            "        except Exception as err:",
            "            self.log_error(status_code, 'Other error: %s' % err)",
            "            error_details = str(err)",
            "        if json_error is not None:",
            "            self.log_error(status_code, 'Endpoint error: %d: %s' % (status_code, json_error))",
            "            error_details = json_error",
            "        self.log_debug(status_code, content)",
            "        if return_status_code:",
            "            return status_code, error_details",
            "        return json_dict, error_details",
            "",
            "    def get(self, api, params):",
            "        method = 'GET'",
            "        return self.send_request(method, api, params)",
            "",
            "    def post(self, api, data, params=None):",
            "        method = 'POST'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def patch(self, api, data, params=None):",
            "        method = 'PATCH'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def delete(self, api, data, params=None):",
            "        method = 'DELETE'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def _is_rest(self, used_unsupported_rest_properties=None):",
            "        if self.use_rest == \"Always\":",
            "            if used_unsupported_rest_properties:",
            "                error = \"REST API currently does not support '%s'\" % \\",
            "                        ', '.join(used_unsupported_rest_properties)",
            "                return True, error",
            "            else:",
            "                return True, None",
            "        if self.use_rest == 'Never' or used_unsupported_rest_properties:",
            "            # force ZAPI if requested or if some parameter requires it",
            "            return False, None",
            "        method = 'HEAD'",
            "        api = 'cluster/software'",
            "        status_code, __ = self.send_request(method, api, params=None, return_status_code=True)",
            "        if status_code == 200:",
            "            return True, None",
            "        return False, None",
            "",
            "    def is_rest(self, used_unsupported_rest_properties=None):",
            "        ''' only return error if there is a reason to '''",
            "        use_rest, error = self._is_rest(used_unsupported_rest_properties)",
            "        if used_unsupported_rest_properties is None:",
            "            return use_rest",
            "        return use_rest, error",
            "",
            "    def log_error(self, status_code, message):",
            "        self.errors.append(message)",
            "        self.debug_logs.append((status_code, message))",
            "",
            "    def log_debug(self, status_code, content):",
            "        self.debug_logs.append((status_code, content))",
            "",
            "",
            "class AwsCvsRestAPI(object):",
            "    def __init__(self, module, timeout=60):",
            "        self.module = module",
            "        self.api_key = self.module.params['api_key']",
            "        self.secret_key = self.module.params['secret_key']",
            "        self.api_url = self.module.params['api_url']",
            "        self.verify = self.module.params['validate_certs']",
            "        self.timeout = timeout",
            "        self.url = 'https://' + self.api_url + '/v1/'",
            "        self.check_required_library()",
            "",
            "    def check_required_library(self):",
            "        if not HAS_REQUESTS:",
            "            self.module.fail_json(msg=missing_required_lib('requests'))",
            "",
            "    def send_request(self, method, api, params, json=None):",
            "        ''' send http request and process reponse, including error conditions '''",
            "        url = self.url + api",
            "        status_code = None",
            "        content = None",
            "        json_dict = None",
            "        json_error = None",
            "        error_details = None",
            "        headers = {",
            "            'Content-type': \"application/json\",",
            "            'api-key': self.api_key,",
            "            'secret-key': self.secret_key,",
            "            'Cache-Control': \"no-cache\",",
            "        }",
            "",
            "        def get_json(response):",
            "            ''' extract json, and error message if present '''",
            "            try:",
            "                json = response.json()",
            "",
            "            except ValueError:",
            "                return None, None",
            "            success_code = [200, 201, 202]",
            "            if response.status_code not in success_code:",
            "                error = json.get('message')",
            "            else:",
            "                error = None",
            "            return json, error",
            "        try:",
            "            response = requests.request(method, url, headers=headers, timeout=self.timeout, json=json)",
            "            status_code = response.status_code",
            "            # If the response was successful, no Exception will be raised",
            "            json_dict, json_error = get_json(response)",
            "        except requests.exceptions.HTTPError as err:",
            "            __, json_error = get_json(response)",
            "            if json_error is None:",
            "                error_details = str(err)",
            "        except requests.exceptions.ConnectionError as err:",
            "            error_details = str(err)",
            "        except Exception as err:",
            "            error_details = str(err)",
            "        if json_error is not None:",
            "            error_details = json_error",
            "",
            "        return json_dict, error_details",
            "",
            "    # If an error was reported in the json payload, it is handled below",
            "    def get(self, api, params=None):",
            "        method = 'GET'",
            "        return self.send_request(method, api, params)",
            "",
            "    def post(self, api, data, params=None):",
            "        method = 'POST'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def patch(self, api, data, params=None):",
            "        method = 'PATCH'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def put(self, api, data, params=None):",
            "        method = 'PUT'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def delete(self, api, data, params=None):",
            "        method = 'DELETE'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def get_state(self, jobId):",
            "        \"\"\" Method to get the state of the job \"\"\"",
            "        method = 'GET'",
            "        response, status_code = self.get('Jobs/%s' % jobId)",
            "        while str(response['state']) not in 'done':",
            "            response, status_code = self.get('Jobs/%s' % jobId)",
            "        return 'done'"
        ],
        "afterPatchFile": [
            "# This code is part of Ansible, but is an independent component.",
            "# This particular file snippet, and this file snippet only, is BSD licensed.",
            "# Modules you write using this snippet, which is embedded dynamically by Ansible",
            "# still belong to the author of the module, and may assign their own license",
            "# to the complete work.",
            "#",
            "# Copyright (c) 2017, Sumit Kumar <sumit4@netapp.com>",
            "# Copyright (c) 2017, Michael Price <michael.price@netapp.com>",
            "# All rights reserved.",
            "#",
            "# Redistribution and use in source and binary forms, with or without modification,",
            "# are permitted provided that the following conditions are met:",
            "#",
            "#    * Redistributions of source code must retain the above copyright",
            "#      notice, this list of conditions and the following disclaimer.",
            "#    * Redistributions in binary form must reproduce the above copyright notice,",
            "#      this list of conditions and the following disclaimer in the documentation",
            "#      and/or other materials provided with the distribution.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND",
            "# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.",
            "# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,",
            "# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
            "# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT",
            "# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE",
            "# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
            "",
            "import json",
            "import os",
            "import random",
            "import mimetypes",
            "",
            "from pprint import pformat",
            "from ansible.module_utils import six",
            "from ansible.module_utils.basic import AnsibleModule, missing_required_lib",
            "from ansible.module_utils.six.moves.urllib.error import HTTPError, URLError",
            "from ansible.module_utils.urls import open_url",
            "from ansible.module_utils.api import basic_auth_argument_spec",
            "from ansible.module_utils._text import to_native",
            "",
            "try:",
            "    from ansible.module_utils.ansible_release import __version__ as ansible_version",
            "except ImportError:",
            "    ansible_version = 'unknown'",
            "",
            "try:",
            "    from netapp_lib.api.zapi import zapi",
            "    HAS_NETAPP_LIB = True",
            "except ImportError:",
            "    HAS_NETAPP_LIB = False",
            "",
            "try:",
            "    import requests",
            "    HAS_REQUESTS = True",
            "except ImportError:",
            "    HAS_REQUESTS = False",
            "",
            "import ssl",
            "try:",
            "    from urlparse import urlparse, urlunparse",
            "except ImportError:",
            "    from urllib.parse import urlparse, urlunparse",
            "",
            "",
            "HAS_SF_SDK = False",
            "SF_BYTE_MAP = dict(",
            "    # Management GUI displays 1024 ** 3 as 1.1 GB, thus use 1000.",
            "    bytes=1,",
            "    b=1,",
            "    kb=1000,",
            "    mb=1000 ** 2,",
            "    gb=1000 ** 3,",
            "    tb=1000 ** 4,",
            "    pb=1000 ** 5,",
            "    eb=1000 ** 6,",
            "    zb=1000 ** 7,",
            "    yb=1000 ** 8",
            ")",
            "",
            "POW2_BYTE_MAP = dict(",
            "    # Here, 1 kb = 1024",
            "    bytes=1,",
            "    b=1,",
            "    kb=1024,",
            "    mb=1024 ** 2,",
            "    gb=1024 ** 3,",
            "    tb=1024 ** 4,",
            "    pb=1024 ** 5,",
            "    eb=1024 ** 6,",
            "    zb=1024 ** 7,",
            "    yb=1024 ** 8",
            ")",
            "",
            "try:",
            "    from solidfire.factory import ElementFactory",
            "    from solidfire.custom.models import TimeIntervalFrequency",
            "    from solidfire.models import Schedule, ScheduleInfo",
            "",
            "    HAS_SF_SDK = True",
            "except Exception:",
            "    HAS_SF_SDK = False",
            "",
            "",
            "def has_netapp_lib():",
            "    return HAS_NETAPP_LIB",
            "",
            "",
            "def has_sf_sdk():",
            "    return HAS_SF_SDK",
            "",
            "",
            "def na_ontap_host_argument_spec():",
            "",
            "    return dict(",
            "        hostname=dict(required=True, type='str'),",
            "        username=dict(required=True, type='str', aliases=['user']),",
            "        password=dict(required=True, type='str', aliases=['pass'], no_log=True),",
            "        https=dict(required=False, type='bool', default=False),",
            "        validate_certs=dict(required=False, type='bool', default=True),",
            "        http_port=dict(required=False, type='int'),",
            "        ontapi=dict(required=False, type='int'),",
            "        use_rest=dict(required=False, type='str', default='Auto', choices=['Never', 'Always', 'Auto'])",
            "    )",
            "",
            "",
            "def ontap_sf_host_argument_spec():",
            "",
            "    return dict(",
            "        hostname=dict(required=True, type='str'),",
            "        username=dict(required=True, type='str', aliases=['user']),",
            "        password=dict(required=True, type='str', aliases=['pass'], no_log=True)",
            "    )",
            "",
            "",
            "def aws_cvs_host_argument_spec():",
            "",
            "    return dict(",
            "        api_url=dict(required=True, type='str'),",
            "        validate_certs=dict(required=False, type='bool', default=True),",
            "        api_key=dict(required=True, type='str', no_log=True),",
            "        secret_key=dict(required=True, type='str', no_log=True)",
            "    )",
            "",
            "",
            "def create_sf_connection(module, port=None):",
            "    hostname = module.params['hostname']",
            "    username = module.params['username']",
            "    password = module.params['password']",
            "",
            "    if HAS_SF_SDK and hostname and username and password:",
            "        try:",
            "            return_val = ElementFactory.create(hostname, username, password, port=port)",
            "            return return_val",
            "        except Exception:",
            "            raise Exception(\"Unable to create SF connection\")",
            "    else:",
            "        module.fail_json(msg=\"the python SolidFire SDK module is required\")",
            "",
            "",
            "def setup_na_ontap_zapi(module, vserver=None):",
            "    hostname = module.params['hostname']",
            "    username = module.params['username']",
            "    password = module.params['password']",
            "    https = module.params['https']",
            "    validate_certs = module.params['validate_certs']",
            "    port = module.params['http_port']",
            "    version = module.params['ontapi']",
            "",
            "    if HAS_NETAPP_LIB:",
            "        # set up zapi",
            "        server = zapi.NaServer(hostname)",
            "        server.set_username(username)",
            "        server.set_password(password)",
            "        if vserver:",
            "            server.set_vserver(vserver)",
            "        if version:",
            "            minor = version",
            "        else:",
            "            minor = 110",
            "        server.set_api_version(major=1, minor=minor)",
            "        # default is HTTP",
            "        if https:",
            "            if port is None:",
            "                port = 443",
            "            transport_type = 'HTTPS'",
            "            # HACK to bypass certificate verification",
            "            if validate_certs is False:",
            "                if not os.environ.get('PYTHONHTTPSVERIFY', '') and getattr(ssl, '_create_unverified_context', None):",
            "                    ssl._create_default_https_context = ssl._create_unverified_context",
            "        else:",
            "            if port is None:",
            "                port = 80",
            "            transport_type = 'HTTP'",
            "        server.set_transport_type(transport_type)",
            "        server.set_port(port)",
            "        server.set_server_type('FILER')",
            "        return server",
            "    else:",
            "        module.fail_json(msg=\"the python NetApp-Lib module is required\")",
            "",
            "",
            "def setup_ontap_zapi(module, vserver=None):",
            "    hostname = module.params['hostname']",
            "    username = module.params['username']",
            "    password = module.params['password']",
            "",
            "    if HAS_NETAPP_LIB:",
            "        # set up zapi",
            "        server = zapi.NaServer(hostname)",
            "        server.set_username(username)",
            "        server.set_password(password)",
            "        if vserver:",
            "            server.set_vserver(vserver)",
            "        # Todo : Replace hard-coded values with configurable parameters.",
            "        server.set_api_version(major=1, minor=110)",
            "        server.set_port(80)",
            "        server.set_server_type('FILER')",
            "        server.set_transport_type('HTTP')",
            "        return server",
            "    else:",
            "        module.fail_json(msg=\"the python NetApp-Lib module is required\")",
            "",
            "",
            "def eseries_host_argument_spec():",
            "    \"\"\"Retrieve a base argument specification common to all NetApp E-Series modules\"\"\"",
            "    argument_spec = basic_auth_argument_spec()",
            "    argument_spec.update(dict(",
            "        api_username=dict(type='str', required=True),",
            "        api_password=dict(type='str', required=True, no_log=True),",
            "        api_url=dict(type='str', required=True),",
            "        ssid=dict(type='str', required=False, default='1'),",
            "        validate_certs=dict(type='bool', required=False, default=True)",
            "    ))",
            "    return argument_spec",
            "",
            "",
            "class NetAppESeriesModule(object):",
            "    \"\"\"Base class for all NetApp E-Series modules.",
            "",
            "    Provides a set of common methods for NetApp E-Series modules, including version checking, mode (proxy, embedded)",
            "    verification, http requests, secure http redirection for embedded web services, and logging setup.",
            "",
            "    Be sure to add the following lines in the module's documentation section:",
            "    extends_documentation_fragment:",
            "        - netapp.eseries",
            "",
            "    :param dict(dict) ansible_options: dictionary of ansible option definitions",
            "    :param str web_services_version: minimally required web services rest api version (default value: \"02.00.0000.0000\")",
            "    :param bool supports_check_mode: whether the module will support the check_mode capabilities (default=False)",
            "    :param list(list) mutually_exclusive: list containing list(s) of mutually exclusive options (optional)",
            "    :param list(list) required_if: list containing list(s) containing the option, the option value, and then",
            "    a list of required options. (optional)",
            "    :param list(list) required_one_of: list containing list(s) of options for which at least one is required. (optional)",
            "    :param list(list) required_together: list containing list(s) of options that are required together. (optional)",
            "    :param bool log_requests: controls whether to log each request (default: True)",
            "    \"\"\"",
            "    DEFAULT_TIMEOUT = 60",
            "    DEFAULT_SECURE_PORT = \"8443\"",
            "    DEFAULT_REST_API_PATH = \"devmgr/v2/\"",
            "    DEFAULT_REST_API_ABOUT_PATH = \"devmgr/utils/about\"",
            "    DEFAULT_HEADERS = {\"Content-Type\": \"application/json\", \"Accept\": \"application/json\",",
            "                       \"netapp-client-type\": \"Ansible-%s\" % ansible_version}",
            "    HTTP_AGENT = \"Ansible / %s\" % ansible_version",
            "    SIZE_UNIT_MAP = dict(bytes=1, b=1, kb=1024, mb=1024**2, gb=1024**3, tb=1024**4,",
            "                         pb=1024**5, eb=1024**6, zb=1024**7, yb=1024**8)",
            "",
            "    def __init__(self, ansible_options, web_services_version=None, supports_check_mode=False,",
            "                 mutually_exclusive=None, required_if=None, required_one_of=None, required_together=None,",
            "                 log_requests=True):",
            "        argument_spec = eseries_host_argument_spec()",
            "        argument_spec.update(ansible_options)",
            "",
            "        self.module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=supports_check_mode,",
            "                                    mutually_exclusive=mutually_exclusive, required_if=required_if,",
            "                                    required_one_of=required_one_of, required_together=required_together)",
            "",
            "        args = self.module.params",
            "        self.web_services_version = web_services_version if web_services_version else \"02.00.0000.0000\"",
            "        self.ssid = args[\"ssid\"]",
            "        self.url = args[\"api_url\"]",
            "        self.log_requests = log_requests",
            "        self.creds = dict(url_username=args[\"api_username\"],",
            "                          url_password=args[\"api_password\"],",
            "                          validate_certs=args[\"validate_certs\"])",
            "",
            "        if not self.url.endswith(\"/\"):",
            "            self.url += \"/\"",
            "",
            "        self.is_embedded_mode = None",
            "        self.is_web_services_valid_cache = None",
            "",
            "    def _check_web_services_version(self):",
            "        \"\"\"Verify proxy or embedded web services meets minimum version required for module.",
            "",
            "        The minimum required web services version is evaluated against version supplied through the web services rest",
            "        api. AnsibleFailJson exception will be raised when the minimum is not met or exceeded.",
            "",
            "        This helper function will update the supplied api url if secure http is not used for embedded web services",
            "",
            "        :raise AnsibleFailJson: raised when the contacted api service does not meet the minimum required version.",
            "        \"\"\"",
            "        if not self.is_web_services_valid_cache:",
            "",
            "            url_parts = urlparse(self.url)",
            "            if not url_parts.scheme or not url_parts.netloc:",
            "                self.module.fail_json(msg=\"Failed to provide valid API URL. Example: https://192.168.1.100:8443/devmgr/v2. URL [%s].\" % self.url)",
            "",
            "            if url_parts.scheme not in [\"http\", \"https\"]:",
            "                self.module.fail_json(msg=\"Protocol must be http or https. URL [%s].\" % self.url)",
            "",
            "            self.url = \"%s://%s/\" % (url_parts.scheme, url_parts.netloc)",
            "            about_url = self.url + self.DEFAULT_REST_API_ABOUT_PATH",
            "            rc, data = request(about_url, timeout=self.DEFAULT_TIMEOUT, headers=self.DEFAULT_HEADERS, ignore_errors=True, **self.creds)",
            "",
            "            if rc != 200:",
            "                self.module.warn(\"Failed to retrieve web services about information! Retrying with secure ports. Array Id [%s].\" % self.ssid)",
            "                self.url = \"https://%s:8443/\" % url_parts.netloc.split(\":\")[0]",
            "                about_url = self.url + self.DEFAULT_REST_API_ABOUT_PATH",
            "                try:",
            "                    rc, data = request(about_url, timeout=self.DEFAULT_TIMEOUT, headers=self.DEFAULT_HEADERS, **self.creds)",
            "                except Exception as error:",
            "                    self.module.fail_json(msg=\"Failed to retrieve the webservices about information! Array Id [%s]. Error [%s].\"",
            "                                              % (self.ssid, to_native(error)))",
            "",
            "            major, minor, other, revision = data[\"version\"].split(\".\")",
            "            minimum_major, minimum_minor, other, minimum_revision = self.web_services_version.split(\".\")",
            "",
            "            if not (major > minimum_major or",
            "                    (major == minimum_major and minor > minimum_minor) or",
            "                    (major == minimum_major and minor == minimum_minor and revision >= minimum_revision)):",
            "                self.module.fail_json(msg=\"Web services version does not meet minimum version required. Current version: [%s].\"",
            "                                          \" Version required: [%s].\" % (data[\"version\"], self.web_services_version))",
            "",
            "            self.module.log(\"Web services rest api version met the minimum required version.\")",
            "            self.is_web_services_valid_cache = True",
            "",
            "    def is_embedded(self):",
            "        \"\"\"Determine whether web services server is the embedded web services.",
            "",
            "        If web services about endpoint fails based on an URLError then the request will be attempted again using",
            "        secure http.",
            "",
            "        :raise AnsibleFailJson: raised when web services about endpoint failed to be contacted.",
            "        :return bool: whether contacted web services is running from storage array (embedded) or from a proxy.",
            "        \"\"\"",
            "        self._check_web_services_version()",
            "",
            "        if self.is_embedded_mode is None:",
            "            about_url = self.url + self.DEFAULT_REST_API_ABOUT_PATH",
            "            try:",
            "                rc, data = request(about_url, timeout=self.DEFAULT_TIMEOUT, headers=self.DEFAULT_HEADERS, **self.creds)",
            "                self.is_embedded_mode = not data[\"runningAsProxy\"]",
            "            except Exception as error:",
            "                self.module.fail_json(msg=\"Failed to retrieve the webservices about information! Array Id [%s]. Error [%s].\"",
            "                                          % (self.ssid, to_native(error)))",
            "",
            "        return self.is_embedded_mode",
            "",
            "    def request(self, path, data=None, method='GET', headers=None, ignore_errors=False):",
            "        \"\"\"Issue an HTTP request to a url, retrieving an optional JSON response.",
            "",
            "        :param str path: web services rest api endpoint path (Example: storage-systems/1/graph). Note that when the",
            "        full url path is specified then that will be used without supplying the protocol, hostname, port and rest path.",
            "        :param data: data required for the request (data may be json or any python structured data)",
            "        :param str method: request method such as GET, POST, DELETE.",
            "        :param dict headers: dictionary containing request headers.",
            "        :param bool ignore_errors: forces the request to ignore any raised exceptions.",
            "        \"\"\"",
            "        self._check_web_services_version()",
            "",
            "        if headers is None:",
            "            headers = self.DEFAULT_HEADERS",
            "",
            "        if not isinstance(data, str) and headers[\"Content-Type\"] == \"application/json\":",
            "            data = json.dumps(data)",
            "",
            "        if path.startswith(\"/\"):",
            "            path = path[1:]",
            "        request_url = self.url + self.DEFAULT_REST_API_PATH + path",
            "",
            "        if self.log_requests or True:",
            "            self.module.log(pformat(dict(url=request_url, data=data, method=method)))",
            "",
            "        return request(url=request_url, data=data, method=method, headers=headers, use_proxy=True, force=False, last_mod_time=None,",
            "                       timeout=self.DEFAULT_TIMEOUT, http_agent=self.HTTP_AGENT, force_basic_auth=True, ignore_errors=ignore_errors, **self.creds)",
            "",
            "",
            "def create_multipart_formdata(files, fields=None, send_8kb=False):",
            "    \"\"\"Create the data for a multipart/form request.",
            "",
            "    :param list(list) files: list of lists each containing (name, filename, path).",
            "    :param list(list) fields: list of lists each containing (key, value).",
            "    :param bool send_8kb: only sends the first 8kb of the files (default: False).",
            "    \"\"\"",
            "    boundary = \"---------------------------\" + \"\".join([str(random.randint(0, 9)) for x in range(27)])",
            "    data_parts = list()",
            "    data = None",
            "",
            "    if six.PY2:  # Generate payload for Python 2",
            "        newline = \"\\r\\n\"",
            "        if fields is not None:",
            "            for key, value in fields:",
            "                data_parts.extend([\"--%s\" % boundary,",
            "                                   'Content-Disposition: form-data; name=\"%s\"' % key,",
            "                                   \"\",",
            "                                   value])",
            "",
            "        for name, filename, path in files:",
            "            with open(path, \"rb\") as fh:",
            "                value = fh.read(8192) if send_8kb else fh.read()",
            "",
            "                data_parts.extend([\"--%s\" % boundary,",
            "                                   'Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (name, filename),",
            "                                   \"Content-Type: %s\" % (mimetypes.guess_type(path)[0] or \"application/octet-stream\"),",
            "                                   \"\",",
            "                                   value])",
            "        data_parts.extend([\"--%s--\" % boundary, \"\"])",
            "        data = newline.join(data_parts)",
            "",
            "    else:",
            "        newline = six.b(\"\\r\\n\")",
            "        if fields is not None:",
            "            for key, value in fields:",
            "                data_parts.extend([six.b(\"--%s\" % boundary),",
            "                                   six.b('Content-Disposition: form-data; name=\"%s\"' % key),",
            "                                   six.b(\"\"),",
            "                                   six.b(value)])",
            "",
            "        for name, filename, path in files:",
            "            with open(path, \"rb\") as fh:",
            "                value = fh.read(8192) if send_8kb else fh.read()",
            "",
            "                data_parts.extend([six.b(\"--%s\" % boundary),",
            "                                   six.b('Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (name, filename)),",
            "                                   six.b(\"Content-Type: %s\" % (mimetypes.guess_type(path)[0] or \"application/octet-stream\")),",
            "                                   six.b(\"\"),",
            "                                   value])",
            "        data_parts.extend([six.b(\"--%s--\" % boundary), b\"\"])",
            "        data = newline.join(data_parts)",
            "",
            "    headers = {",
            "        \"Content-Type\": \"multipart/form-data; boundary=%s\" % boundary,",
            "        \"Content-Length\": str(len(data))}",
            "",
            "    return headers, data",
            "",
            "",
            "def request(url, data=None, headers=None, method='GET', use_proxy=True,",
            "            force=False, last_mod_time=None, timeout=10, validate_certs=True,",
            "            url_username=None, url_password=None, http_agent=None, force_basic_auth=True, ignore_errors=False):",
            "    \"\"\"Issue an HTTP request to a url, retrieving an optional JSON response.\"\"\"",
            "",
            "    if headers is None:",
            "        headers = {\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"}",
            "    headers.update({\"netapp-client-type\": \"Ansible-%s\" % ansible_version})",
            "",
            "    if not http_agent:",
            "        http_agent = \"Ansible / %s\" % ansible_version",
            "",
            "    try:",
            "        r = open_url(url=url, data=data, headers=headers, method=method, use_proxy=use_proxy,",
            "                     force=force, last_mod_time=last_mod_time, timeout=timeout, validate_certs=validate_certs,",
            "                     url_username=url_username, url_password=url_password, http_agent=http_agent,",
            "                     force_basic_auth=force_basic_auth)",
            "    except HTTPError as err:",
            "        r = err.fp",
            "",
            "    try:",
            "        raw_data = r.read()",
            "        if raw_data:",
            "            data = json.loads(raw_data)",
            "        else:",
            "            raw_data = None",
            "    except Exception:",
            "        if ignore_errors:",
            "            pass",
            "        else:",
            "            raise Exception(raw_data)",
            "",
            "    resp_code = r.getcode()",
            "",
            "    if resp_code >= 400 and not ignore_errors:",
            "        raise Exception(resp_code, data)",
            "    else:",
            "        return resp_code, data",
            "",
            "",
            "def ems_log_event(source, server, name=\"Ansible\", id=\"12345\", version=ansible_version,",
            "                  category=\"Information\", event=\"setup\", autosupport=\"false\"):",
            "    ems_log = zapi.NaElement('ems-autosupport-log')",
            "    # Host name invoking the API.",
            "    ems_log.add_new_child(\"computer-name\", name)",
            "    # ID of event. A user defined event-id, range [0..2^32-2].",
            "    ems_log.add_new_child(\"event-id\", id)",
            "    # Name of the application invoking the API.",
            "    ems_log.add_new_child(\"event-source\", source)",
            "    # Version of application invoking the API.",
            "    ems_log.add_new_child(\"app-version\", version)",
            "    # Application defined category of the event.",
            "    ems_log.add_new_child(\"category\", category)",
            "    # Description of event to log. An application defined message to log.",
            "    ems_log.add_new_child(\"event-description\", event)",
            "    ems_log.add_new_child(\"log-level\", \"6\")",
            "    ems_log.add_new_child(\"auto-support\", autosupport)",
            "    server.invoke_successfully(ems_log, True)",
            "",
            "",
            "def get_cserver_zapi(server):",
            "    vserver_info = zapi.NaElement('vserver-get-iter')",
            "    query_details = zapi.NaElement.create_node_with_children('vserver-info', **{'vserver-type': 'admin'})",
            "    query = zapi.NaElement('query')",
            "    query.add_child_elem(query_details)",
            "    vserver_info.add_child_elem(query)",
            "    result = server.invoke_successfully(vserver_info,",
            "                                        enable_tunneling=False)",
            "    attribute_list = result.get_child_by_name('attributes-list')",
            "    vserver_list = attribute_list.get_child_by_name('vserver-info')",
            "    return vserver_list.get_child_content('vserver-name')",
            "",
            "",
            "def get_cserver(connection, is_rest=False):",
            "    if not is_rest:",
            "        return get_cserver_zapi(connection)",
            "",
            "    params = {'fields': 'type'}",
            "    api = \"private/cli/vserver\"",
            "    json, error = connection.get(api, params)",
            "    if json is None or error is not None:",
            "        # exit if there is an error or no data",
            "        return None",
            "    vservers = json.get('records')",
            "    if vservers is not None:",
            "        for vserver in vservers:",
            "            if vserver['type'] == 'admin':     # cluster admin",
            "                return vserver['vserver']",
            "        if len(vservers) == 1:                  # assume vserver admin",
            "            return vservers[0]['vserver']",
            "",
            "    return None",
            "",
            "",
            "class OntapRestAPI(object):",
            "    def __init__(self, module, timeout=60):",
            "        self.module = module",
            "        self.username = self.module.params['username']",
            "        self.password = self.module.params['password']",
            "        self.hostname = self.module.params['hostname']",
            "        self.use_rest = self.module.params['use_rest']",
            "        self.verify = self.module.params['validate_certs']",
            "        self.timeout = timeout",
            "        self.url = 'https://' + self.hostname + '/api/'",
            "        self.errors = list()",
            "        self.debug_logs = list()",
            "        self.check_required_library()",
            "",
            "    def check_required_library(self):",
            "        if not HAS_REQUESTS:",
            "            self.module.fail_json(msg=missing_required_lib('requests'))",
            "",
            "    def send_request(self, method, api, params, json=None, return_status_code=False):",
            "        ''' send http request and process reponse, including error conditions '''",
            "        url = self.url + api",
            "        status_code = None",
            "        content = None",
            "        json_dict = None",
            "        json_error = None",
            "        error_details = None",
            "",
            "        def get_json(response):",
            "            ''' extract json, and error message if present '''",
            "            try:",
            "                json = response.json()",
            "            except ValueError:",
            "                return None, None",
            "            error = json.get('error')",
            "            return json, error",
            "",
            "        try:",
            "            response = requests.request(method, url, verify=self.verify, auth=(self.username, self.password), params=params, timeout=self.timeout, json=json)",
            "            content = response.content  # for debug purposes",
            "            status_code = response.status_code",
            "            # If the response was successful, no Exception will be raised",
            "            response.raise_for_status()",
            "            json_dict, json_error = get_json(response)",
            "        except requests.exceptions.HTTPError as err:",
            "            __, json_error = get_json(response)",
            "            if json_error is None:",
            "                self.log_error(status_code, 'HTTP error: %s' % err)",
            "                error_details = str(err)",
            "            # If an error was reported in the json payload, it is handled below",
            "        except requests.exceptions.ConnectionError as err:",
            "            self.log_error(status_code, 'Connection error: %s' % err)",
            "            error_details = str(err)",
            "        except Exception as err:",
            "            self.log_error(status_code, 'Other error: %s' % err)",
            "            error_details = str(err)",
            "        if json_error is not None:",
            "            self.log_error(status_code, 'Endpoint error: %d: %s' % (status_code, json_error))",
            "            error_details = json_error",
            "        self.log_debug(status_code, content)",
            "        if return_status_code:",
            "            return status_code, error_details",
            "        return json_dict, error_details",
            "",
            "    def get(self, api, params):",
            "        method = 'GET'",
            "        return self.send_request(method, api, params)",
            "",
            "    def post(self, api, data, params=None):",
            "        method = 'POST'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def patch(self, api, data, params=None):",
            "        method = 'PATCH'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def delete(self, api, data, params=None):",
            "        method = 'DELETE'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def _is_rest(self, used_unsupported_rest_properties=None):",
            "        if self.use_rest == \"Always\":",
            "            if used_unsupported_rest_properties:",
            "                error = \"REST API currently does not support '%s'\" % \\",
            "                        ', '.join(used_unsupported_rest_properties)",
            "                return True, error",
            "            else:",
            "                return True, None",
            "        if self.use_rest == 'Never' or used_unsupported_rest_properties:",
            "            # force ZAPI if requested or if some parameter requires it",
            "            return False, None",
            "        method = 'HEAD'",
            "        api = 'cluster/software'",
            "        status_code, __ = self.send_request(method, api, params=None, return_status_code=True)",
            "        if status_code == 200:",
            "            return True, None",
            "        return False, None",
            "",
            "    def is_rest(self, used_unsupported_rest_properties=None):",
            "        ''' only return error if there is a reason to '''",
            "        use_rest, error = self._is_rest(used_unsupported_rest_properties)",
            "        if used_unsupported_rest_properties is None:",
            "            return use_rest",
            "        return use_rest, error",
            "",
            "    def log_error(self, status_code, message):",
            "        self.errors.append(message)",
            "        self.debug_logs.append((status_code, message))",
            "",
            "    def log_debug(self, status_code, content):",
            "        self.debug_logs.append((status_code, content))",
            "",
            "",
            "class AwsCvsRestAPI(object):",
            "    def __init__(self, module, timeout=60):",
            "        self.module = module",
            "        self.api_key = self.module.params['api_key']",
            "        self.secret_key = self.module.params['secret_key']",
            "        self.api_url = self.module.params['api_url']",
            "        self.verify = self.module.params['validate_certs']",
            "        self.timeout = timeout",
            "        self.url = 'https://' + self.api_url + '/v1/'",
            "        self.check_required_library()",
            "",
            "    def check_required_library(self):",
            "        if not HAS_REQUESTS:",
            "            self.module.fail_json(msg=missing_required_lib('requests'))",
            "",
            "    def send_request(self, method, api, params, json=None):",
            "        ''' send http request and process reponse, including error conditions '''",
            "        url = self.url + api",
            "        status_code = None",
            "        content = None",
            "        json_dict = None",
            "        json_error = None",
            "        error_details = None",
            "        headers = {",
            "            'Content-type': \"application/json\",",
            "            'api-key': self.api_key,",
            "            'secret-key': self.secret_key,",
            "            'Cache-Control': \"no-cache\",",
            "        }",
            "",
            "        def get_json(response):",
            "            ''' extract json, and error message if present '''",
            "            try:",
            "                json = response.json()",
            "",
            "            except ValueError:",
            "                return None, None",
            "            success_code = [200, 201, 202]",
            "            if response.status_code not in success_code:",
            "                error = json.get('message')",
            "            else:",
            "                error = None",
            "            return json, error",
            "        try:",
            "            response = requests.request(method, url, headers=headers, timeout=self.timeout, json=json)",
            "            status_code = response.status_code",
            "            # If the response was successful, no Exception will be raised",
            "            json_dict, json_error = get_json(response)",
            "        except requests.exceptions.HTTPError as err:",
            "            __, json_error = get_json(response)",
            "            if json_error is None:",
            "                error_details = str(err)",
            "        except requests.exceptions.ConnectionError as err:",
            "            error_details = str(err)",
            "        except Exception as err:",
            "            error_details = str(err)",
            "        if json_error is not None:",
            "            error_details = json_error",
            "",
            "        return json_dict, error_details",
            "",
            "    # If an error was reported in the json payload, it is handled below",
            "    def get(self, api, params=None):",
            "        method = 'GET'",
            "        return self.send_request(method, api, params)",
            "",
            "    def post(self, api, data, params=None):",
            "        method = 'POST'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def patch(self, api, data, params=None):",
            "        method = 'PATCH'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def put(self, api, data, params=None):",
            "        method = 'PUT'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def delete(self, api, data, params=None):",
            "        method = 'DELETE'",
            "        return self.send_request(method, api, params, json=data)",
            "",
            "    def get_state(self, jobId):",
            "        \"\"\" Method to get the state of the job \"\"\"",
            "        method = 'GET'",
            "        response, status_code = self.get('Jobs/%s' % jobId)",
            "        while str(response['state']) not in 'done':",
            "            response, status_code = self.get('Jobs/%s' % jobId)",
            "        return 'done'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "142": [
                "aws_cvs_host_argument_spec"
            ],
            "143": [
                "aws_cvs_host_argument_spec"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/docker/docker_swarm.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": 622,
                "PatchRowcode": "         name=dict(type='str'),"
            },
            "1": {
                "beforePatchRowNumber": 623,
                "afterPatchRowNumber": 623,
                "PatchRowcode": "         labels=dict(type='dict'),"
            },
            "2": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 624,
                "PatchRowcode": "         signing_ca_cert=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        signing_ca_key=dict(type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 625,
                "PatchRowcode": "+        signing_ca_key=dict(type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 626,
                "PatchRowcode": "         ca_force_rotate=dict(type='int'),"
            },
            "6": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": 627,
                "PatchRowcode": "         autolock_managers=dict(type='bool'),"
            },
            "7": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": 628,
                "PatchRowcode": "         node_id=dict(type='str'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "",
            "# Copyright 2016 Red Hat | Ansible",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: docker_swarm",
            "short_description: Manage Swarm cluster",
            "version_added: \"2.7\"",
            "description:",
            "  - Create a new Swarm cluster.",
            "  - Add/Remove nodes or managers to an existing cluster.",
            "options:",
            "  advertise_addr:",
            "    description:",
            "      - Externally reachable address advertised to other nodes.",
            "      - This can either be an address/port combination",
            "          in the form C(192.168.1.1:4567), or an interface followed by a",
            "          port number, like C(eth0:4567).",
            "      - If the port number is omitted,",
            "          the port number from the listen address is used.",
            "      - If I(advertise_addr) is not specified, it will be automatically",
            "          detected when possible.",
            "      - Only used when swarm is initialised or joined. Because of this it's not",
            "        considered for idempotency checking.",
            "    type: str",
            "  default_addr_pool:",
            "    description:",
            "      - Default address pool in CIDR format.",
            "      - Only used when swarm is initialised. Because of this it's not considered",
            "        for idempotency checking.",
            "      - Requires API version >= 1.39.",
            "    type: list",
            "    elements: str",
            "    version_added: \"2.8\"",
            "  subnet_size:",
            "    description:",
            "      - Default address pool subnet mask length.",
            "      - Only used when swarm is initialised. Because of this it's not considered",
            "        for idempotency checking.",
            "      - Requires API version >= 1.39.",
            "    type: int",
            "    version_added: \"2.8\"",
            "  listen_addr:",
            "    description:",
            "      - Listen address used for inter-manager communication.",
            "      - This can either be an address/port combination in the form",
            "          C(192.168.1.1:4567), or an interface followed by a port number,",
            "          like C(eth0:4567).",
            "      - If the port number is omitted, the default swarm listening port",
            "          is used.",
            "      - Only used when swarm is initialised or joined. Because of this it's not",
            "        considered for idempotency checking.",
            "    type: str",
            "    default: 0.0.0.0:2377",
            "  force:",
            "    description:",
            "      - Use with state C(present) to force creating a new Swarm, even if already part of one.",
            "      - Use with state C(absent) to Leave the swarm even if this node is a manager.",
            "    type: bool",
            "    default: no",
            "  state:",
            "    description:",
            "      - Set to C(present), to create/update a new cluster.",
            "      - Set to C(join), to join an existing cluster.",
            "      - Set to C(absent), to leave an existing cluster.",
            "      - Set to C(remove), to remove an absent node from the cluster.",
            "        Note that removing requires Docker SDK for Python >= 2.4.0.",
            "      - Set to C(inspect) to display swarm informations.",
            "    type: str",
            "    default: present",
            "    choices:",
            "      - present",
            "      - join",
            "      - absent",
            "      - remove",
            "      - inspect",
            "  node_id:",
            "    description:",
            "      - Swarm id of the node to remove.",
            "      - Used with I(state=remove).",
            "    type: str",
            "  join_token:",
            "    description:",
            "      - Swarm token used to join a swarm cluster.",
            "      - Used with I(state=join).",
            "    type: str",
            "  remote_addrs:",
            "    description:",
            "      - Remote address of one or more manager nodes of an existing Swarm to connect to.",
            "      - Used with I(state=join).",
            "    type: list",
            "    elements: str",
            "  task_history_retention_limit:",
            "    description:",
            "      - Maximum number of tasks history stored.",
            "      - Docker default value is C(5).",
            "    type: int",
            "  snapshot_interval:",
            "    description:",
            "      - Number of logs entries between snapshot.",
            "      - Docker default value is C(10000).",
            "    type: int",
            "  keep_old_snapshots:",
            "    description:",
            "      - Number of snapshots to keep beyond the current snapshot.",
            "      - Docker default value is C(0).",
            "    type: int",
            "  log_entries_for_slow_followers:",
            "    description:",
            "      - Number of log entries to keep around to sync up slow followers after a snapshot is created.",
            "    type: int",
            "  heartbeat_tick:",
            "    description:",
            "      - Amount of ticks (in seconds) between each heartbeat.",
            "      - Docker default value is C(1s).",
            "    type: int",
            "  election_tick:",
            "    description:",
            "      - Amount of ticks (in seconds) needed without a leader to trigger a new election.",
            "      - Docker default value is C(10s).",
            "    type: int",
            "  dispatcher_heartbeat_period:",
            "    description:",
            "      - The delay for an agent to send a heartbeat to the dispatcher.",
            "      - Docker default value is C(5s).",
            "    type: int",
            "  node_cert_expiry:",
            "    description:",
            "      - Automatic expiry for nodes certificates.",
            "      - Docker default value is C(3months).",
            "    type: int",
            "  name:",
            "    description:",
            "      - The name of the swarm.",
            "    type: str",
            "  labels:",
            "    description:",
            "      - User-defined key/value metadata.",
            "      - Label operations in this module apply to the docker swarm cluster.",
            "        Use M(docker_node) module to add/modify/remove swarm node labels.",
            "      - Requires API version >= 1.32.",
            "    type: dict",
            "  signing_ca_cert:",
            "    description:",
            "      - The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.",
            "      - This must not be a path to a certificate, but the contents of the certificate.",
            "      - Requires API version >= 1.30.",
            "    type: str",
            "  signing_ca_key:",
            "    description:",
            "      - The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.",
            "      - This must not be a path to a key, but the contents of the key.",
            "      - Requires API version >= 1.30.",
            "    type: str",
            "  ca_force_rotate:",
            "    description:",
            "      - An integer whose purpose is to force swarm to generate a new signing CA certificate and key,",
            "          if none have been specified.",
            "      - Docker default value is C(0).",
            "      - Requires API version >= 1.30.",
            "    type: int",
            "  autolock_managers:",
            "    description:",
            "      - If set, generate a key and use it to lock data stored on the managers.",
            "      - Docker default value is C(no).",
            "      - M(docker_swarm_info) can be used to retrieve the unlock key.",
            "    type: bool",
            "  rotate_worker_token:",
            "    description: Rotate the worker join token.",
            "    type: bool",
            "    default: no",
            "  rotate_manager_token:",
            "    description: Rotate the manager join token.",
            "    type: bool",
            "    default: no",
            "extends_documentation_fragment:",
            "  - docker",
            "  - docker.docker_py_1_documentation",
            "requirements:",
            "  - \"L(Docker SDK for Python,https://docker-py.readthedocs.io/en/stable/) >= 1.10.0 (use L(docker-py,https://pypi.org/project/docker-py/) for Python 2.6)\"",
            "  - Docker API >= 1.25",
            "author:",
            "  - Thierry Bouvet (@tbouvet)",
            "  - Piotr Wojciechowski (@WojciechowskiPiotr)",
            "'''",
            "",
            "EXAMPLES = '''",
            "",
            "- name: Init a new swarm with default parameters",
            "  docker_swarm:",
            "    state: present",
            "",
            "- name: Update swarm configuration",
            "  docker_swarm:",
            "    state: present",
            "    election_tick: 5",
            "",
            "- name: Add nodes",
            "  docker_swarm:",
            "    state: join",
            "    advertise_addr: 192.168.1.2",
            "    join_token: SWMTKN-1--xxxxx",
            "    remote_addrs: [ '192.168.1.1:2377' ]",
            "",
            "- name: Leave swarm for a node",
            "  docker_swarm:",
            "    state: absent",
            "",
            "- name: Remove a swarm manager",
            "  docker_swarm:",
            "    state: absent",
            "    force: true",
            "",
            "- name: Remove node from swarm",
            "  docker_swarm:",
            "    state: remove",
            "    node_id: mynode",
            "",
            "- name: Inspect swarm",
            "  docker_swarm:",
            "    state: inspect",
            "  register: swarm_info",
            "'''",
            "",
            "RETURN = '''",
            "swarm_facts:",
            "  description: Informations about swarm.",
            "  returned: success",
            "  type: dict",
            "  contains:",
            "      JoinTokens:",
            "          description: Tokens to connect to the Swarm.",
            "          returned: success",
            "          type: dict",
            "          contains:",
            "              Worker:",
            "                  description: Token to create a new *worker* node",
            "                  returned: success",
            "                  type: str",
            "                  example: SWMTKN-1--xxxxx",
            "              Manager:",
            "                  description: Token to create a new *manager* node",
            "                  returned: success",
            "                  type: str",
            "                  example: SWMTKN-1--xxxxx",
            "      UnlockKey:",
            "          description: The swarm unlock-key if I(autolock_managers) is C(true).",
            "          returned: on success if I(autolock_managers) is C(true)",
            "            and swarm is initialised, or if I(autolock_managers) has changed.",
            "          type: str",
            "          example: SWMKEY-1-xxx",
            "",
            "actions:",
            "  description: Provides the actions done on the swarm.",
            "  returned: when action failed.",
            "  type: list",
            "  elements: str",
            "  example: \"['This cluster is already a swarm cluster']\"",
            "",
            "'''",
            "",
            "import json",
            "import traceback",
            "",
            "try:",
            "    from docker.errors import DockerException, APIError",
            "except ImportError:",
            "    # missing Docker SDK for Python handled in ansible.module_utils.docker.common",
            "    pass",
            "",
            "from ansible.module_utils.docker.common import (",
            "    DockerBaseClass,",
            "    DifferenceTracker,",
            "    RequestException,",
            ")",
            "",
            "from ansible.module_utils.docker.swarm import AnsibleDockerSwarmClient",
            "",
            "from ansible.module_utils._text import to_native",
            "",
            "",
            "class TaskParameters(DockerBaseClass):",
            "    def __init__(self):",
            "        super(TaskParameters, self).__init__()",
            "",
            "        self.advertise_addr = None",
            "        self.listen_addr = None",
            "        self.remote_addrs = None",
            "        self.join_token = None",
            "",
            "        # Spec",
            "        self.snapshot_interval = None",
            "        self.task_history_retention_limit = None",
            "        self.keep_old_snapshots = None",
            "        self.log_entries_for_slow_followers = None",
            "        self.heartbeat_tick = None",
            "        self.election_tick = None",
            "        self.dispatcher_heartbeat_period = None",
            "        self.node_cert_expiry = None",
            "        self.name = None",
            "        self.labels = None",
            "        self.log_driver = None",
            "        self.signing_ca_cert = None",
            "        self.signing_ca_key = None",
            "        self.ca_force_rotate = None",
            "        self.autolock_managers = None",
            "        self.rotate_worker_token = None",
            "        self.rotate_manager_token = None",
            "        self.default_addr_pool = None",
            "        self.subnet_size = None",
            "",
            "    @staticmethod",
            "    def from_ansible_params(client):",
            "        result = TaskParameters()",
            "        for key, value in client.module.params.items():",
            "            if key in result.__dict__:",
            "                setattr(result, key, value)",
            "",
            "        result.update_parameters(client)",
            "        return result",
            "",
            "    def update_from_swarm_info(self, swarm_info):",
            "        spec = swarm_info['Spec']",
            "",
            "        ca_config = spec.get('CAConfig') or dict()",
            "        if self.node_cert_expiry is None:",
            "            self.node_cert_expiry = ca_config.get('NodeCertExpiry')",
            "        if self.ca_force_rotate is None:",
            "            self.ca_force_rotate = ca_config.get('ForceRotate')",
            "",
            "        dispatcher = spec.get('Dispatcher') or dict()",
            "        if self.dispatcher_heartbeat_period is None:",
            "            self.dispatcher_heartbeat_period = dispatcher.get('HeartbeatPeriod')",
            "",
            "        raft = spec.get('Raft') or dict()",
            "        if self.snapshot_interval is None:",
            "            self.snapshot_interval = raft.get('SnapshotInterval')",
            "        if self.keep_old_snapshots is None:",
            "            self.keep_old_snapshots = raft.get('KeepOldSnapshots')",
            "        if self.heartbeat_tick is None:",
            "            self.heartbeat_tick = raft.get('HeartbeatTick')",
            "        if self.log_entries_for_slow_followers is None:",
            "            self.log_entries_for_slow_followers = raft.get('LogEntriesForSlowFollowers')",
            "        if self.election_tick is None:",
            "            self.election_tick = raft.get('ElectionTick')",
            "",
            "        orchestration = spec.get('Orchestration') or dict()",
            "        if self.task_history_retention_limit is None:",
            "            self.task_history_retention_limit = orchestration.get('TaskHistoryRetentionLimit')",
            "",
            "        encryption_config = spec.get('EncryptionConfig') or dict()",
            "        if self.autolock_managers is None:",
            "            self.autolock_managers = encryption_config.get('AutoLockManagers')",
            "",
            "        if self.name is None:",
            "            self.name = spec['Name']",
            "",
            "        if self.labels is None:",
            "            self.labels = spec.get('Labels') or {}",
            "",
            "        if 'LogDriver' in spec['TaskDefaults']:",
            "            self.log_driver = spec['TaskDefaults']['LogDriver']",
            "",
            "    def update_parameters(self, client):",
            "        assign = dict(",
            "            snapshot_interval='snapshot_interval',",
            "            task_history_retention_limit='task_history_retention_limit',",
            "            keep_old_snapshots='keep_old_snapshots',",
            "            log_entries_for_slow_followers='log_entries_for_slow_followers',",
            "            heartbeat_tick='heartbeat_tick',",
            "            election_tick='election_tick',",
            "            dispatcher_heartbeat_period='dispatcher_heartbeat_period',",
            "            node_cert_expiry='node_cert_expiry',",
            "            name='name',",
            "            labels='labels',",
            "            signing_ca_cert='signing_ca_cert',",
            "            signing_ca_key='signing_ca_key',",
            "            ca_force_rotate='ca_force_rotate',",
            "            autolock_managers='autolock_managers',",
            "            log_driver='log_driver',",
            "        )",
            "        params = dict()",
            "        for dest, source in assign.items():",
            "            if not client.option_minimal_versions[source]['supported']:",
            "                continue",
            "            value = getattr(self, source)",
            "            if value is not None:",
            "                params[dest] = value",
            "        self.spec = client.create_swarm_spec(**params)",
            "",
            "    def compare_to_active(self, other, client, differences):",
            "        for k in self.__dict__:",
            "            if k in ('advertise_addr', 'listen_addr', 'remote_addrs', 'join_token',",
            "                     'rotate_worker_token', 'rotate_manager_token', 'spec',",
            "                     'default_addr_pool', 'subnet_size'):",
            "                continue",
            "            if not client.option_minimal_versions[k]['supported']:",
            "                continue",
            "            value = getattr(self, k)",
            "            if value is None:",
            "                continue",
            "            other_value = getattr(other, k)",
            "            if value != other_value:",
            "                differences.add(k, parameter=value, active=other_value)",
            "        if self.rotate_worker_token:",
            "            differences.add('rotate_worker_token', parameter=True, active=False)",
            "        if self.rotate_manager_token:",
            "            differences.add('rotate_manager_token', parameter=True, active=False)",
            "        return differences",
            "",
            "",
            "class SwarmManager(DockerBaseClass):",
            "",
            "    def __init__(self, client, results):",
            "",
            "        super(SwarmManager, self).__init__()",
            "",
            "        self.client = client",
            "        self.results = results",
            "        self.check_mode = self.client.check_mode",
            "        self.swarm_info = {}",
            "",
            "        self.state = client.module.params['state']",
            "        self.force = client.module.params['force']",
            "        self.node_id = client.module.params['node_id']",
            "",
            "        self.differences = DifferenceTracker()",
            "        self.parameters = TaskParameters.from_ansible_params(client)",
            "",
            "        self.created = False",
            "",
            "    def __call__(self):",
            "        choice_map = {",
            "            \"present\": self.init_swarm,",
            "            \"join\": self.join,",
            "            \"absent\": self.leave,",
            "            \"remove\": self.remove,",
            "            \"inspect\": self.inspect_swarm",
            "        }",
            "",
            "        if self.state == 'inspect':",
            "            self.client.module.deprecate(",
            "                \"The 'inspect' state is deprecated, please use 'docker_swarm_info' to inspect swarm cluster\",",
            "                version='2.12')",
            "",
            "        choice_map.get(self.state)()",
            "",
            "        if self.client.module._diff or self.parameters.debug:",
            "            diff = dict()",
            "            diff['before'], diff['after'] = self.differences.get_before_after()",
            "            self.results['diff'] = diff",
            "",
            "    def inspect_swarm(self):",
            "        try:",
            "            data = self.client.inspect_swarm()",
            "            json_str = json.dumps(data, ensure_ascii=False)",
            "            self.swarm_info = json.loads(json_str)",
            "",
            "            self.results['changed'] = False",
            "            self.results['swarm_facts'] = self.swarm_info",
            "",
            "            unlock_key = self.get_unlock_key()",
            "            self.swarm_info.update(unlock_key)",
            "        except APIError:",
            "            return",
            "",
            "    def get_unlock_key(self):",
            "        default = {'UnlockKey': None}",
            "        if not self.has_swarm_lock_changed():",
            "            return default",
            "        try:",
            "            return self.client.get_unlock_key() or default",
            "        except APIError:",
            "            return default",
            "",
            "    def has_swarm_lock_changed(self):",
            "        return self.parameters.autolock_managers and (",
            "            self.created or self.differences.has_difference_for('autolock_managers')",
            "        )",
            "",
            "    def init_swarm(self):",
            "        if not self.force and self.client.check_if_swarm_manager():",
            "            self.__update_swarm()",
            "            return",
            "",
            "        if not self.check_mode:",
            "            init_arguments = {",
            "                'advertise_addr': self.parameters.advertise_addr,",
            "                'listen_addr': self.parameters.listen_addr,",
            "                'force_new_cluster': self.force,",
            "                'swarm_spec': self.parameters.spec,",
            "            }",
            "            if self.parameters.default_addr_pool is not None:",
            "                init_arguments['default_addr_pool'] = self.parameters.default_addr_pool",
            "            if self.parameters.subnet_size is not None:",
            "                init_arguments['subnet_size'] = self.parameters.subnet_size",
            "            try:",
            "                self.client.init_swarm(**init_arguments)",
            "            except APIError as exc:",
            "                self.client.fail(\"Can not create a new Swarm Cluster: %s\" % to_native(exc))",
            "",
            "        if not self.client.check_if_swarm_manager():",
            "            if not self.check_mode:",
            "                self.client.fail(\"Swarm not created or other error!\")",
            "",
            "        self.created = True",
            "        self.inspect_swarm()",
            "        self.results['actions'].append(\"New Swarm cluster created: %s\" % (self.swarm_info.get('ID')))",
            "        self.differences.add('state', parameter='present', active='absent')",
            "        self.results['changed'] = True",
            "        self.results['swarm_facts'] = {",
            "            'JoinTokens': self.swarm_info.get('JoinTokens'),",
            "            'UnlockKey': self.swarm_info.get('UnlockKey')",
            "        }",
            "",
            "    def __update_swarm(self):",
            "        try:",
            "            self.inspect_swarm()",
            "            version = self.swarm_info['Version']['Index']",
            "            self.parameters.update_from_swarm_info(self.swarm_info)",
            "            old_parameters = TaskParameters()",
            "            old_parameters.update_from_swarm_info(self.swarm_info)",
            "            self.parameters.compare_to_active(old_parameters, self.client, self.differences)",
            "            if self.differences.empty:",
            "                self.results['actions'].append(\"No modification\")",
            "                self.results['changed'] = False",
            "                return",
            "            update_parameters = TaskParameters.from_ansible_params(self.client)",
            "            update_parameters.update_parameters(self.client)",
            "            if not self.check_mode:",
            "                self.client.update_swarm(",
            "                    version=version, swarm_spec=update_parameters.spec,",
            "                    rotate_worker_token=self.parameters.rotate_worker_token,",
            "                    rotate_manager_token=self.parameters.rotate_manager_token)",
            "        except APIError as exc:",
            "            self.client.fail(\"Can not update a Swarm Cluster: %s\" % to_native(exc))",
            "            return",
            "",
            "        self.inspect_swarm()",
            "        self.results['actions'].append(\"Swarm cluster updated\")",
            "        self.results['changed'] = True",
            "",
            "    def join(self):",
            "        if self.client.check_if_swarm_node():",
            "            self.results['actions'].append(\"This node is already part of a swarm.\")",
            "            return",
            "        if not self.check_mode:",
            "            try:",
            "                self.client.join_swarm(",
            "                    remote_addrs=self.parameters.remote_addrs, join_token=self.parameters.join_token,",
            "                    listen_addr=self.parameters.listen_addr, advertise_addr=self.parameters.advertise_addr)",
            "            except APIError as exc:",
            "                self.client.fail(\"Can not join the Swarm Cluster: %s\" % to_native(exc))",
            "        self.results['actions'].append(\"New node is added to swarm cluster\")",
            "        self.differences.add('joined', parameter=True, active=False)",
            "        self.results['changed'] = True",
            "",
            "    def leave(self):",
            "        if not self.client.check_if_swarm_node():",
            "            self.results['actions'].append(\"This node is not part of a swarm.\")",
            "            return",
            "        if not self.check_mode:",
            "            try:",
            "                self.client.leave_swarm(force=self.force)",
            "            except APIError as exc:",
            "                self.client.fail(\"This node can not leave the Swarm Cluster: %s\" % to_native(exc))",
            "        self.results['actions'].append(\"Node has left the swarm cluster\")",
            "        self.differences.add('joined', parameter='absent', active='present')",
            "        self.results['changed'] = True",
            "",
            "    def remove(self):",
            "        if not self.client.check_if_swarm_manager():",
            "            self.client.fail(\"This node is not a manager.\")",
            "",
            "        try:",
            "            status_down = self.client.check_if_swarm_node_is_down(node_id=self.node_id, repeat_check=5)",
            "        except APIError:",
            "            return",
            "",
            "        if not status_down:",
            "            self.client.fail(\"Can not remove the node. The status node is ready and not down.\")",
            "",
            "        if not self.check_mode:",
            "            try:",
            "                self.client.remove_node(node_id=self.node_id, force=self.force)",
            "            except APIError as exc:",
            "                self.client.fail(\"Can not remove the node from the Swarm Cluster: %s\" % to_native(exc))",
            "        self.results['actions'].append(\"Node is removed from swarm cluster.\")",
            "        self.differences.add('joined', parameter=False, active=True)",
            "        self.results['changed'] = True",
            "",
            "",
            "def _detect_remove_operation(client):",
            "    return client.module.params['state'] == 'remove'",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        advertise_addr=dict(type='str'),",
            "        state=dict(type='str', default='present', choices=['present', 'join', 'absent', 'remove', 'inspect']),",
            "        force=dict(type='bool', default=False),",
            "        listen_addr=dict(type='str', default='0.0.0.0:2377'),",
            "        remote_addrs=dict(type='list', elements='str'),",
            "        join_token=dict(type='str'),",
            "        snapshot_interval=dict(type='int'),",
            "        task_history_retention_limit=dict(type='int'),",
            "        keep_old_snapshots=dict(type='int'),",
            "        log_entries_for_slow_followers=dict(type='int'),",
            "        heartbeat_tick=dict(type='int'),",
            "        election_tick=dict(type='int'),",
            "        dispatcher_heartbeat_period=dict(type='int'),",
            "        node_cert_expiry=dict(type='int'),",
            "        name=dict(type='str'),",
            "        labels=dict(type='dict'),",
            "        signing_ca_cert=dict(type='str'),",
            "        signing_ca_key=dict(type='str'),",
            "        ca_force_rotate=dict(type='int'),",
            "        autolock_managers=dict(type='bool'),",
            "        node_id=dict(type='str'),",
            "        rotate_worker_token=dict(type='bool', default=False),",
            "        rotate_manager_token=dict(type='bool', default=False),",
            "        default_addr_pool=dict(type='list', elements='str'),",
            "        subnet_size=dict(type='int'),",
            "    )",
            "",
            "    required_if = [",
            "        ('state', 'join', ['advertise_addr', 'remote_addrs', 'join_token']),",
            "        ('state', 'remove', ['node_id'])",
            "    ]",
            "",
            "    option_minimal_versions = dict(",
            "        labels=dict(docker_py_version='2.6.0', docker_api_version='1.32'),",
            "        signing_ca_cert=dict(docker_py_version='2.6.0', docker_api_version='1.30'),",
            "        signing_ca_key=dict(docker_py_version='2.6.0', docker_api_version='1.30'),",
            "        ca_force_rotate=dict(docker_py_version='2.6.0', docker_api_version='1.30'),",
            "        autolock_managers=dict(docker_py_version='2.6.0'),",
            "        log_driver=dict(docker_py_version='2.6.0'),",
            "        remove_operation=dict(",
            "            docker_py_version='2.4.0',",
            "            detect_usage=_detect_remove_operation,",
            "            usage_msg='remove swarm nodes'",
            "        ),",
            "        default_addr_pool=dict(docker_py_version='4.0.0', docker_api_version='1.39'),",
            "        subnet_size=dict(docker_py_version='4.0.0', docker_api_version='1.39'),",
            "    )",
            "",
            "    client = AnsibleDockerSwarmClient(",
            "        argument_spec=argument_spec,",
            "        supports_check_mode=True,",
            "        required_if=required_if,",
            "        min_docker_version='1.10.0',",
            "        min_docker_api_version='1.25',",
            "        option_minimal_versions=option_minimal_versions,",
            "    )",
            "",
            "    try:",
            "        results = dict(",
            "            changed=False,",
            "            result='',",
            "            actions=[]",
            "        )",
            "",
            "        SwarmManager(client, results)()",
            "        client.module.exit_json(**results)",
            "    except DockerException as e:",
            "        client.fail('An unexpected docker error occurred: {0}'.format(e), exception=traceback.format_exc())",
            "    except RequestException as e:",
            "        client.fail('An unexpected requests error occurred when docker-py tried to talk to the docker daemon: {0}'.format(e), exception=traceback.format_exc())",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "",
            "# Copyright 2016 Red Hat | Ansible",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: docker_swarm",
            "short_description: Manage Swarm cluster",
            "version_added: \"2.7\"",
            "description:",
            "  - Create a new Swarm cluster.",
            "  - Add/Remove nodes or managers to an existing cluster.",
            "options:",
            "  advertise_addr:",
            "    description:",
            "      - Externally reachable address advertised to other nodes.",
            "      - This can either be an address/port combination",
            "          in the form C(192.168.1.1:4567), or an interface followed by a",
            "          port number, like C(eth0:4567).",
            "      - If the port number is omitted,",
            "          the port number from the listen address is used.",
            "      - If I(advertise_addr) is not specified, it will be automatically",
            "          detected when possible.",
            "      - Only used when swarm is initialised or joined. Because of this it's not",
            "        considered for idempotency checking.",
            "    type: str",
            "  default_addr_pool:",
            "    description:",
            "      - Default address pool in CIDR format.",
            "      - Only used when swarm is initialised. Because of this it's not considered",
            "        for idempotency checking.",
            "      - Requires API version >= 1.39.",
            "    type: list",
            "    elements: str",
            "    version_added: \"2.8\"",
            "  subnet_size:",
            "    description:",
            "      - Default address pool subnet mask length.",
            "      - Only used when swarm is initialised. Because of this it's not considered",
            "        for idempotency checking.",
            "      - Requires API version >= 1.39.",
            "    type: int",
            "    version_added: \"2.8\"",
            "  listen_addr:",
            "    description:",
            "      - Listen address used for inter-manager communication.",
            "      - This can either be an address/port combination in the form",
            "          C(192.168.1.1:4567), or an interface followed by a port number,",
            "          like C(eth0:4567).",
            "      - If the port number is omitted, the default swarm listening port",
            "          is used.",
            "      - Only used when swarm is initialised or joined. Because of this it's not",
            "        considered for idempotency checking.",
            "    type: str",
            "    default: 0.0.0.0:2377",
            "  force:",
            "    description:",
            "      - Use with state C(present) to force creating a new Swarm, even if already part of one.",
            "      - Use with state C(absent) to Leave the swarm even if this node is a manager.",
            "    type: bool",
            "    default: no",
            "  state:",
            "    description:",
            "      - Set to C(present), to create/update a new cluster.",
            "      - Set to C(join), to join an existing cluster.",
            "      - Set to C(absent), to leave an existing cluster.",
            "      - Set to C(remove), to remove an absent node from the cluster.",
            "        Note that removing requires Docker SDK for Python >= 2.4.0.",
            "      - Set to C(inspect) to display swarm informations.",
            "    type: str",
            "    default: present",
            "    choices:",
            "      - present",
            "      - join",
            "      - absent",
            "      - remove",
            "      - inspect",
            "  node_id:",
            "    description:",
            "      - Swarm id of the node to remove.",
            "      - Used with I(state=remove).",
            "    type: str",
            "  join_token:",
            "    description:",
            "      - Swarm token used to join a swarm cluster.",
            "      - Used with I(state=join).",
            "    type: str",
            "  remote_addrs:",
            "    description:",
            "      - Remote address of one or more manager nodes of an existing Swarm to connect to.",
            "      - Used with I(state=join).",
            "    type: list",
            "    elements: str",
            "  task_history_retention_limit:",
            "    description:",
            "      - Maximum number of tasks history stored.",
            "      - Docker default value is C(5).",
            "    type: int",
            "  snapshot_interval:",
            "    description:",
            "      - Number of logs entries between snapshot.",
            "      - Docker default value is C(10000).",
            "    type: int",
            "  keep_old_snapshots:",
            "    description:",
            "      - Number of snapshots to keep beyond the current snapshot.",
            "      - Docker default value is C(0).",
            "    type: int",
            "  log_entries_for_slow_followers:",
            "    description:",
            "      - Number of log entries to keep around to sync up slow followers after a snapshot is created.",
            "    type: int",
            "  heartbeat_tick:",
            "    description:",
            "      - Amount of ticks (in seconds) between each heartbeat.",
            "      - Docker default value is C(1s).",
            "    type: int",
            "  election_tick:",
            "    description:",
            "      - Amount of ticks (in seconds) needed without a leader to trigger a new election.",
            "      - Docker default value is C(10s).",
            "    type: int",
            "  dispatcher_heartbeat_period:",
            "    description:",
            "      - The delay for an agent to send a heartbeat to the dispatcher.",
            "      - Docker default value is C(5s).",
            "    type: int",
            "  node_cert_expiry:",
            "    description:",
            "      - Automatic expiry for nodes certificates.",
            "      - Docker default value is C(3months).",
            "    type: int",
            "  name:",
            "    description:",
            "      - The name of the swarm.",
            "    type: str",
            "  labels:",
            "    description:",
            "      - User-defined key/value metadata.",
            "      - Label operations in this module apply to the docker swarm cluster.",
            "        Use M(docker_node) module to add/modify/remove swarm node labels.",
            "      - Requires API version >= 1.32.",
            "    type: dict",
            "  signing_ca_cert:",
            "    description:",
            "      - The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.",
            "      - This must not be a path to a certificate, but the contents of the certificate.",
            "      - Requires API version >= 1.30.",
            "    type: str",
            "  signing_ca_key:",
            "    description:",
            "      - The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.",
            "      - This must not be a path to a key, but the contents of the key.",
            "      - Requires API version >= 1.30.",
            "    type: str",
            "  ca_force_rotate:",
            "    description:",
            "      - An integer whose purpose is to force swarm to generate a new signing CA certificate and key,",
            "          if none have been specified.",
            "      - Docker default value is C(0).",
            "      - Requires API version >= 1.30.",
            "    type: int",
            "  autolock_managers:",
            "    description:",
            "      - If set, generate a key and use it to lock data stored on the managers.",
            "      - Docker default value is C(no).",
            "      - M(docker_swarm_info) can be used to retrieve the unlock key.",
            "    type: bool",
            "  rotate_worker_token:",
            "    description: Rotate the worker join token.",
            "    type: bool",
            "    default: no",
            "  rotate_manager_token:",
            "    description: Rotate the manager join token.",
            "    type: bool",
            "    default: no",
            "extends_documentation_fragment:",
            "  - docker",
            "  - docker.docker_py_1_documentation",
            "requirements:",
            "  - \"L(Docker SDK for Python,https://docker-py.readthedocs.io/en/stable/) >= 1.10.0 (use L(docker-py,https://pypi.org/project/docker-py/) for Python 2.6)\"",
            "  - Docker API >= 1.25",
            "author:",
            "  - Thierry Bouvet (@tbouvet)",
            "  - Piotr Wojciechowski (@WojciechowskiPiotr)",
            "'''",
            "",
            "EXAMPLES = '''",
            "",
            "- name: Init a new swarm with default parameters",
            "  docker_swarm:",
            "    state: present",
            "",
            "- name: Update swarm configuration",
            "  docker_swarm:",
            "    state: present",
            "    election_tick: 5",
            "",
            "- name: Add nodes",
            "  docker_swarm:",
            "    state: join",
            "    advertise_addr: 192.168.1.2",
            "    join_token: SWMTKN-1--xxxxx",
            "    remote_addrs: [ '192.168.1.1:2377' ]",
            "",
            "- name: Leave swarm for a node",
            "  docker_swarm:",
            "    state: absent",
            "",
            "- name: Remove a swarm manager",
            "  docker_swarm:",
            "    state: absent",
            "    force: true",
            "",
            "- name: Remove node from swarm",
            "  docker_swarm:",
            "    state: remove",
            "    node_id: mynode",
            "",
            "- name: Inspect swarm",
            "  docker_swarm:",
            "    state: inspect",
            "  register: swarm_info",
            "'''",
            "",
            "RETURN = '''",
            "swarm_facts:",
            "  description: Informations about swarm.",
            "  returned: success",
            "  type: dict",
            "  contains:",
            "      JoinTokens:",
            "          description: Tokens to connect to the Swarm.",
            "          returned: success",
            "          type: dict",
            "          contains:",
            "              Worker:",
            "                  description: Token to create a new *worker* node",
            "                  returned: success",
            "                  type: str",
            "                  example: SWMTKN-1--xxxxx",
            "              Manager:",
            "                  description: Token to create a new *manager* node",
            "                  returned: success",
            "                  type: str",
            "                  example: SWMTKN-1--xxxxx",
            "      UnlockKey:",
            "          description: The swarm unlock-key if I(autolock_managers) is C(true).",
            "          returned: on success if I(autolock_managers) is C(true)",
            "            and swarm is initialised, or if I(autolock_managers) has changed.",
            "          type: str",
            "          example: SWMKEY-1-xxx",
            "",
            "actions:",
            "  description: Provides the actions done on the swarm.",
            "  returned: when action failed.",
            "  type: list",
            "  elements: str",
            "  example: \"['This cluster is already a swarm cluster']\"",
            "",
            "'''",
            "",
            "import json",
            "import traceback",
            "",
            "try:",
            "    from docker.errors import DockerException, APIError",
            "except ImportError:",
            "    # missing Docker SDK for Python handled in ansible.module_utils.docker.common",
            "    pass",
            "",
            "from ansible.module_utils.docker.common import (",
            "    DockerBaseClass,",
            "    DifferenceTracker,",
            "    RequestException,",
            ")",
            "",
            "from ansible.module_utils.docker.swarm import AnsibleDockerSwarmClient",
            "",
            "from ansible.module_utils._text import to_native",
            "",
            "",
            "class TaskParameters(DockerBaseClass):",
            "    def __init__(self):",
            "        super(TaskParameters, self).__init__()",
            "",
            "        self.advertise_addr = None",
            "        self.listen_addr = None",
            "        self.remote_addrs = None",
            "        self.join_token = None",
            "",
            "        # Spec",
            "        self.snapshot_interval = None",
            "        self.task_history_retention_limit = None",
            "        self.keep_old_snapshots = None",
            "        self.log_entries_for_slow_followers = None",
            "        self.heartbeat_tick = None",
            "        self.election_tick = None",
            "        self.dispatcher_heartbeat_period = None",
            "        self.node_cert_expiry = None",
            "        self.name = None",
            "        self.labels = None",
            "        self.log_driver = None",
            "        self.signing_ca_cert = None",
            "        self.signing_ca_key = None",
            "        self.ca_force_rotate = None",
            "        self.autolock_managers = None",
            "        self.rotate_worker_token = None",
            "        self.rotate_manager_token = None",
            "        self.default_addr_pool = None",
            "        self.subnet_size = None",
            "",
            "    @staticmethod",
            "    def from_ansible_params(client):",
            "        result = TaskParameters()",
            "        for key, value in client.module.params.items():",
            "            if key in result.__dict__:",
            "                setattr(result, key, value)",
            "",
            "        result.update_parameters(client)",
            "        return result",
            "",
            "    def update_from_swarm_info(self, swarm_info):",
            "        spec = swarm_info['Spec']",
            "",
            "        ca_config = spec.get('CAConfig') or dict()",
            "        if self.node_cert_expiry is None:",
            "            self.node_cert_expiry = ca_config.get('NodeCertExpiry')",
            "        if self.ca_force_rotate is None:",
            "            self.ca_force_rotate = ca_config.get('ForceRotate')",
            "",
            "        dispatcher = spec.get('Dispatcher') or dict()",
            "        if self.dispatcher_heartbeat_period is None:",
            "            self.dispatcher_heartbeat_period = dispatcher.get('HeartbeatPeriod')",
            "",
            "        raft = spec.get('Raft') or dict()",
            "        if self.snapshot_interval is None:",
            "            self.snapshot_interval = raft.get('SnapshotInterval')",
            "        if self.keep_old_snapshots is None:",
            "            self.keep_old_snapshots = raft.get('KeepOldSnapshots')",
            "        if self.heartbeat_tick is None:",
            "            self.heartbeat_tick = raft.get('HeartbeatTick')",
            "        if self.log_entries_for_slow_followers is None:",
            "            self.log_entries_for_slow_followers = raft.get('LogEntriesForSlowFollowers')",
            "        if self.election_tick is None:",
            "            self.election_tick = raft.get('ElectionTick')",
            "",
            "        orchestration = spec.get('Orchestration') or dict()",
            "        if self.task_history_retention_limit is None:",
            "            self.task_history_retention_limit = orchestration.get('TaskHistoryRetentionLimit')",
            "",
            "        encryption_config = spec.get('EncryptionConfig') or dict()",
            "        if self.autolock_managers is None:",
            "            self.autolock_managers = encryption_config.get('AutoLockManagers')",
            "",
            "        if self.name is None:",
            "            self.name = spec['Name']",
            "",
            "        if self.labels is None:",
            "            self.labels = spec.get('Labels') or {}",
            "",
            "        if 'LogDriver' in spec['TaskDefaults']:",
            "            self.log_driver = spec['TaskDefaults']['LogDriver']",
            "",
            "    def update_parameters(self, client):",
            "        assign = dict(",
            "            snapshot_interval='snapshot_interval',",
            "            task_history_retention_limit='task_history_retention_limit',",
            "            keep_old_snapshots='keep_old_snapshots',",
            "            log_entries_for_slow_followers='log_entries_for_slow_followers',",
            "            heartbeat_tick='heartbeat_tick',",
            "            election_tick='election_tick',",
            "            dispatcher_heartbeat_period='dispatcher_heartbeat_period',",
            "            node_cert_expiry='node_cert_expiry',",
            "            name='name',",
            "            labels='labels',",
            "            signing_ca_cert='signing_ca_cert',",
            "            signing_ca_key='signing_ca_key',",
            "            ca_force_rotate='ca_force_rotate',",
            "            autolock_managers='autolock_managers',",
            "            log_driver='log_driver',",
            "        )",
            "        params = dict()",
            "        for dest, source in assign.items():",
            "            if not client.option_minimal_versions[source]['supported']:",
            "                continue",
            "            value = getattr(self, source)",
            "            if value is not None:",
            "                params[dest] = value",
            "        self.spec = client.create_swarm_spec(**params)",
            "",
            "    def compare_to_active(self, other, client, differences):",
            "        for k in self.__dict__:",
            "            if k in ('advertise_addr', 'listen_addr', 'remote_addrs', 'join_token',",
            "                     'rotate_worker_token', 'rotate_manager_token', 'spec',",
            "                     'default_addr_pool', 'subnet_size'):",
            "                continue",
            "            if not client.option_minimal_versions[k]['supported']:",
            "                continue",
            "            value = getattr(self, k)",
            "            if value is None:",
            "                continue",
            "            other_value = getattr(other, k)",
            "            if value != other_value:",
            "                differences.add(k, parameter=value, active=other_value)",
            "        if self.rotate_worker_token:",
            "            differences.add('rotate_worker_token', parameter=True, active=False)",
            "        if self.rotate_manager_token:",
            "            differences.add('rotate_manager_token', parameter=True, active=False)",
            "        return differences",
            "",
            "",
            "class SwarmManager(DockerBaseClass):",
            "",
            "    def __init__(self, client, results):",
            "",
            "        super(SwarmManager, self).__init__()",
            "",
            "        self.client = client",
            "        self.results = results",
            "        self.check_mode = self.client.check_mode",
            "        self.swarm_info = {}",
            "",
            "        self.state = client.module.params['state']",
            "        self.force = client.module.params['force']",
            "        self.node_id = client.module.params['node_id']",
            "",
            "        self.differences = DifferenceTracker()",
            "        self.parameters = TaskParameters.from_ansible_params(client)",
            "",
            "        self.created = False",
            "",
            "    def __call__(self):",
            "        choice_map = {",
            "            \"present\": self.init_swarm,",
            "            \"join\": self.join,",
            "            \"absent\": self.leave,",
            "            \"remove\": self.remove,",
            "            \"inspect\": self.inspect_swarm",
            "        }",
            "",
            "        if self.state == 'inspect':",
            "            self.client.module.deprecate(",
            "                \"The 'inspect' state is deprecated, please use 'docker_swarm_info' to inspect swarm cluster\",",
            "                version='2.12')",
            "",
            "        choice_map.get(self.state)()",
            "",
            "        if self.client.module._diff or self.parameters.debug:",
            "            diff = dict()",
            "            diff['before'], diff['after'] = self.differences.get_before_after()",
            "            self.results['diff'] = diff",
            "",
            "    def inspect_swarm(self):",
            "        try:",
            "            data = self.client.inspect_swarm()",
            "            json_str = json.dumps(data, ensure_ascii=False)",
            "            self.swarm_info = json.loads(json_str)",
            "",
            "            self.results['changed'] = False",
            "            self.results['swarm_facts'] = self.swarm_info",
            "",
            "            unlock_key = self.get_unlock_key()",
            "            self.swarm_info.update(unlock_key)",
            "        except APIError:",
            "            return",
            "",
            "    def get_unlock_key(self):",
            "        default = {'UnlockKey': None}",
            "        if not self.has_swarm_lock_changed():",
            "            return default",
            "        try:",
            "            return self.client.get_unlock_key() or default",
            "        except APIError:",
            "            return default",
            "",
            "    def has_swarm_lock_changed(self):",
            "        return self.parameters.autolock_managers and (",
            "            self.created or self.differences.has_difference_for('autolock_managers')",
            "        )",
            "",
            "    def init_swarm(self):",
            "        if not self.force and self.client.check_if_swarm_manager():",
            "            self.__update_swarm()",
            "            return",
            "",
            "        if not self.check_mode:",
            "            init_arguments = {",
            "                'advertise_addr': self.parameters.advertise_addr,",
            "                'listen_addr': self.parameters.listen_addr,",
            "                'force_new_cluster': self.force,",
            "                'swarm_spec': self.parameters.spec,",
            "            }",
            "            if self.parameters.default_addr_pool is not None:",
            "                init_arguments['default_addr_pool'] = self.parameters.default_addr_pool",
            "            if self.parameters.subnet_size is not None:",
            "                init_arguments['subnet_size'] = self.parameters.subnet_size",
            "            try:",
            "                self.client.init_swarm(**init_arguments)",
            "            except APIError as exc:",
            "                self.client.fail(\"Can not create a new Swarm Cluster: %s\" % to_native(exc))",
            "",
            "        if not self.client.check_if_swarm_manager():",
            "            if not self.check_mode:",
            "                self.client.fail(\"Swarm not created or other error!\")",
            "",
            "        self.created = True",
            "        self.inspect_swarm()",
            "        self.results['actions'].append(\"New Swarm cluster created: %s\" % (self.swarm_info.get('ID')))",
            "        self.differences.add('state', parameter='present', active='absent')",
            "        self.results['changed'] = True",
            "        self.results['swarm_facts'] = {",
            "            'JoinTokens': self.swarm_info.get('JoinTokens'),",
            "            'UnlockKey': self.swarm_info.get('UnlockKey')",
            "        }",
            "",
            "    def __update_swarm(self):",
            "        try:",
            "            self.inspect_swarm()",
            "            version = self.swarm_info['Version']['Index']",
            "            self.parameters.update_from_swarm_info(self.swarm_info)",
            "            old_parameters = TaskParameters()",
            "            old_parameters.update_from_swarm_info(self.swarm_info)",
            "            self.parameters.compare_to_active(old_parameters, self.client, self.differences)",
            "            if self.differences.empty:",
            "                self.results['actions'].append(\"No modification\")",
            "                self.results['changed'] = False",
            "                return",
            "            update_parameters = TaskParameters.from_ansible_params(self.client)",
            "            update_parameters.update_parameters(self.client)",
            "            if not self.check_mode:",
            "                self.client.update_swarm(",
            "                    version=version, swarm_spec=update_parameters.spec,",
            "                    rotate_worker_token=self.parameters.rotate_worker_token,",
            "                    rotate_manager_token=self.parameters.rotate_manager_token)",
            "        except APIError as exc:",
            "            self.client.fail(\"Can not update a Swarm Cluster: %s\" % to_native(exc))",
            "            return",
            "",
            "        self.inspect_swarm()",
            "        self.results['actions'].append(\"Swarm cluster updated\")",
            "        self.results['changed'] = True",
            "",
            "    def join(self):",
            "        if self.client.check_if_swarm_node():",
            "            self.results['actions'].append(\"This node is already part of a swarm.\")",
            "            return",
            "        if not self.check_mode:",
            "            try:",
            "                self.client.join_swarm(",
            "                    remote_addrs=self.parameters.remote_addrs, join_token=self.parameters.join_token,",
            "                    listen_addr=self.parameters.listen_addr, advertise_addr=self.parameters.advertise_addr)",
            "            except APIError as exc:",
            "                self.client.fail(\"Can not join the Swarm Cluster: %s\" % to_native(exc))",
            "        self.results['actions'].append(\"New node is added to swarm cluster\")",
            "        self.differences.add('joined', parameter=True, active=False)",
            "        self.results['changed'] = True",
            "",
            "    def leave(self):",
            "        if not self.client.check_if_swarm_node():",
            "            self.results['actions'].append(\"This node is not part of a swarm.\")",
            "            return",
            "        if not self.check_mode:",
            "            try:",
            "                self.client.leave_swarm(force=self.force)",
            "            except APIError as exc:",
            "                self.client.fail(\"This node can not leave the Swarm Cluster: %s\" % to_native(exc))",
            "        self.results['actions'].append(\"Node has left the swarm cluster\")",
            "        self.differences.add('joined', parameter='absent', active='present')",
            "        self.results['changed'] = True",
            "",
            "    def remove(self):",
            "        if not self.client.check_if_swarm_manager():",
            "            self.client.fail(\"This node is not a manager.\")",
            "",
            "        try:",
            "            status_down = self.client.check_if_swarm_node_is_down(node_id=self.node_id, repeat_check=5)",
            "        except APIError:",
            "            return",
            "",
            "        if not status_down:",
            "            self.client.fail(\"Can not remove the node. The status node is ready and not down.\")",
            "",
            "        if not self.check_mode:",
            "            try:",
            "                self.client.remove_node(node_id=self.node_id, force=self.force)",
            "            except APIError as exc:",
            "                self.client.fail(\"Can not remove the node from the Swarm Cluster: %s\" % to_native(exc))",
            "        self.results['actions'].append(\"Node is removed from swarm cluster.\")",
            "        self.differences.add('joined', parameter=False, active=True)",
            "        self.results['changed'] = True",
            "",
            "",
            "def _detect_remove_operation(client):",
            "    return client.module.params['state'] == 'remove'",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        advertise_addr=dict(type='str'),",
            "        state=dict(type='str', default='present', choices=['present', 'join', 'absent', 'remove', 'inspect']),",
            "        force=dict(type='bool', default=False),",
            "        listen_addr=dict(type='str', default='0.0.0.0:2377'),",
            "        remote_addrs=dict(type='list', elements='str'),",
            "        join_token=dict(type='str'),",
            "        snapshot_interval=dict(type='int'),",
            "        task_history_retention_limit=dict(type='int'),",
            "        keep_old_snapshots=dict(type='int'),",
            "        log_entries_for_slow_followers=dict(type='int'),",
            "        heartbeat_tick=dict(type='int'),",
            "        election_tick=dict(type='int'),",
            "        dispatcher_heartbeat_period=dict(type='int'),",
            "        node_cert_expiry=dict(type='int'),",
            "        name=dict(type='str'),",
            "        labels=dict(type='dict'),",
            "        signing_ca_cert=dict(type='str'),",
            "        signing_ca_key=dict(type='str', no_log=True),",
            "        ca_force_rotate=dict(type='int'),",
            "        autolock_managers=dict(type='bool'),",
            "        node_id=dict(type='str'),",
            "        rotate_worker_token=dict(type='bool', default=False),",
            "        rotate_manager_token=dict(type='bool', default=False),",
            "        default_addr_pool=dict(type='list', elements='str'),",
            "        subnet_size=dict(type='int'),",
            "    )",
            "",
            "    required_if = [",
            "        ('state', 'join', ['advertise_addr', 'remote_addrs', 'join_token']),",
            "        ('state', 'remove', ['node_id'])",
            "    ]",
            "",
            "    option_minimal_versions = dict(",
            "        labels=dict(docker_py_version='2.6.0', docker_api_version='1.32'),",
            "        signing_ca_cert=dict(docker_py_version='2.6.0', docker_api_version='1.30'),",
            "        signing_ca_key=dict(docker_py_version='2.6.0', docker_api_version='1.30'),",
            "        ca_force_rotate=dict(docker_py_version='2.6.0', docker_api_version='1.30'),",
            "        autolock_managers=dict(docker_py_version='2.6.0'),",
            "        log_driver=dict(docker_py_version='2.6.0'),",
            "        remove_operation=dict(",
            "            docker_py_version='2.4.0',",
            "            detect_usage=_detect_remove_operation,",
            "            usage_msg='remove swarm nodes'",
            "        ),",
            "        default_addr_pool=dict(docker_py_version='4.0.0', docker_api_version='1.39'),",
            "        subnet_size=dict(docker_py_version='4.0.0', docker_api_version='1.39'),",
            "    )",
            "",
            "    client = AnsibleDockerSwarmClient(",
            "        argument_spec=argument_spec,",
            "        supports_check_mode=True,",
            "        required_if=required_if,",
            "        min_docker_version='1.10.0',",
            "        min_docker_api_version='1.25',",
            "        option_minimal_versions=option_minimal_versions,",
            "    )",
            "",
            "    try:",
            "        results = dict(",
            "            changed=False,",
            "            result='',",
            "            actions=[]",
            "        )",
            "",
            "        SwarmManager(client, results)()",
            "        client.module.exit_json(**results)",
            "    except DockerException as e:",
            "        client.fail('An unexpected docker error occurred: {0}'.format(e), exception=traceback.format_exc())",
            "    except RequestException as e:",
            "        client.fail('An unexpected requests error occurred when docker-py tried to talk to the docker daemon: {0}'.format(e), exception=traceback.format_exc())",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "625": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_backend_service.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 732,
                "afterPatchRowNumber": 732,
                "PatchRowcode": "             health_checks=dict(required=True, type='list', elements='str'),"
            },
            "1": {
                "beforePatchRowNumber": 733,
                "afterPatchRowNumber": 733,
                "PatchRowcode": "             iap=dict("
            },
            "2": {
                "beforePatchRowNumber": 734,
                "afterPatchRowNumber": 734,
                "PatchRowcode": "                 type='dict',"
            },
            "3": {
                "beforePatchRowNumber": 735,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                options=dict(enabled=dict(type='bool'), oauth2_client_id=dict(required=True, type='str'), oauth2_client_secret=dict(required=True, type='str')),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 735,
                "PatchRowcode": "+                options=dict(enabled=dict(type='bool'), oauth2_client_id=dict(required=True, type='str'), oauth2_client_secret=dict(required=True, type='str', no_log=True)),"
            },
            "5": {
                "beforePatchRowNumber": 736,
                "afterPatchRowNumber": 736,
                "PatchRowcode": "             ),"
            },
            "6": {
                "beforePatchRowNumber": 737,
                "afterPatchRowNumber": 737,
                "PatchRowcode": "             load_balancing_scheme=dict(default='EXTERNAL', type='str'),"
            },
            "7": {
                "beforePatchRowNumber": 738,
                "afterPatchRowNumber": 738,
                "PatchRowcode": "             name=dict(required=True, type='str'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_backend_service",
            "description:",
            "- A Backend Service defines a group of virtual machines that will serve traffic for",
            "  load balancing. This resource is a global backend service, appropriate for external",
            "  load balancing or self-managed internal load balancing.",
            "- For managed internal load balancing, use a regional backend service instead.",
            "- Currently self-managed internal load balancing is only available in beta.",
            "short_description: Creates a GCP BackendService",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  affinity_cookie_ttl_sec:",
            "    description:",
            "    - Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set",
            "      to 0, the cookie is non-persistent and lasts only until the end of the browser",
            "      session (or equivalent). The maximum allowed value for TTL is one day.",
            "    - When the load balancing scheme is INTERNAL, this field is not used.",
            "    required: false",
            "    type: int",
            "  backends:",
            "    description:",
            "    - The set of backends that serve this BackendService.",
            "    required: false",
            "    type: list",
            "    suboptions:",
            "      balancing_mode:",
            "        description:",
            "        - Specifies the balancing mode for this backend.",
            "        - For global HTTP(S) or TCP/SSL load balancing, the default is UTILIZATION.",
            "          Valid values are UTILIZATION, RATE (for HTTP(S)) and CONNECTION (for TCP/SSL).",
            "        - 'Some valid choices include: \"UTILIZATION\", \"RATE\", \"CONNECTION\"'",
            "        required: false",
            "        default: UTILIZATION",
            "        type: str",
            "      capacity_scaler:",
            "        description:",
            "        - A multiplier applied to the group's maximum servicing capacity (based on",
            "          UTILIZATION, RATE or CONNECTION).",
            "        - Default value is 1, which means the group will serve up to 100% of its configured",
            "          capacity (depending on balancingMode). A setting of 0 means the group is",
            "          completely drained, offering 0% of its available Capacity. Valid range is",
            "          [0.0,1.0].",
            "        required: false",
            "        default: '1.0'",
            "        type: str",
            "      description:",
            "        description:",
            "        - An optional description of this resource.",
            "        - Provide this property when you create the resource.",
            "        required: false",
            "        type: str",
            "      group:",
            "        description:",
            "        - The fully-qualified URL of an Instance Group or Network Endpoint Group resource.",
            "          In case of instance group this defines the list of instances that serve",
            "          traffic. Member virtual machine instances from each instance group must",
            "          live in the same zone as the instance group itself. No two backends in a",
            "          backend service are allowed to use same Instance Group resource.",
            "        - For Network Endpoint Groups this defines list of endpoints. All endpoints",
            "          of Network Endpoint Group must be hosted on instances located in the same",
            "          zone as the Network Endpoint Group.",
            "        - Backend service can not contain mix of Instance Group and Network Endpoint",
            "          Group backends.",
            "        - Note that you must specify an Instance Group or Network Endpoint Group resource",
            "          using the fully-qualified URL, rather than a partial URL.",
            "        required: false",
            "        type: str",
            "      max_connections:",
            "        description:",
            "        - The max number of simultaneous connections for the group. Can be used with",
            "          either CONNECTION or UTILIZATION balancing modes.",
            "        - For CONNECTION mode, either maxConnections or one of maxConnectionsPerInstance",
            "          or maxConnectionsPerEndpoint, as appropriate for group type, must be set.",
            "        required: false",
            "        type: int",
            "      max_connections_per_instance:",
            "        description:",
            "        - The max number of simultaneous connections that a single backend instance",
            "          can handle. This is used to calculate the capacity of the group. Can be",
            "          used in either CONNECTION or UTILIZATION balancing modes.",
            "        - For CONNECTION mode, either maxConnections or maxConnectionsPerInstance",
            "          must be set.",
            "        required: false",
            "        type: int",
            "      max_connections_per_endpoint:",
            "        description:",
            "        - The max number of simultaneous connections that a single backend network",
            "          endpoint can handle. This is used to calculate the capacity of the group.",
            "          Can be used in either CONNECTION or UTILIZATION balancing modes.",
            "        - For CONNECTION mode, either maxConnections or maxConnectionsPerEndpoint",
            "          must be set.",
            "        required: false",
            "        type: int",
            "        version_added: 2.9",
            "      max_rate:",
            "        description:",
            "        - The max requests per second (RPS) of the group.",
            "        - Can be used with either RATE or UTILIZATION balancing modes, but required",
            "          if RATE mode. For RATE mode, either maxRate or one of maxRatePerInstance",
            "          or maxRatePerEndpoint, as appropriate for group type, must be set.",
            "        required: false",
            "        type: int",
            "      max_rate_per_instance:",
            "        description:",
            "        - The max requests per second (RPS) that a single backend instance can handle.",
            "          This is used to calculate the capacity of the group. Can be used in either",
            "          balancing mode. For RATE mode, either maxRate or maxRatePerInstance must",
            "          be set.",
            "        required: false",
            "        type: str",
            "      max_rate_per_endpoint:",
            "        description:",
            "        - The max requests per second (RPS) that a single backend network endpoint",
            "          can handle. This is used to calculate the capacity of the group. Can be",
            "          used in either balancing mode. For RATE mode, either maxRate or maxRatePerEndpoint",
            "          must be set.",
            "        required: false",
            "        type: str",
            "        version_added: 2.9",
            "      max_utilization:",
            "        description:",
            "        - Used when balancingMode is UTILIZATION. This ratio defines the CPU utilization",
            "          target for the group. The default is 0.8. Valid range is [0.0, 1.0].",
            "        required: false",
            "        default: '0.8'",
            "        type: str",
            "  cdn_policy:",
            "    description:",
            "    - Cloud CDN configuration for this BackendService.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      cache_key_policy:",
            "        description:",
            "        - The CacheKeyPolicy for this CdnPolicy.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          include_host:",
            "            description:",
            "            - If true requests to different hosts will be cached separately.",
            "            required: false",
            "            type: bool",
            "          include_protocol:",
            "            description:",
            "            - If true, http and https requests will be cached separately.",
            "            required: false",
            "            type: bool",
            "          include_query_string:",
            "            description:",
            "            - If true, include query string parameters in the cache key according",
            "              to query_string_whitelist and query_string_blacklist. If neither is",
            "              set, the entire query string will be included.",
            "            - If false, the query string will be excluded from the cache key entirely.",
            "            required: false",
            "            type: bool",
            "          query_string_blacklist:",
            "            description:",
            "            - Names of query string parameters to exclude in cache keys.",
            "            - All other parameters will be included. Either specify query_string_whitelist",
            "              or query_string_blacklist, not both.",
            "            - \"'&' and '=' will be percent encoded and not treated as delimiters.\"",
            "            required: false",
            "            type: list",
            "          query_string_whitelist:",
            "            description:",
            "            - Names of query string parameters to include in cache keys.",
            "            - All other parameters will be excluded. Either specify query_string_whitelist",
            "              or query_string_blacklist, not both.",
            "            - \"'&' and '=' will be percent encoded and not treated as delimiters.\"",
            "            required: false",
            "            type: list",
            "      signed_url_cache_max_age_sec:",
            "        description:",
            "        - Maximum number of seconds the response to a signed URL request will be considered",
            "          fresh, defaults to 1hr (3600s). After this time period, the response will",
            "          be revalidated before being served.",
            "        - 'When serving responses to signed URL requests, Cloud CDN will internally",
            "          behave as though all responses from this backend had a \"Cache-Control: public,",
            "          max-age=[TTL]\" header, regardless of any existing Cache-Control header.",
            "          The actual headers served in responses will not be altered.'",
            "        required: false",
            "        default: '3600'",
            "        type: int",
            "        version_added: 2.8",
            "  connection_draining:",
            "    description:",
            "    - Settings for connection draining .",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      draining_timeout_sec:",
            "        description:",
            "        - Time for which instance will be drained (not accept new connections, but",
            "          still work to finish started).",
            "        required: false",
            "        default: '300'",
            "        type: int",
            "  description:",
            "    description:",
            "    - An optional description of this resource.",
            "    required: false",
            "    type: str",
            "  enable_cdn:",
            "    description:",
            "    - If true, enable Cloud CDN for this BackendService.",
            "    required: false",
            "    type: bool",
            "  health_checks:",
            "    description:",
            "    - The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health",
            "      checking this BackendService. Currently at most one health check can be specified,",
            "      and a health check is required.",
            "    - For internal load balancing, a URL to a HealthCheck resource must be specified",
            "      instead.",
            "    required: true",
            "    type: list",
            "  iap:",
            "    description:",
            "    - Settings for enabling Cloud Identity Aware Proxy.",
            "    required: false",
            "    type: dict",
            "    version_added: 2.7",
            "    suboptions:",
            "      enabled:",
            "        description:",
            "        - Enables IAP.",
            "        required: false",
            "        type: bool",
            "      oauth2_client_id:",
            "        description:",
            "        - OAuth2 Client ID for IAP .",
            "        required: true",
            "        type: str",
            "      oauth2_client_secret:",
            "        description:",
            "        - OAuth2 Client Secret for IAP .",
            "        required: true",
            "        type: str",
            "  load_balancing_scheme:",
            "    description:",
            "    - Indicates whether the backend service will be used with internal or external",
            "      load balancing. A backend service created for one type of load balancing cannot",
            "      be used with the other. Must be `EXTERNAL` or `INTERNAL_SELF_MANAGED` for a",
            "      global backend service. Defaults to `EXTERNAL`.",
            "    - 'Some valid choices include: \"EXTERNAL\", \"INTERNAL_SELF_MANAGED\"'",
            "    required: false",
            "    default: EXTERNAL",
            "    type: str",
            "    version_added: 2.7",
            "  name:",
            "    description:",
            "    - Name of the resource. Provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  port_name:",
            "    description:",
            "    - Name of backend port. The same name should appear in the instance groups referenced",
            "      by this service. Required when the load balancing scheme is EXTERNAL.",
            "    required: false",
            "    type: str",
            "  protocol:",
            "    description:",
            "    - The protocol this BackendService uses to communicate with backends.",
            "    - 'Possible values are HTTP, HTTPS, HTTP2, TCP, and SSL. The default is HTTP.",
            "      **NOTE**: HTTP2 is only valid for beta HTTP/2 load balancer types and may result",
            "      in errors if used with the GA API.'",
            "    - 'Some valid choices include: \"HTTP\", \"HTTPS\", \"HTTP2\", \"TCP\", \"SSL\"'",
            "    required: false",
            "    type: str",
            "  security_policy:",
            "    description:",
            "    - The security policy associated with this backend service.",
            "    required: false",
            "    type: str",
            "    version_added: 2.8",
            "  session_affinity:",
            "    description:",
            "    - Type of session affinity to use. The default is NONE.",
            "    - When the load balancing scheme is EXTERNAL, can be NONE, CLIENT_IP, or GENERATED_COOKIE.",
            "    - When the protocol is UDP, this field is not used.",
            "    - 'Some valid choices include: \"NONE\", \"CLIENT_IP\", \"GENERATED_COOKIE\"'",
            "    required: false",
            "    type: str",
            "  timeout_sec:",
            "    description:",
            "    - How many seconds to wait for the backend before considering it a failed request.",
            "      Default is 30 seconds. Valid range is [1, 86400].",
            "    required: false",
            "    type: int",
            "    aliases:",
            "    - timeout_seconds",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/v1/backendServices)'",
            "- 'Official Documentation: U(https://cloud.google.com/compute/docs/load-balancing/http/backend-service)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a instance group",
            "  gcp_compute_instance_group:",
            "    name: instancegroup-backendservice",
            "    zone: us-central1-a",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: instancegroup",
            "",
            "- name: create a HTTP health check",
            "  gcp_compute_http_health_check:",
            "    name: httphealthcheck-backendservice",
            "    healthy_threshold: 10",
            "    port: 8080",
            "    timeout_sec: 2",
            "    unhealthy_threshold: 5",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: healthcheck",
            "",
            "- name: create a backend service",
            "  gcp_compute_backend_service:",
            "    name: test_object",
            "    backends:",
            "    - group: \"{{ instancegroup.selfLink }}\"",
            "    health_checks:",
            "    - \"{{ healthcheck.selfLink }}\"",
            "    enable_cdn: 'true'",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "affinityCookieTtlSec:",
            "  description:",
            "  - Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set",
            "    to 0, the cookie is non-persistent and lasts only until the end of the browser",
            "    session (or equivalent). The maximum allowed value for TTL is one day.",
            "  - When the load balancing scheme is INTERNAL, this field is not used.",
            "  returned: success",
            "  type: int",
            "backends:",
            "  description:",
            "  - The set of backends that serve this BackendService.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    balancingMode:",
            "      description:",
            "      - Specifies the balancing mode for this backend.",
            "      - For global HTTP(S) or TCP/SSL load balancing, the default is UTILIZATION.",
            "        Valid values are UTILIZATION, RATE (for HTTP(S)) and CONNECTION (for TCP/SSL).",
            "      returned: success",
            "      type: str",
            "    capacityScaler:",
            "      description:",
            "      - A multiplier applied to the group's maximum servicing capacity (based on UTILIZATION,",
            "        RATE or CONNECTION).",
            "      - Default value is 1, which means the group will serve up to 100% of its configured",
            "        capacity (depending on balancingMode). A setting of 0 means the group is completely",
            "        drained, offering 0% of its available Capacity. Valid range is [0.0,1.0].",
            "      returned: success",
            "      type: str",
            "    description:",
            "      description:",
            "      - An optional description of this resource.",
            "      - Provide this property when you create the resource.",
            "      returned: success",
            "      type: str",
            "    group:",
            "      description:",
            "      - The fully-qualified URL of an Instance Group or Network Endpoint Group resource.",
            "        In case of instance group this defines the list of instances that serve traffic.",
            "        Member virtual machine instances from each instance group must live in the",
            "        same zone as the instance group itself. No two backends in a backend service",
            "        are allowed to use same Instance Group resource.",
            "      - For Network Endpoint Groups this defines list of endpoints. All endpoints",
            "        of Network Endpoint Group must be hosted on instances located in the same",
            "        zone as the Network Endpoint Group.",
            "      - Backend service can not contain mix of Instance Group and Network Endpoint",
            "        Group backends.",
            "      - Note that you must specify an Instance Group or Network Endpoint Group resource",
            "        using the fully-qualified URL, rather than a partial URL.",
            "      returned: success",
            "      type: str",
            "    maxConnections:",
            "      description:",
            "      - The max number of simultaneous connections for the group. Can be used with",
            "        either CONNECTION or UTILIZATION balancing modes.",
            "      - For CONNECTION mode, either maxConnections or one of maxConnectionsPerInstance",
            "        or maxConnectionsPerEndpoint, as appropriate for group type, must be set.",
            "      returned: success",
            "      type: int",
            "    maxConnectionsPerInstance:",
            "      description:",
            "      - The max number of simultaneous connections that a single backend instance",
            "        can handle. This is used to calculate the capacity of the group. Can be used",
            "        in either CONNECTION or UTILIZATION balancing modes.",
            "      - For CONNECTION mode, either maxConnections or maxConnectionsPerInstance must",
            "        be set.",
            "      returned: success",
            "      type: int",
            "    maxConnectionsPerEndpoint:",
            "      description:",
            "      - The max number of simultaneous connections that a single backend network endpoint",
            "        can handle. This is used to calculate the capacity of the group. Can be used",
            "        in either CONNECTION or UTILIZATION balancing modes.",
            "      - For CONNECTION mode, either maxConnections or maxConnectionsPerEndpoint must",
            "        be set.",
            "      returned: success",
            "      type: int",
            "    maxRate:",
            "      description:",
            "      - The max requests per second (RPS) of the group.",
            "      - Can be used with either RATE or UTILIZATION balancing modes, but required",
            "        if RATE mode. For RATE mode, either maxRate or one of maxRatePerInstance or",
            "        maxRatePerEndpoint, as appropriate for group type, must be set.",
            "      returned: success",
            "      type: int",
            "    maxRatePerInstance:",
            "      description:",
            "      - The max requests per second (RPS) that a single backend instance can handle.",
            "        This is used to calculate the capacity of the group. Can be used in either",
            "        balancing mode. For RATE mode, either maxRate or maxRatePerInstance must be",
            "        set.",
            "      returned: success",
            "      type: str",
            "    maxRatePerEndpoint:",
            "      description:",
            "      - The max requests per second (RPS) that a single backend network endpoint can",
            "        handle. This is used to calculate the capacity of the group. Can be used in",
            "        either balancing mode. For RATE mode, either maxRate or maxRatePerEndpoint",
            "        must be set.",
            "      returned: success",
            "      type: str",
            "    maxUtilization:",
            "      description:",
            "      - Used when balancingMode is UTILIZATION. This ratio defines the CPU utilization",
            "        target for the group. The default is 0.8. Valid range is [0.0, 1.0].",
            "      returned: success",
            "      type: str",
            "cdnPolicy:",
            "  description:",
            "  - Cloud CDN configuration for this BackendService.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    cacheKeyPolicy:",
            "      description:",
            "      - The CacheKeyPolicy for this CdnPolicy.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        includeHost:",
            "          description:",
            "          - If true requests to different hosts will be cached separately.",
            "          returned: success",
            "          type: bool",
            "        includeProtocol:",
            "          description:",
            "          - If true, http and https requests will be cached separately.",
            "          returned: success",
            "          type: bool",
            "        includeQueryString:",
            "          description:",
            "          - If true, include query string parameters in the cache key according to",
            "            query_string_whitelist and query_string_blacklist. If neither is set,",
            "            the entire query string will be included.",
            "          - If false, the query string will be excluded from the cache key entirely.",
            "          returned: success",
            "          type: bool",
            "        queryStringBlacklist:",
            "          description:",
            "          - Names of query string parameters to exclude in cache keys.",
            "          - All other parameters will be included. Either specify query_string_whitelist",
            "            or query_string_blacklist, not both.",
            "          - \"'&' and '=' will be percent encoded and not treated as delimiters.\"",
            "          returned: success",
            "          type: list",
            "        queryStringWhitelist:",
            "          description:",
            "          - Names of query string parameters to include in cache keys.",
            "          - All other parameters will be excluded. Either specify query_string_whitelist",
            "            or query_string_blacklist, not both.",
            "          - \"'&' and '=' will be percent encoded and not treated as delimiters.\"",
            "          returned: success",
            "          type: list",
            "    signedUrlCacheMaxAgeSec:",
            "      description:",
            "      - Maximum number of seconds the response to a signed URL request will be considered",
            "        fresh, defaults to 1hr (3600s). After this time period, the response will",
            "        be revalidated before being served.",
            "      - 'When serving responses to signed URL requests, Cloud CDN will internally",
            "        behave as though all responses from this backend had a \"Cache-Control: public,",
            "        max-age=[TTL]\" header, regardless of any existing Cache-Control header. The",
            "        actual headers served in responses will not be altered.'",
            "      returned: success",
            "      type: int",
            "connectionDraining:",
            "  description:",
            "  - Settings for connection draining .",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    drainingTimeoutSec:",
            "      description:",
            "      - Time for which instance will be drained (not accept new connections, but still",
            "        work to finish started).",
            "      returned: success",
            "      type: int",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "fingerprint:",
            "  description:",
            "  - Fingerprint of this resource. A hash of the contents stored in this object. This",
            "    field is used in optimistic locking.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource.",
            "  returned: success",
            "  type: str",
            "enableCDN:",
            "  description:",
            "  - If true, enable Cloud CDN for this BackendService.",
            "  returned: success",
            "  type: bool",
            "healthChecks:",
            "  description:",
            "  - The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health",
            "    checking this BackendService. Currently at most one health check can be specified,",
            "    and a health check is required.",
            "  - For internal load balancing, a URL to a HealthCheck resource must be specified",
            "    instead.",
            "  returned: success",
            "  type: list",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "iap:",
            "  description:",
            "  - Settings for enabling Cloud Identity Aware Proxy.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    enabled:",
            "      description:",
            "      - Enables IAP.",
            "      returned: success",
            "      type: bool",
            "    oauth2ClientId:",
            "      description:",
            "      - OAuth2 Client ID for IAP .",
            "      returned: success",
            "      type: str",
            "    oauth2ClientSecret:",
            "      description:",
            "      - OAuth2 Client Secret for IAP .",
            "      returned: success",
            "      type: str",
            "    oauth2ClientSecretSha256:",
            "      description:",
            "      - OAuth2 Client Secret SHA-256 for IAP .",
            "      returned: success",
            "      type: str",
            "loadBalancingScheme:",
            "  description:",
            "  - Indicates whether the backend service will be used with internal or external load",
            "    balancing. A backend service created for one type of load balancing cannot be",
            "    used with the other. Must be `EXTERNAL` or `INTERNAL_SELF_MANAGED` for a global",
            "    backend service. Defaults to `EXTERNAL`.",
            "  returned: success",
            "  type: str",
            "name:",
            "  description:",
            "  - Name of the resource. Provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "portName:",
            "  description:",
            "  - Name of backend port. The same name should appear in the instance groups referenced",
            "    by this service. Required when the load balancing scheme is EXTERNAL.",
            "  returned: success",
            "  type: str",
            "protocol:",
            "  description:",
            "  - The protocol this BackendService uses to communicate with backends.",
            "  - 'Possible values are HTTP, HTTPS, HTTP2, TCP, and SSL. The default is HTTP. **NOTE**:",
            "    HTTP2 is only valid for beta HTTP/2 load balancer types and may result in errors",
            "    if used with the GA API.'",
            "  returned: success",
            "  type: str",
            "securityPolicy:",
            "  description:",
            "  - The security policy associated with this backend service.",
            "  returned: success",
            "  type: str",
            "sessionAffinity:",
            "  description:",
            "  - Type of session affinity to use. The default is NONE.",
            "  - When the load balancing scheme is EXTERNAL, can be NONE, CLIENT_IP, or GENERATED_COOKIE.",
            "  - When the protocol is UDP, this field is not used.",
            "  returned: success",
            "  type: str",
            "timeoutSec:",
            "  description:",
            "  - How many seconds to wait for the backend before considering it a failed request.",
            "    Default is 30 seconds. Valid range is [1, 86400].",
            "  returned: success",
            "  type: int",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            affinity_cookie_ttl_sec=dict(type='int'),",
            "            backends=dict(",
            "                type='list',",
            "                elements='dict',",
            "                options=dict(",
            "                    balancing_mode=dict(default='UTILIZATION', type='str'),",
            "                    capacity_scaler=dict(default=1.0, type='str'),",
            "                    description=dict(type='str'),",
            "                    group=dict(type='str'),",
            "                    max_connections=dict(type='int'),",
            "                    max_connections_per_instance=dict(type='int'),",
            "                    max_connections_per_endpoint=dict(type='int'),",
            "                    max_rate=dict(type='int'),",
            "                    max_rate_per_instance=dict(type='str'),",
            "                    max_rate_per_endpoint=dict(type='str'),",
            "                    max_utilization=dict(default=0.8, type='str'),",
            "                ),",
            "            ),",
            "            cdn_policy=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    cache_key_policy=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            include_host=dict(type='bool'),",
            "                            include_protocol=dict(type='bool'),",
            "                            include_query_string=dict(type='bool'),",
            "                            query_string_blacklist=dict(type='list', elements='str'),",
            "                            query_string_whitelist=dict(type='list', elements='str'),",
            "                        ),",
            "                    ),",
            "                    signed_url_cache_max_age_sec=dict(default=3600, type='int'),",
            "                ),",
            "            ),",
            "            connection_draining=dict(type='dict', options=dict(draining_timeout_sec=dict(default=300, type='int'))),",
            "            description=dict(type='str'),",
            "            enable_cdn=dict(type='bool'),",
            "            health_checks=dict(required=True, type='list', elements='str'),",
            "            iap=dict(",
            "                type='dict',",
            "                options=dict(enabled=dict(type='bool'), oauth2_client_id=dict(required=True, type='str'), oauth2_client_secret=dict(required=True, type='str')),",
            "            ),",
            "            load_balancing_scheme=dict(default='EXTERNAL', type='str'),",
            "            name=dict(required=True, type='str'),",
            "            port_name=dict(type='str'),",
            "            protocol=dict(type='str'),",
            "            security_policy=dict(type='str'),",
            "            session_affinity=dict(type='str'),",
            "            timeout_sec=dict(type='int', aliases=['timeout_seconds']),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#backendService'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.put(link, resource_to_request(module)))",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('securityPolicy') != request.get('securityPolicy'):",
            "        security_policy_update(module, request, response)",
            "",
            "",
            "def security_policy_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/global/backendServices/{name}/setSecurityPolicy\"]).format(**module.params),",
            "        {u'securityPolicy': module.params.get('security_policy')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#backendService',",
            "        u'affinityCookieTtlSec': module.params.get('affinity_cookie_ttl_sec'),",
            "        u'backends': BackendServiceBackendsArray(module.params.get('backends', []), module).to_request(),",
            "        u'cdnPolicy': BackendServiceCdnpolicy(module.params.get('cdn_policy', {}), module).to_request(),",
            "        u'connectionDraining': BackendServiceConnectiondraining(module.params.get('connection_draining', {}), module).to_request(),",
            "        u'description': module.params.get('description'),",
            "        u'enableCDN': module.params.get('enable_cdn'),",
            "        u'healthChecks': module.params.get('health_checks'),",
            "        u'iap': BackendServiceIap(module.params.get('iap', {}), module).to_request(),",
            "        u'loadBalancingScheme': module.params.get('load_balancing_scheme'),",
            "        u'name': module.params.get('name'),",
            "        u'portName': module.params.get('port_name'),",
            "        u'protocol': module.params.get('protocol'),",
            "        u'securityPolicy': module.params.get('security_policy'),",
            "        u'sessionAffinity': module.params.get('session_affinity'),",
            "        u'timeoutSec': module.params.get('timeout_sec'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/backendServices/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/backendServices\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'affinityCookieTtlSec': response.get(u'affinityCookieTtlSec'),",
            "        u'backends': BackendServiceBackendsArray(response.get(u'backends', []), module).from_response(),",
            "        u'cdnPolicy': BackendServiceCdnpolicy(response.get(u'cdnPolicy', {}), module).from_response(),",
            "        u'connectionDraining': BackendServiceConnectiondraining(response.get(u'connectionDraining', {}), module).from_response(),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'fingerprint': response.get(u'fingerprint'),",
            "        u'description': response.get(u'description'),",
            "        u'enableCDN': response.get(u'enableCDN'),",
            "        u'healthChecks': response.get(u'healthChecks'),",
            "        u'id': response.get(u'id'),",
            "        u'iap': BackendServiceIap(response.get(u'iap', {}), module).from_response(),",
            "        u'loadBalancingScheme': module.params.get('load_balancing_scheme'),",
            "        u'name': module.params.get('name'),",
            "        u'portName': response.get(u'portName'),",
            "        u'protocol': response.get(u'protocol'),",
            "        u'securityPolicy': response.get(u'securityPolicy'),",
            "        u'sessionAffinity': response.get(u'sessionAffinity'),",
            "        u'timeoutSec': response.get(u'timeoutSec'),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#backendService')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class BackendServiceBackendsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'balancingMode': item.get('balancing_mode'),",
            "                u'capacityScaler': item.get('capacity_scaler'),",
            "                u'description': item.get('description'),",
            "                u'group': item.get('group'),",
            "                u'maxConnections': item.get('max_connections'),",
            "                u'maxConnectionsPerInstance': item.get('max_connections_per_instance'),",
            "                u'maxConnectionsPerEndpoint': item.get('max_connections_per_endpoint'),",
            "                u'maxRate': item.get('max_rate'),",
            "                u'maxRatePerInstance': item.get('max_rate_per_instance'),",
            "                u'maxRatePerEndpoint': item.get('max_rate_per_endpoint'),",
            "                u'maxUtilization': item.get('max_utilization'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'balancingMode': item.get(u'balancingMode'),",
            "                u'capacityScaler': item.get(u'capacityScaler'),",
            "                u'description': item.get(u'description'),",
            "                u'group': item.get(u'group'),",
            "                u'maxConnections': item.get(u'maxConnections'),",
            "                u'maxConnectionsPerInstance': item.get(u'maxConnectionsPerInstance'),",
            "                u'maxConnectionsPerEndpoint': item.get(u'maxConnectionsPerEndpoint'),",
            "                u'maxRate': item.get(u'maxRate'),",
            "                u'maxRatePerInstance': item.get(u'maxRatePerInstance'),",
            "                u'maxRatePerEndpoint': item.get(u'maxRatePerEndpoint'),",
            "                u'maxUtilization': item.get(u'maxUtilization'),",
            "            }",
            "        )",
            "",
            "",
            "class BackendServiceCdnpolicy(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'cacheKeyPolicy': BackendServiceCachekeypolicy(self.request.get('cache_key_policy', {}), self.module).to_request(),",
            "                u'signedUrlCacheMaxAgeSec': self.request.get('signed_url_cache_max_age_sec'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'cacheKeyPolicy': BackendServiceCachekeypolicy(self.request.get(u'cacheKeyPolicy', {}), self.module).from_response(),",
            "                u'signedUrlCacheMaxAgeSec': self.request.get(u'signedUrlCacheMaxAgeSec'),",
            "            }",
            "        )",
            "",
            "",
            "class BackendServiceCachekeypolicy(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'includeHost': self.request.get('include_host'),",
            "                u'includeProtocol': self.request.get('include_protocol'),",
            "                u'includeQueryString': self.request.get('include_query_string'),",
            "                u'queryStringBlacklist': self.request.get('query_string_blacklist'),",
            "                u'queryStringWhitelist': self.request.get('query_string_whitelist'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'includeHost': self.request.get(u'includeHost'),",
            "                u'includeProtocol': self.request.get(u'includeProtocol'),",
            "                u'includeQueryString': self.request.get(u'includeQueryString'),",
            "                u'queryStringBlacklist': self.request.get(u'queryStringBlacklist'),",
            "                u'queryStringWhitelist': self.request.get(u'queryStringWhitelist'),",
            "            }",
            "        )",
            "",
            "",
            "class BackendServiceConnectiondraining(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'drainingTimeoutSec': self.request.get('draining_timeout_sec')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'drainingTimeoutSec': self.request.get(u'drainingTimeoutSec')})",
            "",
            "",
            "class BackendServiceIap(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'enabled': self.request.get('enabled'),",
            "                u'oauth2ClientId': self.request.get('oauth2_client_id'),",
            "                u'oauth2ClientSecret': self.request.get('oauth2_client_secret'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'enabled': self.request.get(u'enabled'),",
            "                u'oauth2ClientId': self.request.get(u'oauth2ClientId'),",
            "                u'oauth2ClientSecret': self.request.get(u'oauth2ClientSecret'),",
            "            }",
            "        )",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_backend_service",
            "description:",
            "- A Backend Service defines a group of virtual machines that will serve traffic for",
            "  load balancing. This resource is a global backend service, appropriate for external",
            "  load balancing or self-managed internal load balancing.",
            "- For managed internal load balancing, use a regional backend service instead.",
            "- Currently self-managed internal load balancing is only available in beta.",
            "short_description: Creates a GCP BackendService",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  affinity_cookie_ttl_sec:",
            "    description:",
            "    - Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set",
            "      to 0, the cookie is non-persistent and lasts only until the end of the browser",
            "      session (or equivalent). The maximum allowed value for TTL is one day.",
            "    - When the load balancing scheme is INTERNAL, this field is not used.",
            "    required: false",
            "    type: int",
            "  backends:",
            "    description:",
            "    - The set of backends that serve this BackendService.",
            "    required: false",
            "    type: list",
            "    suboptions:",
            "      balancing_mode:",
            "        description:",
            "        - Specifies the balancing mode for this backend.",
            "        - For global HTTP(S) or TCP/SSL load balancing, the default is UTILIZATION.",
            "          Valid values are UTILIZATION, RATE (for HTTP(S)) and CONNECTION (for TCP/SSL).",
            "        - 'Some valid choices include: \"UTILIZATION\", \"RATE\", \"CONNECTION\"'",
            "        required: false",
            "        default: UTILIZATION",
            "        type: str",
            "      capacity_scaler:",
            "        description:",
            "        - A multiplier applied to the group's maximum servicing capacity (based on",
            "          UTILIZATION, RATE or CONNECTION).",
            "        - Default value is 1, which means the group will serve up to 100% of its configured",
            "          capacity (depending on balancingMode). A setting of 0 means the group is",
            "          completely drained, offering 0% of its available Capacity. Valid range is",
            "          [0.0,1.0].",
            "        required: false",
            "        default: '1.0'",
            "        type: str",
            "      description:",
            "        description:",
            "        - An optional description of this resource.",
            "        - Provide this property when you create the resource.",
            "        required: false",
            "        type: str",
            "      group:",
            "        description:",
            "        - The fully-qualified URL of an Instance Group or Network Endpoint Group resource.",
            "          In case of instance group this defines the list of instances that serve",
            "          traffic. Member virtual machine instances from each instance group must",
            "          live in the same zone as the instance group itself. No two backends in a",
            "          backend service are allowed to use same Instance Group resource.",
            "        - For Network Endpoint Groups this defines list of endpoints. All endpoints",
            "          of Network Endpoint Group must be hosted on instances located in the same",
            "          zone as the Network Endpoint Group.",
            "        - Backend service can not contain mix of Instance Group and Network Endpoint",
            "          Group backends.",
            "        - Note that you must specify an Instance Group or Network Endpoint Group resource",
            "          using the fully-qualified URL, rather than a partial URL.",
            "        required: false",
            "        type: str",
            "      max_connections:",
            "        description:",
            "        - The max number of simultaneous connections for the group. Can be used with",
            "          either CONNECTION or UTILIZATION balancing modes.",
            "        - For CONNECTION mode, either maxConnections or one of maxConnectionsPerInstance",
            "          or maxConnectionsPerEndpoint, as appropriate for group type, must be set.",
            "        required: false",
            "        type: int",
            "      max_connections_per_instance:",
            "        description:",
            "        - The max number of simultaneous connections that a single backend instance",
            "          can handle. This is used to calculate the capacity of the group. Can be",
            "          used in either CONNECTION or UTILIZATION balancing modes.",
            "        - For CONNECTION mode, either maxConnections or maxConnectionsPerInstance",
            "          must be set.",
            "        required: false",
            "        type: int",
            "      max_connections_per_endpoint:",
            "        description:",
            "        - The max number of simultaneous connections that a single backend network",
            "          endpoint can handle. This is used to calculate the capacity of the group.",
            "          Can be used in either CONNECTION or UTILIZATION balancing modes.",
            "        - For CONNECTION mode, either maxConnections or maxConnectionsPerEndpoint",
            "          must be set.",
            "        required: false",
            "        type: int",
            "        version_added: 2.9",
            "      max_rate:",
            "        description:",
            "        - The max requests per second (RPS) of the group.",
            "        - Can be used with either RATE or UTILIZATION balancing modes, but required",
            "          if RATE mode. For RATE mode, either maxRate or one of maxRatePerInstance",
            "          or maxRatePerEndpoint, as appropriate for group type, must be set.",
            "        required: false",
            "        type: int",
            "      max_rate_per_instance:",
            "        description:",
            "        - The max requests per second (RPS) that a single backend instance can handle.",
            "          This is used to calculate the capacity of the group. Can be used in either",
            "          balancing mode. For RATE mode, either maxRate or maxRatePerInstance must",
            "          be set.",
            "        required: false",
            "        type: str",
            "      max_rate_per_endpoint:",
            "        description:",
            "        - The max requests per second (RPS) that a single backend network endpoint",
            "          can handle. This is used to calculate the capacity of the group. Can be",
            "          used in either balancing mode. For RATE mode, either maxRate or maxRatePerEndpoint",
            "          must be set.",
            "        required: false",
            "        type: str",
            "        version_added: 2.9",
            "      max_utilization:",
            "        description:",
            "        - Used when balancingMode is UTILIZATION. This ratio defines the CPU utilization",
            "          target for the group. The default is 0.8. Valid range is [0.0, 1.0].",
            "        required: false",
            "        default: '0.8'",
            "        type: str",
            "  cdn_policy:",
            "    description:",
            "    - Cloud CDN configuration for this BackendService.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      cache_key_policy:",
            "        description:",
            "        - The CacheKeyPolicy for this CdnPolicy.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          include_host:",
            "            description:",
            "            - If true requests to different hosts will be cached separately.",
            "            required: false",
            "            type: bool",
            "          include_protocol:",
            "            description:",
            "            - If true, http and https requests will be cached separately.",
            "            required: false",
            "            type: bool",
            "          include_query_string:",
            "            description:",
            "            - If true, include query string parameters in the cache key according",
            "              to query_string_whitelist and query_string_blacklist. If neither is",
            "              set, the entire query string will be included.",
            "            - If false, the query string will be excluded from the cache key entirely.",
            "            required: false",
            "            type: bool",
            "          query_string_blacklist:",
            "            description:",
            "            - Names of query string parameters to exclude in cache keys.",
            "            - All other parameters will be included. Either specify query_string_whitelist",
            "              or query_string_blacklist, not both.",
            "            - \"'&' and '=' will be percent encoded and not treated as delimiters.\"",
            "            required: false",
            "            type: list",
            "          query_string_whitelist:",
            "            description:",
            "            - Names of query string parameters to include in cache keys.",
            "            - All other parameters will be excluded. Either specify query_string_whitelist",
            "              or query_string_blacklist, not both.",
            "            - \"'&' and '=' will be percent encoded and not treated as delimiters.\"",
            "            required: false",
            "            type: list",
            "      signed_url_cache_max_age_sec:",
            "        description:",
            "        - Maximum number of seconds the response to a signed URL request will be considered",
            "          fresh, defaults to 1hr (3600s). After this time period, the response will",
            "          be revalidated before being served.",
            "        - 'When serving responses to signed URL requests, Cloud CDN will internally",
            "          behave as though all responses from this backend had a \"Cache-Control: public,",
            "          max-age=[TTL]\" header, regardless of any existing Cache-Control header.",
            "          The actual headers served in responses will not be altered.'",
            "        required: false",
            "        default: '3600'",
            "        type: int",
            "        version_added: 2.8",
            "  connection_draining:",
            "    description:",
            "    - Settings for connection draining .",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      draining_timeout_sec:",
            "        description:",
            "        - Time for which instance will be drained (not accept new connections, but",
            "          still work to finish started).",
            "        required: false",
            "        default: '300'",
            "        type: int",
            "  description:",
            "    description:",
            "    - An optional description of this resource.",
            "    required: false",
            "    type: str",
            "  enable_cdn:",
            "    description:",
            "    - If true, enable Cloud CDN for this BackendService.",
            "    required: false",
            "    type: bool",
            "  health_checks:",
            "    description:",
            "    - The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health",
            "      checking this BackendService. Currently at most one health check can be specified,",
            "      and a health check is required.",
            "    - For internal load balancing, a URL to a HealthCheck resource must be specified",
            "      instead.",
            "    required: true",
            "    type: list",
            "  iap:",
            "    description:",
            "    - Settings for enabling Cloud Identity Aware Proxy.",
            "    required: false",
            "    type: dict",
            "    version_added: 2.7",
            "    suboptions:",
            "      enabled:",
            "        description:",
            "        - Enables IAP.",
            "        required: false",
            "        type: bool",
            "      oauth2_client_id:",
            "        description:",
            "        - OAuth2 Client ID for IAP .",
            "        required: true",
            "        type: str",
            "      oauth2_client_secret:",
            "        description:",
            "        - OAuth2 Client Secret for IAP .",
            "        required: true",
            "        type: str",
            "  load_balancing_scheme:",
            "    description:",
            "    - Indicates whether the backend service will be used with internal or external",
            "      load balancing. A backend service created for one type of load balancing cannot",
            "      be used with the other. Must be `EXTERNAL` or `INTERNAL_SELF_MANAGED` for a",
            "      global backend service. Defaults to `EXTERNAL`.",
            "    - 'Some valid choices include: \"EXTERNAL\", \"INTERNAL_SELF_MANAGED\"'",
            "    required: false",
            "    default: EXTERNAL",
            "    type: str",
            "    version_added: 2.7",
            "  name:",
            "    description:",
            "    - Name of the resource. Provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  port_name:",
            "    description:",
            "    - Name of backend port. The same name should appear in the instance groups referenced",
            "      by this service. Required when the load balancing scheme is EXTERNAL.",
            "    required: false",
            "    type: str",
            "  protocol:",
            "    description:",
            "    - The protocol this BackendService uses to communicate with backends.",
            "    - 'Possible values are HTTP, HTTPS, HTTP2, TCP, and SSL. The default is HTTP.",
            "      **NOTE**: HTTP2 is only valid for beta HTTP/2 load balancer types and may result",
            "      in errors if used with the GA API.'",
            "    - 'Some valid choices include: \"HTTP\", \"HTTPS\", \"HTTP2\", \"TCP\", \"SSL\"'",
            "    required: false",
            "    type: str",
            "  security_policy:",
            "    description:",
            "    - The security policy associated with this backend service.",
            "    required: false",
            "    type: str",
            "    version_added: 2.8",
            "  session_affinity:",
            "    description:",
            "    - Type of session affinity to use. The default is NONE.",
            "    - When the load balancing scheme is EXTERNAL, can be NONE, CLIENT_IP, or GENERATED_COOKIE.",
            "    - When the protocol is UDP, this field is not used.",
            "    - 'Some valid choices include: \"NONE\", \"CLIENT_IP\", \"GENERATED_COOKIE\"'",
            "    required: false",
            "    type: str",
            "  timeout_sec:",
            "    description:",
            "    - How many seconds to wait for the backend before considering it a failed request.",
            "      Default is 30 seconds. Valid range is [1, 86400].",
            "    required: false",
            "    type: int",
            "    aliases:",
            "    - timeout_seconds",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/v1/backendServices)'",
            "- 'Official Documentation: U(https://cloud.google.com/compute/docs/load-balancing/http/backend-service)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a instance group",
            "  gcp_compute_instance_group:",
            "    name: instancegroup-backendservice",
            "    zone: us-central1-a",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: instancegroup",
            "",
            "- name: create a HTTP health check",
            "  gcp_compute_http_health_check:",
            "    name: httphealthcheck-backendservice",
            "    healthy_threshold: 10",
            "    port: 8080",
            "    timeout_sec: 2",
            "    unhealthy_threshold: 5",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: healthcheck",
            "",
            "- name: create a backend service",
            "  gcp_compute_backend_service:",
            "    name: test_object",
            "    backends:",
            "    - group: \"{{ instancegroup.selfLink }}\"",
            "    health_checks:",
            "    - \"{{ healthcheck.selfLink }}\"",
            "    enable_cdn: 'true'",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "affinityCookieTtlSec:",
            "  description:",
            "  - Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set",
            "    to 0, the cookie is non-persistent and lasts only until the end of the browser",
            "    session (or equivalent). The maximum allowed value for TTL is one day.",
            "  - When the load balancing scheme is INTERNAL, this field is not used.",
            "  returned: success",
            "  type: int",
            "backends:",
            "  description:",
            "  - The set of backends that serve this BackendService.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    balancingMode:",
            "      description:",
            "      - Specifies the balancing mode for this backend.",
            "      - For global HTTP(S) or TCP/SSL load balancing, the default is UTILIZATION.",
            "        Valid values are UTILIZATION, RATE (for HTTP(S)) and CONNECTION (for TCP/SSL).",
            "      returned: success",
            "      type: str",
            "    capacityScaler:",
            "      description:",
            "      - A multiplier applied to the group's maximum servicing capacity (based on UTILIZATION,",
            "        RATE or CONNECTION).",
            "      - Default value is 1, which means the group will serve up to 100% of its configured",
            "        capacity (depending on balancingMode). A setting of 0 means the group is completely",
            "        drained, offering 0% of its available Capacity. Valid range is [0.0,1.0].",
            "      returned: success",
            "      type: str",
            "    description:",
            "      description:",
            "      - An optional description of this resource.",
            "      - Provide this property when you create the resource.",
            "      returned: success",
            "      type: str",
            "    group:",
            "      description:",
            "      - The fully-qualified URL of an Instance Group or Network Endpoint Group resource.",
            "        In case of instance group this defines the list of instances that serve traffic.",
            "        Member virtual machine instances from each instance group must live in the",
            "        same zone as the instance group itself. No two backends in a backend service",
            "        are allowed to use same Instance Group resource.",
            "      - For Network Endpoint Groups this defines list of endpoints. All endpoints",
            "        of Network Endpoint Group must be hosted on instances located in the same",
            "        zone as the Network Endpoint Group.",
            "      - Backend service can not contain mix of Instance Group and Network Endpoint",
            "        Group backends.",
            "      - Note that you must specify an Instance Group or Network Endpoint Group resource",
            "        using the fully-qualified URL, rather than a partial URL.",
            "      returned: success",
            "      type: str",
            "    maxConnections:",
            "      description:",
            "      - The max number of simultaneous connections for the group. Can be used with",
            "        either CONNECTION or UTILIZATION balancing modes.",
            "      - For CONNECTION mode, either maxConnections or one of maxConnectionsPerInstance",
            "        or maxConnectionsPerEndpoint, as appropriate for group type, must be set.",
            "      returned: success",
            "      type: int",
            "    maxConnectionsPerInstance:",
            "      description:",
            "      - The max number of simultaneous connections that a single backend instance",
            "        can handle. This is used to calculate the capacity of the group. Can be used",
            "        in either CONNECTION or UTILIZATION balancing modes.",
            "      - For CONNECTION mode, either maxConnections or maxConnectionsPerInstance must",
            "        be set.",
            "      returned: success",
            "      type: int",
            "    maxConnectionsPerEndpoint:",
            "      description:",
            "      - The max number of simultaneous connections that a single backend network endpoint",
            "        can handle. This is used to calculate the capacity of the group. Can be used",
            "        in either CONNECTION or UTILIZATION balancing modes.",
            "      - For CONNECTION mode, either maxConnections or maxConnectionsPerEndpoint must",
            "        be set.",
            "      returned: success",
            "      type: int",
            "    maxRate:",
            "      description:",
            "      - The max requests per second (RPS) of the group.",
            "      - Can be used with either RATE or UTILIZATION balancing modes, but required",
            "        if RATE mode. For RATE mode, either maxRate or one of maxRatePerInstance or",
            "        maxRatePerEndpoint, as appropriate for group type, must be set.",
            "      returned: success",
            "      type: int",
            "    maxRatePerInstance:",
            "      description:",
            "      - The max requests per second (RPS) that a single backend instance can handle.",
            "        This is used to calculate the capacity of the group. Can be used in either",
            "        balancing mode. For RATE mode, either maxRate or maxRatePerInstance must be",
            "        set.",
            "      returned: success",
            "      type: str",
            "    maxRatePerEndpoint:",
            "      description:",
            "      - The max requests per second (RPS) that a single backend network endpoint can",
            "        handle. This is used to calculate the capacity of the group. Can be used in",
            "        either balancing mode. For RATE mode, either maxRate or maxRatePerEndpoint",
            "        must be set.",
            "      returned: success",
            "      type: str",
            "    maxUtilization:",
            "      description:",
            "      - Used when balancingMode is UTILIZATION. This ratio defines the CPU utilization",
            "        target for the group. The default is 0.8. Valid range is [0.0, 1.0].",
            "      returned: success",
            "      type: str",
            "cdnPolicy:",
            "  description:",
            "  - Cloud CDN configuration for this BackendService.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    cacheKeyPolicy:",
            "      description:",
            "      - The CacheKeyPolicy for this CdnPolicy.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        includeHost:",
            "          description:",
            "          - If true requests to different hosts will be cached separately.",
            "          returned: success",
            "          type: bool",
            "        includeProtocol:",
            "          description:",
            "          - If true, http and https requests will be cached separately.",
            "          returned: success",
            "          type: bool",
            "        includeQueryString:",
            "          description:",
            "          - If true, include query string parameters in the cache key according to",
            "            query_string_whitelist and query_string_blacklist. If neither is set,",
            "            the entire query string will be included.",
            "          - If false, the query string will be excluded from the cache key entirely.",
            "          returned: success",
            "          type: bool",
            "        queryStringBlacklist:",
            "          description:",
            "          - Names of query string parameters to exclude in cache keys.",
            "          - All other parameters will be included. Either specify query_string_whitelist",
            "            or query_string_blacklist, not both.",
            "          - \"'&' and '=' will be percent encoded and not treated as delimiters.\"",
            "          returned: success",
            "          type: list",
            "        queryStringWhitelist:",
            "          description:",
            "          - Names of query string parameters to include in cache keys.",
            "          - All other parameters will be excluded. Either specify query_string_whitelist",
            "            or query_string_blacklist, not both.",
            "          - \"'&' and '=' will be percent encoded and not treated as delimiters.\"",
            "          returned: success",
            "          type: list",
            "    signedUrlCacheMaxAgeSec:",
            "      description:",
            "      - Maximum number of seconds the response to a signed URL request will be considered",
            "        fresh, defaults to 1hr (3600s). After this time period, the response will",
            "        be revalidated before being served.",
            "      - 'When serving responses to signed URL requests, Cloud CDN will internally",
            "        behave as though all responses from this backend had a \"Cache-Control: public,",
            "        max-age=[TTL]\" header, regardless of any existing Cache-Control header. The",
            "        actual headers served in responses will not be altered.'",
            "      returned: success",
            "      type: int",
            "connectionDraining:",
            "  description:",
            "  - Settings for connection draining .",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    drainingTimeoutSec:",
            "      description:",
            "      - Time for which instance will be drained (not accept new connections, but still",
            "        work to finish started).",
            "      returned: success",
            "      type: int",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "fingerprint:",
            "  description:",
            "  - Fingerprint of this resource. A hash of the contents stored in this object. This",
            "    field is used in optimistic locking.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource.",
            "  returned: success",
            "  type: str",
            "enableCDN:",
            "  description:",
            "  - If true, enable Cloud CDN for this BackendService.",
            "  returned: success",
            "  type: bool",
            "healthChecks:",
            "  description:",
            "  - The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health",
            "    checking this BackendService. Currently at most one health check can be specified,",
            "    and a health check is required.",
            "  - For internal load balancing, a URL to a HealthCheck resource must be specified",
            "    instead.",
            "  returned: success",
            "  type: list",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "iap:",
            "  description:",
            "  - Settings for enabling Cloud Identity Aware Proxy.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    enabled:",
            "      description:",
            "      - Enables IAP.",
            "      returned: success",
            "      type: bool",
            "    oauth2ClientId:",
            "      description:",
            "      - OAuth2 Client ID for IAP .",
            "      returned: success",
            "      type: str",
            "    oauth2ClientSecret:",
            "      description:",
            "      - OAuth2 Client Secret for IAP .",
            "      returned: success",
            "      type: str",
            "    oauth2ClientSecretSha256:",
            "      description:",
            "      - OAuth2 Client Secret SHA-256 for IAP .",
            "      returned: success",
            "      type: str",
            "loadBalancingScheme:",
            "  description:",
            "  - Indicates whether the backend service will be used with internal or external load",
            "    balancing. A backend service created for one type of load balancing cannot be",
            "    used with the other. Must be `EXTERNAL` or `INTERNAL_SELF_MANAGED` for a global",
            "    backend service. Defaults to `EXTERNAL`.",
            "  returned: success",
            "  type: str",
            "name:",
            "  description:",
            "  - Name of the resource. Provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "portName:",
            "  description:",
            "  - Name of backend port. The same name should appear in the instance groups referenced",
            "    by this service. Required when the load balancing scheme is EXTERNAL.",
            "  returned: success",
            "  type: str",
            "protocol:",
            "  description:",
            "  - The protocol this BackendService uses to communicate with backends.",
            "  - 'Possible values are HTTP, HTTPS, HTTP2, TCP, and SSL. The default is HTTP. **NOTE**:",
            "    HTTP2 is only valid for beta HTTP/2 load balancer types and may result in errors",
            "    if used with the GA API.'",
            "  returned: success",
            "  type: str",
            "securityPolicy:",
            "  description:",
            "  - The security policy associated with this backend service.",
            "  returned: success",
            "  type: str",
            "sessionAffinity:",
            "  description:",
            "  - Type of session affinity to use. The default is NONE.",
            "  - When the load balancing scheme is EXTERNAL, can be NONE, CLIENT_IP, or GENERATED_COOKIE.",
            "  - When the protocol is UDP, this field is not used.",
            "  returned: success",
            "  type: str",
            "timeoutSec:",
            "  description:",
            "  - How many seconds to wait for the backend before considering it a failed request.",
            "    Default is 30 seconds. Valid range is [1, 86400].",
            "  returned: success",
            "  type: int",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            affinity_cookie_ttl_sec=dict(type='int'),",
            "            backends=dict(",
            "                type='list',",
            "                elements='dict',",
            "                options=dict(",
            "                    balancing_mode=dict(default='UTILIZATION', type='str'),",
            "                    capacity_scaler=dict(default=1.0, type='str'),",
            "                    description=dict(type='str'),",
            "                    group=dict(type='str'),",
            "                    max_connections=dict(type='int'),",
            "                    max_connections_per_instance=dict(type='int'),",
            "                    max_connections_per_endpoint=dict(type='int'),",
            "                    max_rate=dict(type='int'),",
            "                    max_rate_per_instance=dict(type='str'),",
            "                    max_rate_per_endpoint=dict(type='str'),",
            "                    max_utilization=dict(default=0.8, type='str'),",
            "                ),",
            "            ),",
            "            cdn_policy=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    cache_key_policy=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            include_host=dict(type='bool'),",
            "                            include_protocol=dict(type='bool'),",
            "                            include_query_string=dict(type='bool'),",
            "                            query_string_blacklist=dict(type='list', elements='str'),",
            "                            query_string_whitelist=dict(type='list', elements='str'),",
            "                        ),",
            "                    ),",
            "                    signed_url_cache_max_age_sec=dict(default=3600, type='int'),",
            "                ),",
            "            ),",
            "            connection_draining=dict(type='dict', options=dict(draining_timeout_sec=dict(default=300, type='int'))),",
            "            description=dict(type='str'),",
            "            enable_cdn=dict(type='bool'),",
            "            health_checks=dict(required=True, type='list', elements='str'),",
            "            iap=dict(",
            "                type='dict',",
            "                options=dict(enabled=dict(type='bool'), oauth2_client_id=dict(required=True, type='str'), oauth2_client_secret=dict(required=True, type='str', no_log=True)),",
            "            ),",
            "            load_balancing_scheme=dict(default='EXTERNAL', type='str'),",
            "            name=dict(required=True, type='str'),",
            "            port_name=dict(type='str'),",
            "            protocol=dict(type='str'),",
            "            security_policy=dict(type='str'),",
            "            session_affinity=dict(type='str'),",
            "            timeout_sec=dict(type='int', aliases=['timeout_seconds']),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#backendService'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.put(link, resource_to_request(module)))",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('securityPolicy') != request.get('securityPolicy'):",
            "        security_policy_update(module, request, response)",
            "",
            "",
            "def security_policy_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/global/backendServices/{name}/setSecurityPolicy\"]).format(**module.params),",
            "        {u'securityPolicy': module.params.get('security_policy')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#backendService',",
            "        u'affinityCookieTtlSec': module.params.get('affinity_cookie_ttl_sec'),",
            "        u'backends': BackendServiceBackendsArray(module.params.get('backends', []), module).to_request(),",
            "        u'cdnPolicy': BackendServiceCdnpolicy(module.params.get('cdn_policy', {}), module).to_request(),",
            "        u'connectionDraining': BackendServiceConnectiondraining(module.params.get('connection_draining', {}), module).to_request(),",
            "        u'description': module.params.get('description'),",
            "        u'enableCDN': module.params.get('enable_cdn'),",
            "        u'healthChecks': module.params.get('health_checks'),",
            "        u'iap': BackendServiceIap(module.params.get('iap', {}), module).to_request(),",
            "        u'loadBalancingScheme': module.params.get('load_balancing_scheme'),",
            "        u'name': module.params.get('name'),",
            "        u'portName': module.params.get('port_name'),",
            "        u'protocol': module.params.get('protocol'),",
            "        u'securityPolicy': module.params.get('security_policy'),",
            "        u'sessionAffinity': module.params.get('session_affinity'),",
            "        u'timeoutSec': module.params.get('timeout_sec'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/backendServices/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/backendServices\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'affinityCookieTtlSec': response.get(u'affinityCookieTtlSec'),",
            "        u'backends': BackendServiceBackendsArray(response.get(u'backends', []), module).from_response(),",
            "        u'cdnPolicy': BackendServiceCdnpolicy(response.get(u'cdnPolicy', {}), module).from_response(),",
            "        u'connectionDraining': BackendServiceConnectiondraining(response.get(u'connectionDraining', {}), module).from_response(),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'fingerprint': response.get(u'fingerprint'),",
            "        u'description': response.get(u'description'),",
            "        u'enableCDN': response.get(u'enableCDN'),",
            "        u'healthChecks': response.get(u'healthChecks'),",
            "        u'id': response.get(u'id'),",
            "        u'iap': BackendServiceIap(response.get(u'iap', {}), module).from_response(),",
            "        u'loadBalancingScheme': module.params.get('load_balancing_scheme'),",
            "        u'name': module.params.get('name'),",
            "        u'portName': response.get(u'portName'),",
            "        u'protocol': response.get(u'protocol'),",
            "        u'securityPolicy': response.get(u'securityPolicy'),",
            "        u'sessionAffinity': response.get(u'sessionAffinity'),",
            "        u'timeoutSec': response.get(u'timeoutSec'),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#backendService')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class BackendServiceBackendsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'balancingMode': item.get('balancing_mode'),",
            "                u'capacityScaler': item.get('capacity_scaler'),",
            "                u'description': item.get('description'),",
            "                u'group': item.get('group'),",
            "                u'maxConnections': item.get('max_connections'),",
            "                u'maxConnectionsPerInstance': item.get('max_connections_per_instance'),",
            "                u'maxConnectionsPerEndpoint': item.get('max_connections_per_endpoint'),",
            "                u'maxRate': item.get('max_rate'),",
            "                u'maxRatePerInstance': item.get('max_rate_per_instance'),",
            "                u'maxRatePerEndpoint': item.get('max_rate_per_endpoint'),",
            "                u'maxUtilization': item.get('max_utilization'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'balancingMode': item.get(u'balancingMode'),",
            "                u'capacityScaler': item.get(u'capacityScaler'),",
            "                u'description': item.get(u'description'),",
            "                u'group': item.get(u'group'),",
            "                u'maxConnections': item.get(u'maxConnections'),",
            "                u'maxConnectionsPerInstance': item.get(u'maxConnectionsPerInstance'),",
            "                u'maxConnectionsPerEndpoint': item.get(u'maxConnectionsPerEndpoint'),",
            "                u'maxRate': item.get(u'maxRate'),",
            "                u'maxRatePerInstance': item.get(u'maxRatePerInstance'),",
            "                u'maxRatePerEndpoint': item.get(u'maxRatePerEndpoint'),",
            "                u'maxUtilization': item.get(u'maxUtilization'),",
            "            }",
            "        )",
            "",
            "",
            "class BackendServiceCdnpolicy(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'cacheKeyPolicy': BackendServiceCachekeypolicy(self.request.get('cache_key_policy', {}), self.module).to_request(),",
            "                u'signedUrlCacheMaxAgeSec': self.request.get('signed_url_cache_max_age_sec'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'cacheKeyPolicy': BackendServiceCachekeypolicy(self.request.get(u'cacheKeyPolicy', {}), self.module).from_response(),",
            "                u'signedUrlCacheMaxAgeSec': self.request.get(u'signedUrlCacheMaxAgeSec'),",
            "            }",
            "        )",
            "",
            "",
            "class BackendServiceCachekeypolicy(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'includeHost': self.request.get('include_host'),",
            "                u'includeProtocol': self.request.get('include_protocol'),",
            "                u'includeQueryString': self.request.get('include_query_string'),",
            "                u'queryStringBlacklist': self.request.get('query_string_blacklist'),",
            "                u'queryStringWhitelist': self.request.get('query_string_whitelist'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'includeHost': self.request.get(u'includeHost'),",
            "                u'includeProtocol': self.request.get(u'includeProtocol'),",
            "                u'includeQueryString': self.request.get(u'includeQueryString'),",
            "                u'queryStringBlacklist': self.request.get(u'queryStringBlacklist'),",
            "                u'queryStringWhitelist': self.request.get(u'queryStringWhitelist'),",
            "            }",
            "        )",
            "",
            "",
            "class BackendServiceConnectiondraining(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'drainingTimeoutSec': self.request.get('draining_timeout_sec')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'drainingTimeoutSec': self.request.get(u'drainingTimeoutSec')})",
            "",
            "",
            "class BackendServiceIap(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'enabled': self.request.get('enabled'),",
            "                u'oauth2ClientId': self.request.get('oauth2_client_id'),",
            "                u'oauth2ClientSecret': self.request.get('oauth2_client_secret'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'enabled': self.request.get(u'enabled'),",
            "                u'oauth2ClientId': self.request.get(u'oauth2ClientId'),",
            "                u'oauth2ClientSecret': self.request.get(u'oauth2ClientSecret'),",
            "            }",
            "        )",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "735": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_disk.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": 460,
                "PatchRowcode": "             type=dict(type='str'),"
            },
            "1": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "             source_image=dict(type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "             zone=dict(required=True, type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),"
            },
            "4": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+            source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),"
            },
            "7": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": 465,
                "PatchRowcode": "             source_snapshot=dict(type='dict'),"
            },
            "8": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            source_snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+            source_snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),"
            },
            "10": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "         )"
            },
            "11": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "     )"
            },
            "12": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": 469,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_disk",
            "description:",
            "- Persistent disks are durable storage devices that function similarly to the physical",
            "  disks in a desktop or a server. Compute Engine manages the hardware behind these",
            "  devices to ensure data redundancy and optimize performance for you. Persistent disks",
            "  are available as either standard hard disk drives (HDD) or solid-state drives (SSD).",
            "- Persistent disks are located independently from your virtual machine instances,",
            "  so you can detach or move persistent disks to keep your data even after you delete",
            "  your instances. Persistent disk performance scales automatically with size, so you",
            "  can resize your existing persistent disks or add more persistent disks to an instance",
            "  to meet your performance and storage space requirements.",
            "- Add a persistent disk to your instance when you need reliable and affordable storage",
            "  with consistent performance characteristics.",
            "short_description: Creates a GCP Disk",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource. Provide this property when you create",
            "      the resource.",
            "    required: false",
            "    type: str",
            "  labels:",
            "    description:",
            "    - Labels to apply to this disk. A list of key->value pairs.",
            "    required: false",
            "    type: dict",
            "    version_added: 2.7",
            "  licenses:",
            "    description:",
            "    - Any applicable publicly visible licenses.",
            "    required: false",
            "    type: list",
            "  name:",
            "    description:",
            "    - Name of the resource. Provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  size_gb:",
            "    description:",
            "    - Size of the persistent disk, specified in GB. You can specify this field when",
            "      creating a persistent disk using the sourceImage or sourceSnapshot parameter,",
            "      or specify it alone to create an empty persistent disk.",
            "    - If you specify this field along with sourceImage or sourceSnapshot, the value",
            "      of sizeGb must not be less than the size of the sourceImage or the size of the",
            "      snapshot.",
            "    required: false",
            "    type: int",
            "  physical_block_size_bytes:",
            "    description:",
            "    - Physical block size of the persistent disk, in bytes. If not present in a request,",
            "      a default value is used. Currently supported sizes are 4096 and 16384, other",
            "      sizes may be added in the future.",
            "    - If an unsupported value is requested, the error message will list the supported",
            "      values for the caller's project.",
            "    required: false",
            "    type: int",
            "    version_added: 2.8",
            "  type:",
            "    description:",
            "    - URL of the disk type resource describing which disk type to use to create the",
            "      disk. Provide this when creating the disk.",
            "    required: false",
            "    type: str",
            "    version_added: 2.7",
            "  source_image:",
            "    description:",
            "    - The source image used to create this disk. If the source image is deleted, this",
            "      field will not be set.",
            "    - 'To create a disk with one of the public operating system images, specify the",
            "      image by its family name. For example, specify family/debian-8 to use the latest",
            "      Debian 8 image: projects/debian-cloud/global/images/family/debian-8 Alternatively,",
            "      use a specific version of a public operating system image: projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD",
            "      To create a disk with a private image that you created, specify the image name",
            "      in the following format: global/images/my-private-image You can also specify",
            "      a private image by its image family, which returns the latest version of the",
            "      image in that family. Replace the image name with family/family-name: global/images/family/my-private-family",
            "      .'",
            "    required: false",
            "    type: str",
            "  zone:",
            "    description:",
            "    - A reference to the zone where the disk resides.",
            "    required: true",
            "    type: str",
            "  source_image_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source image. Required if the source",
            "      image is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "  disk_encryption_key:",
            "    description:",
            "    - Encrypts the disk using a customer-supplied encryption key.",
            "    - After you encrypt a disk with a customer-supplied key, you must provide the",
            "      same key if you use the disk later (e.g. to create a disk snapshot or an image,",
            "      or to attach the disk to a virtual machine).",
            "    - Customer-supplied encryption keys do not protect access to metadata of the disk.",
            "    - If you do not provide an encryption key when creating the disk, then the disk",
            "      will be encrypted using an automatically generated key and you do not need to",
            "      provide a key to use the disk later.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "  source_snapshot:",
            "    description:",
            "    - The source snapshot used to create this disk. You can provide this as a partial",
            "      or full URL to the resource.",
            "    - 'This field represents a link to a Snapshot resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''selfLink'' and value",
            "      of your resource''s selfLink Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_snapshot task and then set this source_snapshot field to \"{{",
            "      name-of-resource }}\"'",
            "    required: false",
            "    type: dict",
            "  source_snapshot_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source snapshot. Required if the",
            "      source snapshot is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/v1/disks)'",
            "- 'Adding a persistent disk: U(https://cloud.google.com/compute/docs/disks/add-persistent-disk)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a disk",
            "  gcp_compute_disk:",
            "    name: test_object",
            "    size_gb: 50",
            "    disk_encryption_key:",
            "      raw_key: SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0=",
            "    zone: us-central1-a",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "labelFingerprint:",
            "  description:",
            "  - The fingerprint used for optimistic locking of this resource. Used internally",
            "    during updates.",
            "  returned: success",
            "  type: str",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource. Provide this property when you create",
            "    the resource.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "lastAttachTimestamp:",
            "  description:",
            "  - Last attach timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "lastDetachTimestamp:",
            "  description:",
            "  - Last detach timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "labels:",
            "  description:",
            "  - Labels to apply to this disk. A list of key->value pairs.",
            "  returned: success",
            "  type: dict",
            "licenses:",
            "  description:",
            "  - Any applicable publicly visible licenses.",
            "  returned: success",
            "  type: list",
            "name:",
            "  description:",
            "  - Name of the resource. Provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "sizeGb:",
            "  description:",
            "  - Size of the persistent disk, specified in GB. You can specify this field when",
            "    creating a persistent disk using the sourceImage or sourceSnapshot parameter,",
            "    or specify it alone to create an empty persistent disk.",
            "  - If you specify this field along with sourceImage or sourceSnapshot, the value",
            "    of sizeGb must not be less than the size of the sourceImage or the size of the",
            "    snapshot.",
            "  returned: success",
            "  type: int",
            "users:",
            "  description:",
            "  - 'Links to the users of the disk (attached instances) in form: project/zones/zone/instances/instance",
            "    .'",
            "  returned: success",
            "  type: list",
            "physicalBlockSizeBytes:",
            "  description:",
            "  - Physical block size of the persistent disk, in bytes. If not present in a request,",
            "    a default value is used. Currently supported sizes are 4096 and 16384, other sizes",
            "    may be added in the future.",
            "  - If an unsupported value is requested, the error message will list the supported",
            "    values for the caller's project.",
            "  returned: success",
            "  type: int",
            "type:",
            "  description:",
            "  - URL of the disk type resource describing which disk type to use to create the",
            "    disk. Provide this when creating the disk.",
            "  returned: success",
            "  type: str",
            "sourceImage:",
            "  description:",
            "  - The source image used to create this disk. If the source image is deleted, this",
            "    field will not be set.",
            "  - 'To create a disk with one of the public operating system images, specify the",
            "    image by its family name. For example, specify family/debian-8 to use the latest",
            "    Debian 8 image: projects/debian-cloud/global/images/family/debian-8 Alternatively,",
            "    use a specific version of a public operating system image: projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD",
            "    To create a disk with a private image that you created, specify the image name",
            "    in the following format: global/images/my-private-image You can also specify a",
            "    private image by its image family, which returns the latest version of the image",
            "    in that family. Replace the image name with family/family-name: global/images/family/my-private-family",
            "    .'",
            "  returned: success",
            "  type: str",
            "zone:",
            "  description:",
            "  - A reference to the zone where the disk resides.",
            "  returned: success",
            "  type: str",
            "sourceImageEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source image. Required if the source",
            "    image is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "sourceImageId:",
            "  description:",
            "  - The ID value of the image used to create this disk. This value identifies the",
            "    exact image that was used to create this persistent disk. For example, if you",
            "    created the persistent disk from an image that was later deleted and recreated",
            "    under the same name, the source image ID would identify the exact version of the",
            "    image that was used.",
            "  returned: success",
            "  type: str",
            "diskEncryptionKey:",
            "  description:",
            "  - Encrypts the disk using a customer-supplied encryption key.",
            "  - After you encrypt a disk with a customer-supplied key, you must provide the same",
            "    key if you use the disk later (e.g. to create a disk snapshot or an image, or",
            "    to attach the disk to a virtual machine).",
            "  - Customer-supplied encryption keys do not protect access to metadata of the disk.",
            "  - If you do not provide an encryption key when creating the disk, then the disk",
            "    will be encrypted using an automatically generated key and you do not need to",
            "    provide a key to use the disk later.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "sourceSnapshot:",
            "  description:",
            "  - The source snapshot used to create this disk. You can provide this as a partial",
            "    or full URL to the resource.",
            "  returned: success",
            "  type: dict",
            "sourceSnapshotEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source snapshot. Required if the source",
            "    snapshot is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "sourceSnapshotId:",
            "  description:",
            "  - The unique ID of the snapshot used to create this disk. This value identifies",
            "    the exact snapshot that was used to create this persistent disk. For example,",
            "    if you created the persistent disk from a snapshot that was later deleted and",
            "    recreated under the same name, the source snapshot ID would identify the exact",
            "    version of the snapshot that was used.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            description=dict(type='str'),",
            "            labels=dict(type='dict'),",
            "            licenses=dict(type='list', elements='str'),",
            "            name=dict(required=True, type='str'),",
            "            size_gb=dict(type='int'),",
            "            physical_block_size_bytes=dict(type='int'),",
            "            type=dict(type='str'),",
            "            source_image=dict(type='str'),",
            "            zone=dict(required=True, type='str'),",
            "            source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),",
            "            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),",
            "            source_snapshot=dict(type='dict'),",
            "            source_snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#disk'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('labels') != request.get('labels'):",
            "        label_fingerprint_update(module, request, response)",
            "    if response.get('sizeGb') != request.get('sizeGb'):",
            "        size_gb_update(module, request, response)",
            "",
            "",
            "def label_fingerprint_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/zones/{zone}/disks/{name}/setLabels\"]).format(**module.params),",
            "        {u'labelFingerprint': response.get('labelFingerprint'), u'labels': module.params.get('labels')},",
            "    )",
            "",
            "",
            "def size_gb_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/zones/{zone}/disks/{name}/resize\"]).format(**module.params),",
            "        {u'sizeGb': module.params.get('size_gb')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#disk',",
            "        u'sourceImageEncryptionKey': DiskSourceimageencryptionkey(module.params.get('source_image_encryption_key', {}), module).to_request(),",
            "        u'diskEncryptionKey': DiskDiskencryptionkey(module.params.get('disk_encryption_key', {}), module).to_request(),",
            "        u'sourceSnapshotEncryptionKey': DiskSourcesnapshotencryptionkey(module.params.get('source_snapshot_encryption_key', {}), module).to_request(),",
            "        u'description': module.params.get('description'),",
            "        u'labels': module.params.get('labels'),",
            "        u'licenses': module.params.get('licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'sizeGb': module.params.get('size_gb'),",
            "        u'physicalBlockSizeBytes': module.params.get('physical_block_size_bytes'),",
            "        u'type': disk_type_selflink(module.params.get('type'), module.params),",
            "        u'sourceImage': module.params.get('source_image'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/disks/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/disks\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'description': response.get(u'description'),",
            "        u'id': response.get(u'id'),",
            "        u'lastAttachTimestamp': response.get(u'lastAttachTimestamp'),",
            "        u'lastDetachTimestamp': response.get(u'lastDetachTimestamp'),",
            "        u'labels': response.get(u'labels'),",
            "        u'licenses': response.get(u'licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'sizeGb': response.get(u'sizeGb'),",
            "        u'users': response.get(u'users'),",
            "        u'physicalBlockSizeBytes': response.get(u'physicalBlockSizeBytes'),",
            "        u'type': response.get(u'type'),",
            "        u'sourceImage': module.params.get('source_image'),",
            "    }",
            "",
            "",
            "def disk_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/.*/diskTypes/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/diskTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#disk')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class DiskSourceimageencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "class DiskDiskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "class DiskSourcesnapshotencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_disk",
            "description:",
            "- Persistent disks are durable storage devices that function similarly to the physical",
            "  disks in a desktop or a server. Compute Engine manages the hardware behind these",
            "  devices to ensure data redundancy and optimize performance for you. Persistent disks",
            "  are available as either standard hard disk drives (HDD) or solid-state drives (SSD).",
            "- Persistent disks are located independently from your virtual machine instances,",
            "  so you can detach or move persistent disks to keep your data even after you delete",
            "  your instances. Persistent disk performance scales automatically with size, so you",
            "  can resize your existing persistent disks or add more persistent disks to an instance",
            "  to meet your performance and storage space requirements.",
            "- Add a persistent disk to your instance when you need reliable and affordable storage",
            "  with consistent performance characteristics.",
            "short_description: Creates a GCP Disk",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource. Provide this property when you create",
            "      the resource.",
            "    required: false",
            "    type: str",
            "  labels:",
            "    description:",
            "    - Labels to apply to this disk. A list of key->value pairs.",
            "    required: false",
            "    type: dict",
            "    version_added: 2.7",
            "  licenses:",
            "    description:",
            "    - Any applicable publicly visible licenses.",
            "    required: false",
            "    type: list",
            "  name:",
            "    description:",
            "    - Name of the resource. Provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  size_gb:",
            "    description:",
            "    - Size of the persistent disk, specified in GB. You can specify this field when",
            "      creating a persistent disk using the sourceImage or sourceSnapshot parameter,",
            "      or specify it alone to create an empty persistent disk.",
            "    - If you specify this field along with sourceImage or sourceSnapshot, the value",
            "      of sizeGb must not be less than the size of the sourceImage or the size of the",
            "      snapshot.",
            "    required: false",
            "    type: int",
            "  physical_block_size_bytes:",
            "    description:",
            "    - Physical block size of the persistent disk, in bytes. If not present in a request,",
            "      a default value is used. Currently supported sizes are 4096 and 16384, other",
            "      sizes may be added in the future.",
            "    - If an unsupported value is requested, the error message will list the supported",
            "      values for the caller's project.",
            "    required: false",
            "    type: int",
            "    version_added: 2.8",
            "  type:",
            "    description:",
            "    - URL of the disk type resource describing which disk type to use to create the",
            "      disk. Provide this when creating the disk.",
            "    required: false",
            "    type: str",
            "    version_added: 2.7",
            "  source_image:",
            "    description:",
            "    - The source image used to create this disk. If the source image is deleted, this",
            "      field will not be set.",
            "    - 'To create a disk with one of the public operating system images, specify the",
            "      image by its family name. For example, specify family/debian-8 to use the latest",
            "      Debian 8 image: projects/debian-cloud/global/images/family/debian-8 Alternatively,",
            "      use a specific version of a public operating system image: projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD",
            "      To create a disk with a private image that you created, specify the image name",
            "      in the following format: global/images/my-private-image You can also specify",
            "      a private image by its image family, which returns the latest version of the",
            "      image in that family. Replace the image name with family/family-name: global/images/family/my-private-family",
            "      .'",
            "    required: false",
            "    type: str",
            "  zone:",
            "    description:",
            "    - A reference to the zone where the disk resides.",
            "    required: true",
            "    type: str",
            "  source_image_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source image. Required if the source",
            "      image is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "  disk_encryption_key:",
            "    description:",
            "    - Encrypts the disk using a customer-supplied encryption key.",
            "    - After you encrypt a disk with a customer-supplied key, you must provide the",
            "      same key if you use the disk later (e.g. to create a disk snapshot or an image,",
            "      or to attach the disk to a virtual machine).",
            "    - Customer-supplied encryption keys do not protect access to metadata of the disk.",
            "    - If you do not provide an encryption key when creating the disk, then the disk",
            "      will be encrypted using an automatically generated key and you do not need to",
            "      provide a key to use the disk later.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "  source_snapshot:",
            "    description:",
            "    - The source snapshot used to create this disk. You can provide this as a partial",
            "      or full URL to the resource.",
            "    - 'This field represents a link to a Snapshot resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''selfLink'' and value",
            "      of your resource''s selfLink Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_snapshot task and then set this source_snapshot field to \"{{",
            "      name-of-resource }}\"'",
            "    required: false",
            "    type: dict",
            "  source_snapshot_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source snapshot. Required if the",
            "      source snapshot is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/v1/disks)'",
            "- 'Adding a persistent disk: U(https://cloud.google.com/compute/docs/disks/add-persistent-disk)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a disk",
            "  gcp_compute_disk:",
            "    name: test_object",
            "    size_gb: 50",
            "    disk_encryption_key:",
            "      raw_key: SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0=",
            "    zone: us-central1-a",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "labelFingerprint:",
            "  description:",
            "  - The fingerprint used for optimistic locking of this resource. Used internally",
            "    during updates.",
            "  returned: success",
            "  type: str",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource. Provide this property when you create",
            "    the resource.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "lastAttachTimestamp:",
            "  description:",
            "  - Last attach timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "lastDetachTimestamp:",
            "  description:",
            "  - Last detach timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "labels:",
            "  description:",
            "  - Labels to apply to this disk. A list of key->value pairs.",
            "  returned: success",
            "  type: dict",
            "licenses:",
            "  description:",
            "  - Any applicable publicly visible licenses.",
            "  returned: success",
            "  type: list",
            "name:",
            "  description:",
            "  - Name of the resource. Provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "sizeGb:",
            "  description:",
            "  - Size of the persistent disk, specified in GB. You can specify this field when",
            "    creating a persistent disk using the sourceImage or sourceSnapshot parameter,",
            "    or specify it alone to create an empty persistent disk.",
            "  - If you specify this field along with sourceImage or sourceSnapshot, the value",
            "    of sizeGb must not be less than the size of the sourceImage or the size of the",
            "    snapshot.",
            "  returned: success",
            "  type: int",
            "users:",
            "  description:",
            "  - 'Links to the users of the disk (attached instances) in form: project/zones/zone/instances/instance",
            "    .'",
            "  returned: success",
            "  type: list",
            "physicalBlockSizeBytes:",
            "  description:",
            "  - Physical block size of the persistent disk, in bytes. If not present in a request,",
            "    a default value is used. Currently supported sizes are 4096 and 16384, other sizes",
            "    may be added in the future.",
            "  - If an unsupported value is requested, the error message will list the supported",
            "    values for the caller's project.",
            "  returned: success",
            "  type: int",
            "type:",
            "  description:",
            "  - URL of the disk type resource describing which disk type to use to create the",
            "    disk. Provide this when creating the disk.",
            "  returned: success",
            "  type: str",
            "sourceImage:",
            "  description:",
            "  - The source image used to create this disk. If the source image is deleted, this",
            "    field will not be set.",
            "  - 'To create a disk with one of the public operating system images, specify the",
            "    image by its family name. For example, specify family/debian-8 to use the latest",
            "    Debian 8 image: projects/debian-cloud/global/images/family/debian-8 Alternatively,",
            "    use a specific version of a public operating system image: projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD",
            "    To create a disk with a private image that you created, specify the image name",
            "    in the following format: global/images/my-private-image You can also specify a",
            "    private image by its image family, which returns the latest version of the image",
            "    in that family. Replace the image name with family/family-name: global/images/family/my-private-family",
            "    .'",
            "  returned: success",
            "  type: str",
            "zone:",
            "  description:",
            "  - A reference to the zone where the disk resides.",
            "  returned: success",
            "  type: str",
            "sourceImageEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source image. Required if the source",
            "    image is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "sourceImageId:",
            "  description:",
            "  - The ID value of the image used to create this disk. This value identifies the",
            "    exact image that was used to create this persistent disk. For example, if you",
            "    created the persistent disk from an image that was later deleted and recreated",
            "    under the same name, the source image ID would identify the exact version of the",
            "    image that was used.",
            "  returned: success",
            "  type: str",
            "diskEncryptionKey:",
            "  description:",
            "  - Encrypts the disk using a customer-supplied encryption key.",
            "  - After you encrypt a disk with a customer-supplied key, you must provide the same",
            "    key if you use the disk later (e.g. to create a disk snapshot or an image, or",
            "    to attach the disk to a virtual machine).",
            "  - Customer-supplied encryption keys do not protect access to metadata of the disk.",
            "  - If you do not provide an encryption key when creating the disk, then the disk",
            "    will be encrypted using an automatically generated key and you do not need to",
            "    provide a key to use the disk later.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "sourceSnapshot:",
            "  description:",
            "  - The source snapshot used to create this disk. You can provide this as a partial",
            "    or full URL to the resource.",
            "  returned: success",
            "  type: dict",
            "sourceSnapshotEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source snapshot. Required if the source",
            "    snapshot is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "sourceSnapshotId:",
            "  description:",
            "  - The unique ID of the snapshot used to create this disk. This value identifies",
            "    the exact snapshot that was used to create this persistent disk. For example,",
            "    if you created the persistent disk from a snapshot that was later deleted and",
            "    recreated under the same name, the source snapshot ID would identify the exact",
            "    version of the snapshot that was used.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            description=dict(type='str'),",
            "            labels=dict(type='dict'),",
            "            licenses=dict(type='list', elements='str'),",
            "            name=dict(required=True, type='str'),",
            "            size_gb=dict(type='int'),",
            "            physical_block_size_bytes=dict(type='int'),",
            "            type=dict(type='str'),",
            "            source_image=dict(type='str'),",
            "            zone=dict(required=True, type='str'),",
            "            source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),",
            "            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),",
            "            source_snapshot=dict(type='dict'),",
            "            source_snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#disk'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('labels') != request.get('labels'):",
            "        label_fingerprint_update(module, request, response)",
            "    if response.get('sizeGb') != request.get('sizeGb'):",
            "        size_gb_update(module, request, response)",
            "",
            "",
            "def label_fingerprint_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/zones/{zone}/disks/{name}/setLabels\"]).format(**module.params),",
            "        {u'labelFingerprint': response.get('labelFingerprint'), u'labels': module.params.get('labels')},",
            "    )",
            "",
            "",
            "def size_gb_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/zones/{zone}/disks/{name}/resize\"]).format(**module.params),",
            "        {u'sizeGb': module.params.get('size_gb')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#disk',",
            "        u'sourceImageEncryptionKey': DiskSourceimageencryptionkey(module.params.get('source_image_encryption_key', {}), module).to_request(),",
            "        u'diskEncryptionKey': DiskDiskencryptionkey(module.params.get('disk_encryption_key', {}), module).to_request(),",
            "        u'sourceSnapshotEncryptionKey': DiskSourcesnapshotencryptionkey(module.params.get('source_snapshot_encryption_key', {}), module).to_request(),",
            "        u'description': module.params.get('description'),",
            "        u'labels': module.params.get('labels'),",
            "        u'licenses': module.params.get('licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'sizeGb': module.params.get('size_gb'),",
            "        u'physicalBlockSizeBytes': module.params.get('physical_block_size_bytes'),",
            "        u'type': disk_type_selflink(module.params.get('type'), module.params),",
            "        u'sourceImage': module.params.get('source_image'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/disks/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/disks\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'description': response.get(u'description'),",
            "        u'id': response.get(u'id'),",
            "        u'lastAttachTimestamp': response.get(u'lastAttachTimestamp'),",
            "        u'lastDetachTimestamp': response.get(u'lastDetachTimestamp'),",
            "        u'labels': response.get(u'labels'),",
            "        u'licenses': response.get(u'licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'sizeGb': response.get(u'sizeGb'),",
            "        u'users': response.get(u'users'),",
            "        u'physicalBlockSizeBytes': response.get(u'physicalBlockSizeBytes'),",
            "        u'type': response.get(u'type'),",
            "        u'sourceImage': module.params.get('source_image'),",
            "    }",
            "",
            "",
            "def disk_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/.*/diskTypes/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/diskTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#disk')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class DiskSourceimageencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "class DiskDiskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "class DiskSourcesnapshotencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "463": [
                "main"
            ],
            "464": [
                "main"
            ],
            "466": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "             disk_size_gb=dict(type='int'),"
            },
            "1": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "             family=dict(type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "             guest_os_features=dict(type='list', elements='dict', options=dict(type=dict(type='str'))),"
            },
            "3": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+            image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),"
            },
            "5": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": 465,
                "PatchRowcode": "             labels=dict(type='dict'),"
            },
            "6": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "             licenses=dict(type='list', elements='str'),"
            },
            "7": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "             name=dict(required=True, type='str'),"
            },
            "8": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "             raw_disk=dict(type='dict', options=dict(container_type=dict(type='str'), sha1_checksum=dict(type='str'), source=dict(required=True, type='str'))),"
            },
            "9": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "             source_disk=dict(type='dict'),"
            },
            "10": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            source_disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+            source_disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),"
            },
            "12": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 471,
                "PatchRowcode": "             source_disk_id=dict(type='str'),"
            },
            "13": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 472,
                "PatchRowcode": "             source_type=dict(type='str'),"
            },
            "14": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": 473,
                "PatchRowcode": "         )"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_image",
            "description:",
            "- Represents an Image resource.",
            "- Google Compute Engine uses operating system images to create the root persistent",
            "  disks for your instances. You specify an image when you create an instance. Images",
            "  contain a boot loader, an operating system, and a root file system. Linux operating",
            "  system images are also capable of running containers on Compute Engine.",
            "- Images can be either public or custom.",
            "- Public images are provided and maintained by Google, open-source communities, and",
            "  third-party vendors. By default, all projects have access to these images and can",
            "  use them to create instances. Custom images are available only to your project.",
            "  You can create a custom image from root persistent disks and other images. Then,",
            "  use the custom image to create an instance.",
            "short_description: Creates a GCP Image",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource. Provide this property when you create",
            "      the resource.",
            "    required: false",
            "    type: str",
            "  disk_size_gb:",
            "    description:",
            "    - Size of the image when restored onto a persistent disk (in GB).",
            "    required: false",
            "    type: int",
            "  family:",
            "    description:",
            "    - The name of the image family to which this image belongs. You can create disks",
            "      by specifying an image family instead of a specific image name. The image family",
            "      always returns its latest image that is not deprecated. The name of the image",
            "      family must comply with RFC1035.",
            "    required: false",
            "    type: str",
            "  guest_os_features:",
            "    description:",
            "    - A list of features to enable on the guest OS. Applicable for bootable images",
            "      only. Currently, only one feature can be enabled, VIRTIO_SCSI_MULTIQUEUE, which",
            "      allows each virtual CPU to have its own queue. For Windows images, you can only",
            "      enable VIRTIO_SCSI_MULTIQUEUE on images with driver version 1.2.0.1621 or higher.",
            "      Linux images with kernel versions 3.17 and higher will support VIRTIO_SCSI_MULTIQUEUE.",
            "    - For new Windows images, the server might also populate this field with the value",
            "      WINDOWS, to indicate that this is a Windows image.",
            "    - This value is purely informational and does not enable or disable any features.",
            "    required: false",
            "    type: list",
            "    suboptions:",
            "      type:",
            "        description:",
            "        - The type of supported feature. Currently only VIRTIO_SCSI_MULTIQUEUE is",
            "          supported. For newer Windows images, the server might also populate this",
            "          property with the value WINDOWS to indicate that this is a Windows image.",
            "          This value is purely informational and does not enable or disable any features.",
            "        - 'Some valid choices include: \"VIRTIO_SCSI_MULTIQUEUE\"'",
            "        required: false",
            "        type: str",
            "  image_encryption_key:",
            "    description:",
            "    - Encrypts the image using a customer-supplied encryption key.",
            "    - After you encrypt an image with a customer-supplied key, you must provide the",
            "      same key if you use the image later (e.g. to create a disk from the image) .",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "  labels:",
            "    description:",
            "    - Labels to apply to this Image.",
            "    required: false",
            "    type: dict",
            "    version_added: 2.8",
            "  licenses:",
            "    description:",
            "    - Any applicable license URI.",
            "    required: false",
            "    type: list",
            "  name:",
            "    description:",
            "    - Name of the resource; provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  raw_disk:",
            "    description:",
            "    - The parameters of the raw disk image.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      container_type:",
            "        description:",
            "        - The format used to encode and transmit the block device, which should be",
            "          TAR. This is just a container and transmission format and not a runtime",
            "          format. Provided by the client when the disk image is created.",
            "        - 'Some valid choices include: \"TAR\"'",
            "        required: false",
            "        type: str",
            "      sha1_checksum:",
            "        description:",
            "        - An optional SHA1 checksum of the disk image before unpackaging.",
            "        - This is provided by the client when the disk image is created.",
            "        required: false",
            "        type: str",
            "      source:",
            "        description:",
            "        - The full Google Cloud Storage URL where disk storage is stored You must",
            "          provide either this property or the sourceDisk property but not both.",
            "        required: true",
            "        type: str",
            "  source_disk:",
            "    description:",
            "    - The source disk to create this image based on.",
            "    - You must provide either this property or the rawDisk.source property but not",
            "      both to create an image.",
            "    - 'This field represents a link to a Disk resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''selfLink'' and value",
            "      of your resource''s selfLink Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_disk task and then set this source_disk field to \"{{ name-of-resource",
            "      }}\"'",
            "    required: false",
            "    type: dict",
            "  source_disk_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source disk. Required if the source",
            "      disk is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "  source_disk_id:",
            "    description:",
            "    - The ID value of the disk used to create this image. This value may be used to",
            "      determine whether the image was taken from the current or a previous instance",
            "      of a given disk name.",
            "    required: false",
            "    type: str",
            "  source_type:",
            "    description:",
            "    - The type of the image used to create this disk. The default and only value is",
            "      RAW .",
            "    - 'Some valid choices include: \"RAW\"'",
            "    required: false",
            "    type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/v1/images)'",
            "- 'Official Documentation: U(https://cloud.google.com/compute/docs/images)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a disk",
            "  gcp_compute_disk:",
            "    name: disk-image",
            "    zone: us-central1-a",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: disk",
            "",
            "- name: create a image",
            "  gcp_compute_image:",
            "    name: test_object",
            "    source_disk: \"{{ disk }}\"",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "archiveSizeBytes:",
            "  description:",
            "  - Size of the image tar.gz archive stored in Google Cloud Storage (in bytes).",
            "  returned: success",
            "  type: int",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "deprecated:",
            "  description:",
            "  - The deprecation status associated with this image.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    deleted:",
            "      description:",
            "      - An optional RFC3339 timestamp on or after which the state of this resource",
            "        is intended to change to DELETED. This is only informational and the status",
            "        will not change unless the client explicitly changes it.",
            "      returned: success",
            "      type: str",
            "    deprecated:",
            "      description:",
            "      - An optional RFC3339 timestamp on or after which the state of this resource",
            "        is intended to change to DEPRECATED. This is only informational and the status",
            "        will not change unless the client explicitly changes it.",
            "      returned: success",
            "      type: str",
            "    obsolete:",
            "      description:",
            "      - An optional RFC3339 timestamp on or after which the state of this resource",
            "        is intended to change to OBSOLETE. This is only informational and the status",
            "        will not change unless the client explicitly changes it.",
            "      returned: success",
            "      type: str",
            "    replacement:",
            "      description:",
            "      - The URL of the suggested replacement for a deprecated resource.",
            "      - The suggested replacement resource must be the same kind of resource as the",
            "        deprecated resource.",
            "      returned: success",
            "      type: str",
            "    state:",
            "      description:",
            "      - The deprecation state of this resource. This can be DEPRECATED, OBSOLETE,",
            "        or DELETED. Operations which create a new resource using a DEPRECATED resource",
            "        will return successfully, but with a warning indicating the deprecated resource",
            "        and recommending its replacement. Operations which use OBSOLETE or DELETED",
            "        resources will be rejected and result in an error.",
            "      returned: success",
            "      type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource. Provide this property when you create",
            "    the resource.",
            "  returned: success",
            "  type: str",
            "diskSizeGb:",
            "  description:",
            "  - Size of the image when restored onto a persistent disk (in GB).",
            "  returned: success",
            "  type: int",
            "family:",
            "  description:",
            "  - The name of the image family to which this image belongs. You can create disks",
            "    by specifying an image family instead of a specific image name. The image family",
            "    always returns its latest image that is not deprecated. The name of the image",
            "    family must comply with RFC1035.",
            "  returned: success",
            "  type: str",
            "guestOsFeatures:",
            "  description:",
            "  - A list of features to enable on the guest OS. Applicable for bootable images only.",
            "    Currently, only one feature can be enabled, VIRTIO_SCSI_MULTIQUEUE, which allows",
            "    each virtual CPU to have its own queue. For Windows images, you can only enable",
            "    VIRTIO_SCSI_MULTIQUEUE on images with driver version 1.2.0.1621 or higher. Linux",
            "    images with kernel versions 3.17 and higher will support VIRTIO_SCSI_MULTIQUEUE.",
            "  - For new Windows images, the server might also populate this field with the value",
            "    WINDOWS, to indicate that this is a Windows image.",
            "  - This value is purely informational and does not enable or disable any features.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    type:",
            "      description:",
            "      - The type of supported feature. Currently only VIRTIO_SCSI_MULTIQUEUE is supported.",
            "        For newer Windows images, the server might also populate this property with",
            "        the value WINDOWS to indicate that this is a Windows image. This value is",
            "        purely informational and does not enable or disable any features.",
            "      returned: success",
            "      type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource. This identifier is defined by the server.",
            "  returned: success",
            "  type: int",
            "imageEncryptionKey:",
            "  description:",
            "  - Encrypts the image using a customer-supplied encryption key.",
            "  - After you encrypt an image with a customer-supplied key, you must provide the",
            "    same key if you use the image later (e.g. to create a disk from the image) .",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "labels:",
            "  description:",
            "  - Labels to apply to this Image.",
            "  returned: success",
            "  type: dict",
            "labelFingerprint:",
            "  description:",
            "  - The fingerprint used for optimistic locking of this resource. Used internally",
            "    during updates.",
            "  returned: success",
            "  type: str",
            "licenses:",
            "  description:",
            "  - Any applicable license URI.",
            "  returned: success",
            "  type: list",
            "name:",
            "  description:",
            "  - Name of the resource; provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "rawDisk:",
            "  description:",
            "  - The parameters of the raw disk image.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    containerType:",
            "      description:",
            "      - The format used to encode and transmit the block device, which should be TAR.",
            "        This is just a container and transmission format and not a runtime format.",
            "        Provided by the client when the disk image is created.",
            "      returned: success",
            "      type: str",
            "    sha1Checksum:",
            "      description:",
            "      - An optional SHA1 checksum of the disk image before unpackaging.",
            "      - This is provided by the client when the disk image is created.",
            "      returned: success",
            "      type: str",
            "    source:",
            "      description:",
            "      - The full Google Cloud Storage URL where disk storage is stored You must provide",
            "        either this property or the sourceDisk property but not both.",
            "      returned: success",
            "      type: str",
            "sourceDisk:",
            "  description:",
            "  - The source disk to create this image based on.",
            "  - You must provide either this property or the rawDisk.source property but not both",
            "    to create an image.",
            "  returned: success",
            "  type: dict",
            "sourceDiskEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source disk. Required if the source",
            "    disk is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "sourceDiskId:",
            "  description:",
            "  - The ID value of the disk used to create this image. This value may be used to",
            "    determine whether the image was taken from the current or a previous instance",
            "    of a given disk name.",
            "  returned: success",
            "  type: str",
            "sourceType:",
            "  description:",
            "  - The type of the image used to create this disk. The default and only value is",
            "    RAW .",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            description=dict(type='str'),",
            "            disk_size_gb=dict(type='int'),",
            "            family=dict(type='str'),",
            "            guest_os_features=dict(type='list', elements='dict', options=dict(type=dict(type='str'))),",
            "            image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),",
            "            labels=dict(type='dict'),",
            "            licenses=dict(type='list', elements='str'),",
            "            name=dict(required=True, type='str'),",
            "            raw_disk=dict(type='dict', options=dict(container_type=dict(type='str'), sha1_checksum=dict(type='str'), source=dict(required=True, type='str'))),",
            "            source_disk=dict(type='dict'),",
            "            source_disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),",
            "            source_disk_id=dict(type='str'),",
            "            source_type=dict(type='str'),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#image'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('labels') != request.get('labels'):",
            "        labels_update(module, request, response)",
            "",
            "",
            "def labels_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/global/images/{name}/setLabels\"]).format(**module.params),",
            "        {u'labels': module.params.get('labels'), u'labelFingerprint': response.get('labelFingerprint')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#image',",
            "        u'description': module.params.get('description'),",
            "        u'diskSizeGb': module.params.get('disk_size_gb'),",
            "        u'family': module.params.get('family'),",
            "        u'guestOsFeatures': ImageGuestosfeaturesArray(module.params.get('guest_os_features', []), module).to_request(),",
            "        u'imageEncryptionKey': ImageImageencryptionkey(module.params.get('image_encryption_key', {}), module).to_request(),",
            "        u'labels': module.params.get('labels'),",
            "        u'licenses': module.params.get('licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'rawDisk': ImageRawdisk(module.params.get('raw_disk', {}), module).to_request(),",
            "        u'sourceDisk': replace_resource_dict(module.params.get(u'source_disk', {}), 'selfLink'),",
            "        u'sourceDiskEncryptionKey': ImageSourcediskencryptionkey(module.params.get('source_disk_encryption_key', {}), module).to_request(),",
            "        u'sourceDiskId': module.params.get('source_disk_id'),",
            "        u'sourceType': module.params.get('source_type'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/images/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/images\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'archiveSizeBytes': response.get(u'archiveSizeBytes'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'deprecated': ImageDeprecated(response.get(u'deprecated', {}), module).from_response(),",
            "        u'description': response.get(u'description'),",
            "        u'diskSizeGb': response.get(u'diskSizeGb'),",
            "        u'family': response.get(u'family'),",
            "        u'guestOsFeatures': ImageGuestosfeaturesArray(response.get(u'guestOsFeatures', []), module).from_response(),",
            "        u'id': response.get(u'id'),",
            "        u'imageEncryptionKey': ImageImageencryptionkey(response.get(u'imageEncryptionKey', {}), module).from_response(),",
            "        u'labels': response.get(u'labels'),",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "        u'licenses': response.get(u'licenses'),",
            "        u'name': response.get(u'name'),",
            "        u'rawDisk': ImageRawdisk(response.get(u'rawDisk', {}), module).from_response(),",
            "        u'sourceDisk': response.get(u'sourceDisk'),",
            "        u'sourceDiskEncryptionKey': ImageSourcediskencryptionkey(response.get(u'sourceDiskEncryptionKey', {}), module).from_response(),",
            "        u'sourceDiskId': response.get(u'sourceDiskId'),",
            "        u'sourceType': response.get(u'sourceType'),",
            "    }",
            "",
            "",
            "def license_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1//projects/.*/global/licenses/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1//projects/{project}/global/licenses/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#image')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class ImageDeprecated(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'deleted': self.request.get('deleted'),",
            "                u'deprecated': self.request.get('deprecated'),",
            "                u'obsolete': self.request.get('obsolete'),",
            "                u'replacement': self.request.get('replacement'),",
            "                u'state': self.request.get('state'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'deleted': self.request.get(u'deleted'),",
            "                u'deprecated': self.request.get(u'deprecated'),",
            "                u'obsolete': self.request.get(u'obsolete'),",
            "                u'replacement': self.request.get(u'replacement'),",
            "                u'state': self.request.get(u'state'),",
            "            }",
            "        )",
            "",
            "",
            "class ImageGuestosfeaturesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'type': item.get('type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'type': item.get(u'type')})",
            "",
            "",
            "class ImageImageencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "class ImageRawdisk(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {u'containerType': self.request.get('container_type'), u'sha1Checksum': self.request.get('sha1_checksum'), u'source': self.request.get('source')}",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {u'containerType': self.request.get(u'containerType'), u'sha1Checksum': self.request.get(u'sha1Checksum'), u'source': self.request.get(u'source')}",
            "        )",
            "",
            "",
            "class ImageSourcediskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_image",
            "description:",
            "- Represents an Image resource.",
            "- Google Compute Engine uses operating system images to create the root persistent",
            "  disks for your instances. You specify an image when you create an instance. Images",
            "  contain a boot loader, an operating system, and a root file system. Linux operating",
            "  system images are also capable of running containers on Compute Engine.",
            "- Images can be either public or custom.",
            "- Public images are provided and maintained by Google, open-source communities, and",
            "  third-party vendors. By default, all projects have access to these images and can",
            "  use them to create instances. Custom images are available only to your project.",
            "  You can create a custom image from root persistent disks and other images. Then,",
            "  use the custom image to create an instance.",
            "short_description: Creates a GCP Image",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource. Provide this property when you create",
            "      the resource.",
            "    required: false",
            "    type: str",
            "  disk_size_gb:",
            "    description:",
            "    - Size of the image when restored onto a persistent disk (in GB).",
            "    required: false",
            "    type: int",
            "  family:",
            "    description:",
            "    - The name of the image family to which this image belongs. You can create disks",
            "      by specifying an image family instead of a specific image name. The image family",
            "      always returns its latest image that is not deprecated. The name of the image",
            "      family must comply with RFC1035.",
            "    required: false",
            "    type: str",
            "  guest_os_features:",
            "    description:",
            "    - A list of features to enable on the guest OS. Applicable for bootable images",
            "      only. Currently, only one feature can be enabled, VIRTIO_SCSI_MULTIQUEUE, which",
            "      allows each virtual CPU to have its own queue. For Windows images, you can only",
            "      enable VIRTIO_SCSI_MULTIQUEUE on images with driver version 1.2.0.1621 or higher.",
            "      Linux images with kernel versions 3.17 and higher will support VIRTIO_SCSI_MULTIQUEUE.",
            "    - For new Windows images, the server might also populate this field with the value",
            "      WINDOWS, to indicate that this is a Windows image.",
            "    - This value is purely informational and does not enable or disable any features.",
            "    required: false",
            "    type: list",
            "    suboptions:",
            "      type:",
            "        description:",
            "        - The type of supported feature. Currently only VIRTIO_SCSI_MULTIQUEUE is",
            "          supported. For newer Windows images, the server might also populate this",
            "          property with the value WINDOWS to indicate that this is a Windows image.",
            "          This value is purely informational and does not enable or disable any features.",
            "        - 'Some valid choices include: \"VIRTIO_SCSI_MULTIQUEUE\"'",
            "        required: false",
            "        type: str",
            "  image_encryption_key:",
            "    description:",
            "    - Encrypts the image using a customer-supplied encryption key.",
            "    - After you encrypt an image with a customer-supplied key, you must provide the",
            "      same key if you use the image later (e.g. to create a disk from the image) .",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "  labels:",
            "    description:",
            "    - Labels to apply to this Image.",
            "    required: false",
            "    type: dict",
            "    version_added: 2.8",
            "  licenses:",
            "    description:",
            "    - Any applicable license URI.",
            "    required: false",
            "    type: list",
            "  name:",
            "    description:",
            "    - Name of the resource; provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  raw_disk:",
            "    description:",
            "    - The parameters of the raw disk image.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      container_type:",
            "        description:",
            "        - The format used to encode and transmit the block device, which should be",
            "          TAR. This is just a container and transmission format and not a runtime",
            "          format. Provided by the client when the disk image is created.",
            "        - 'Some valid choices include: \"TAR\"'",
            "        required: false",
            "        type: str",
            "      sha1_checksum:",
            "        description:",
            "        - An optional SHA1 checksum of the disk image before unpackaging.",
            "        - This is provided by the client when the disk image is created.",
            "        required: false",
            "        type: str",
            "      source:",
            "        description:",
            "        - The full Google Cloud Storage URL where disk storage is stored You must",
            "          provide either this property or the sourceDisk property but not both.",
            "        required: true",
            "        type: str",
            "  source_disk:",
            "    description:",
            "    - The source disk to create this image based on.",
            "    - You must provide either this property or the rawDisk.source property but not",
            "      both to create an image.",
            "    - 'This field represents a link to a Disk resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''selfLink'' and value",
            "      of your resource''s selfLink Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_disk task and then set this source_disk field to \"{{ name-of-resource",
            "      }}\"'",
            "    required: false",
            "    type: dict",
            "  source_disk_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source disk. Required if the source",
            "      disk is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "  source_disk_id:",
            "    description:",
            "    - The ID value of the disk used to create this image. This value may be used to",
            "      determine whether the image was taken from the current or a previous instance",
            "      of a given disk name.",
            "    required: false",
            "    type: str",
            "  source_type:",
            "    description:",
            "    - The type of the image used to create this disk. The default and only value is",
            "      RAW .",
            "    - 'Some valid choices include: \"RAW\"'",
            "    required: false",
            "    type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/v1/images)'",
            "- 'Official Documentation: U(https://cloud.google.com/compute/docs/images)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a disk",
            "  gcp_compute_disk:",
            "    name: disk-image",
            "    zone: us-central1-a",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: disk",
            "",
            "- name: create a image",
            "  gcp_compute_image:",
            "    name: test_object",
            "    source_disk: \"{{ disk }}\"",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "archiveSizeBytes:",
            "  description:",
            "  - Size of the image tar.gz archive stored in Google Cloud Storage (in bytes).",
            "  returned: success",
            "  type: int",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "deprecated:",
            "  description:",
            "  - The deprecation status associated with this image.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    deleted:",
            "      description:",
            "      - An optional RFC3339 timestamp on or after which the state of this resource",
            "        is intended to change to DELETED. This is only informational and the status",
            "        will not change unless the client explicitly changes it.",
            "      returned: success",
            "      type: str",
            "    deprecated:",
            "      description:",
            "      - An optional RFC3339 timestamp on or after which the state of this resource",
            "        is intended to change to DEPRECATED. This is only informational and the status",
            "        will not change unless the client explicitly changes it.",
            "      returned: success",
            "      type: str",
            "    obsolete:",
            "      description:",
            "      - An optional RFC3339 timestamp on or after which the state of this resource",
            "        is intended to change to OBSOLETE. This is only informational and the status",
            "        will not change unless the client explicitly changes it.",
            "      returned: success",
            "      type: str",
            "    replacement:",
            "      description:",
            "      - The URL of the suggested replacement for a deprecated resource.",
            "      - The suggested replacement resource must be the same kind of resource as the",
            "        deprecated resource.",
            "      returned: success",
            "      type: str",
            "    state:",
            "      description:",
            "      - The deprecation state of this resource. This can be DEPRECATED, OBSOLETE,",
            "        or DELETED. Operations which create a new resource using a DEPRECATED resource",
            "        will return successfully, but with a warning indicating the deprecated resource",
            "        and recommending its replacement. Operations which use OBSOLETE or DELETED",
            "        resources will be rejected and result in an error.",
            "      returned: success",
            "      type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource. Provide this property when you create",
            "    the resource.",
            "  returned: success",
            "  type: str",
            "diskSizeGb:",
            "  description:",
            "  - Size of the image when restored onto a persistent disk (in GB).",
            "  returned: success",
            "  type: int",
            "family:",
            "  description:",
            "  - The name of the image family to which this image belongs. You can create disks",
            "    by specifying an image family instead of a specific image name. The image family",
            "    always returns its latest image that is not deprecated. The name of the image",
            "    family must comply with RFC1035.",
            "  returned: success",
            "  type: str",
            "guestOsFeatures:",
            "  description:",
            "  - A list of features to enable on the guest OS. Applicable for bootable images only.",
            "    Currently, only one feature can be enabled, VIRTIO_SCSI_MULTIQUEUE, which allows",
            "    each virtual CPU to have its own queue. For Windows images, you can only enable",
            "    VIRTIO_SCSI_MULTIQUEUE on images with driver version 1.2.0.1621 or higher. Linux",
            "    images with kernel versions 3.17 and higher will support VIRTIO_SCSI_MULTIQUEUE.",
            "  - For new Windows images, the server might also populate this field with the value",
            "    WINDOWS, to indicate that this is a Windows image.",
            "  - This value is purely informational and does not enable or disable any features.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    type:",
            "      description:",
            "      - The type of supported feature. Currently only VIRTIO_SCSI_MULTIQUEUE is supported.",
            "        For newer Windows images, the server might also populate this property with",
            "        the value WINDOWS to indicate that this is a Windows image. This value is",
            "        purely informational and does not enable or disable any features.",
            "      returned: success",
            "      type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource. This identifier is defined by the server.",
            "  returned: success",
            "  type: int",
            "imageEncryptionKey:",
            "  description:",
            "  - Encrypts the image using a customer-supplied encryption key.",
            "  - After you encrypt an image with a customer-supplied key, you must provide the",
            "    same key if you use the image later (e.g. to create a disk from the image) .",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "labels:",
            "  description:",
            "  - Labels to apply to this Image.",
            "  returned: success",
            "  type: dict",
            "labelFingerprint:",
            "  description:",
            "  - The fingerprint used for optimistic locking of this resource. Used internally",
            "    during updates.",
            "  returned: success",
            "  type: str",
            "licenses:",
            "  description:",
            "  - Any applicable license URI.",
            "  returned: success",
            "  type: list",
            "name:",
            "  description:",
            "  - Name of the resource; provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "rawDisk:",
            "  description:",
            "  - The parameters of the raw disk image.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    containerType:",
            "      description:",
            "      - The format used to encode and transmit the block device, which should be TAR.",
            "        This is just a container and transmission format and not a runtime format.",
            "        Provided by the client when the disk image is created.",
            "      returned: success",
            "      type: str",
            "    sha1Checksum:",
            "      description:",
            "      - An optional SHA1 checksum of the disk image before unpackaging.",
            "      - This is provided by the client when the disk image is created.",
            "      returned: success",
            "      type: str",
            "    source:",
            "      description:",
            "      - The full Google Cloud Storage URL where disk storage is stored You must provide",
            "        either this property or the sourceDisk property but not both.",
            "      returned: success",
            "      type: str",
            "sourceDisk:",
            "  description:",
            "  - The source disk to create this image based on.",
            "  - You must provide either this property or the rawDisk.source property but not both",
            "    to create an image.",
            "  returned: success",
            "  type: dict",
            "sourceDiskEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source disk. Required if the source",
            "    disk is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "sourceDiskId:",
            "  description:",
            "  - The ID value of the disk used to create this image. This value may be used to",
            "    determine whether the image was taken from the current or a previous instance",
            "    of a given disk name.",
            "  returned: success",
            "  type: str",
            "sourceType:",
            "  description:",
            "  - The type of the image used to create this disk. The default and only value is",
            "    RAW .",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            description=dict(type='str'),",
            "            disk_size_gb=dict(type='int'),",
            "            family=dict(type='str'),",
            "            guest_os_features=dict(type='list', elements='dict', options=dict(type=dict(type='str'))),",
            "            image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),",
            "            labels=dict(type='dict'),",
            "            licenses=dict(type='list', elements='str'),",
            "            name=dict(required=True, type='str'),",
            "            raw_disk=dict(type='dict', options=dict(container_type=dict(type='str'), sha1_checksum=dict(type='str'), source=dict(required=True, type='str'))),",
            "            source_disk=dict(type='dict'),",
            "            source_disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),",
            "            source_disk_id=dict(type='str'),",
            "            source_type=dict(type='str'),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#image'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('labels') != request.get('labels'):",
            "        labels_update(module, request, response)",
            "",
            "",
            "def labels_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/global/images/{name}/setLabels\"]).format(**module.params),",
            "        {u'labels': module.params.get('labels'), u'labelFingerprint': response.get('labelFingerprint')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#image',",
            "        u'description': module.params.get('description'),",
            "        u'diskSizeGb': module.params.get('disk_size_gb'),",
            "        u'family': module.params.get('family'),",
            "        u'guestOsFeatures': ImageGuestosfeaturesArray(module.params.get('guest_os_features', []), module).to_request(),",
            "        u'imageEncryptionKey': ImageImageencryptionkey(module.params.get('image_encryption_key', {}), module).to_request(),",
            "        u'labels': module.params.get('labels'),",
            "        u'licenses': module.params.get('licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'rawDisk': ImageRawdisk(module.params.get('raw_disk', {}), module).to_request(),",
            "        u'sourceDisk': replace_resource_dict(module.params.get(u'source_disk', {}), 'selfLink'),",
            "        u'sourceDiskEncryptionKey': ImageSourcediskencryptionkey(module.params.get('source_disk_encryption_key', {}), module).to_request(),",
            "        u'sourceDiskId': module.params.get('source_disk_id'),",
            "        u'sourceType': module.params.get('source_type'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/images/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/images\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'archiveSizeBytes': response.get(u'archiveSizeBytes'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'deprecated': ImageDeprecated(response.get(u'deprecated', {}), module).from_response(),",
            "        u'description': response.get(u'description'),",
            "        u'diskSizeGb': response.get(u'diskSizeGb'),",
            "        u'family': response.get(u'family'),",
            "        u'guestOsFeatures': ImageGuestosfeaturesArray(response.get(u'guestOsFeatures', []), module).from_response(),",
            "        u'id': response.get(u'id'),",
            "        u'imageEncryptionKey': ImageImageencryptionkey(response.get(u'imageEncryptionKey', {}), module).from_response(),",
            "        u'labels': response.get(u'labels'),",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "        u'licenses': response.get(u'licenses'),",
            "        u'name': response.get(u'name'),",
            "        u'rawDisk': ImageRawdisk(response.get(u'rawDisk', {}), module).from_response(),",
            "        u'sourceDisk': response.get(u'sourceDisk'),",
            "        u'sourceDiskEncryptionKey': ImageSourcediskencryptionkey(response.get(u'sourceDiskEncryptionKey', {}), module).from_response(),",
            "        u'sourceDiskId': response.get(u'sourceDiskId'),",
            "        u'sourceType': response.get(u'sourceType'),",
            "    }",
            "",
            "",
            "def license_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1//projects/.*/global/licenses/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1//projects/{project}/global/licenses/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#image')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class ImageDeprecated(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'deleted': self.request.get('deleted'),",
            "                u'deprecated': self.request.get('deprecated'),",
            "                u'obsolete': self.request.get('obsolete'),",
            "                u'replacement': self.request.get('replacement'),",
            "                u'state': self.request.get('state'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'deleted': self.request.get(u'deleted'),",
            "                u'deprecated': self.request.get(u'deprecated'),",
            "                u'obsolete': self.request.get(u'obsolete'),",
            "                u'replacement': self.request.get(u'replacement'),",
            "                u'state': self.request.get(u'state'),",
            "            }",
            "        )",
            "",
            "",
            "class ImageGuestosfeaturesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'type': item.get('type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'type': item.get(u'type')})",
            "",
            "",
            "class ImageImageencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "class ImageRawdisk(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {u'containerType': self.request.get('container_type'), u'sha1Checksum': self.request.get('sha1_checksum'), u'source': self.request.get('source')}",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {u'containerType': self.request.get(u'containerType'), u'sha1Checksum': self.request.get(u'sha1Checksum'), u'source': self.request.get(u'source')}",
            "        )",
            "",
            "",
            "class ImageSourcediskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "464": [
                "main"
            ],
            "470": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_instance_template.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 914,
                "afterPatchRowNumber": 914,
                "PatchRowcode": "                             auto_delete=dict(type='bool'),"
            },
            "1": {
                "beforePatchRowNumber": 915,
                "afterPatchRowNumber": 915,
                "PatchRowcode": "                             boot=dict(type='bool'),"
            },
            "2": {
                "beforePatchRowNumber": 916,
                "afterPatchRowNumber": 916,
                "PatchRowcode": "                             device_name=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 917,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), rsa_encrypted_key=dict(type='str'))),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 917,
                "PatchRowcode": "+                            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), rsa_encrypted_key=dict(type='str', no_log=True))),"
            },
            "5": {
                "beforePatchRowNumber": 918,
                "afterPatchRowNumber": 918,
                "PatchRowcode": "                             index=dict(type='int'),"
            },
            "6": {
                "beforePatchRowNumber": 919,
                "afterPatchRowNumber": 919,
                "PatchRowcode": "                             initialize_params=dict("
            },
            "7": {
                "beforePatchRowNumber": 920,
                "afterPatchRowNumber": 920,
                "PatchRowcode": "                                 type='dict',"
            },
            "8": {
                "beforePatchRowNumber": 923,
                "afterPatchRowNumber": 923,
                "PatchRowcode": "                                     disk_size_gb=dict(type='int'),"
            },
            "9": {
                "beforePatchRowNumber": 924,
                "afterPatchRowNumber": 924,
                "PatchRowcode": "                                     disk_type=dict(type='str'),"
            },
            "10": {
                "beforePatchRowNumber": 925,
                "afterPatchRowNumber": 925,
                "PatchRowcode": "                                     source_image=dict(type='str'),"
            },
            "11": {
                "beforePatchRowNumber": 926,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 926,
                "PatchRowcode": "+                                    source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),"
            },
            "13": {
                "beforePatchRowNumber": 927,
                "afterPatchRowNumber": 927,
                "PatchRowcode": "                                 ),"
            },
            "14": {
                "beforePatchRowNumber": 928,
                "afterPatchRowNumber": 928,
                "PatchRowcode": "                             ),"
            },
            "15": {
                "beforePatchRowNumber": 929,
                "afterPatchRowNumber": 929,
                "PatchRowcode": "                             interface=dict(type='str'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_instance_template",
            "description:",
            "- Defines an Instance Template resource that provides configuration settings for your",
            "  virtual machine instances. Instance templates are not tied to the lifetime of an",
            "  instance and can be used and reused as to deploy virtual machines. You can also",
            "  use different templates to create different virtual machine configurations. Instance",
            "  templates are required when you create a managed instance group.",
            "- 'Tip: Disks should be set to autoDelete=true so that leftover disks are not left",
            "  behind on machine deletion.'",
            "short_description: Creates a GCP InstanceTemplate",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource. Provide this property when you create",
            "      the resource.",
            "    required: false",
            "    type: str",
            "  name:",
            "    description:",
            "    - Name of the resource. The name is 1-63 characters long and complies with RFC1035.",
            "    required: true",
            "    type: str",
            "  properties:",
            "    description:",
            "    - The instance properties for this instance template.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      can_ip_forward:",
            "        description:",
            "        - Enables instances created based on this template to send packets with source",
            "          IP addresses other than their own and receive packets with destination IP",
            "          addresses other than their own. If these instances will be used as an IP",
            "          gateway or it will be set as the next-hop in a Route resource, specify true.",
            "          If unsure, leave this set to false.",
            "        required: false",
            "        type: bool",
            "      description:",
            "        description:",
            "        - An optional text description for the instances that are created from this",
            "          instance template.",
            "        required: false",
            "        type: str",
            "      disks:",
            "        description:",
            "        - An array of disks that are associated with the instances that are created",
            "          from this template.",
            "        required: false",
            "        type: list",
            "        suboptions:",
            "          auto_delete:",
            "            description:",
            "            - Specifies whether the disk will be auto-deleted when the instance is",
            "              deleted (but not when the disk is detached from the instance).",
            "            - 'Tip: Disks should be set to autoDelete=true so that leftover disks",
            "              are not left behind on machine deletion.'",
            "            required: false",
            "            type: bool",
            "          boot:",
            "            description:",
            "            - Indicates that this is a boot disk. The virtual machine will use the",
            "              first partition of the disk for its root filesystem.",
            "            required: false",
            "            type: bool",
            "          device_name:",
            "            description:",
            "            - Specifies a unique device name of your choice that is reflected into",
            "              the /dev/disk/by-id/google-* tree of a Linux operating system running",
            "              within the instance. This name can be used to reference the device for",
            "              mounting, resizing, and so on, from within the instance.",
            "            required: false",
            "            type: str",
            "          disk_encryption_key:",
            "            description:",
            "            - Encrypts or decrypts a disk using a customer-supplied encryption key.",
            "            required: false",
            "            type: dict",
            "            suboptions:",
            "              raw_key:",
            "                description:",
            "                - Specifies a 256-bit customer-supplied encryption key, encoded in",
            "                  RFC 4648 base64 to either encrypt or decrypt this resource.",
            "                required: false",
            "                type: str",
            "              rsa_encrypted_key:",
            "                description:",
            "                - Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied",
            "                  encryption key to either encrypt or decrypt this resource.",
            "                required: false",
            "                type: str",
            "          index:",
            "            description:",
            "            - Assigns a zero-based index to this disk, where 0 is reserved for the",
            "              boot disk. For example, if you have many disks attached to an instance,",
            "              each disk would have a unique index number. If not specified, the server",
            "              will choose an appropriate value.",
            "            required: false",
            "            type: int",
            "          initialize_params:",
            "            description:",
            "            - Specifies the parameters for a new disk that will be created alongside",
            "              the new instance. Use initialization parameters to create boot disks",
            "              or local SSDs attached to the new instance.",
            "            required: false",
            "            type: dict",
            "            suboptions:",
            "              disk_name:",
            "                description:",
            "                - Specifies the disk name. If not specified, the default is to use",
            "                  the name of the instance.",
            "                required: false",
            "                type: str",
            "              disk_size_gb:",
            "                description:",
            "                - Specifies the size of the disk in base-2 GB.",
            "                required: false",
            "                type: int",
            "              disk_type:",
            "                description:",
            "                - Reference to a disk type.",
            "                - Specifies the disk type to use to create the instance.",
            "                - If not specified, the default is pd-standard.",
            "                required: false",
            "                type: str",
            "              source_image:",
            "                description:",
            "                - The source image to create this disk. When creating a new instance,",
            "                  one of initializeParams.sourceImage or disks.source is required.",
            "                  To create a disk with one of the public operating system images,",
            "                  specify the image by its family name.",
            "                required: false",
            "                type: str",
            "              source_image_encryption_key:",
            "                description:",
            "                - The customer-supplied encryption key of the source image. Required",
            "                  if the source image is protected by a customer-supplied encryption",
            "                  key.",
            "                - Instance templates do not store customer-supplied encryption keys,",
            "                  so you cannot create disks for instances in a managed instance group",
            "                  if the source images are encrypted with your own keys.",
            "                required: false",
            "                type: dict",
            "                suboptions:",
            "                  raw_key:",
            "                    description:",
            "                    - Specifies a 256-bit customer-supplied encryption key, encoded",
            "                      in RFC 4648 base64 to either encrypt or decrypt this resource.",
            "                    required: false",
            "                    type: str",
            "          interface:",
            "            description:",
            "            - Specifies the disk interface to use for attaching this disk, which is",
            "              either SCSI or NVME. The default is SCSI.",
            "            - Persistent disks must always use SCSI and the request will fail if you",
            "              attempt to attach a persistent disk in any other format than SCSI.",
            "            - 'Some valid choices include: \"SCSI\", \"NVME\"'",
            "            required: false",
            "            type: str",
            "          mode:",
            "            description:",
            "            - The mode in which to attach this disk, either READ_WRITE or READ_ONLY.",
            "              If not specified, the default is to attach the disk in READ_WRITE mode.",
            "            - 'Some valid choices include: \"READ_WRITE\", \"READ_ONLY\"'",
            "            required: false",
            "            type: str",
            "          source:",
            "            description:",
            "            - Reference to a disk. When creating a new instance, one of initializeParams.sourceImage",
            "              or disks.source is required.",
            "            - If desired, you can also attach existing non-root persistent disks using",
            "              this property. This field is only applicable for persistent disks.",
            "            - Note that for InstanceTemplate, specify the disk name, not the URL for",
            "              the disk.",
            "            - 'This field represents a link to a Disk resource in GCP. It can be specified",
            "              in two ways. First, you can place a dictionary with key ''name'' and",
            "              value of your resource''s name Alternatively, you can add `register:",
            "              name-of-resource` to a gcp_compute_disk task and then set this source",
            "              field to \"{{ name-of-resource }}\"'",
            "            required: false",
            "            type: dict",
            "          type:",
            "            description:",
            "            - Specifies the type of the disk, either SCRATCH or PERSISTENT. If not",
            "              specified, the default is PERSISTENT.",
            "            - 'Some valid choices include: \"SCRATCH\", \"PERSISTENT\"'",
            "            required: false",
            "            type: str",
            "      labels:",
            "        description:",
            "        - Labels to apply to this address. A list of key->value pairs.",
            "        required: false",
            "        type: dict",
            "        version_added: 2.9",
            "      machine_type:",
            "        description:",
            "        - The machine type to use in the VM instance template.",
            "        required: true",
            "        type: str",
            "      min_cpu_platform:",
            "        description:",
            "        - Specifies a minimum CPU platform for the VM instance. Applicable values",
            "          are the friendly names of CPU platforms .",
            "        required: false",
            "        type: str",
            "      metadata:",
            "        description:",
            "        - The metadata key/value pairs to assign to instances that are created from",
            "          this template. These pairs can consist of custom metadata or predefined",
            "          keys.",
            "        required: false",
            "        type: dict",
            "      guest_accelerators:",
            "        description:",
            "        - List of the type and count of accelerator cards attached to the instance",
            "          .",
            "        required: false",
            "        type: list",
            "        suboptions:",
            "          accelerator_count:",
            "            description:",
            "            - The number of the guest accelerator cards exposed to this instance.",
            "            required: false",
            "            type: int",
            "          accelerator_type:",
            "            description:",
            "            - Full or partial URL of the accelerator type resource to expose to this",
            "              instance.",
            "            required: false",
            "            type: str",
            "      network_interfaces:",
            "        description:",
            "        - An array of configurations for this interface. This specifies how this interface",
            "          is configured to interact with other network services, such as connecting",
            "          to the internet. Only one network interface is supported per instance.",
            "        required: false",
            "        type: list",
            "        suboptions:",
            "          access_configs:",
            "            description:",
            "            - An array of configurations for this interface. Currently, only one access",
            "              config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs",
            "              specified, then this instance will have no external internet access.",
            "            required: false",
            "            type: list",
            "            suboptions:",
            "              name:",
            "                description:",
            "                - The name of this access configuration. The default and recommended",
            "                  name is External NAT but you can use any arbitrary string you would",
            "                  like. For example, My external IP or Network Access.",
            "                required: true",
            "                type: str",
            "              nat_ip:",
            "                description:",
            "                - Reference to an address.",
            "                - An external IP address associated with this instance.",
            "                - Specify an unused static external IP address available to the project",
            "                  or leave this field undefined to use an IP from a shared ephemeral",
            "                  IP address pool. If you specify a static external IP address, it",
            "                  must live in the same region as the zone of the instance.",
            "                - 'This field represents a link to a Address resource in GCP. It can",
            "                  be specified in two ways. First, you can place a dictionary with",
            "                  key ''address'' and value of your resource''s address Alternatively,",
            "                  you can add `register: name-of-resource` to a gcp_compute_address",
            "                  task and then set this nat_ip field to \"{{ name-of-resource }}\"'",
            "                required: false",
            "                type: dict",
            "              type:",
            "                description:",
            "                - The type of configuration. The default and only option is ONE_TO_ONE_NAT.",
            "                - 'Some valid choices include: \"ONE_TO_ONE_NAT\"'",
            "                required: true",
            "                type: str",
            "          alias_ip_ranges:",
            "            description:",
            "            - An array of alias IP ranges for this network interface. Can only be",
            "              specified for network interfaces on subnet-mode networks.",
            "            required: false",
            "            type: list",
            "            suboptions:",
            "              ip_cidr_range:",
            "                description:",
            "                - The IP CIDR range represented by this alias IP range.",
            "                - This IP CIDR range must belong to the specified subnetwork and cannot",
            "                  contain IP addresses reserved by system or used by other network",
            "                  interfaces. This range may be a single IP address (e.g. 10.2.3.4),",
            "                  a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).",
            "                required: false",
            "                type: str",
            "              subnetwork_range_name:",
            "                description:",
            "                - Optional subnetwork secondary range name specifying the secondary",
            "                  range from which to allocate the IP CIDR range for this alias IP",
            "                  range. If left unspecified, the primary range of the subnetwork",
            "                  will be used.",
            "                required: false",
            "                type: str",
            "          network:",
            "            description:",
            "            - Specifies the title of an existing network. When creating an instance,",
            "              if neither the network nor the subnetwork is specified, the default",
            "              network global/networks/default is used; if the network is not specified",
            "              but the subnetwork is specified, the network is inferred.",
            "            - 'This field represents a link to a Network resource in GCP. It can be",
            "              specified in two ways. First, you can place a dictionary with key ''selfLink''",
            "              and value of your resource''s selfLink Alternatively, you can add `register:",
            "              name-of-resource` to a gcp_compute_network task and then set this network",
            "              field to \"{{ name-of-resource }}\"'",
            "            required: false",
            "            type: dict",
            "          network_ip:",
            "            description:",
            "            - An IPv4 internal network address to assign to the instance for this",
            "              network interface. If not specified by the user, an unused internal",
            "              IP is assigned by the system.",
            "            required: false",
            "            type: str",
            "          subnetwork:",
            "            description:",
            "            - Reference to a VPC network.",
            "            - If the network resource is in legacy mode, do not provide this property.",
            "              If the network is in auto subnet mode, providing the subnetwork is optional.",
            "              If the network is in custom subnet mode, then this field should be specified.",
            "            - 'This field represents a link to a Subnetwork resource in GCP. It can",
            "              be specified in two ways. First, you can place a dictionary with key",
            "              ''selfLink'' and value of your resource''s selfLink Alternatively, you",
            "              can add `register: name-of-resource` to a gcp_compute_subnetwork task",
            "              and then set this subnetwork field to \"{{ name-of-resource }}\"'",
            "            required: false",
            "            type: dict",
            "      scheduling:",
            "        description:",
            "        - Sets the scheduling options for this instance.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          automatic_restart:",
            "            description:",
            "            - Specifies whether the instance should be automatically restarted if",
            "              it is terminated by Compute Engine (not terminated by a user).",
            "            - You can only set the automatic restart option for standard instances.",
            "              Preemptible instances cannot be automatically restarted.",
            "            required: false",
            "            type: bool",
            "          on_host_maintenance:",
            "            description:",
            "            - Defines the maintenance behavior for this instance. For standard instances,",
            "              the default behavior is MIGRATE. For preemptible instances, the default",
            "              and only possible behavior is TERMINATE.",
            "            - For more information, see Setting Instance Scheduling Options.",
            "            required: false",
            "            type: str",
            "          preemptible:",
            "            description:",
            "            - Defines whether the instance is preemptible. This can only be set during",
            "              instance creation, it cannot be set or changed after the instance has",
            "              been created.",
            "            required: false",
            "            type: bool",
            "      service_accounts:",
            "        description:",
            "        - A list of service accounts, with their specified scopes, authorized for",
            "          this instance. Only one service account per VM instance is supported.",
            "        required: false",
            "        type: list",
            "        suboptions:",
            "          email:",
            "            description:",
            "            - Email address of the service account.",
            "            required: false",
            "            type: str",
            "          scopes:",
            "            description:",
            "            - The list of scopes to be made available for this service account.",
            "            required: false",
            "            type: list",
            "      tags:",
            "        description:",
            "        - A list of tags to apply to this instance. Tags are used to identify valid",
            "          sources or targets for network firewalls and are specified by the client",
            "          during instance creation. The tags can be later modified by the setTags",
            "          method. Each tag within the list must comply with RFC1035.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          fingerprint:",
            "            description:",
            "            - Specifies a fingerprint for this request, which is essentially a hash",
            "              of the metadata's contents and used for optimistic locking.",
            "            - The fingerprint is initially generated by Compute Engine and changes",
            "              after every request to modify or update metadata. You must always provide",
            "              an up-to-date fingerprint hash in order to update or change metadata.",
            "            required: false",
            "            type: str",
            "          items:",
            "            description:",
            "            - An array of tags. Each tag must be 1-63 characters long, and comply",
            "              with RFC1035.",
            "            required: false",
            "            type: list",
            "extends_documentation_fragment: gcp",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a network",
            "  gcp_compute_network:",
            "    name: network-instancetemplate",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: network",
            "",
            "- name: create a address",
            "  gcp_compute_address:",
            "    name: address-instancetemplate",
            "    region: us-west1",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: address",
            "",
            "- name: create a instance template",
            "  gcp_compute_instance_template:",
            "    name: test_object",
            "    properties:",
            "      disks:",
            "      - auto_delete: 'true'",
            "        boot: 'true'",
            "        initialize_params:",
            "          source_image: projects/ubuntu-os-cloud/global/images/family/ubuntu-1604-lts",
            "      machine_type: n1-standard-1",
            "      network_interfaces:",
            "      - network: \"{{ network }}\"",
            "        access_configs:",
            "        - name: test-config",
            "          type: ONE_TO_ONE_NAT",
            "          nat_ip: \"{{ address }}\"",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource. Provide this property when you create",
            "    the resource.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource. This identifier is defined by the server.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the resource. The name is 1-63 characters long and complies with RFC1035.",
            "  returned: success",
            "  type: str",
            "properties:",
            "  description:",
            "  - The instance properties for this instance template.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    canIpForward:",
            "      description:",
            "      - Enables instances created based on this template to send packets with source",
            "        IP addresses other than their own and receive packets with destination IP",
            "        addresses other than their own. If these instances will be used as an IP gateway",
            "        or it will be set as the next-hop in a Route resource, specify true. If unsure,",
            "        leave this set to false.",
            "      returned: success",
            "      type: bool",
            "    description:",
            "      description:",
            "      - An optional text description for the instances that are created from this",
            "        instance template.",
            "      returned: success",
            "      type: str",
            "    disks:",
            "      description:",
            "      - An array of disks that are associated with the instances that are created",
            "        from this template.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        autoDelete:",
            "          description:",
            "          - Specifies whether the disk will be auto-deleted when the instance is deleted",
            "            (but not when the disk is detached from the instance).",
            "          - 'Tip: Disks should be set to autoDelete=true so that leftover disks are",
            "            not left behind on machine deletion.'",
            "          returned: success",
            "          type: bool",
            "        boot:",
            "          description:",
            "          - Indicates that this is a boot disk. The virtual machine will use the first",
            "            partition of the disk for its root filesystem.",
            "          returned: success",
            "          type: bool",
            "        deviceName:",
            "          description:",
            "          - Specifies a unique device name of your choice that is reflected into the",
            "            /dev/disk/by-id/google-* tree of a Linux operating system running within",
            "            the instance. This name can be used to reference the device for mounting,",
            "            resizing, and so on, from within the instance.",
            "          returned: success",
            "          type: str",
            "        diskEncryptionKey:",
            "          description:",
            "          - Encrypts or decrypts a disk using a customer-supplied encryption key.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            rawKey:",
            "              description:",
            "              - Specifies a 256-bit customer-supplied encryption key, encoded in RFC",
            "                4648 base64 to either encrypt or decrypt this resource.",
            "              returned: success",
            "              type: str",
            "            rsaEncryptedKey:",
            "              description:",
            "              - Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied",
            "                encryption key to either encrypt or decrypt this resource.",
            "              returned: success",
            "              type: str",
            "            sha256:",
            "              description:",
            "              - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied",
            "                encryption key that protects this resource.",
            "              returned: success",
            "              type: str",
            "        index:",
            "          description:",
            "          - Assigns a zero-based index to this disk, where 0 is reserved for the boot",
            "            disk. For example, if you have many disks attached to an instance, each",
            "            disk would have a unique index number. If not specified, the server will",
            "            choose an appropriate value.",
            "          returned: success",
            "          type: int",
            "        initializeParams:",
            "          description:",
            "          - Specifies the parameters for a new disk that will be created alongside",
            "            the new instance. Use initialization parameters to create boot disks or",
            "            local SSDs attached to the new instance.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            diskName:",
            "              description:",
            "              - Specifies the disk name. If not specified, the default is to use the",
            "                name of the instance.",
            "              returned: success",
            "              type: str",
            "            diskSizeGb:",
            "              description:",
            "              - Specifies the size of the disk in base-2 GB.",
            "              returned: success",
            "              type: int",
            "            diskType:",
            "              description:",
            "              - Reference to a disk type.",
            "              - Specifies the disk type to use to create the instance.",
            "              - If not specified, the default is pd-standard.",
            "              returned: success",
            "              type: str",
            "            sourceImage:",
            "              description:",
            "              - The source image to create this disk. When creating a new instance,",
            "                one of initializeParams.sourceImage or disks.source is required. To",
            "                create a disk with one of the public operating system images, specify",
            "                the image by its family name.",
            "              returned: success",
            "              type: str",
            "            sourceImageEncryptionKey:",
            "              description:",
            "              - The customer-supplied encryption key of the source image. Required",
            "                if the source image is protected by a customer-supplied encryption",
            "                key.",
            "              - Instance templates do not store customer-supplied encryption keys,",
            "                so you cannot create disks for instances in a managed instance group",
            "                if the source images are encrypted with your own keys.",
            "              returned: success",
            "              type: complex",
            "              contains:",
            "                rawKey:",
            "                  description:",
            "                  - Specifies a 256-bit customer-supplied encryption key, encoded",
            "                    in RFC 4648 base64 to either encrypt or decrypt this resource.",
            "                  returned: success",
            "                  type: str",
            "                sha256:",
            "                  description:",
            "                  - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied",
            "                    encryption key that protects this resource.",
            "                  returned: success",
            "                  type: str",
            "        interface:",
            "          description:",
            "          - Specifies the disk interface to use for attaching this disk, which is",
            "            either SCSI or NVME. The default is SCSI.",
            "          - Persistent disks must always use SCSI and the request will fail if you",
            "            attempt to attach a persistent disk in any other format than SCSI.",
            "          returned: success",
            "          type: str",
            "        mode:",
            "          description:",
            "          - The mode in which to attach this disk, either READ_WRITE or READ_ONLY.",
            "            If not specified, the default is to attach the disk in READ_WRITE mode.",
            "          returned: success",
            "          type: str",
            "        source:",
            "          description:",
            "          - Reference to a disk. When creating a new instance, one of initializeParams.sourceImage",
            "            or disks.source is required.",
            "          - If desired, you can also attach existing non-root persistent disks using",
            "            this property. This field is only applicable for persistent disks.",
            "          - Note that for InstanceTemplate, specify the disk name, not the URL for",
            "            the disk.",
            "          returned: success",
            "          type: dict",
            "        type:",
            "          description:",
            "          - Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified,",
            "            the default is PERSISTENT.",
            "          returned: success",
            "          type: str",
            "    labels:",
            "      description:",
            "      - Labels to apply to this address. A list of key->value pairs.",
            "      returned: success",
            "      type: dict",
            "    machineType:",
            "      description:",
            "      - The machine type to use in the VM instance template.",
            "      returned: success",
            "      type: str",
            "    minCpuPlatform:",
            "      description:",
            "      - Specifies a minimum CPU platform for the VM instance. Applicable values are",
            "        the friendly names of CPU platforms .",
            "      returned: success",
            "      type: str",
            "    metadata:",
            "      description:",
            "      - The metadata key/value pairs to assign to instances that are created from",
            "        this template. These pairs can consist of custom metadata or predefined keys.",
            "      returned: success",
            "      type: dict",
            "    guestAccelerators:",
            "      description:",
            "      - List of the type and count of accelerator cards attached to the instance .",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        acceleratorCount:",
            "          description:",
            "          - The number of the guest accelerator cards exposed to this instance.",
            "          returned: success",
            "          type: int",
            "        acceleratorType:",
            "          description:",
            "          - Full or partial URL of the accelerator type resource to expose to this",
            "            instance.",
            "          returned: success",
            "          type: str",
            "    networkInterfaces:",
            "      description:",
            "      - An array of configurations for this interface. This specifies how this interface",
            "        is configured to interact with other network services, such as connecting",
            "        to the internet. Only one network interface is supported per instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        accessConfigs:",
            "          description:",
            "          - An array of configurations for this interface. Currently, only one access",
            "            config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs specified,",
            "            then this instance will have no external internet access.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            name:",
            "              description:",
            "              - The name of this access configuration. The default and recommended",
            "                name is External NAT but you can use any arbitrary string you would",
            "                like. For example, My external IP or Network Access.",
            "              returned: success",
            "              type: str",
            "            natIP:",
            "              description:",
            "              - Reference to an address.",
            "              - An external IP address associated with this instance.",
            "              - Specify an unused static external IP address available to the project",
            "                or leave this field undefined to use an IP from a shared ephemeral",
            "                IP address pool. If you specify a static external IP address, it must",
            "                live in the same region as the zone of the instance.",
            "              returned: success",
            "              type: dict",
            "            type:",
            "              description:",
            "              - The type of configuration. The default and only option is ONE_TO_ONE_NAT.",
            "              returned: success",
            "              type: str",
            "        aliasIpRanges:",
            "          description:",
            "          - An array of alias IP ranges for this network interface. Can only be specified",
            "            for network interfaces on subnet-mode networks.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            ipCidrRange:",
            "              description:",
            "              - The IP CIDR range represented by this alias IP range.",
            "              - This IP CIDR range must belong to the specified subnetwork and cannot",
            "                contain IP addresses reserved by system or used by other network interfaces.",
            "                This range may be a single IP address (e.g. 10.2.3.4), a netmask (e.g.",
            "                /24) or a CIDR format string (e.g. 10.1.2.0/24).",
            "              returned: success",
            "              type: str",
            "            subnetworkRangeName:",
            "              description:",
            "              - Optional subnetwork secondary range name specifying the secondary",
            "                range from which to allocate the IP CIDR range for this alias IP range.",
            "                If left unspecified, the primary range of the subnetwork will be used.",
            "              returned: success",
            "              type: str",
            "        name:",
            "          description:",
            "          - The name of the network interface, generated by the server. For network",
            "            devices, these are eth0, eth1, etc .",
            "          returned: success",
            "          type: str",
            "        network:",
            "          description:",
            "          - Specifies the title of an existing network. When creating an instance,",
            "            if neither the network nor the subnetwork is specified, the default network",
            "            global/networks/default is used; if the network is not specified but the",
            "            subnetwork is specified, the network is inferred.",
            "          returned: success",
            "          type: dict",
            "        networkIP:",
            "          description:",
            "          - An IPv4 internal network address to assign to the instance for this network",
            "            interface. If not specified by the user, an unused internal IP is assigned",
            "            by the system.",
            "          returned: success",
            "          type: str",
            "        subnetwork:",
            "          description:",
            "          - Reference to a VPC network.",
            "          - If the network resource is in legacy mode, do not provide this property.",
            "            If the network is in auto subnet mode, providing the subnetwork is optional.",
            "            If the network is in custom subnet mode, then this field should be specified.",
            "          returned: success",
            "          type: dict",
            "    scheduling:",
            "      description:",
            "      - Sets the scheduling options for this instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        automaticRestart:",
            "          description:",
            "          - Specifies whether the instance should be automatically restarted if it",
            "            is terminated by Compute Engine (not terminated by a user).",
            "          - You can only set the automatic restart option for standard instances.",
            "            Preemptible instances cannot be automatically restarted.",
            "          returned: success",
            "          type: bool",
            "        onHostMaintenance:",
            "          description:",
            "          - Defines the maintenance behavior for this instance. For standard instances,",
            "            the default behavior is MIGRATE. For preemptible instances, the default",
            "            and only possible behavior is TERMINATE.",
            "          - For more information, see Setting Instance Scheduling Options.",
            "          returned: success",
            "          type: str",
            "        preemptible:",
            "          description:",
            "          - Defines whether the instance is preemptible. This can only be set during",
            "            instance creation, it cannot be set or changed after the instance has",
            "            been created.",
            "          returned: success",
            "          type: bool",
            "    serviceAccounts:",
            "      description:",
            "      - A list of service accounts, with their specified scopes, authorized for this",
            "        instance. Only one service account per VM instance is supported.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        email:",
            "          description:",
            "          - Email address of the service account.",
            "          returned: success",
            "          type: str",
            "        scopes:",
            "          description:",
            "          - The list of scopes to be made available for this service account.",
            "          returned: success",
            "          type: list",
            "    tags:",
            "      description:",
            "      - A list of tags to apply to this instance. Tags are used to identify valid",
            "        sources or targets for network firewalls and are specified by the client during",
            "        instance creation. The tags can be later modified by the setTags method. Each",
            "        tag within the list must comply with RFC1035.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        fingerprint:",
            "          description:",
            "          - Specifies a fingerprint for this request, which is essentially a hash",
            "            of the metadata's contents and used for optimistic locking.",
            "          - The fingerprint is initially generated by Compute Engine and changes after",
            "            every request to modify or update metadata. You must always provide an",
            "            up-to-date fingerprint hash in order to update or change metadata.",
            "          returned: success",
            "          type: str",
            "        items:",
            "          description:",
            "          - An array of tags. Each tag must be 1-63 characters long, and comply with",
            "            RFC1035.",
            "          returned: success",
            "          type: list",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            description=dict(type='str'),",
            "            name=dict(required=True, type='str'),",
            "            properties=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    can_ip_forward=dict(type='bool'),",
            "                    description=dict(type='str'),",
            "                    disks=dict(",
            "                        type='list',",
            "                        elements='dict',",
            "                        options=dict(",
            "                            auto_delete=dict(type='bool'),",
            "                            boot=dict(type='bool'),",
            "                            device_name=dict(type='str'),",
            "                            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), rsa_encrypted_key=dict(type='str'))),",
            "                            index=dict(type='int'),",
            "                            initialize_params=dict(",
            "                                type='dict',",
            "                                options=dict(",
            "                                    disk_name=dict(type='str'),",
            "                                    disk_size_gb=dict(type='int'),",
            "                                    disk_type=dict(type='str'),",
            "                                    source_image=dict(type='str'),",
            "                                    source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),",
            "                                ),",
            "                            ),",
            "                            interface=dict(type='str'),",
            "                            mode=dict(type='str'),",
            "                            source=dict(type='dict'),",
            "                            type=dict(type='str'),",
            "                        ),",
            "                    ),",
            "                    labels=dict(type='dict'),",
            "                    machine_type=dict(required=True, type='str'),",
            "                    min_cpu_platform=dict(type='str'),",
            "                    metadata=dict(type='dict'),",
            "                    guest_accelerators=dict(type='list', elements='dict', options=dict(accelerator_count=dict(type='int'), accelerator_type=dict(type='str'))),",
            "                    network_interfaces=dict(",
            "                        type='list',",
            "                        elements='dict',",
            "                        options=dict(",
            "                            access_configs=dict(",
            "                                type='list',",
            "                                elements='dict',",
            "                                options=dict(name=dict(required=True, type='str'), nat_ip=dict(type='dict'), type=dict(required=True, type='str')),",
            "                            ),",
            "                            alias_ip_ranges=dict(",
            "                                type='list', elements='dict', options=dict(ip_cidr_range=dict(type='str'), subnetwork_range_name=dict(type='str'))",
            "                            ),",
            "                            network=dict(type='dict'),",
            "                            network_ip=dict(type='str'),",
            "                            subnetwork=dict(type='dict'),",
            "                        ),",
            "                    ),",
            "                    scheduling=dict(",
            "                        type='dict', options=dict(automatic_restart=dict(type='bool'), on_host_maintenance=dict(type='str'), preemptible=dict(type='bool'))",
            "                    ),",
            "                    service_accounts=dict(type='list', elements='dict', options=dict(email=dict(type='str'), scopes=dict(type='list', elements='str'))),",
            "                    tags=dict(type='dict', options=dict(fingerprint=dict(type='str'), items=dict(type='list', elements='str'))),",
            "                ),",
            "            ),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#instanceTemplate'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind):",
            "    delete(module, self_link(module), kind)",
            "    create(module, collection(module), kind)",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#instanceTemplate',",
            "        u'description': module.params.get('description'),",
            "        u'name': module.params.get('name'),",
            "        u'properties': InstanceTemplateProperties(module.params.get('properties', {}), module).to_request(),",
            "    }",
            "    request = encode_request(request, module)",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/instanceTemplates/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/instanceTemplates\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    result = decode_response(result, module)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "    request = decode_response(request, module)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'description': response.get(u'description'),",
            "        u'id': response.get(u'id'),",
            "        u'name': response.get(u'name'),",
            "        u'properties': InstanceTemplateProperties(response.get(u'properties', {}), module).from_response(),",
            "    }",
            "",
            "",
            "def disk_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/.*/diskTypes/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/diskTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    response = fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#instanceTemplate')",
            "    if response:",
            "        return decode_response(response, module)",
            "    else:",
            "        return {}",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "def encode_request(request, module):",
            "    if 'properties' in request and request['properties'] is not None and 'metadata' in request['properties'] and request['properties']['metadata'] is not None:",
            "        request['properties']['metadata'] = metadata_encoder(request['properties']['metadata'])",
            "    return request",
            "",
            "",
            "def decode_response(response, module):",
            "    if (",
            "        'properties' in response",
            "        and response['properties'] is not None",
            "        and 'metadata' in response['properties']",
            "        and response['properties']['metadata'] is not None",
            "    ):",
            "        response['properties']['metadata'] = metadata_decoder(response['properties']['metadata'])",
            "    return response",
            "",
            "",
            "# TODO(alexstephen): Implement updating metadata on existing resources.",
            "",
            "# Expose instance 'metadata' as a simple name/value pair hash. However the API",
            "# defines metadata as a NestedObject with the following layout:",
            "#",
            "# metadata {",
            "#   fingerprint: 'hash-of-last-metadata'",
            "#   items: [",
            "#     {",
            "#       key: 'metadata1-key'",
            "#       value: 'metadata1-value'",
            "#     },",
            "#     ...",
            "#   ]",
            "# }",
            "#",
            "def metadata_encoder(metadata):",
            "    metadata_new = []",
            "    for key in metadata:",
            "        value = metadata[key]",
            "        metadata_new.append({\"key\": key, \"value\": value})",
            "    return {'items': metadata_new}",
            "",
            "",
            "# Map metadata.items[]{key:,value:} => metadata[key]=value",
            "def metadata_decoder(metadata):",
            "    items = {}",
            "    if 'items' in metadata:",
            "        metadata_items = metadata['items']",
            "        for item in metadata_items:",
            "            items[item['key']] = item['value']",
            "    return items",
            "",
            "",
            "class InstanceTemplateProperties(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'canIpForward': self.request.get('can_ip_forward'),",
            "                u'description': self.request.get('description'),",
            "                u'disks': InstanceTemplateDisksArray(self.request.get('disks', []), self.module).to_request(),",
            "                u'labels': self.request.get('labels'),",
            "                u'machineType': self.request.get('machine_type'),",
            "                u'minCpuPlatform': self.request.get('min_cpu_platform'),",
            "                u'metadata': self.request.get('metadata'),",
            "                u'guestAccelerators': InstanceTemplateGuestacceleratorsArray(self.request.get('guest_accelerators', []), self.module).to_request(),",
            "                u'networkInterfaces': InstanceTemplateNetworkinterfacesArray(self.request.get('network_interfaces', []), self.module).to_request(),",
            "                u'scheduling': InstanceTemplateScheduling(self.request.get('scheduling', {}), self.module).to_request(),",
            "                u'serviceAccounts': InstanceTemplateServiceaccountsArray(self.request.get('service_accounts', []), self.module).to_request(),",
            "                u'tags': InstanceTemplateTags(self.request.get('tags', {}), self.module).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'canIpForward': self.request.get(u'canIpForward'),",
            "                u'description': self.request.get(u'description'),",
            "                u'disks': InstanceTemplateDisksArray(self.request.get(u'disks', []), self.module).from_response(),",
            "                u'labels': self.request.get(u'labels'),",
            "                u'machineType': self.request.get(u'machineType'),",
            "                u'minCpuPlatform': self.request.get(u'minCpuPlatform'),",
            "                u'metadata': self.request.get(u'metadata'),",
            "                u'guestAccelerators': InstanceTemplateGuestacceleratorsArray(self.request.get(u'guestAccelerators', []), self.module).from_response(),",
            "                u'networkInterfaces': InstanceTemplateNetworkinterfacesArray(self.request.get(u'networkInterfaces', []), self.module).from_response(),",
            "                u'scheduling': InstanceTemplateScheduling(self.request.get(u'scheduling', {}), self.module).from_response(),",
            "                u'serviceAccounts': InstanceTemplateServiceaccountsArray(self.request.get(u'serviceAccounts', []), self.module).from_response(),",
            "                u'tags': InstanceTemplateTags(self.request.get(u'tags', {}), self.module).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateDisksArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'autoDelete': item.get('auto_delete'),",
            "                u'boot': item.get('boot'),",
            "                u'deviceName': item.get('device_name'),",
            "                u'diskEncryptionKey': InstanceTemplateDiskencryptionkey(item.get('disk_encryption_key', {}), self.module).to_request(),",
            "                u'index': item.get('index'),",
            "                u'initializeParams': InstanceTemplateInitializeparams(item.get('initialize_params', {}), self.module).to_request(),",
            "                u'interface': item.get('interface'),",
            "                u'mode': item.get('mode'),",
            "                u'source': replace_resource_dict(item.get(u'source', {}), 'name'),",
            "                u'type': item.get('type'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'autoDelete': item.get(u'autoDelete'),",
            "                u'boot': item.get(u'boot'),",
            "                u'deviceName': item.get(u'deviceName'),",
            "                u'diskEncryptionKey': InstanceTemplateDiskencryptionkey(item.get(u'diskEncryptionKey', {}), self.module).from_response(),",
            "                u'index': item.get(u'index'),",
            "                u'initializeParams': InstanceTemplateInitializeparams(self.module.params.get('initialize_params', {}), self.module).to_request(),",
            "                u'interface': item.get(u'interface'),",
            "                u'mode': item.get(u'mode'),",
            "                u'source': item.get(u'source'),",
            "                u'type': item.get(u'type'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateDiskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'rsaEncryptedKey': self.request.get('rsa_encrypted_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'rsaEncryptedKey': self.request.get(u'rsaEncryptedKey')})",
            "",
            "",
            "class InstanceTemplateInitializeparams(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'diskName': self.request.get('disk_name'),",
            "                u'diskSizeGb': self.request.get('disk_size_gb'),",
            "                u'diskType': disk_type_selflink(self.request.get('disk_type'), self.module.params),",
            "                u'sourceImage': self.request.get('source_image'),",
            "                u'sourceImageEncryptionKey': InstanceTemplateSourceimageencryptionkey(",
            "                    self.request.get('source_image_encryption_key', {}), self.module",
            "                ).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'diskName': self.request.get(u'diskName'),",
            "                u'diskSizeGb': self.request.get(u'diskSizeGb'),",
            "                u'diskType': self.request.get(u'diskType'),",
            "                u'sourceImage': self.request.get(u'sourceImage'),",
            "                u'sourceImageEncryptionKey': InstanceTemplateSourceimageencryptionkey(",
            "                    self.request.get(u'sourceImageEncryptionKey', {}), self.module",
            "                ).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateSourceimageencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "class InstanceTemplateGuestacceleratorsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'acceleratorCount': item.get('accelerator_count'), u'acceleratorType': item.get('accelerator_type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'acceleratorCount': item.get(u'acceleratorCount'), u'acceleratorType': item.get(u'acceleratorType')})",
            "",
            "",
            "class InstanceTemplateNetworkinterfacesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'accessConfigs': InstanceTemplateAccessconfigsArray(item.get('access_configs', []), self.module).to_request(),",
            "                u'aliasIpRanges': InstanceTemplateAliasiprangesArray(item.get('alias_ip_ranges', []), self.module).to_request(),",
            "                u'network': replace_resource_dict(item.get(u'network', {}), 'selfLink'),",
            "                u'networkIP': item.get('network_ip'),",
            "                u'subnetwork': replace_resource_dict(item.get(u'subnetwork', {}), 'selfLink'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'accessConfigs': InstanceTemplateAccessconfigsArray(item.get(u'accessConfigs', []), self.module).from_response(),",
            "                u'aliasIpRanges': InstanceTemplateAliasiprangesArray(item.get(u'aliasIpRanges', []), self.module).from_response(),",
            "                u'network': item.get(u'network'),",
            "                u'networkIP': item.get(u'networkIP'),",
            "                u'subnetwork': item.get(u'subnetwork'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateAccessconfigsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {u'name': item.get('name'), u'natIP': replace_resource_dict(item.get(u'nat_ip', {}), 'address'), u'type': item.get('type')}",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'name': item.get(u'name'), u'natIP': item.get(u'natIP'), u'type': item.get(u'type')})",
            "",
            "",
            "class InstanceTemplateAliasiprangesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'ipCidrRange': item.get('ip_cidr_range'), u'subnetworkRangeName': item.get('subnetwork_range_name')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'ipCidrRange': item.get(u'ipCidrRange'), u'subnetworkRangeName': item.get(u'subnetworkRangeName')})",
            "",
            "",
            "class InstanceTemplateScheduling(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'automaticRestart': self.request.get('automatic_restart'),",
            "                u'onHostMaintenance': self.request.get('on_host_maintenance'),",
            "                u'preemptible': self.request.get('preemptible'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'automaticRestart': self.request.get(u'automaticRestart'),",
            "                u'onHostMaintenance': self.request.get(u'onHostMaintenance'),",
            "                u'preemptible': self.request.get(u'preemptible'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateServiceaccountsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'email': item.get('email'), u'scopes': item.get('scopes')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'email': item.get(u'email'), u'scopes': item.get(u'scopes')})",
            "",
            "",
            "class InstanceTemplateTags(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'fingerprint': self.request.get('fingerprint'), u'items': self.request.get('items')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'fingerprint': self.request.get(u'fingerprint'), u'items': self.request.get(u'items')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_instance_template",
            "description:",
            "- Defines an Instance Template resource that provides configuration settings for your",
            "  virtual machine instances. Instance templates are not tied to the lifetime of an",
            "  instance and can be used and reused as to deploy virtual machines. You can also",
            "  use different templates to create different virtual machine configurations. Instance",
            "  templates are required when you create a managed instance group.",
            "- 'Tip: Disks should be set to autoDelete=true so that leftover disks are not left",
            "  behind on machine deletion.'",
            "short_description: Creates a GCP InstanceTemplate",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource. Provide this property when you create",
            "      the resource.",
            "    required: false",
            "    type: str",
            "  name:",
            "    description:",
            "    - Name of the resource. The name is 1-63 characters long and complies with RFC1035.",
            "    required: true",
            "    type: str",
            "  properties:",
            "    description:",
            "    - The instance properties for this instance template.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      can_ip_forward:",
            "        description:",
            "        - Enables instances created based on this template to send packets with source",
            "          IP addresses other than their own and receive packets with destination IP",
            "          addresses other than their own. If these instances will be used as an IP",
            "          gateway or it will be set as the next-hop in a Route resource, specify true.",
            "          If unsure, leave this set to false.",
            "        required: false",
            "        type: bool",
            "      description:",
            "        description:",
            "        - An optional text description for the instances that are created from this",
            "          instance template.",
            "        required: false",
            "        type: str",
            "      disks:",
            "        description:",
            "        - An array of disks that are associated with the instances that are created",
            "          from this template.",
            "        required: false",
            "        type: list",
            "        suboptions:",
            "          auto_delete:",
            "            description:",
            "            - Specifies whether the disk will be auto-deleted when the instance is",
            "              deleted (but not when the disk is detached from the instance).",
            "            - 'Tip: Disks should be set to autoDelete=true so that leftover disks",
            "              are not left behind on machine deletion.'",
            "            required: false",
            "            type: bool",
            "          boot:",
            "            description:",
            "            - Indicates that this is a boot disk. The virtual machine will use the",
            "              first partition of the disk for its root filesystem.",
            "            required: false",
            "            type: bool",
            "          device_name:",
            "            description:",
            "            - Specifies a unique device name of your choice that is reflected into",
            "              the /dev/disk/by-id/google-* tree of a Linux operating system running",
            "              within the instance. This name can be used to reference the device for",
            "              mounting, resizing, and so on, from within the instance.",
            "            required: false",
            "            type: str",
            "          disk_encryption_key:",
            "            description:",
            "            - Encrypts or decrypts a disk using a customer-supplied encryption key.",
            "            required: false",
            "            type: dict",
            "            suboptions:",
            "              raw_key:",
            "                description:",
            "                - Specifies a 256-bit customer-supplied encryption key, encoded in",
            "                  RFC 4648 base64 to either encrypt or decrypt this resource.",
            "                required: false",
            "                type: str",
            "              rsa_encrypted_key:",
            "                description:",
            "                - Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied",
            "                  encryption key to either encrypt or decrypt this resource.",
            "                required: false",
            "                type: str",
            "          index:",
            "            description:",
            "            - Assigns a zero-based index to this disk, where 0 is reserved for the",
            "              boot disk. For example, if you have many disks attached to an instance,",
            "              each disk would have a unique index number. If not specified, the server",
            "              will choose an appropriate value.",
            "            required: false",
            "            type: int",
            "          initialize_params:",
            "            description:",
            "            - Specifies the parameters for a new disk that will be created alongside",
            "              the new instance. Use initialization parameters to create boot disks",
            "              or local SSDs attached to the new instance.",
            "            required: false",
            "            type: dict",
            "            suboptions:",
            "              disk_name:",
            "                description:",
            "                - Specifies the disk name. If not specified, the default is to use",
            "                  the name of the instance.",
            "                required: false",
            "                type: str",
            "              disk_size_gb:",
            "                description:",
            "                - Specifies the size of the disk in base-2 GB.",
            "                required: false",
            "                type: int",
            "              disk_type:",
            "                description:",
            "                - Reference to a disk type.",
            "                - Specifies the disk type to use to create the instance.",
            "                - If not specified, the default is pd-standard.",
            "                required: false",
            "                type: str",
            "              source_image:",
            "                description:",
            "                - The source image to create this disk. When creating a new instance,",
            "                  one of initializeParams.sourceImage or disks.source is required.",
            "                  To create a disk with one of the public operating system images,",
            "                  specify the image by its family name.",
            "                required: false",
            "                type: str",
            "              source_image_encryption_key:",
            "                description:",
            "                - The customer-supplied encryption key of the source image. Required",
            "                  if the source image is protected by a customer-supplied encryption",
            "                  key.",
            "                - Instance templates do not store customer-supplied encryption keys,",
            "                  so you cannot create disks for instances in a managed instance group",
            "                  if the source images are encrypted with your own keys.",
            "                required: false",
            "                type: dict",
            "                suboptions:",
            "                  raw_key:",
            "                    description:",
            "                    - Specifies a 256-bit customer-supplied encryption key, encoded",
            "                      in RFC 4648 base64 to either encrypt or decrypt this resource.",
            "                    required: false",
            "                    type: str",
            "          interface:",
            "            description:",
            "            - Specifies the disk interface to use for attaching this disk, which is",
            "              either SCSI or NVME. The default is SCSI.",
            "            - Persistent disks must always use SCSI and the request will fail if you",
            "              attempt to attach a persistent disk in any other format than SCSI.",
            "            - 'Some valid choices include: \"SCSI\", \"NVME\"'",
            "            required: false",
            "            type: str",
            "          mode:",
            "            description:",
            "            - The mode in which to attach this disk, either READ_WRITE or READ_ONLY.",
            "              If not specified, the default is to attach the disk in READ_WRITE mode.",
            "            - 'Some valid choices include: \"READ_WRITE\", \"READ_ONLY\"'",
            "            required: false",
            "            type: str",
            "          source:",
            "            description:",
            "            - Reference to a disk. When creating a new instance, one of initializeParams.sourceImage",
            "              or disks.source is required.",
            "            - If desired, you can also attach existing non-root persistent disks using",
            "              this property. This field is only applicable for persistent disks.",
            "            - Note that for InstanceTemplate, specify the disk name, not the URL for",
            "              the disk.",
            "            - 'This field represents a link to a Disk resource in GCP. It can be specified",
            "              in two ways. First, you can place a dictionary with key ''name'' and",
            "              value of your resource''s name Alternatively, you can add `register:",
            "              name-of-resource` to a gcp_compute_disk task and then set this source",
            "              field to \"{{ name-of-resource }}\"'",
            "            required: false",
            "            type: dict",
            "          type:",
            "            description:",
            "            - Specifies the type of the disk, either SCRATCH or PERSISTENT. If not",
            "              specified, the default is PERSISTENT.",
            "            - 'Some valid choices include: \"SCRATCH\", \"PERSISTENT\"'",
            "            required: false",
            "            type: str",
            "      labels:",
            "        description:",
            "        - Labels to apply to this address. A list of key->value pairs.",
            "        required: false",
            "        type: dict",
            "        version_added: 2.9",
            "      machine_type:",
            "        description:",
            "        - The machine type to use in the VM instance template.",
            "        required: true",
            "        type: str",
            "      min_cpu_platform:",
            "        description:",
            "        - Specifies a minimum CPU platform for the VM instance. Applicable values",
            "          are the friendly names of CPU platforms .",
            "        required: false",
            "        type: str",
            "      metadata:",
            "        description:",
            "        - The metadata key/value pairs to assign to instances that are created from",
            "          this template. These pairs can consist of custom metadata or predefined",
            "          keys.",
            "        required: false",
            "        type: dict",
            "      guest_accelerators:",
            "        description:",
            "        - List of the type and count of accelerator cards attached to the instance",
            "          .",
            "        required: false",
            "        type: list",
            "        suboptions:",
            "          accelerator_count:",
            "            description:",
            "            - The number of the guest accelerator cards exposed to this instance.",
            "            required: false",
            "            type: int",
            "          accelerator_type:",
            "            description:",
            "            - Full or partial URL of the accelerator type resource to expose to this",
            "              instance.",
            "            required: false",
            "            type: str",
            "      network_interfaces:",
            "        description:",
            "        - An array of configurations for this interface. This specifies how this interface",
            "          is configured to interact with other network services, such as connecting",
            "          to the internet. Only one network interface is supported per instance.",
            "        required: false",
            "        type: list",
            "        suboptions:",
            "          access_configs:",
            "            description:",
            "            - An array of configurations for this interface. Currently, only one access",
            "              config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs",
            "              specified, then this instance will have no external internet access.",
            "            required: false",
            "            type: list",
            "            suboptions:",
            "              name:",
            "                description:",
            "                - The name of this access configuration. The default and recommended",
            "                  name is External NAT but you can use any arbitrary string you would",
            "                  like. For example, My external IP or Network Access.",
            "                required: true",
            "                type: str",
            "              nat_ip:",
            "                description:",
            "                - Reference to an address.",
            "                - An external IP address associated with this instance.",
            "                - Specify an unused static external IP address available to the project",
            "                  or leave this field undefined to use an IP from a shared ephemeral",
            "                  IP address pool. If you specify a static external IP address, it",
            "                  must live in the same region as the zone of the instance.",
            "                - 'This field represents a link to a Address resource in GCP. It can",
            "                  be specified in two ways. First, you can place a dictionary with",
            "                  key ''address'' and value of your resource''s address Alternatively,",
            "                  you can add `register: name-of-resource` to a gcp_compute_address",
            "                  task and then set this nat_ip field to \"{{ name-of-resource }}\"'",
            "                required: false",
            "                type: dict",
            "              type:",
            "                description:",
            "                - The type of configuration. The default and only option is ONE_TO_ONE_NAT.",
            "                - 'Some valid choices include: \"ONE_TO_ONE_NAT\"'",
            "                required: true",
            "                type: str",
            "          alias_ip_ranges:",
            "            description:",
            "            - An array of alias IP ranges for this network interface. Can only be",
            "              specified for network interfaces on subnet-mode networks.",
            "            required: false",
            "            type: list",
            "            suboptions:",
            "              ip_cidr_range:",
            "                description:",
            "                - The IP CIDR range represented by this alias IP range.",
            "                - This IP CIDR range must belong to the specified subnetwork and cannot",
            "                  contain IP addresses reserved by system or used by other network",
            "                  interfaces. This range may be a single IP address (e.g. 10.2.3.4),",
            "                  a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).",
            "                required: false",
            "                type: str",
            "              subnetwork_range_name:",
            "                description:",
            "                - Optional subnetwork secondary range name specifying the secondary",
            "                  range from which to allocate the IP CIDR range for this alias IP",
            "                  range. If left unspecified, the primary range of the subnetwork",
            "                  will be used.",
            "                required: false",
            "                type: str",
            "          network:",
            "            description:",
            "            - Specifies the title of an existing network. When creating an instance,",
            "              if neither the network nor the subnetwork is specified, the default",
            "              network global/networks/default is used; if the network is not specified",
            "              but the subnetwork is specified, the network is inferred.",
            "            - 'This field represents a link to a Network resource in GCP. It can be",
            "              specified in two ways. First, you can place a dictionary with key ''selfLink''",
            "              and value of your resource''s selfLink Alternatively, you can add `register:",
            "              name-of-resource` to a gcp_compute_network task and then set this network",
            "              field to \"{{ name-of-resource }}\"'",
            "            required: false",
            "            type: dict",
            "          network_ip:",
            "            description:",
            "            - An IPv4 internal network address to assign to the instance for this",
            "              network interface. If not specified by the user, an unused internal",
            "              IP is assigned by the system.",
            "            required: false",
            "            type: str",
            "          subnetwork:",
            "            description:",
            "            - Reference to a VPC network.",
            "            - If the network resource is in legacy mode, do not provide this property.",
            "              If the network is in auto subnet mode, providing the subnetwork is optional.",
            "              If the network is in custom subnet mode, then this field should be specified.",
            "            - 'This field represents a link to a Subnetwork resource in GCP. It can",
            "              be specified in two ways. First, you can place a dictionary with key",
            "              ''selfLink'' and value of your resource''s selfLink Alternatively, you",
            "              can add `register: name-of-resource` to a gcp_compute_subnetwork task",
            "              and then set this subnetwork field to \"{{ name-of-resource }}\"'",
            "            required: false",
            "            type: dict",
            "      scheduling:",
            "        description:",
            "        - Sets the scheduling options for this instance.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          automatic_restart:",
            "            description:",
            "            - Specifies whether the instance should be automatically restarted if",
            "              it is terminated by Compute Engine (not terminated by a user).",
            "            - You can only set the automatic restart option for standard instances.",
            "              Preemptible instances cannot be automatically restarted.",
            "            required: false",
            "            type: bool",
            "          on_host_maintenance:",
            "            description:",
            "            - Defines the maintenance behavior for this instance. For standard instances,",
            "              the default behavior is MIGRATE. For preemptible instances, the default",
            "              and only possible behavior is TERMINATE.",
            "            - For more information, see Setting Instance Scheduling Options.",
            "            required: false",
            "            type: str",
            "          preemptible:",
            "            description:",
            "            - Defines whether the instance is preemptible. This can only be set during",
            "              instance creation, it cannot be set or changed after the instance has",
            "              been created.",
            "            required: false",
            "            type: bool",
            "      service_accounts:",
            "        description:",
            "        - A list of service accounts, with their specified scopes, authorized for",
            "          this instance. Only one service account per VM instance is supported.",
            "        required: false",
            "        type: list",
            "        suboptions:",
            "          email:",
            "            description:",
            "            - Email address of the service account.",
            "            required: false",
            "            type: str",
            "          scopes:",
            "            description:",
            "            - The list of scopes to be made available for this service account.",
            "            required: false",
            "            type: list",
            "      tags:",
            "        description:",
            "        - A list of tags to apply to this instance. Tags are used to identify valid",
            "          sources or targets for network firewalls and are specified by the client",
            "          during instance creation. The tags can be later modified by the setTags",
            "          method. Each tag within the list must comply with RFC1035.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          fingerprint:",
            "            description:",
            "            - Specifies a fingerprint for this request, which is essentially a hash",
            "              of the metadata's contents and used for optimistic locking.",
            "            - The fingerprint is initially generated by Compute Engine and changes",
            "              after every request to modify or update metadata. You must always provide",
            "              an up-to-date fingerprint hash in order to update or change metadata.",
            "            required: false",
            "            type: str",
            "          items:",
            "            description:",
            "            - An array of tags. Each tag must be 1-63 characters long, and comply",
            "              with RFC1035.",
            "            required: false",
            "            type: list",
            "extends_documentation_fragment: gcp",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a network",
            "  gcp_compute_network:",
            "    name: network-instancetemplate",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: network",
            "",
            "- name: create a address",
            "  gcp_compute_address:",
            "    name: address-instancetemplate",
            "    region: us-west1",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: address",
            "",
            "- name: create a instance template",
            "  gcp_compute_instance_template:",
            "    name: test_object",
            "    properties:",
            "      disks:",
            "      - auto_delete: 'true'",
            "        boot: 'true'",
            "        initialize_params:",
            "          source_image: projects/ubuntu-os-cloud/global/images/family/ubuntu-1604-lts",
            "      machine_type: n1-standard-1",
            "      network_interfaces:",
            "      - network: \"{{ network }}\"",
            "        access_configs:",
            "        - name: test-config",
            "          type: ONE_TO_ONE_NAT",
            "          nat_ip: \"{{ address }}\"",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource. Provide this property when you create",
            "    the resource.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource. This identifier is defined by the server.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the resource. The name is 1-63 characters long and complies with RFC1035.",
            "  returned: success",
            "  type: str",
            "properties:",
            "  description:",
            "  - The instance properties for this instance template.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    canIpForward:",
            "      description:",
            "      - Enables instances created based on this template to send packets with source",
            "        IP addresses other than their own and receive packets with destination IP",
            "        addresses other than their own. If these instances will be used as an IP gateway",
            "        or it will be set as the next-hop in a Route resource, specify true. If unsure,",
            "        leave this set to false.",
            "      returned: success",
            "      type: bool",
            "    description:",
            "      description:",
            "      - An optional text description for the instances that are created from this",
            "        instance template.",
            "      returned: success",
            "      type: str",
            "    disks:",
            "      description:",
            "      - An array of disks that are associated with the instances that are created",
            "        from this template.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        autoDelete:",
            "          description:",
            "          - Specifies whether the disk will be auto-deleted when the instance is deleted",
            "            (but not when the disk is detached from the instance).",
            "          - 'Tip: Disks should be set to autoDelete=true so that leftover disks are",
            "            not left behind on machine deletion.'",
            "          returned: success",
            "          type: bool",
            "        boot:",
            "          description:",
            "          - Indicates that this is a boot disk. The virtual machine will use the first",
            "            partition of the disk for its root filesystem.",
            "          returned: success",
            "          type: bool",
            "        deviceName:",
            "          description:",
            "          - Specifies a unique device name of your choice that is reflected into the",
            "            /dev/disk/by-id/google-* tree of a Linux operating system running within",
            "            the instance. This name can be used to reference the device for mounting,",
            "            resizing, and so on, from within the instance.",
            "          returned: success",
            "          type: str",
            "        diskEncryptionKey:",
            "          description:",
            "          - Encrypts or decrypts a disk using a customer-supplied encryption key.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            rawKey:",
            "              description:",
            "              - Specifies a 256-bit customer-supplied encryption key, encoded in RFC",
            "                4648 base64 to either encrypt or decrypt this resource.",
            "              returned: success",
            "              type: str",
            "            rsaEncryptedKey:",
            "              description:",
            "              - Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied",
            "                encryption key to either encrypt or decrypt this resource.",
            "              returned: success",
            "              type: str",
            "            sha256:",
            "              description:",
            "              - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied",
            "                encryption key that protects this resource.",
            "              returned: success",
            "              type: str",
            "        index:",
            "          description:",
            "          - Assigns a zero-based index to this disk, where 0 is reserved for the boot",
            "            disk. For example, if you have many disks attached to an instance, each",
            "            disk would have a unique index number. If not specified, the server will",
            "            choose an appropriate value.",
            "          returned: success",
            "          type: int",
            "        initializeParams:",
            "          description:",
            "          - Specifies the parameters for a new disk that will be created alongside",
            "            the new instance. Use initialization parameters to create boot disks or",
            "            local SSDs attached to the new instance.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            diskName:",
            "              description:",
            "              - Specifies the disk name. If not specified, the default is to use the",
            "                name of the instance.",
            "              returned: success",
            "              type: str",
            "            diskSizeGb:",
            "              description:",
            "              - Specifies the size of the disk in base-2 GB.",
            "              returned: success",
            "              type: int",
            "            diskType:",
            "              description:",
            "              - Reference to a disk type.",
            "              - Specifies the disk type to use to create the instance.",
            "              - If not specified, the default is pd-standard.",
            "              returned: success",
            "              type: str",
            "            sourceImage:",
            "              description:",
            "              - The source image to create this disk. When creating a new instance,",
            "                one of initializeParams.sourceImage or disks.source is required. To",
            "                create a disk with one of the public operating system images, specify",
            "                the image by its family name.",
            "              returned: success",
            "              type: str",
            "            sourceImageEncryptionKey:",
            "              description:",
            "              - The customer-supplied encryption key of the source image. Required",
            "                if the source image is protected by a customer-supplied encryption",
            "                key.",
            "              - Instance templates do not store customer-supplied encryption keys,",
            "                so you cannot create disks for instances in a managed instance group",
            "                if the source images are encrypted with your own keys.",
            "              returned: success",
            "              type: complex",
            "              contains:",
            "                rawKey:",
            "                  description:",
            "                  - Specifies a 256-bit customer-supplied encryption key, encoded",
            "                    in RFC 4648 base64 to either encrypt or decrypt this resource.",
            "                  returned: success",
            "                  type: str",
            "                sha256:",
            "                  description:",
            "                  - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied",
            "                    encryption key that protects this resource.",
            "                  returned: success",
            "                  type: str",
            "        interface:",
            "          description:",
            "          - Specifies the disk interface to use for attaching this disk, which is",
            "            either SCSI or NVME. The default is SCSI.",
            "          - Persistent disks must always use SCSI and the request will fail if you",
            "            attempt to attach a persistent disk in any other format than SCSI.",
            "          returned: success",
            "          type: str",
            "        mode:",
            "          description:",
            "          - The mode in which to attach this disk, either READ_WRITE or READ_ONLY.",
            "            If not specified, the default is to attach the disk in READ_WRITE mode.",
            "          returned: success",
            "          type: str",
            "        source:",
            "          description:",
            "          - Reference to a disk. When creating a new instance, one of initializeParams.sourceImage",
            "            or disks.source is required.",
            "          - If desired, you can also attach existing non-root persistent disks using",
            "            this property. This field is only applicable for persistent disks.",
            "          - Note that for InstanceTemplate, specify the disk name, not the URL for",
            "            the disk.",
            "          returned: success",
            "          type: dict",
            "        type:",
            "          description:",
            "          - Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified,",
            "            the default is PERSISTENT.",
            "          returned: success",
            "          type: str",
            "    labels:",
            "      description:",
            "      - Labels to apply to this address. A list of key->value pairs.",
            "      returned: success",
            "      type: dict",
            "    machineType:",
            "      description:",
            "      - The machine type to use in the VM instance template.",
            "      returned: success",
            "      type: str",
            "    minCpuPlatform:",
            "      description:",
            "      - Specifies a minimum CPU platform for the VM instance. Applicable values are",
            "        the friendly names of CPU platforms .",
            "      returned: success",
            "      type: str",
            "    metadata:",
            "      description:",
            "      - The metadata key/value pairs to assign to instances that are created from",
            "        this template. These pairs can consist of custom metadata or predefined keys.",
            "      returned: success",
            "      type: dict",
            "    guestAccelerators:",
            "      description:",
            "      - List of the type and count of accelerator cards attached to the instance .",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        acceleratorCount:",
            "          description:",
            "          - The number of the guest accelerator cards exposed to this instance.",
            "          returned: success",
            "          type: int",
            "        acceleratorType:",
            "          description:",
            "          - Full or partial URL of the accelerator type resource to expose to this",
            "            instance.",
            "          returned: success",
            "          type: str",
            "    networkInterfaces:",
            "      description:",
            "      - An array of configurations for this interface. This specifies how this interface",
            "        is configured to interact with other network services, such as connecting",
            "        to the internet. Only one network interface is supported per instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        accessConfigs:",
            "          description:",
            "          - An array of configurations for this interface. Currently, only one access",
            "            config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs specified,",
            "            then this instance will have no external internet access.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            name:",
            "              description:",
            "              - The name of this access configuration. The default and recommended",
            "                name is External NAT but you can use any arbitrary string you would",
            "                like. For example, My external IP or Network Access.",
            "              returned: success",
            "              type: str",
            "            natIP:",
            "              description:",
            "              - Reference to an address.",
            "              - An external IP address associated with this instance.",
            "              - Specify an unused static external IP address available to the project",
            "                or leave this field undefined to use an IP from a shared ephemeral",
            "                IP address pool. If you specify a static external IP address, it must",
            "                live in the same region as the zone of the instance.",
            "              returned: success",
            "              type: dict",
            "            type:",
            "              description:",
            "              - The type of configuration. The default and only option is ONE_TO_ONE_NAT.",
            "              returned: success",
            "              type: str",
            "        aliasIpRanges:",
            "          description:",
            "          - An array of alias IP ranges for this network interface. Can only be specified",
            "            for network interfaces on subnet-mode networks.",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            ipCidrRange:",
            "              description:",
            "              - The IP CIDR range represented by this alias IP range.",
            "              - This IP CIDR range must belong to the specified subnetwork and cannot",
            "                contain IP addresses reserved by system or used by other network interfaces.",
            "                This range may be a single IP address (e.g. 10.2.3.4), a netmask (e.g.",
            "                /24) or a CIDR format string (e.g. 10.1.2.0/24).",
            "              returned: success",
            "              type: str",
            "            subnetworkRangeName:",
            "              description:",
            "              - Optional subnetwork secondary range name specifying the secondary",
            "                range from which to allocate the IP CIDR range for this alias IP range.",
            "                If left unspecified, the primary range of the subnetwork will be used.",
            "              returned: success",
            "              type: str",
            "        name:",
            "          description:",
            "          - The name of the network interface, generated by the server. For network",
            "            devices, these are eth0, eth1, etc .",
            "          returned: success",
            "          type: str",
            "        network:",
            "          description:",
            "          - Specifies the title of an existing network. When creating an instance,",
            "            if neither the network nor the subnetwork is specified, the default network",
            "            global/networks/default is used; if the network is not specified but the",
            "            subnetwork is specified, the network is inferred.",
            "          returned: success",
            "          type: dict",
            "        networkIP:",
            "          description:",
            "          - An IPv4 internal network address to assign to the instance for this network",
            "            interface. If not specified by the user, an unused internal IP is assigned",
            "            by the system.",
            "          returned: success",
            "          type: str",
            "        subnetwork:",
            "          description:",
            "          - Reference to a VPC network.",
            "          - If the network resource is in legacy mode, do not provide this property.",
            "            If the network is in auto subnet mode, providing the subnetwork is optional.",
            "            If the network is in custom subnet mode, then this field should be specified.",
            "          returned: success",
            "          type: dict",
            "    scheduling:",
            "      description:",
            "      - Sets the scheduling options for this instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        automaticRestart:",
            "          description:",
            "          - Specifies whether the instance should be automatically restarted if it",
            "            is terminated by Compute Engine (not terminated by a user).",
            "          - You can only set the automatic restart option for standard instances.",
            "            Preemptible instances cannot be automatically restarted.",
            "          returned: success",
            "          type: bool",
            "        onHostMaintenance:",
            "          description:",
            "          - Defines the maintenance behavior for this instance. For standard instances,",
            "            the default behavior is MIGRATE. For preemptible instances, the default",
            "            and only possible behavior is TERMINATE.",
            "          - For more information, see Setting Instance Scheduling Options.",
            "          returned: success",
            "          type: str",
            "        preemptible:",
            "          description:",
            "          - Defines whether the instance is preemptible. This can only be set during",
            "            instance creation, it cannot be set or changed after the instance has",
            "            been created.",
            "          returned: success",
            "          type: bool",
            "    serviceAccounts:",
            "      description:",
            "      - A list of service accounts, with their specified scopes, authorized for this",
            "        instance. Only one service account per VM instance is supported.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        email:",
            "          description:",
            "          - Email address of the service account.",
            "          returned: success",
            "          type: str",
            "        scopes:",
            "          description:",
            "          - The list of scopes to be made available for this service account.",
            "          returned: success",
            "          type: list",
            "    tags:",
            "      description:",
            "      - A list of tags to apply to this instance. Tags are used to identify valid",
            "        sources or targets for network firewalls and are specified by the client during",
            "        instance creation. The tags can be later modified by the setTags method. Each",
            "        tag within the list must comply with RFC1035.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        fingerprint:",
            "          description:",
            "          - Specifies a fingerprint for this request, which is essentially a hash",
            "            of the metadata's contents and used for optimistic locking.",
            "          - The fingerprint is initially generated by Compute Engine and changes after",
            "            every request to modify or update metadata. You must always provide an",
            "            up-to-date fingerprint hash in order to update or change metadata.",
            "          returned: success",
            "          type: str",
            "        items:",
            "          description:",
            "          - An array of tags. Each tag must be 1-63 characters long, and comply with",
            "            RFC1035.",
            "          returned: success",
            "          type: list",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            description=dict(type='str'),",
            "            name=dict(required=True, type='str'),",
            "            properties=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    can_ip_forward=dict(type='bool'),",
            "                    description=dict(type='str'),",
            "                    disks=dict(",
            "                        type='list',",
            "                        elements='dict',",
            "                        options=dict(",
            "                            auto_delete=dict(type='bool'),",
            "                            boot=dict(type='bool'),",
            "                            device_name=dict(type='str'),",
            "                            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), rsa_encrypted_key=dict(type='str', no_log=True))),",
            "                            index=dict(type='int'),",
            "                            initialize_params=dict(",
            "                                type='dict',",
            "                                options=dict(",
            "                                    disk_name=dict(type='str'),",
            "                                    disk_size_gb=dict(type='int'),",
            "                                    disk_type=dict(type='str'),",
            "                                    source_image=dict(type='str'),",
            "                                    source_image_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),",
            "                                ),",
            "                            ),",
            "                            interface=dict(type='str'),",
            "                            mode=dict(type='str'),",
            "                            source=dict(type='dict'),",
            "                            type=dict(type='str'),",
            "                        ),",
            "                    ),",
            "                    labels=dict(type='dict'),",
            "                    machine_type=dict(required=True, type='str'),",
            "                    min_cpu_platform=dict(type='str'),",
            "                    metadata=dict(type='dict'),",
            "                    guest_accelerators=dict(type='list', elements='dict', options=dict(accelerator_count=dict(type='int'), accelerator_type=dict(type='str'))),",
            "                    network_interfaces=dict(",
            "                        type='list',",
            "                        elements='dict',",
            "                        options=dict(",
            "                            access_configs=dict(",
            "                                type='list',",
            "                                elements='dict',",
            "                                options=dict(name=dict(required=True, type='str'), nat_ip=dict(type='dict'), type=dict(required=True, type='str')),",
            "                            ),",
            "                            alias_ip_ranges=dict(",
            "                                type='list', elements='dict', options=dict(ip_cidr_range=dict(type='str'), subnetwork_range_name=dict(type='str'))",
            "                            ),",
            "                            network=dict(type='dict'),",
            "                            network_ip=dict(type='str'),",
            "                            subnetwork=dict(type='dict'),",
            "                        ),",
            "                    ),",
            "                    scheduling=dict(",
            "                        type='dict', options=dict(automatic_restart=dict(type='bool'), on_host_maintenance=dict(type='str'), preemptible=dict(type='bool'))",
            "                    ),",
            "                    service_accounts=dict(type='list', elements='dict', options=dict(email=dict(type='str'), scopes=dict(type='list', elements='str'))),",
            "                    tags=dict(type='dict', options=dict(fingerprint=dict(type='str'), items=dict(type='list', elements='str'))),",
            "                ),",
            "            ),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#instanceTemplate'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind):",
            "    delete(module, self_link(module), kind)",
            "    create(module, collection(module), kind)",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#instanceTemplate',",
            "        u'description': module.params.get('description'),",
            "        u'name': module.params.get('name'),",
            "        u'properties': InstanceTemplateProperties(module.params.get('properties', {}), module).to_request(),",
            "    }",
            "    request = encode_request(request, module)",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/instanceTemplates/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/instanceTemplates\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    result = decode_response(result, module)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "    request = decode_response(request, module)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'description': response.get(u'description'),",
            "        u'id': response.get(u'id'),",
            "        u'name': response.get(u'name'),",
            "        u'properties': InstanceTemplateProperties(response.get(u'properties', {}), module).from_response(),",
            "    }",
            "",
            "",
            "def disk_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/.*/diskTypes/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/diskTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    response = fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#instanceTemplate')",
            "    if response:",
            "        return decode_response(response, module)",
            "    else:",
            "        return {}",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "def encode_request(request, module):",
            "    if 'properties' in request and request['properties'] is not None and 'metadata' in request['properties'] and request['properties']['metadata'] is not None:",
            "        request['properties']['metadata'] = metadata_encoder(request['properties']['metadata'])",
            "    return request",
            "",
            "",
            "def decode_response(response, module):",
            "    if (",
            "        'properties' in response",
            "        and response['properties'] is not None",
            "        and 'metadata' in response['properties']",
            "        and response['properties']['metadata'] is not None",
            "    ):",
            "        response['properties']['metadata'] = metadata_decoder(response['properties']['metadata'])",
            "    return response",
            "",
            "",
            "# TODO(alexstephen): Implement updating metadata on existing resources.",
            "",
            "# Expose instance 'metadata' as a simple name/value pair hash. However the API",
            "# defines metadata as a NestedObject with the following layout:",
            "#",
            "# metadata {",
            "#   fingerprint: 'hash-of-last-metadata'",
            "#   items: [",
            "#     {",
            "#       key: 'metadata1-key'",
            "#       value: 'metadata1-value'",
            "#     },",
            "#     ...",
            "#   ]",
            "# }",
            "#",
            "def metadata_encoder(metadata):",
            "    metadata_new = []",
            "    for key in metadata:",
            "        value = metadata[key]",
            "        metadata_new.append({\"key\": key, \"value\": value})",
            "    return {'items': metadata_new}",
            "",
            "",
            "# Map metadata.items[]{key:,value:} => metadata[key]=value",
            "def metadata_decoder(metadata):",
            "    items = {}",
            "    if 'items' in metadata:",
            "        metadata_items = metadata['items']",
            "        for item in metadata_items:",
            "            items[item['key']] = item['value']",
            "    return items",
            "",
            "",
            "class InstanceTemplateProperties(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'canIpForward': self.request.get('can_ip_forward'),",
            "                u'description': self.request.get('description'),",
            "                u'disks': InstanceTemplateDisksArray(self.request.get('disks', []), self.module).to_request(),",
            "                u'labels': self.request.get('labels'),",
            "                u'machineType': self.request.get('machine_type'),",
            "                u'minCpuPlatform': self.request.get('min_cpu_platform'),",
            "                u'metadata': self.request.get('metadata'),",
            "                u'guestAccelerators': InstanceTemplateGuestacceleratorsArray(self.request.get('guest_accelerators', []), self.module).to_request(),",
            "                u'networkInterfaces': InstanceTemplateNetworkinterfacesArray(self.request.get('network_interfaces', []), self.module).to_request(),",
            "                u'scheduling': InstanceTemplateScheduling(self.request.get('scheduling', {}), self.module).to_request(),",
            "                u'serviceAccounts': InstanceTemplateServiceaccountsArray(self.request.get('service_accounts', []), self.module).to_request(),",
            "                u'tags': InstanceTemplateTags(self.request.get('tags', {}), self.module).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'canIpForward': self.request.get(u'canIpForward'),",
            "                u'description': self.request.get(u'description'),",
            "                u'disks': InstanceTemplateDisksArray(self.request.get(u'disks', []), self.module).from_response(),",
            "                u'labels': self.request.get(u'labels'),",
            "                u'machineType': self.request.get(u'machineType'),",
            "                u'minCpuPlatform': self.request.get(u'minCpuPlatform'),",
            "                u'metadata': self.request.get(u'metadata'),",
            "                u'guestAccelerators': InstanceTemplateGuestacceleratorsArray(self.request.get(u'guestAccelerators', []), self.module).from_response(),",
            "                u'networkInterfaces': InstanceTemplateNetworkinterfacesArray(self.request.get(u'networkInterfaces', []), self.module).from_response(),",
            "                u'scheduling': InstanceTemplateScheduling(self.request.get(u'scheduling', {}), self.module).from_response(),",
            "                u'serviceAccounts': InstanceTemplateServiceaccountsArray(self.request.get(u'serviceAccounts', []), self.module).from_response(),",
            "                u'tags': InstanceTemplateTags(self.request.get(u'tags', {}), self.module).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateDisksArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'autoDelete': item.get('auto_delete'),",
            "                u'boot': item.get('boot'),",
            "                u'deviceName': item.get('device_name'),",
            "                u'diskEncryptionKey': InstanceTemplateDiskencryptionkey(item.get('disk_encryption_key', {}), self.module).to_request(),",
            "                u'index': item.get('index'),",
            "                u'initializeParams': InstanceTemplateInitializeparams(item.get('initialize_params', {}), self.module).to_request(),",
            "                u'interface': item.get('interface'),",
            "                u'mode': item.get('mode'),",
            "                u'source': replace_resource_dict(item.get(u'source', {}), 'name'),",
            "                u'type': item.get('type'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'autoDelete': item.get(u'autoDelete'),",
            "                u'boot': item.get(u'boot'),",
            "                u'deviceName': item.get(u'deviceName'),",
            "                u'diskEncryptionKey': InstanceTemplateDiskencryptionkey(item.get(u'diskEncryptionKey', {}), self.module).from_response(),",
            "                u'index': item.get(u'index'),",
            "                u'initializeParams': InstanceTemplateInitializeparams(self.module.params.get('initialize_params', {}), self.module).to_request(),",
            "                u'interface': item.get(u'interface'),",
            "                u'mode': item.get(u'mode'),",
            "                u'source': item.get(u'source'),",
            "                u'type': item.get(u'type'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateDiskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'rsaEncryptedKey': self.request.get('rsa_encrypted_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'rsaEncryptedKey': self.request.get(u'rsaEncryptedKey')})",
            "",
            "",
            "class InstanceTemplateInitializeparams(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'diskName': self.request.get('disk_name'),",
            "                u'diskSizeGb': self.request.get('disk_size_gb'),",
            "                u'diskType': disk_type_selflink(self.request.get('disk_type'), self.module.params),",
            "                u'sourceImage': self.request.get('source_image'),",
            "                u'sourceImageEncryptionKey': InstanceTemplateSourceimageencryptionkey(",
            "                    self.request.get('source_image_encryption_key', {}), self.module",
            "                ).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'diskName': self.request.get(u'diskName'),",
            "                u'diskSizeGb': self.request.get(u'diskSizeGb'),",
            "                u'diskType': self.request.get(u'diskType'),",
            "                u'sourceImage': self.request.get(u'sourceImage'),",
            "                u'sourceImageEncryptionKey': InstanceTemplateSourceimageencryptionkey(",
            "                    self.request.get(u'sourceImageEncryptionKey', {}), self.module",
            "                ).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateSourceimageencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "class InstanceTemplateGuestacceleratorsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'acceleratorCount': item.get('accelerator_count'), u'acceleratorType': item.get('accelerator_type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'acceleratorCount': item.get(u'acceleratorCount'), u'acceleratorType': item.get(u'acceleratorType')})",
            "",
            "",
            "class InstanceTemplateNetworkinterfacesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'accessConfigs': InstanceTemplateAccessconfigsArray(item.get('access_configs', []), self.module).to_request(),",
            "                u'aliasIpRanges': InstanceTemplateAliasiprangesArray(item.get('alias_ip_ranges', []), self.module).to_request(),",
            "                u'network': replace_resource_dict(item.get(u'network', {}), 'selfLink'),",
            "                u'networkIP': item.get('network_ip'),",
            "                u'subnetwork': replace_resource_dict(item.get(u'subnetwork', {}), 'selfLink'),",
            "            }",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'accessConfigs': InstanceTemplateAccessconfigsArray(item.get(u'accessConfigs', []), self.module).from_response(),",
            "                u'aliasIpRanges': InstanceTemplateAliasiprangesArray(item.get(u'aliasIpRanges', []), self.module).from_response(),",
            "                u'network': item.get(u'network'),",
            "                u'networkIP': item.get(u'networkIP'),",
            "                u'subnetwork': item.get(u'subnetwork'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateAccessconfigsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict(",
            "            {u'name': item.get('name'), u'natIP': replace_resource_dict(item.get(u'nat_ip', {}), 'address'), u'type': item.get('type')}",
            "        )",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'name': item.get(u'name'), u'natIP': item.get(u'natIP'), u'type': item.get(u'type')})",
            "",
            "",
            "class InstanceTemplateAliasiprangesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'ipCidrRange': item.get('ip_cidr_range'), u'subnetworkRangeName': item.get('subnetwork_range_name')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'ipCidrRange': item.get(u'ipCidrRange'), u'subnetworkRangeName': item.get(u'subnetworkRangeName')})",
            "",
            "",
            "class InstanceTemplateScheduling(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'automaticRestart': self.request.get('automatic_restart'),",
            "                u'onHostMaintenance': self.request.get('on_host_maintenance'),",
            "                u'preemptible': self.request.get('preemptible'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'automaticRestart': self.request.get(u'automaticRestart'),",
            "                u'onHostMaintenance': self.request.get(u'onHostMaintenance'),",
            "                u'preemptible': self.request.get(u'preemptible'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceTemplateServiceaccountsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'email': item.get('email'), u'scopes': item.get('scopes')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'email': item.get(u'email'), u'scopes': item.get(u'scopes')})",
            "",
            "",
            "class InstanceTemplateTags(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'fingerprint': self.request.get('fingerprint'), u'items': self.request.get('items')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'fingerprint': self.request.get(u'fingerprint'), u'items': self.request.get(u'items')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "917": [
                "main"
            ],
            "926": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_region_disk.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "             replica_zones=dict(required=True, type='list', elements='str'),"
            },
            "1": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "             type=dict(type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "             region=dict(required=True, type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),"
            },
            "5": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "             source_snapshot=dict(type='dict'),"
            },
            "6": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            source_snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+            source_snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),"
            },
            "8": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "         )"
            },
            "9": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "     )"
            },
            "10": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 377,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_region_disk",
            "description:",
            "- Persistent disks are durable storage devices that function similarly to the physical",
            "  disks in a desktop or a server. Compute Engine manages the hardware behind these",
            "  devices to ensure data redundancy and optimize performance for you. Persistent disks",
            "  are available as either standard hard disk drives (HDD) or solid-state drives (SSD).",
            "- Persistent disks are located independently from your virtual machine instances,",
            "  so you can detach or move persistent disks to keep your data even after you delete",
            "  your instances. Persistent disk performance scales automatically with size, so you",
            "  can resize your existing persistent disks or add more persistent disks to an instance",
            "  to meet your performance and storage space requirements.",
            "- Add a persistent disk to your instance when you need reliable and affordable storage",
            "  with consistent performance characteristics.",
            "short_description: Creates a GCP RegionDisk",
            "version_added: 2.8",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource. Provide this property when you create",
            "      the resource.",
            "    required: false",
            "    type: str",
            "  labels:",
            "    description:",
            "    - Labels to apply to this disk. A list of key->value pairs.",
            "    required: false",
            "    type: dict",
            "  licenses:",
            "    description:",
            "    - Any applicable publicly visible licenses.",
            "    required: false",
            "    type: list",
            "  name:",
            "    description:",
            "    - Name of the resource. Provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  size_gb:",
            "    description:",
            "    - Size of the persistent disk, specified in GB. You can specify this field when",
            "      creating a persistent disk using the sourceImage or sourceSnapshot parameter,",
            "      or specify it alone to create an empty persistent disk.",
            "    - If you specify this field along with sourceImage or sourceSnapshot, the value",
            "      of sizeGb must not be less than the size of the sourceImage or the size of the",
            "      snapshot.",
            "    required: false",
            "    type: int",
            "  physical_block_size_bytes:",
            "    description:",
            "    - Physical block size of the persistent disk, in bytes. If not present in a request,",
            "      a default value is used. Currently supported sizes are 4096 and 16384, other",
            "      sizes may be added in the future.",
            "    - If an unsupported value is requested, the error message will list the supported",
            "      values for the caller's project.",
            "    required: false",
            "    type: int",
            "  replica_zones:",
            "    description:",
            "    - URLs of the zones where the disk should be replicated to.",
            "    required: true",
            "    type: list",
            "  type:",
            "    description:",
            "    - URL of the disk type resource describing which disk type to use to create the",
            "      disk. Provide this when creating the disk.",
            "    required: false",
            "    type: str",
            "  region:",
            "    description:",
            "    - A reference to the region where the disk resides.",
            "    required: true",
            "    type: str",
            "  disk_encryption_key:",
            "    description:",
            "    - Encrypts the disk using a customer-supplied encryption key.",
            "    - After you encrypt a disk with a customer-supplied key, you must provide the",
            "      same key if you use the disk later (e.g. to create a disk snapshot or an image,",
            "      or to attach the disk to a virtual machine).",
            "    - Customer-supplied encryption keys do not protect access to metadata of the disk.",
            "    - If you do not provide an encryption key when creating the disk, then the disk",
            "      will be encrypted using an automatically generated key and you do not need to",
            "      provide a key to use the disk later.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "  source_snapshot:",
            "    description:",
            "    - The source snapshot used to create this disk. You can provide this as a partial",
            "      or full URL to the resource.",
            "    - 'This field represents a link to a Snapshot resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''selfLink'' and value",
            "      of your resource''s selfLink Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_snapshot task and then set this source_snapshot field to \"{{",
            "      name-of-resource }}\"'",
            "    required: false",
            "    type: dict",
            "  source_snapshot_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source snapshot. Required if the",
            "      source snapshot is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/rest/beta/regionDisks)'",
            "- 'Adding or Resizing Regional Persistent Disks: U(https://cloud.google.com/compute/docs/disks/regional-persistent-disk)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a region disk",
            "  gcp_compute_region_disk:",
            "    name: test_object",
            "    size_gb: 500",
            "    disk_encryption_key:",
            "      raw_key: SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0=",
            "    region: us-central1",
            "    replica_zones:",
            "    - https://www.googleapis.com/compute/v1/projects/google.com:graphite-playground/zones/us-central1-a",
            "    - https://www.googleapis.com/compute/v1/projects/google.com:graphite-playground/zones/us-central1-b",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "labelFingerprint:",
            "  description:",
            "  - The fingerprint used for optimistic locking of this resource. Used internally",
            "    during updates.",
            "  returned: success",
            "  type: str",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource. Provide this property when you create",
            "    the resource.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "lastAttachTimestamp:",
            "  description:",
            "  - Last attach timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "lastDetachTimestamp:",
            "  description:",
            "  - Last detach timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "labels:",
            "  description:",
            "  - Labels to apply to this disk. A list of key->value pairs.",
            "  returned: success",
            "  type: dict",
            "licenses:",
            "  description:",
            "  - Any applicable publicly visible licenses.",
            "  returned: success",
            "  type: list",
            "name:",
            "  description:",
            "  - Name of the resource. Provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "sizeGb:",
            "  description:",
            "  - Size of the persistent disk, specified in GB. You can specify this field when",
            "    creating a persistent disk using the sourceImage or sourceSnapshot parameter,",
            "    or specify it alone to create an empty persistent disk.",
            "  - If you specify this field along with sourceImage or sourceSnapshot, the value",
            "    of sizeGb must not be less than the size of the sourceImage or the size of the",
            "    snapshot.",
            "  returned: success",
            "  type: int",
            "users:",
            "  description:",
            "  - 'Links to the users of the disk (attached instances) in form: project/zones/zone/instances/instance",
            "    .'",
            "  returned: success",
            "  type: list",
            "physicalBlockSizeBytes:",
            "  description:",
            "  - Physical block size of the persistent disk, in bytes. If not present in a request,",
            "    a default value is used. Currently supported sizes are 4096 and 16384, other sizes",
            "    may be added in the future.",
            "  - If an unsupported value is requested, the error message will list the supported",
            "    values for the caller's project.",
            "  returned: success",
            "  type: int",
            "replicaZones:",
            "  description:",
            "  - URLs of the zones where the disk should be replicated to.",
            "  returned: success",
            "  type: list",
            "type:",
            "  description:",
            "  - URL of the disk type resource describing which disk type to use to create the",
            "    disk. Provide this when creating the disk.",
            "  returned: success",
            "  type: str",
            "region:",
            "  description:",
            "  - A reference to the region where the disk resides.",
            "  returned: success",
            "  type: str",
            "diskEncryptionKey:",
            "  description:",
            "  - Encrypts the disk using a customer-supplied encryption key.",
            "  - After you encrypt a disk with a customer-supplied key, you must provide the same",
            "    key if you use the disk later (e.g. to create a disk snapshot or an image, or",
            "    to attach the disk to a virtual machine).",
            "  - Customer-supplied encryption keys do not protect access to metadata of the disk.",
            "  - If you do not provide an encryption key when creating the disk, then the disk",
            "    will be encrypted using an automatically generated key and you do not need to",
            "    provide a key to use the disk later.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "sourceSnapshot:",
            "  description:",
            "  - The source snapshot used to create this disk. You can provide this as a partial",
            "    or full URL to the resource.",
            "  returned: success",
            "  type: dict",
            "sourceSnapshotEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source snapshot. Required if the source",
            "    snapshot is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "sourceSnapshotId:",
            "  description:",
            "  - The unique ID of the snapshot used to create this disk. This value identifies",
            "    the exact snapshot that was used to create this persistent disk. For example,",
            "    if you created the persistent disk from a snapshot that was later deleted and",
            "    recreated under the same name, the source snapshot ID would identify the exact",
            "    version of the snapshot that was used.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            description=dict(type='str'),",
            "            labels=dict(type='dict'),",
            "            licenses=dict(type='list', elements='str'),",
            "            name=dict(required=True, type='str'),",
            "            size_gb=dict(type='int'),",
            "            physical_block_size_bytes=dict(type='int'),",
            "            replica_zones=dict(required=True, type='list', elements='str'),",
            "            type=dict(type='str'),",
            "            region=dict(required=True, type='str'),",
            "            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),",
            "            source_snapshot=dict(type='dict'),",
            "            source_snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'))),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#disk'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('labels') != request.get('labels'):",
            "        label_fingerprint_update(module, request, response)",
            "    if response.get('sizeGb') != request.get('sizeGb'):",
            "        size_gb_update(module, request, response)",
            "",
            "",
            "def label_fingerprint_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/regions/{region}/disks/{name}/setLabels\"]).format(**module.params),",
            "        {u'labelFingerprint': response.get('labelFingerprint'), u'labels': module.params.get('labels')},",
            "    )",
            "",
            "",
            "def size_gb_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/regions/{region}/disks/{name}/resize\"]).format(**module.params),",
            "        {u'sizeGb': module.params.get('size_gb')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#disk',",
            "        u'diskEncryptionKey': RegionDiskDiskencryptionkey(module.params.get('disk_encryption_key', {}), module).to_request(),",
            "        u'sourceSnapshotEncryptionKey': RegionDiskSourcesnapshotencryptionkey(module.params.get('source_snapshot_encryption_key', {}), module).to_request(),",
            "        u'description': module.params.get('description'),",
            "        u'labels': module.params.get('labels'),",
            "        u'licenses': module.params.get('licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'sizeGb': module.params.get('size_gb'),",
            "        u'physicalBlockSizeBytes': module.params.get('physical_block_size_bytes'),",
            "        u'replicaZones': module.params.get('replica_zones'),",
            "        u'type': region_disk_type_selflink(module.params.get('type'), module.params),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/disks/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/disks\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'description': response.get(u'description'),",
            "        u'id': response.get(u'id'),",
            "        u'lastAttachTimestamp': response.get(u'lastAttachTimestamp'),",
            "        u'lastDetachTimestamp': response.get(u'lastDetachTimestamp'),",
            "        u'labels': response.get(u'labels'),",
            "        u'licenses': response.get(u'licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'sizeGb': response.get(u'sizeGb'),",
            "        u'users': response.get(u'users'),",
            "        u'physicalBlockSizeBytes': response.get(u'physicalBlockSizeBytes'),",
            "        u'replicaZones': response.get(u'replicaZones'),",
            "        u'type': response.get(u'type'),",
            "    }",
            "",
            "",
            "def zone_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def region_disk_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/regions/.*/diskTypes/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/diskTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#disk')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class RegionDiskDiskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "class RegionDiskSourcesnapshotencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_region_disk",
            "description:",
            "- Persistent disks are durable storage devices that function similarly to the physical",
            "  disks in a desktop or a server. Compute Engine manages the hardware behind these",
            "  devices to ensure data redundancy and optimize performance for you. Persistent disks",
            "  are available as either standard hard disk drives (HDD) or solid-state drives (SSD).",
            "- Persistent disks are located independently from your virtual machine instances,",
            "  so you can detach or move persistent disks to keep your data even after you delete",
            "  your instances. Persistent disk performance scales automatically with size, so you",
            "  can resize your existing persistent disks or add more persistent disks to an instance",
            "  to meet your performance and storage space requirements.",
            "- Add a persistent disk to your instance when you need reliable and affordable storage",
            "  with consistent performance characteristics.",
            "short_description: Creates a GCP RegionDisk",
            "version_added: 2.8",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource. Provide this property when you create",
            "      the resource.",
            "    required: false",
            "    type: str",
            "  labels:",
            "    description:",
            "    - Labels to apply to this disk. A list of key->value pairs.",
            "    required: false",
            "    type: dict",
            "  licenses:",
            "    description:",
            "    - Any applicable publicly visible licenses.",
            "    required: false",
            "    type: list",
            "  name:",
            "    description:",
            "    - Name of the resource. Provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  size_gb:",
            "    description:",
            "    - Size of the persistent disk, specified in GB. You can specify this field when",
            "      creating a persistent disk using the sourceImage or sourceSnapshot parameter,",
            "      or specify it alone to create an empty persistent disk.",
            "    - If you specify this field along with sourceImage or sourceSnapshot, the value",
            "      of sizeGb must not be less than the size of the sourceImage or the size of the",
            "      snapshot.",
            "    required: false",
            "    type: int",
            "  physical_block_size_bytes:",
            "    description:",
            "    - Physical block size of the persistent disk, in bytes. If not present in a request,",
            "      a default value is used. Currently supported sizes are 4096 and 16384, other",
            "      sizes may be added in the future.",
            "    - If an unsupported value is requested, the error message will list the supported",
            "      values for the caller's project.",
            "    required: false",
            "    type: int",
            "  replica_zones:",
            "    description:",
            "    - URLs of the zones where the disk should be replicated to.",
            "    required: true",
            "    type: list",
            "  type:",
            "    description:",
            "    - URL of the disk type resource describing which disk type to use to create the",
            "      disk. Provide this when creating the disk.",
            "    required: false",
            "    type: str",
            "  region:",
            "    description:",
            "    - A reference to the region where the disk resides.",
            "    required: true",
            "    type: str",
            "  disk_encryption_key:",
            "    description:",
            "    - Encrypts the disk using a customer-supplied encryption key.",
            "    - After you encrypt a disk with a customer-supplied key, you must provide the",
            "      same key if you use the disk later (e.g. to create a disk snapshot or an image,",
            "      or to attach the disk to a virtual machine).",
            "    - Customer-supplied encryption keys do not protect access to metadata of the disk.",
            "    - If you do not provide an encryption key when creating the disk, then the disk",
            "      will be encrypted using an automatically generated key and you do not need to",
            "      provide a key to use the disk later.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "  source_snapshot:",
            "    description:",
            "    - The source snapshot used to create this disk. You can provide this as a partial",
            "      or full URL to the resource.",
            "    - 'This field represents a link to a Snapshot resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''selfLink'' and value",
            "      of your resource''s selfLink Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_snapshot task and then set this source_snapshot field to \"{{",
            "      name-of-resource }}\"'",
            "    required: false",
            "    type: dict",
            "  source_snapshot_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source snapshot. Required if the",
            "      source snapshot is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/rest/beta/regionDisks)'",
            "- 'Adding or Resizing Regional Persistent Disks: U(https://cloud.google.com/compute/docs/disks/regional-persistent-disk)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a region disk",
            "  gcp_compute_region_disk:",
            "    name: test_object",
            "    size_gb: 500",
            "    disk_encryption_key:",
            "      raw_key: SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0=",
            "    region: us-central1",
            "    replica_zones:",
            "    - https://www.googleapis.com/compute/v1/projects/google.com:graphite-playground/zones/us-central1-a",
            "    - https://www.googleapis.com/compute/v1/projects/google.com:graphite-playground/zones/us-central1-b",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "labelFingerprint:",
            "  description:",
            "  - The fingerprint used for optimistic locking of this resource. Used internally",
            "    during updates.",
            "  returned: success",
            "  type: str",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource. Provide this property when you create",
            "    the resource.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "lastAttachTimestamp:",
            "  description:",
            "  - Last attach timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "lastDetachTimestamp:",
            "  description:",
            "  - Last detach timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "labels:",
            "  description:",
            "  - Labels to apply to this disk. A list of key->value pairs.",
            "  returned: success",
            "  type: dict",
            "licenses:",
            "  description:",
            "  - Any applicable publicly visible licenses.",
            "  returned: success",
            "  type: list",
            "name:",
            "  description:",
            "  - Name of the resource. Provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "sizeGb:",
            "  description:",
            "  - Size of the persistent disk, specified in GB. You can specify this field when",
            "    creating a persistent disk using the sourceImage or sourceSnapshot parameter,",
            "    or specify it alone to create an empty persistent disk.",
            "  - If you specify this field along with sourceImage or sourceSnapshot, the value",
            "    of sizeGb must not be less than the size of the sourceImage or the size of the",
            "    snapshot.",
            "  returned: success",
            "  type: int",
            "users:",
            "  description:",
            "  - 'Links to the users of the disk (attached instances) in form: project/zones/zone/instances/instance",
            "    .'",
            "  returned: success",
            "  type: list",
            "physicalBlockSizeBytes:",
            "  description:",
            "  - Physical block size of the persistent disk, in bytes. If not present in a request,",
            "    a default value is used. Currently supported sizes are 4096 and 16384, other sizes",
            "    may be added in the future.",
            "  - If an unsupported value is requested, the error message will list the supported",
            "    values for the caller's project.",
            "  returned: success",
            "  type: int",
            "replicaZones:",
            "  description:",
            "  - URLs of the zones where the disk should be replicated to.",
            "  returned: success",
            "  type: list",
            "type:",
            "  description:",
            "  - URL of the disk type resource describing which disk type to use to create the",
            "    disk. Provide this when creating the disk.",
            "  returned: success",
            "  type: str",
            "region:",
            "  description:",
            "  - A reference to the region where the disk resides.",
            "  returned: success",
            "  type: str",
            "diskEncryptionKey:",
            "  description:",
            "  - Encrypts the disk using a customer-supplied encryption key.",
            "  - After you encrypt a disk with a customer-supplied key, you must provide the same",
            "    key if you use the disk later (e.g. to create a disk snapshot or an image, or",
            "    to attach the disk to a virtual machine).",
            "  - Customer-supplied encryption keys do not protect access to metadata of the disk.",
            "  - If you do not provide an encryption key when creating the disk, then the disk",
            "    will be encrypted using an automatically generated key and you do not need to",
            "    provide a key to use the disk later.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "sourceSnapshot:",
            "  description:",
            "  - The source snapshot used to create this disk. You can provide this as a partial",
            "    or full URL to the resource.",
            "  returned: success",
            "  type: dict",
            "sourceSnapshotEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source snapshot. Required if the source",
            "    snapshot is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "sourceSnapshotId:",
            "  description:",
            "  - The unique ID of the snapshot used to create this disk. This value identifies",
            "    the exact snapshot that was used to create this persistent disk. For example,",
            "    if you created the persistent disk from a snapshot that was later deleted and",
            "    recreated under the same name, the source snapshot ID would identify the exact",
            "    version of the snapshot that was used.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            description=dict(type='str'),",
            "            labels=dict(type='dict'),",
            "            licenses=dict(type='list', elements='str'),",
            "            name=dict(required=True, type='str'),",
            "            size_gb=dict(type='int'),",
            "            physical_block_size_bytes=dict(type='int'),",
            "            replica_zones=dict(required=True, type='list', elements='str'),",
            "            type=dict(type='str'),",
            "            region=dict(required=True, type='str'),",
            "            disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),",
            "            source_snapshot=dict(type='dict'),",
            "            source_snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True))),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#disk'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('labels') != request.get('labels'):",
            "        label_fingerprint_update(module, request, response)",
            "    if response.get('sizeGb') != request.get('sizeGb'):",
            "        size_gb_update(module, request, response)",
            "",
            "",
            "def label_fingerprint_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/regions/{region}/disks/{name}/setLabels\"]).format(**module.params),",
            "        {u'labelFingerprint': response.get('labelFingerprint'), u'labels': module.params.get('labels')},",
            "    )",
            "",
            "",
            "def size_gb_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/regions/{region}/disks/{name}/resize\"]).format(**module.params),",
            "        {u'sizeGb': module.params.get('size_gb')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#disk',",
            "        u'diskEncryptionKey': RegionDiskDiskencryptionkey(module.params.get('disk_encryption_key', {}), module).to_request(),",
            "        u'sourceSnapshotEncryptionKey': RegionDiskSourcesnapshotencryptionkey(module.params.get('source_snapshot_encryption_key', {}), module).to_request(),",
            "        u'description': module.params.get('description'),",
            "        u'labels': module.params.get('labels'),",
            "        u'licenses': module.params.get('licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'sizeGb': module.params.get('size_gb'),",
            "        u'physicalBlockSizeBytes': module.params.get('physical_block_size_bytes'),",
            "        u'replicaZones': module.params.get('replica_zones'),",
            "        u'type': region_disk_type_selflink(module.params.get('type'), module.params),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/disks/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/disks\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'description': response.get(u'description'),",
            "        u'id': response.get(u'id'),",
            "        u'lastAttachTimestamp': response.get(u'lastAttachTimestamp'),",
            "        u'lastDetachTimestamp': response.get(u'lastDetachTimestamp'),",
            "        u'labels': response.get(u'labels'),",
            "        u'licenses': response.get(u'licenses'),",
            "        u'name': module.params.get('name'),",
            "        u'sizeGb': response.get(u'sizeGb'),",
            "        u'users': response.get(u'users'),",
            "        u'physicalBlockSizeBytes': response.get(u'physicalBlockSizeBytes'),",
            "        u'replicaZones': response.get(u'replicaZones'),",
            "        u'type': response.get(u'type'),",
            "    }",
            "",
            "",
            "def zone_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/zones/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/zones/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def region_disk_type_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1/projects/.*/regions/.*/diskTypes/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/diskTypes/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#disk')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class RegionDiskDiskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "class RegionDiskSourcesnapshotencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "372": [
                "main"
            ],
            "374": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_snapshot.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "             labels=dict(type='dict'),"
            },
            "1": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "             source_disk=dict(required=True, type='dict'),"
            },
            "2": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "             zone=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),"
            },
            "4": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            source_disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+            snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+            source_disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),"
            },
            "7": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "         )"
            },
            "8": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "     )"
            },
            "9": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 298,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_snapshot",
            "description:",
            "- Represents a Persistent Disk Snapshot resource.",
            "- Use snapshots to back up data from your persistent disks. Snapshots are different",
            "  from public images and custom images, which are used primarily to create instances",
            "  or configure instance templates. Snapshots are useful for periodic backup of the",
            "  data on your persistent disks. You can create snapshots from persistent disks even",
            "  while they are attached to running instances.",
            "- Snapshots are incremental, so you can create regular snapshots on a persistent disk",
            "  faster and at a much lower cost than if you regularly created a full image of the",
            "  disk.",
            "short_description: Creates a GCP Snapshot",
            "version_added: 2.9",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  name:",
            "    description:",
            "    - Name of the resource; provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource.",
            "    required: false",
            "    type: str",
            "  labels:",
            "    description:",
            "    - Labels to apply to this Snapshot.",
            "    required: false",
            "    type: dict",
            "  source_disk:",
            "    description:",
            "    - A reference to the disk used to create this snapshot.",
            "    - 'This field represents a link to a Disk resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''name'' and value of",
            "      your resource''s name Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_disk task and then set this source_disk field to \"{{ name-of-resource",
            "      }}\"'",
            "    required: true",
            "    type: dict",
            "  zone:",
            "    description:",
            "    - A reference to the zone where the disk is hosted.",
            "    required: false",
            "    type: str",
            "  snapshot_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the snapshot. Required if the source",
            "      snapshot is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "  source_disk_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source snapshot. Required if the",
            "      source snapshot is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/rest/v1/snapshots)'",
            "- 'Official Documentation: U(https://cloud.google.com/compute/docs/disks/create-snapshots)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a disk",
            "  gcp_compute_disk:",
            "    name: disk-snapshot",
            "    zone: us-central1-a",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: disk",
            "",
            "- name: create a snapshot",
            "  gcp_compute_snapshot:",
            "    name: test_object",
            "    source_disk: \"{{ disk }}\"",
            "    zone: us-central1-a",
            "    labels:",
            "      my_label: value",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "diskSizeGb:",
            "  description:",
            "  - Size of the snapshot, specified in GB.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the resource; provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource.",
            "  returned: success",
            "  type: str",
            "storageBytes:",
            "  description:",
            "  - A size of the the storage used by the snapshot. As snapshots share storage, this",
            "    number is expected to change with snapshot creation/deletion.",
            "  returned: success",
            "  type: int",
            "licenses:",
            "  description:",
            "  - A list of public visible licenses that apply to this snapshot. This can be because",
            "    the original image had licenses attached (such as a Windows image). snapshotEncryptionKey",
            "    nested object Encrypts the snapshot using a customer-supplied encryption key.",
            "  returned: success",
            "  type: list",
            "labels:",
            "  description:",
            "  - Labels to apply to this Snapshot.",
            "  returned: success",
            "  type: dict",
            "labelFingerprint:",
            "  description:",
            "  - The fingerprint used for optimistic locking of this resource. Used internally",
            "    during updates.",
            "  returned: success",
            "  type: str",
            "sourceDisk:",
            "  description:",
            "  - A reference to the disk used to create this snapshot.",
            "  returned: success",
            "  type: dict",
            "zone:",
            "  description:",
            "  - A reference to the zone where the disk is hosted.",
            "  returned: success",
            "  type: str",
            "snapshotEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the snapshot. Required if the source snapshot",
            "    is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "sourceDiskEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source snapshot. Required if the source",
            "    snapshot is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            name=dict(required=True, type='str'),",
            "            description=dict(type='str'),",
            "            labels=dict(type='dict'),",
            "            source_disk=dict(required=True, type='dict'),",
            "            zone=dict(type='str'),",
            "            snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),",
            "            source_disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str'), kms_key_name=dict(type='str'))),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#snapshot'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, create_link(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('labels') != request.get('labels'):",
            "        labels_update(module, request, response)",
            "",
            "",
            "def labels_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/global/snapshots/{name}/setLabels\"]).format(**module.params),",
            "        {u'labels': module.params.get('labels'), u'labelFingerprint': response.get('labelFingerprint')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#snapshot',",
            "        u'sourceDisk': replace_resource_dict(module.params.get(u'source_disk', {}), 'name'),",
            "        u'zone': module.params.get('zone'),",
            "        u'name': module.params.get('name'),",
            "        u'description': module.params.get('description'),",
            "        u'labels': module.params.get('labels'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/snapshots/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/snapshots\".format(**module.params)",
            "",
            "",
            "def create_link(module):",
            "    res = {'project': module.params['project'], 'zone': module.params['zone'], 'source_disk': replace_resource_dict(module.params['source_disk'], 'name')}",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/disks/{source_disk}/createSnapshot\".format(**res)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'id': response.get(u'id'),",
            "        u'diskSizeGb': response.get(u'diskSizeGb'),",
            "        u'name': module.params.get('name'),",
            "        u'description': module.params.get('description'),",
            "        u'storageBytes': response.get(u'storageBytes'),",
            "        u'licenses': response.get(u'licenses'),",
            "        u'labels': response.get(u'labels'),",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "    }",
            "",
            "",
            "def license_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1//projects/.*/global/licenses/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1//projects/{project}/global/licenses/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#snapshot')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = navigate_hash(op_result, ['selfLink'])",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class SnapshotSnapshotencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "class SnapshotSourcediskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_snapshot",
            "description:",
            "- Represents a Persistent Disk Snapshot resource.",
            "- Use snapshots to back up data from your persistent disks. Snapshots are different",
            "  from public images and custom images, which are used primarily to create instances",
            "  or configure instance templates. Snapshots are useful for periodic backup of the",
            "  data on your persistent disks. You can create snapshots from persistent disks even",
            "  while they are attached to running instances.",
            "- Snapshots are incremental, so you can create regular snapshots on a persistent disk",
            "  faster and at a much lower cost than if you regularly created a full image of the",
            "  disk.",
            "short_description: Creates a GCP Snapshot",
            "version_added: 2.9",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  name:",
            "    description:",
            "    - Name of the resource; provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource.",
            "    required: false",
            "    type: str",
            "  labels:",
            "    description:",
            "    - Labels to apply to this Snapshot.",
            "    required: false",
            "    type: dict",
            "  source_disk:",
            "    description:",
            "    - A reference to the disk used to create this snapshot.",
            "    - 'This field represents a link to a Disk resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''name'' and value of",
            "      your resource''s name Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_disk task and then set this source_disk field to \"{{ name-of-resource",
            "      }}\"'",
            "    required: true",
            "    type: dict",
            "  zone:",
            "    description:",
            "    - A reference to the zone where the disk is hosted.",
            "    required: false",
            "    type: str",
            "  snapshot_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the snapshot. Required if the source",
            "      snapshot is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "  source_disk_encryption_key:",
            "    description:",
            "    - The customer-supplied encryption key of the source snapshot. Required if the",
            "      source snapshot is protected by a customer-supplied encryption key.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      raw_key:",
            "        description:",
            "        - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "          base64 to either encrypt or decrypt this resource.",
            "        required: false",
            "        type: str",
            "      kms_key_name:",
            "        description:",
            "        - The name of the encryption key that is stored in Google Cloud KMS.",
            "        required: false",
            "        type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/rest/v1/snapshots)'",
            "- 'Official Documentation: U(https://cloud.google.com/compute/docs/disks/create-snapshots)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a disk",
            "  gcp_compute_disk:",
            "    name: disk-snapshot",
            "    zone: us-central1-a",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: disk",
            "",
            "- name: create a snapshot",
            "  gcp_compute_snapshot:",
            "    name: test_object",
            "    source_disk: \"{{ disk }}\"",
            "    zone: us-central1-a",
            "    labels:",
            "      my_label: value",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "diskSizeGb:",
            "  description:",
            "  - Size of the snapshot, specified in GB.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the resource; provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource.",
            "  returned: success",
            "  type: str",
            "storageBytes:",
            "  description:",
            "  - A size of the the storage used by the snapshot. As snapshots share storage, this",
            "    number is expected to change with snapshot creation/deletion.",
            "  returned: success",
            "  type: int",
            "licenses:",
            "  description:",
            "  - A list of public visible licenses that apply to this snapshot. This can be because",
            "    the original image had licenses attached (such as a Windows image). snapshotEncryptionKey",
            "    nested object Encrypts the snapshot using a customer-supplied encryption key.",
            "  returned: success",
            "  type: list",
            "labels:",
            "  description:",
            "  - Labels to apply to this Snapshot.",
            "  returned: success",
            "  type: dict",
            "labelFingerprint:",
            "  description:",
            "  - The fingerprint used for optimistic locking of this resource. Used internally",
            "    during updates.",
            "  returned: success",
            "  type: str",
            "sourceDisk:",
            "  description:",
            "  - A reference to the disk used to create this snapshot.",
            "  returned: success",
            "  type: dict",
            "zone:",
            "  description:",
            "  - A reference to the zone where the disk is hosted.",
            "  returned: success",
            "  type: str",
            "snapshotEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the snapshot. Required if the source snapshot",
            "    is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    sha256:",
            "      description:",
            "      - The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption",
            "        key that protects this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "sourceDiskEncryptionKey:",
            "  description:",
            "  - The customer-supplied encryption key of the source snapshot. Required if the source",
            "    snapshot is protected by a customer-supplied encryption key.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    rawKey:",
            "      description:",
            "      - Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648",
            "        base64 to either encrypt or decrypt this resource.",
            "      returned: success",
            "      type: str",
            "    kmsKeyName:",
            "      description:",
            "      - The name of the encryption key that is stored in Google Cloud KMS.",
            "      returned: success",
            "      type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import re",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            name=dict(required=True, type='str'),",
            "            description=dict(type='str'),",
            "            labels=dict(type='dict'),",
            "            source_disk=dict(required=True, type='dict'),",
            "            zone=dict(type='str'),",
            "            snapshot_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),",
            "            source_disk_encryption_key=dict(type='dict', options=dict(raw_key=dict(type='str', no_log=True), kms_key_name=dict(type='str'))),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#snapshot'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, create_link(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    update_fields(module, resource_to_request(module), response_to_hash(module, fetch))",
            "    return fetch_resource(module, self_link(module), kind)",
            "",
            "",
            "def update_fields(module, request, response):",
            "    if response.get('labels') != request.get('labels'):",
            "        labels_update(module, request, response)",
            "",
            "",
            "def labels_update(module, request, response):",
            "    auth = GcpSession(module, 'compute')",
            "    auth.post(",
            "        ''.join([\"https://www.googleapis.com/compute/v1/\", \"projects/{project}/global/snapshots/{name}/setLabels\"]).format(**module.params),",
            "        {u'labels': module.params.get('labels'), u'labelFingerprint': response.get('labelFingerprint')},",
            "    )",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#snapshot',",
            "        u'sourceDisk': replace_resource_dict(module.params.get(u'source_disk', {}), 'name'),",
            "        u'zone': module.params.get('zone'),",
            "        u'name': module.params.get('name'),",
            "        u'description': module.params.get('description'),",
            "        u'labels': module.params.get('labels'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/snapshots/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/snapshots\".format(**module.params)",
            "",
            "",
            "def create_link(module):",
            "    res = {'project': module.params['project'], 'zone': module.params['zone'], 'source_disk': replace_resource_dict(module.params['source_disk'], 'name')}",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/disks/{source_disk}/createSnapshot\".format(**res)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'id': response.get(u'id'),",
            "        u'diskSizeGb': response.get(u'diskSizeGb'),",
            "        u'name': module.params.get('name'),",
            "        u'description': module.params.get('description'),",
            "        u'storageBytes': response.get(u'storageBytes'),",
            "        u'licenses': response.get(u'licenses'),",
            "        u'labels': response.get(u'labels'),",
            "        u'labelFingerprint': response.get(u'labelFingerprint'),",
            "    }",
            "",
            "",
            "def license_selflink(name, params):",
            "    if name is None:",
            "        return",
            "    url = r\"https://www.googleapis.com/compute/v1//projects/.*/global/licenses/.*\"",
            "    if not re.match(url, name):",
            "        name = \"https://www.googleapis.com/compute/v1//projects/{project}/global/licenses/%s\".format(**params) % name",
            "    return name",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#snapshot')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = navigate_hash(op_result, ['selfLink'])",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class SnapshotSnapshotencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "class SnapshotSourcediskencryptionkey(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get('raw_key'), u'kmsKeyName': self.request.get('kms_key_name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'rawKey': self.request.get(u'rawKey'), u'kmsKeyName': self.request.get(u'kmsKeyName')})",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "294": [
                "main"
            ],
            "295": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_ssl_certificate.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "             certificate=dict(required=True, type='str'),"
            },
            "1": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             description=dict(type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "             name=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            private_key=dict(required=True, type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+            private_key=dict(required=True, type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         )"
            },
            "6": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     )"
            },
            "7": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_ssl_certificate",
            "description:",
            "- An SslCertificate resource, used for HTTPS load balancing. This resource provides",
            "  a mechanism to upload an SSL key and certificate to the load balancer to serve secure",
            "  connections from the user.",
            "short_description: Creates a GCP SslCertificate",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  certificate:",
            "    description:",
            "    - The certificate in PEM format.",
            "    - The certificate chain must be no greater than 5 certs long.",
            "    - The chain must include at least one intermediate cert.",
            "    required: true",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource.",
            "    required: false",
            "    type: str",
            "  name:",
            "    description:",
            "    - Name of the resource. Provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: false",
            "    type: str",
            "  private_key:",
            "    description:",
            "    - The write-only private key in PEM format.",
            "    required: true",
            "    type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/rest/v1/sslCertificates)'",
            "- 'Official Documentation: U(https://cloud.google.com/load-balancing/docs/ssl-certificates)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a SSL certificate",
            "  gcp_compute_ssl_certificate:",
            "    name: test_object",
            "    description: A certificate for testing. Do not use this certificate in production",
            "    certificate: |-",
            "      -----BEGIN CERTIFICATE-----",
            "      MIICqjCCAk+gAwIBAgIJAIuJ+0352Kq4MAoGCCqGSM49BAMCMIGwMQswCQYDVQQG",
            "      EwJVUzETMBEGA1UECAwKV2FzaGluZ3RvbjERMA8GA1UEBwwIS2lya2xhbmQxFTAT",
            "      BgNVBAoMDEdvb2dsZSwgSW5jLjEeMBwGA1UECwwVR29vZ2xlIENsb3VkIFBsYXRm",
            "      b3JtMR8wHQYDVQQDDBZ3d3cubXktc2VjdXJlLXNpdGUuY29tMSEwHwYJKoZIhvcN",
            "      AQkBFhJuZWxzb25hQGdvb2dsZS5jb20wHhcNMTcwNjI4MDQ1NjI2WhcNMjcwNjI2",
            "      MDQ1NjI2WjCBsDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldhc2hpbmd0b24xETAP",
            "      BgNVBAcMCEtpcmtsYW5kMRUwEwYDVQQKDAxHb29nbGUsIEluYy4xHjAcBgNVBAsM",
            "      FUdvb2dsZSBDbG91ZCBQbGF0Zm9ybTEfMB0GA1UEAwwWd3d3Lm15LXNlY3VyZS1z",
            "      aXRlLmNvbTEhMB8GCSqGSIb3DQEJARYSbmVsc29uYUBnb29nbGUuY29tMFkwEwYH",
            "      KoZIzj0CAQYIKoZIzj0DAQcDQgAEHGzpcRJ4XzfBJCCPMQeXQpTXwlblimODQCuQ",
            "      4mzkzTv0dXyB750fOGN02HtkpBOZzzvUARTR10JQoSe2/5PIwaNQME4wHQYDVR0O",
            "      BBYEFKIQC3A2SDpxcdfn0YLKineDNq/BMB8GA1UdIwQYMBaAFKIQC3A2SDpxcdfn",
            "      0YLKineDNq/BMAwGA1UdEwQFMAMBAf8wCgYIKoZIzj0EAwIDSQAwRgIhALs4vy+O",
            "      M3jcqgA4fSW/oKw6UJxp+M6a+nGMX+UJR3YgAiEAvvl39QRVAiv84hdoCuyON0lJ",
            "      zqGNhIPGq2ULqXKK8BY=",
            "      -----END CERTIFICATE-----",
            "    private_key: |-",
            "      -----BEGIN EC PRIVATE KEY-----",
            "      MHcCAQEEIObtRo8tkUqoMjeHhsOh2ouPpXCgBcP+EDxZCB/tws15oAoGCCqGSM49",
            "      AwEHoUQDQgAEHGzpcRJ4XzfBJCCPMQeXQpTXwlblimODQCuQ4mzkzTv0dXyB750f",
            "      OGN02HtkpBOZzzvUARTR10JQoSe2/5PIwQ==",
            "      -----END EC PRIVATE KEY-----",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "certificate:",
            "  description:",
            "  - The certificate in PEM format.",
            "  - The certificate chain must be no greater than 5 certs long.",
            "  - The chain must include at least one intermediate cert.",
            "  returned: success",
            "  type: str",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the resource. Provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "privateKey:",
            "  description:",
            "  - The write-only private key in PEM format.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            certificate=dict(required=True, type='str'),",
            "            description=dict(type='str'),",
            "            name=dict(type='str'),",
            "            private_key=dict(required=True, type='str'),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#sslCertificate'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind):",
            "    delete(module, self_link(module), kind)",
            "    create(module, collection(module), kind)",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#sslCertificate',",
            "        u'certificate': module.params.get('certificate'),",
            "        u'description': module.params.get('description'),",
            "        u'name': module.params.get('name'),",
            "        u'privateKey': module.params.get('private_key'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/sslCertificates/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/sslCertificates\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'certificate': response.get(u'certificate'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'description': response.get(u'description'),",
            "        u'id': response.get(u'id'),",
            "        u'name': response.get(u'name'),",
            "        u'privateKey': module.params.get('private_key'),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#sslCertificate')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_ssl_certificate",
            "description:",
            "- An SslCertificate resource, used for HTTPS load balancing. This resource provides",
            "  a mechanism to upload an SSL key and certificate to the load balancer to serve secure",
            "  connections from the user.",
            "short_description: Creates a GCP SslCertificate",
            "version_added: 2.6",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  certificate:",
            "    description:",
            "    - The certificate in PEM format.",
            "    - The certificate chain must be no greater than 5 certs long.",
            "    - The chain must include at least one intermediate cert.",
            "    required: true",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource.",
            "    required: false",
            "    type: str",
            "  name:",
            "    description:",
            "    - Name of the resource. Provided by the client when the resource is created. The",
            "      name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "      which means the first character must be a lowercase letter, and all following",
            "      characters must be a dash, lowercase letter, or digit, except the last character,",
            "      which cannot be a dash.",
            "    required: false",
            "    type: str",
            "  private_key:",
            "    description:",
            "    - The write-only private key in PEM format.",
            "    required: true",
            "    type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/rest/v1/sslCertificates)'",
            "- 'Official Documentation: U(https://cloud.google.com/load-balancing/docs/ssl-certificates)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a SSL certificate",
            "  gcp_compute_ssl_certificate:",
            "    name: test_object",
            "    description: A certificate for testing. Do not use this certificate in production",
            "    certificate: |-",
            "      -----BEGIN CERTIFICATE-----",
            "      MIICqjCCAk+gAwIBAgIJAIuJ+0352Kq4MAoGCCqGSM49BAMCMIGwMQswCQYDVQQG",
            "      EwJVUzETMBEGA1UECAwKV2FzaGluZ3RvbjERMA8GA1UEBwwIS2lya2xhbmQxFTAT",
            "      BgNVBAoMDEdvb2dsZSwgSW5jLjEeMBwGA1UECwwVR29vZ2xlIENsb3VkIFBsYXRm",
            "      b3JtMR8wHQYDVQQDDBZ3d3cubXktc2VjdXJlLXNpdGUuY29tMSEwHwYJKoZIhvcN",
            "      AQkBFhJuZWxzb25hQGdvb2dsZS5jb20wHhcNMTcwNjI4MDQ1NjI2WhcNMjcwNjI2",
            "      MDQ1NjI2WjCBsDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldhc2hpbmd0b24xETAP",
            "      BgNVBAcMCEtpcmtsYW5kMRUwEwYDVQQKDAxHb29nbGUsIEluYy4xHjAcBgNVBAsM",
            "      FUdvb2dsZSBDbG91ZCBQbGF0Zm9ybTEfMB0GA1UEAwwWd3d3Lm15LXNlY3VyZS1z",
            "      aXRlLmNvbTEhMB8GCSqGSIb3DQEJARYSbmVsc29uYUBnb29nbGUuY29tMFkwEwYH",
            "      KoZIzj0CAQYIKoZIzj0DAQcDQgAEHGzpcRJ4XzfBJCCPMQeXQpTXwlblimODQCuQ",
            "      4mzkzTv0dXyB750fOGN02HtkpBOZzzvUARTR10JQoSe2/5PIwaNQME4wHQYDVR0O",
            "      BBYEFKIQC3A2SDpxcdfn0YLKineDNq/BMB8GA1UdIwQYMBaAFKIQC3A2SDpxcdfn",
            "      0YLKineDNq/BMAwGA1UdEwQFMAMBAf8wCgYIKoZIzj0EAwIDSQAwRgIhALs4vy+O",
            "      M3jcqgA4fSW/oKw6UJxp+M6a+nGMX+UJR3YgAiEAvvl39QRVAiv84hdoCuyON0lJ",
            "      zqGNhIPGq2ULqXKK8BY=",
            "      -----END CERTIFICATE-----",
            "    private_key: |-",
            "      -----BEGIN EC PRIVATE KEY-----",
            "      MHcCAQEEIObtRo8tkUqoMjeHhsOh2ouPpXCgBcP+EDxZCB/tws15oAoGCCqGSM49",
            "      AwEHoUQDQgAEHGzpcRJ4XzfBJCCPMQeXQpTXwlblimODQCuQ4mzkzTv0dXyB750f",
            "      OGN02HtkpBOZzzvUARTR10JQoSe2/5PIwQ==",
            "      -----END EC PRIVATE KEY-----",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "certificate:",
            "  description:",
            "  - The certificate in PEM format.",
            "  - The certificate chain must be no greater than 5 certs long.",
            "  - The chain must include at least one intermediate cert.",
            "  returned: success",
            "  type: str",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource.",
            "  returned: success",
            "  type: str",
            "id:",
            "  description:",
            "  - The unique identifier for the resource.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the resource. Provided by the client when the resource is created. The",
            "    name must be 1-63 characters long, and comply with RFC1035. Specifically, the",
            "    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`",
            "    which means the first character must be a lowercase letter, and all following",
            "    characters must be a dash, lowercase letter, or digit, except the last character,",
            "    which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "privateKey:",
            "  description:",
            "  - The write-only private key in PEM format.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            certificate=dict(required=True, type='str'),",
            "            description=dict(type='str'),",
            "            name=dict(type='str'),",
            "            private_key=dict(required=True, type='str', no_log=True),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#sslCertificate'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind):",
            "    delete(module, self_link(module), kind)",
            "    create(module, collection(module), kind)",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#sslCertificate',",
            "        u'certificate': module.params.get('certificate'),",
            "        u'description': module.params.get('description'),",
            "        u'name': module.params.get('name'),",
            "        u'privateKey': module.params.get('private_key'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/sslCertificates/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/global/sslCertificates\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'certificate': response.get(u'certificate'),",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'description': response.get(u'description'),",
            "        u'id': response.get(u'id'),",
            "        u'name': response.get(u'name'),",
            "        u'privateKey': module.params.get('private_key'),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#sslCertificate')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "183": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_compute_vpn_tunnel.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "             target_vpn_gateway=dict(type='dict'),"
            },
            "1": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "             router=dict(type='dict'),"
            },
            "2": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "             peer_ip=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            shared_secret=dict(required=True, type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+            shared_secret=dict(required=True, type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "             ike_version=dict(default=2, type='int'),"
            },
            "6": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "             local_traffic_selector=dict(type='list', elements='str'),"
            },
            "7": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "             remote_traffic_selector=dict(type='list', elements='str'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_vpn_tunnel",
            "description:",
            "- VPN tunnel resource.",
            "short_description: Creates a GCP VpnTunnel",
            "version_added: 2.7",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  name:",
            "    description:",
            "    - Name of the resource. The name must be 1-63 characters long, and comply with",
            "      RFC1035. Specifically, the name must be 1-63 characters long and match the regular",
            "      expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must",
            "      be a lowercase letter, and all following characters must be a dash, lowercase",
            "      letter, or digit, except the last character, which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource.",
            "    required: false",
            "    type: str",
            "  target_vpn_gateway:",
            "    description:",
            "    - URL of the Target VPN gateway with which this VPN tunnel is associated.",
            "    - 'This field represents a link to a TargetVpnGateway resource in GCP. It can",
            "      be specified in two ways. First, you can place a dictionary with key ''selfLink''",
            "      and value of your resource''s selfLink Alternatively, you can add `register:",
            "      name-of-resource` to a gcp_compute_target_vpn_gateway task and then set this",
            "      target_vpn_gateway field to \"{{ name-of-resource }}\"'",
            "    required: false",
            "    type: dict",
            "  router:",
            "    description:",
            "    - URL of router resource to be used for dynamic routing.",
            "    - 'This field represents a link to a Router resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''selfLink'' and value",
            "      of your resource''s selfLink Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_router task and then set this router field to \"{{ name-of-resource",
            "      }}\"'",
            "    required: false",
            "    type: dict",
            "  peer_ip:",
            "    description:",
            "    - IP address of the peer VPN gateway. Only IPv4 is supported.",
            "    required: false",
            "    type: str",
            "  shared_secret:",
            "    description:",
            "    - Shared secret used to set the secure session between the Cloud VPN gateway and",
            "      the peer VPN gateway.",
            "    required: true",
            "    type: str",
            "  ike_version:",
            "    description:",
            "    - IKE protocol version to use when establishing the VPN tunnel with peer VPN gateway.",
            "    - Acceptable IKE versions are 1 or 2. Default version is 2.",
            "    required: false",
            "    default: '2'",
            "    type: int",
            "  local_traffic_selector:",
            "    description:",
            "    - Local traffic selector to use when establishing the VPN tunnel with peer VPN",
            "      gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`.",
            "      The ranges should be disjoint.",
            "    - Only IPv4 is supported.",
            "    required: false",
            "    type: list",
            "  remote_traffic_selector:",
            "    description:",
            "    - Remote traffic selector to use when establishing the VPN tunnel with peer VPN",
            "      gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`.",
            "      The ranges should be disjoint.",
            "    - Only IPv4 is supported.",
            "    required: false",
            "    type: list",
            "  region:",
            "    description:",
            "    - The region where the tunnel is located.",
            "    required: true",
            "    type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/rest/v1/vpnTunnels)'",
            "- 'Cloud VPN Overview: U(https://cloud.google.com/vpn/docs/concepts/overview)'",
            "- 'Networks and Tunnel Routing: U(https://cloud.google.com/vpn/docs/concepts/choosing-networks-routing)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a network",
            "  gcp_compute_network:",
            "    name: network-vpn-tunnel",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: network",
            "",
            "- name: create a router",
            "  gcp_compute_router:",
            "    name: router-vpn-tunnel",
            "    network: \"{{ network }}\"",
            "    bgp:",
            "      asn: 64514",
            "      advertise_mode: CUSTOM",
            "      advertised_groups:",
            "      - ALL_SUBNETS",
            "      advertised_ip_ranges:",
            "      - range: 1.2.3.4",
            "      - range: 6.7.0.0/16",
            "    region: us-central1",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: router",
            "",
            "- name: create a target vpn gateway",
            "  gcp_compute_target_vpn_gateway:",
            "    name: gateway-vpn-tunnel",
            "    region: us-west1",
            "    network: \"{{ network }}\"",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: gateway",
            "",
            "- name: create a vpn tunnel",
            "  gcp_compute_vpn_tunnel:",
            "    name: test_object",
            "    region: us-west1",
            "    target_vpn_gateway: \"{{ gateway }}\"",
            "    router: \"{{ router }}\"",
            "    shared_secret: super secret",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "name:",
            "  description:",
            "  - Name of the resource. The name must be 1-63 characters long, and comply with RFC1035.",
            "    Specifically, the name must be 1-63 characters long and match the regular expression",
            "    `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase",
            "    letter, and all following characters must be a dash, lowercase letter, or digit,",
            "    except the last character, which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource.",
            "  returned: success",
            "  type: str",
            "targetVpnGateway:",
            "  description:",
            "  - URL of the Target VPN gateway with which this VPN tunnel is associated.",
            "  returned: success",
            "  type: dict",
            "router:",
            "  description:",
            "  - URL of router resource to be used for dynamic routing.",
            "  returned: success",
            "  type: dict",
            "peerIp:",
            "  description:",
            "  - IP address of the peer VPN gateway. Only IPv4 is supported.",
            "  returned: success",
            "  type: str",
            "sharedSecret:",
            "  description:",
            "  - Shared secret used to set the secure session between the Cloud VPN gateway and",
            "    the peer VPN gateway.",
            "  returned: success",
            "  type: str",
            "sharedSecretHash:",
            "  description:",
            "  - Hash of the shared secret.",
            "  returned: success",
            "  type: str",
            "ikeVersion:",
            "  description:",
            "  - IKE protocol version to use when establishing the VPN tunnel with peer VPN gateway.",
            "  - Acceptable IKE versions are 1 or 2. Default version is 2.",
            "  returned: success",
            "  type: int",
            "localTrafficSelector:",
            "  description:",
            "  - Local traffic selector to use when establishing the VPN tunnel with peer VPN gateway.",
            "    The value should be a CIDR formatted string, for example `192.168.0.0/16`. The",
            "    ranges should be disjoint.",
            "  - Only IPv4 is supported.",
            "  returned: success",
            "  type: list",
            "remoteTrafficSelector:",
            "  description:",
            "  - Remote traffic selector to use when establishing the VPN tunnel with peer VPN",
            "    gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`.",
            "    The ranges should be disjoint.",
            "  - Only IPv4 is supported.",
            "  returned: success",
            "  type: list",
            "region:",
            "  description:",
            "  - The region where the tunnel is located.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            name=dict(required=True, type='str'),",
            "            description=dict(type='str'),",
            "            target_vpn_gateway=dict(type='dict'),",
            "            router=dict(type='dict'),",
            "            peer_ip=dict(type='str'),",
            "            shared_secret=dict(required=True, type='str'),",
            "            ike_version=dict(default=2, type='int'),",
            "            local_traffic_selector=dict(type='list', elements='str'),",
            "            remote_traffic_selector=dict(type='list', elements='str'),",
            "            region=dict(required=True, type='str'),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#vpnTunnel'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind):",
            "    delete(module, self_link(module), kind)",
            "    create(module, collection(module), kind)",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#vpnTunnel',",
            "        u'name': module.params.get('name'),",
            "        u'description': module.params.get('description'),",
            "        u'targetVpnGateway': replace_resource_dict(module.params.get(u'target_vpn_gateway', {}), 'selfLink'),",
            "        u'router': replace_resource_dict(module.params.get(u'router', {}), 'selfLink'),",
            "        u'peerIp': module.params.get('peer_ip'),",
            "        u'sharedSecret': module.params.get('shared_secret'),",
            "        u'ikeVersion': module.params.get('ike_version'),",
            "        u'localTrafficSelector': module.params.get('local_traffic_selector'),",
            "        u'remoteTrafficSelector': module.params.get('remote_traffic_selector'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/vpnTunnels/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/vpnTunnels\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'name': response.get(u'name'),",
            "        u'description': module.params.get('description'),",
            "        u'targetVpnGateway': replace_resource_dict(module.params.get(u'target_vpn_gateway', {}), 'selfLink'),",
            "        u'router': replace_resource_dict(module.params.get(u'router', {}), 'selfLink'),",
            "        u'peerIp': response.get(u'peerIp'),",
            "        u'sharedSecret': response.get(u'sharedSecret'),",
            "        u'sharedSecretHash': response.get(u'sharedSecretHash'),",
            "        u'ikeVersion': response.get(u'ikeVersion'),",
            "        u'localTrafficSelector': response.get(u'localTrafficSelector'),",
            "        u'remoteTrafficSelector': response.get(u'remoteTrafficSelector'),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#vpnTunnel')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_compute_vpn_tunnel",
            "description:",
            "- VPN tunnel resource.",
            "short_description: Creates a GCP VpnTunnel",
            "version_added: 2.7",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  name:",
            "    description:",
            "    - Name of the resource. The name must be 1-63 characters long, and comply with",
            "      RFC1035. Specifically, the name must be 1-63 characters long and match the regular",
            "      expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must",
            "      be a lowercase letter, and all following characters must be a dash, lowercase",
            "      letter, or digit, except the last character, which cannot be a dash.",
            "    required: true",
            "    type: str",
            "  description:",
            "    description:",
            "    - An optional description of this resource.",
            "    required: false",
            "    type: str",
            "  target_vpn_gateway:",
            "    description:",
            "    - URL of the Target VPN gateway with which this VPN tunnel is associated.",
            "    - 'This field represents a link to a TargetVpnGateway resource in GCP. It can",
            "      be specified in two ways. First, you can place a dictionary with key ''selfLink''",
            "      and value of your resource''s selfLink Alternatively, you can add `register:",
            "      name-of-resource` to a gcp_compute_target_vpn_gateway task and then set this",
            "      target_vpn_gateway field to \"{{ name-of-resource }}\"'",
            "    required: false",
            "    type: dict",
            "  router:",
            "    description:",
            "    - URL of router resource to be used for dynamic routing.",
            "    - 'This field represents a link to a Router resource in GCP. It can be specified",
            "      in two ways. First, you can place a dictionary with key ''selfLink'' and value",
            "      of your resource''s selfLink Alternatively, you can add `register: name-of-resource`",
            "      to a gcp_compute_router task and then set this router field to \"{{ name-of-resource",
            "      }}\"'",
            "    required: false",
            "    type: dict",
            "  peer_ip:",
            "    description:",
            "    - IP address of the peer VPN gateway. Only IPv4 is supported.",
            "    required: false",
            "    type: str",
            "  shared_secret:",
            "    description:",
            "    - Shared secret used to set the secure session between the Cloud VPN gateway and",
            "      the peer VPN gateway.",
            "    required: true",
            "    type: str",
            "  ike_version:",
            "    description:",
            "    - IKE protocol version to use when establishing the VPN tunnel with peer VPN gateway.",
            "    - Acceptable IKE versions are 1 or 2. Default version is 2.",
            "    required: false",
            "    default: '2'",
            "    type: int",
            "  local_traffic_selector:",
            "    description:",
            "    - Local traffic selector to use when establishing the VPN tunnel with peer VPN",
            "      gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`.",
            "      The ranges should be disjoint.",
            "    - Only IPv4 is supported.",
            "    required: false",
            "    type: list",
            "  remote_traffic_selector:",
            "    description:",
            "    - Remote traffic selector to use when establishing the VPN tunnel with peer VPN",
            "      gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`.",
            "      The ranges should be disjoint.",
            "    - Only IPv4 is supported.",
            "    required: false",
            "    type: list",
            "  region:",
            "    description:",
            "    - The region where the tunnel is located.",
            "    required: true",
            "    type: str",
            "extends_documentation_fragment: gcp",
            "notes:",
            "- 'API Reference: U(https://cloud.google.com/compute/docs/reference/rest/v1/vpnTunnels)'",
            "- 'Cloud VPN Overview: U(https://cloud.google.com/vpn/docs/concepts/overview)'",
            "- 'Networks and Tunnel Routing: U(https://cloud.google.com/vpn/docs/concepts/choosing-networks-routing)'",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a network",
            "  gcp_compute_network:",
            "    name: network-vpn-tunnel",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: network",
            "",
            "- name: create a router",
            "  gcp_compute_router:",
            "    name: router-vpn-tunnel",
            "    network: \"{{ network }}\"",
            "    bgp:",
            "      asn: 64514",
            "      advertise_mode: CUSTOM",
            "      advertised_groups:",
            "      - ALL_SUBNETS",
            "      advertised_ip_ranges:",
            "      - range: 1.2.3.4",
            "      - range: 6.7.0.0/16",
            "    region: us-central1",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: router",
            "",
            "- name: create a target vpn gateway",
            "  gcp_compute_target_vpn_gateway:",
            "    name: gateway-vpn-tunnel",
            "    region: us-west1",
            "    network: \"{{ network }}\"",
            "    project: \"{{ gcp_project }}\"",
            "    auth_kind: \"{{ gcp_cred_kind }}\"",
            "    service_account_file: \"{{ gcp_cred_file }}\"",
            "    state: present",
            "  register: gateway",
            "",
            "- name: create a vpn tunnel",
            "  gcp_compute_vpn_tunnel:",
            "    name: test_object",
            "    region: us-west1",
            "    target_vpn_gateway: \"{{ gateway }}\"",
            "    router: \"{{ router }}\"",
            "    shared_secret: super secret",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "creationTimestamp:",
            "  description:",
            "  - Creation timestamp in RFC3339 text format.",
            "  returned: success",
            "  type: str",
            "name:",
            "  description:",
            "  - Name of the resource. The name must be 1-63 characters long, and comply with RFC1035.",
            "    Specifically, the name must be 1-63 characters long and match the regular expression",
            "    `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase",
            "    letter, and all following characters must be a dash, lowercase letter, or digit,",
            "    except the last character, which cannot be a dash.",
            "  returned: success",
            "  type: str",
            "description:",
            "  description:",
            "  - An optional description of this resource.",
            "  returned: success",
            "  type: str",
            "targetVpnGateway:",
            "  description:",
            "  - URL of the Target VPN gateway with which this VPN tunnel is associated.",
            "  returned: success",
            "  type: dict",
            "router:",
            "  description:",
            "  - URL of router resource to be used for dynamic routing.",
            "  returned: success",
            "  type: dict",
            "peerIp:",
            "  description:",
            "  - IP address of the peer VPN gateway. Only IPv4 is supported.",
            "  returned: success",
            "  type: str",
            "sharedSecret:",
            "  description:",
            "  - Shared secret used to set the secure session between the Cloud VPN gateway and",
            "    the peer VPN gateway.",
            "  returned: success",
            "  type: str",
            "sharedSecretHash:",
            "  description:",
            "  - Hash of the shared secret.",
            "  returned: success",
            "  type: str",
            "ikeVersion:",
            "  description:",
            "  - IKE protocol version to use when establishing the VPN tunnel with peer VPN gateway.",
            "  - Acceptable IKE versions are 1 or 2. Default version is 2.",
            "  returned: success",
            "  type: int",
            "localTrafficSelector:",
            "  description:",
            "  - Local traffic selector to use when establishing the VPN tunnel with peer VPN gateway.",
            "    The value should be a CIDR formatted string, for example `192.168.0.0/16`. The",
            "    ranges should be disjoint.",
            "  - Only IPv4 is supported.",
            "  returned: success",
            "  type: list",
            "remoteTrafficSelector:",
            "  description:",
            "  - Remote traffic selector to use when establishing the VPN tunnel with peer VPN",
            "    gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`.",
            "    The ranges should be disjoint.",
            "  - Only IPv4 is supported.",
            "  returned: success",
            "  type: list",
            "region:",
            "  description:",
            "  - The region where the tunnel is located.",
            "  returned: success",
            "  type: str",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            name=dict(required=True, type='str'),",
            "            description=dict(type='str'),",
            "            target_vpn_gateway=dict(type='dict'),",
            "            router=dict(type='dict'),",
            "            peer_ip=dict(type='str'),",
            "            shared_secret=dict(required=True, type='str', no_log=True),",
            "            ike_version=dict(default=2, type='int'),",
            "            local_traffic_selector=dict(type='list', elements='str'),",
            "            remote_traffic_selector=dict(type='list', elements='str'),",
            "            region=dict(required=True, type='str'),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/compute']",
            "",
            "    state = module.params['state']",
            "    kind = 'compute#vpnTunnel'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind):",
            "    delete(module, self_link(module), kind)",
            "    create(module, collection(module), kind)",
            "",
            "",
            "def delete(module, link, kind):",
            "    auth = GcpSession(module, 'compute')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'compute#vpnTunnel',",
            "        u'name': module.params.get('name'),",
            "        u'description': module.params.get('description'),",
            "        u'targetVpnGateway': replace_resource_dict(module.params.get(u'target_vpn_gateway', {}), 'selfLink'),",
            "        u'router': replace_resource_dict(module.params.get(u'router', {}), 'selfLink'),",
            "        u'peerIp': module.params.get('peer_ip'),",
            "        u'sharedSecret': module.params.get('shared_secret'),",
            "        u'ikeVersion': module.params.get('ike_version'),",
            "        u'localTrafficSelector': module.params.get('local_traffic_selector'),",
            "        u'remoteTrafficSelector': module.params.get('remote_traffic_selector'),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'compute')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/vpnTunnels/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/vpnTunnels\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    try:",
            "        module.raise_for_status(response)",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError):",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % response.text)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'creationTimestamp': response.get(u'creationTimestamp'),",
            "        u'name': response.get(u'name'),",
            "        u'description': module.params.get('description'),",
            "        u'targetVpnGateway': replace_resource_dict(module.params.get(u'target_vpn_gateway', {}), 'selfLink'),",
            "        u'router': replace_resource_dict(module.params.get(u'router', {}), 'selfLink'),",
            "        u'peerIp': response.get(u'peerIp'),",
            "        u'sharedSecret': response.get(u'sharedSecret'),",
            "        u'sharedSecretHash': response.get(u'sharedSecretHash'),",
            "        u'ikeVersion': response.get(u'ikeVersion'),",
            "        u'localTrafficSelector': response.get(u'localTrafficSelector'),",
            "        u'remoteTrafficSelector': response.get(u'remoteTrafficSelector'),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'compute#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'compute#vpnTunnel')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'compute#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "283": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/cloud/google/gcp_sql_instance.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 688,
                "afterPatchRowNumber": 688,
                "PatchRowcode": "                         options=dict("
            },
            "1": {
                "beforePatchRowNumber": 689,
                "afterPatchRowNumber": 689,
                "PatchRowcode": "                             ca_certificate=dict(type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 690,
                "afterPatchRowNumber": 690,
                "PatchRowcode": "                             client_certificate=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 691,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            client_key=dict(type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 691,
                "PatchRowcode": "+                            client_key=dict(type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 692,
                "afterPatchRowNumber": 692,
                "PatchRowcode": "                             connect_retry_interval=dict(type='int'),"
            },
            "6": {
                "beforePatchRowNumber": 693,
                "afterPatchRowNumber": 693,
                "PatchRowcode": "                             dump_file_path=dict(type='str'),"
            },
            "7": {
                "beforePatchRowNumber": 694,
                "afterPatchRowNumber": 694,
                "PatchRowcode": "                             master_heartbeat_period=dict(type='int'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_sql_instance",
            "description:",
            "- Represents a Cloud SQL instance. Cloud SQL instances are SQL databases hosted in",
            "  Google's cloud. The Instances resource provides methods for common configuration",
            "  and management tasks.",
            "short_description: Creates a GCP Instance",
            "version_added: 2.7",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  backend_type:",
            "    description:",
            "    - \"* FIRST_GEN: First Generation instance. MySQL only.\"",
            "    - \"* SECOND_GEN: Second Generation instance or PostgreSQL instance.\"",
            "    - \"* EXTERNAL: A database server that is not managed by Google.\"",
            "    - 'Some valid choices include: \"FIRST_GEN\", \"SECOND_GEN\", \"EXTERNAL\"'",
            "    required: false",
            "    type: str",
            "  connection_name:",
            "    description:",
            "    - Connection name of the Cloud SQL instance used in connection strings.",
            "    required: false",
            "    type: str",
            "  database_version:",
            "    description:",
            "    - The database engine type and version. For First Generation instances, can be",
            "      MYSQL_5_5, or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or",
            "      MYSQL_5_7. Defaults to MYSQL_5_6.",
            "    - 'PostgreSQL instances: POSTGRES_9_6 The databaseVersion property can not be",
            "      changed after instance creation.'",
            "    - 'Some valid choices include: \"MYSQL_5_5\", \"MYSQL_5_6\", \"MYSQL_5_7\", \"POSTGRES_9_6\"'",
            "    required: false",
            "    type: str",
            "  failover_replica:",
            "    description:",
            "    - The name and status of the failover replica. This property is applicable only",
            "      to Second Generation instances.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      name:",
            "        description:",
            "        - The name of the failover replica. If specified at instance creation, a failover",
            "          replica is created for the instance. The name doesn't include the project",
            "          ID. This property is applicable only to Second Generation instances.",
            "        required: false",
            "        type: str",
            "  instance_type:",
            "    description:",
            "    - The instance type. This can be one of the following.",
            "    - \"* CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating from a master.\"",
            "    - \"* ON_PREMISES_INSTANCE: An instance running on the customer's premises.\"",
            "    - \"* READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a read-replica.\"",
            "    - 'Some valid choices include: \"CLOUD_SQL_INSTANCE\", \"ON_PREMISES_INSTANCE\", \"READ_REPLICA_INSTANCE\"'",
            "    required: false",
            "    type: str",
            "  ipv6_address:",
            "    description:",
            "    - The IPv6 address assigned to the instance. This property is applicable only",
            "      to First Generation instances.",
            "    required: false",
            "    type: str",
            "  master_instance_name:",
            "    description:",
            "    - The name of the instance which will act as master in the replication setup.",
            "    required: false",
            "    type: str",
            "  max_disk_size:",
            "    description:",
            "    - The maximum disk size of the instance in bytes.",
            "    required: false",
            "    type: int",
            "  name:",
            "    description:",
            "    - Name of the Cloud SQL instance. This does not include the project ID.",
            "    required: true",
            "    type: str",
            "  region:",
            "    description:",
            "    - The geographical region. Defaults to us-central or us-central1 depending on",
            "      the instance type (First Generation or Second Generation/PostgreSQL).",
            "    required: false",
            "    type: str",
            "  replica_configuration:",
            "    description:",
            "    - Configuration specific to failover replicas and read replicas.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      failover_target:",
            "        description:",
            "        - Specifies if the replica is the failover target. If the field is set to",
            "          true the replica will be designated as a failover replica.",
            "        - In case the master instance fails, the replica instance will be promoted",
            "          as the new master instance.",
            "        - Only one replica can be specified as failover target, and the replica has",
            "          to be in different zone with the master instance.",
            "        required: false",
            "        type: bool",
            "      mysql_replica_configuration:",
            "        description:",
            "        - MySQL specific configuration when replicating from a MySQL on-premises master.",
            "          Replication configuration information such as the username, password, certificates,",
            "          and keys are not stored in the instance metadata. The configuration information",
            "          is used only to set up the replication connection and is stored by MySQL",
            "          in a file named master.info in the data directory.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          ca_certificate:",
            "            description:",
            "            - PEM representation of the trusted CA's x509 certificate.",
            "            required: false",
            "            type: str",
            "          client_certificate:",
            "            description:",
            "            - PEM representation of the slave's x509 certificate .",
            "            required: false",
            "            type: str",
            "          client_key:",
            "            description:",
            "            - PEM representation of the slave's private key. The corresponding public",
            "              key is encoded in the client's certificate.",
            "            required: false",
            "            type: str",
            "          connect_retry_interval:",
            "            description:",
            "            - Seconds to wait between connect retries. MySQL's default is 60 seconds.",
            "            required: false",
            "            type: int",
            "          dump_file_path:",
            "            description:",
            "            - Path to a SQL dump file in Google Cloud Storage from which the slave",
            "              instance is to be created. The URI is in the form gs://bucketName/fileName.",
            "              Compressed gzip files (.gz) are also supported. Dumps should have the",
            "              binlog coordinates from which replication should begin. This can be",
            "              accomplished by setting --master-data to 1 when using mysqldump.",
            "            required: false",
            "            type: str",
            "          master_heartbeat_period:",
            "            description:",
            "            - Interval in milliseconds between replication heartbeats.",
            "            required: false",
            "            type: int",
            "          password:",
            "            description:",
            "            - The password for the replication connection.",
            "            required: false",
            "            type: str",
            "          ssl_cipher:",
            "            description:",
            "            - A list of permissible ciphers to use for SSL encryption.",
            "            required: false",
            "            type: str",
            "          username:",
            "            description:",
            "            - The username for the replication connection.",
            "            required: false",
            "            type: str",
            "          verify_server_certificate:",
            "            description:",
            "            - Whether or not to check the master's Common Name value in the certificate",
            "              that it sends during the SSL handshake.",
            "            required: false",
            "            type: bool",
            "      replica_names:",
            "        description:",
            "        - The replicas of the instance.",
            "        required: false",
            "        type: list",
            "      service_account_email_address:",
            "        description:",
            "        - The service account email address assigned to the instance. This property",
            "          is applicable only to Second Generation instances.",
            "        required: false",
            "        type: str",
            "  settings:",
            "    description:",
            "    - The user settings.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      database_flags:",
            "        description:",
            "        - The database flags passed to the instance at startup.",
            "        required: false",
            "        type: list",
            "        version_added: 2.9",
            "        suboptions:",
            "          name:",
            "            description:",
            "            - The name of the flag. These flags are passed at instance startup, so",
            "              include both server options and system variables for MySQL. Flags should",
            "              be specified with underscores, not hyphens.",
            "            required: false",
            "            type: str",
            "          value:",
            "            description:",
            "            - The value of the flag. Booleans should be set to on for true and off",
            "              for false. This field must be omitted if the flag doesn't take a value.",
            "            required: false",
            "            type: str",
            "      ip_configuration:",
            "        description:",
            "        - The settings for IP Management. This allows to enable or disable the instance",
            "          IP and manage which external networks can connect to the instance. The IPv4",
            "          address cannot be disabled for Second Generation instances.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          ipv4_enabled:",
            "            description:",
            "            - Whether the instance should be assigned an IP address or not.",
            "            required: false",
            "            type: bool",
            "          authorized_networks:",
            "            description:",
            "            - The list of external networks that are allowed to connect to the instance",
            "              using the IP. In CIDR notation, also known as 'slash' notation (e.g.",
            "              192.168.100.0/24).",
            "            required: false",
            "            type: list",
            "            suboptions:",
            "              expiration_time:",
            "                description:",
            "                - The time when this access control entry expires in RFC 3339 format,",
            "                  for example 2012-11-15T16:19:00.094Z.",
            "                required: false",
            "                type: str",
            "              name:",
            "                description:",
            "                - An optional label to identify this entry.",
            "                required: false",
            "                type: str",
            "              value:",
            "                description:",
            "                - The whitelisted value for the access control list. For example,",
            "                  to grant access to a client from an external IP (IPv4 or IPv6) address",
            "                  or subnet, use that address or subnet here.",
            "                required: false",
            "                type: str",
            "          require_ssl:",
            "            description:",
            "            - Whether the mysqld should default to 'REQUIRE X509' for users connecting",
            "              over IP.",
            "            required: false",
            "            type: bool",
            "      tier:",
            "        description:",
            "        - The tier or machine type for this instance, for example db-n1-standard-1.",
            "          For MySQL instances, this field determines whether the instance is Second",
            "          Generation (recommended) or First Generation.",
            "        required: false",
            "        type: str",
            "      availability_type:",
            "        description:",
            "        - The availabilityType define if your postgres instance is run zonal or regional.",
            "        - 'Some valid choices include: \"ZONAL\", \"REGIONAL\"'",
            "        required: false",
            "        type: str",
            "      backup_configuration:",
            "        description:",
            "        - The daily backup configuration for the instance.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          enabled:",
            "            description:",
            "            - Enable Autobackup for your instance.",
            "            required: false",
            "            type: bool",
            "          binary_log_enabled:",
            "            description:",
            "            - Whether binary log is enabled. If backup configuration is disabled,",
            "              binary log must be disabled as well. MySQL only.",
            "            required: false",
            "            type: bool",
            "          start_time:",
            "            description:",
            "            - Define the backup start time in UTC (HH:MM) .",
            "            required: false",
            "            type: str",
            "extends_documentation_fragment: gcp",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a instance",
            "  gcp_sql_instance:",
            "    name: \"{{resource_name}}-2\"",
            "    settings:",
            "      ip_configuration:",
            "        authorized_networks:",
            "        - name: google dns server",
            "          value: 8.8.8.8/32",
            "      tier: db-n1-standard-1",
            "    region: us-central1",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "backendType:",
            "  description:",
            "  - \"* FIRST_GEN: First Generation instance. MySQL only.\"",
            "  - \"* SECOND_GEN: Second Generation instance or PostgreSQL instance.\"",
            "  - \"* EXTERNAL: A database server that is not managed by Google.\"",
            "  returned: success",
            "  type: str",
            "connectionName:",
            "  description:",
            "  - Connection name of the Cloud SQL instance used in connection strings.",
            "  returned: success",
            "  type: str",
            "databaseVersion:",
            "  description:",
            "  - The database engine type and version. For First Generation instances, can be MYSQL_5_5,",
            "    or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or MYSQL_5_7.",
            "    Defaults to MYSQL_5_6.",
            "  - 'PostgreSQL instances: POSTGRES_9_6 The databaseVersion property can not be changed",
            "    after instance creation.'",
            "  returned: success",
            "  type: str",
            "failoverReplica:",
            "  description:",
            "  - The name and status of the failover replica. This property is applicable only",
            "    to Second Generation instances.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    available:",
            "      description:",
            "      - The availability status of the failover replica. A false status indicates",
            "        that the failover replica is out of sync. The master can only failover to",
            "        the failover replica when the status is true.",
            "      returned: success",
            "      type: bool",
            "    name:",
            "      description:",
            "      - The name of the failover replica. If specified at instance creation, a failover",
            "        replica is created for the instance. The name doesn't include the project",
            "        ID. This property is applicable only to Second Generation instances.",
            "      returned: success",
            "      type: str",
            "instanceType:",
            "  description:",
            "  - The instance type. This can be one of the following.",
            "  - \"* CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating from a master.\"",
            "  - \"* ON_PREMISES_INSTANCE: An instance running on the customer's premises.\"",
            "  - \"* READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a read-replica.\"",
            "  returned: success",
            "  type: str",
            "ipAddresses:",
            "  description:",
            "  - The assigned IP addresses for the instance.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    ipAddress:",
            "      description:",
            "      - The IP address assigned.",
            "      returned: success",
            "      type: str",
            "    timeToRetire:",
            "      description:",
            "      - The due time for this IP to be retired in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.",
            "        This field is only available when the IP is scheduled to be retired.",
            "      returned: success",
            "      type: str",
            "    type:",
            "      description:",
            "      - The type of this IP address. A PRIMARY address is an address that can accept",
            "        incoming connections. An OUTGOING address is the source address of connections",
            "        originating from the instance, if supported.",
            "      returned: success",
            "      type: str",
            "ipv6Address:",
            "  description:",
            "  - The IPv6 address assigned to the instance. This property is applicable only to",
            "    First Generation instances.",
            "  returned: success",
            "  type: str",
            "masterInstanceName:",
            "  description:",
            "  - The name of the instance which will act as master in the replication setup.",
            "  returned: success",
            "  type: str",
            "maxDiskSize:",
            "  description:",
            "  - The maximum disk size of the instance in bytes.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the Cloud SQL instance. This does not include the project ID.",
            "  returned: success",
            "  type: str",
            "region:",
            "  description:",
            "  - The geographical region. Defaults to us-central or us-central1 depending on the",
            "    instance type (First Generation or Second Generation/PostgreSQL).",
            "  returned: success",
            "  type: str",
            "replicaConfiguration:",
            "  description:",
            "  - Configuration specific to failover replicas and read replicas.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    failoverTarget:",
            "      description:",
            "      - Specifies if the replica is the failover target. If the field is set to true",
            "        the replica will be designated as a failover replica.",
            "      - In case the master instance fails, the replica instance will be promoted as",
            "        the new master instance.",
            "      - Only one replica can be specified as failover target, and the replica has",
            "        to be in different zone with the master instance.",
            "      returned: success",
            "      type: bool",
            "    mysqlReplicaConfiguration:",
            "      description:",
            "      - MySQL specific configuration when replicating from a MySQL on-premises master.",
            "        Replication configuration information such as the username, password, certificates,",
            "        and keys are not stored in the instance metadata. The configuration information",
            "        is used only to set up the replication connection and is stored by MySQL in",
            "        a file named master.info in the data directory.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        caCertificate:",
            "          description:",
            "          - PEM representation of the trusted CA's x509 certificate.",
            "          returned: success",
            "          type: str",
            "        clientCertificate:",
            "          description:",
            "          - PEM representation of the slave's x509 certificate .",
            "          returned: success",
            "          type: str",
            "        clientKey:",
            "          description:",
            "          - PEM representation of the slave's private key. The corresponding public",
            "            key is encoded in the client's certificate.",
            "          returned: success",
            "          type: str",
            "        connectRetryInterval:",
            "          description:",
            "          - Seconds to wait between connect retries. MySQL's default is 60 seconds.",
            "          returned: success",
            "          type: int",
            "        dumpFilePath:",
            "          description:",
            "          - Path to a SQL dump file in Google Cloud Storage from which the slave instance",
            "            is to be created. The URI is in the form gs://bucketName/fileName. Compressed",
            "            gzip files (.gz) are also supported. Dumps should have the binlog coordinates",
            "            from which replication should begin. This can be accomplished by setting",
            "            --master-data to 1 when using mysqldump.",
            "          returned: success",
            "          type: str",
            "        masterHeartbeatPeriod:",
            "          description:",
            "          - Interval in milliseconds between replication heartbeats.",
            "          returned: success",
            "          type: int",
            "        password:",
            "          description:",
            "          - The password for the replication connection.",
            "          returned: success",
            "          type: str",
            "        sslCipher:",
            "          description:",
            "          - A list of permissible ciphers to use for SSL encryption.",
            "          returned: success",
            "          type: str",
            "        username:",
            "          description:",
            "          - The username for the replication connection.",
            "          returned: success",
            "          type: str",
            "        verifyServerCertificate:",
            "          description:",
            "          - Whether or not to check the master's Common Name value in the certificate",
            "            that it sends during the SSL handshake.",
            "          returned: success",
            "          type: bool",
            "    replicaNames:",
            "      description:",
            "      - The replicas of the instance.",
            "      returned: success",
            "      type: list",
            "    serviceAccountEmailAddress:",
            "      description:",
            "      - The service account email address assigned to the instance. This property",
            "        is applicable only to Second Generation instances.",
            "      returned: success",
            "      type: str",
            "settings:",
            "  description:",
            "  - The user settings.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    databaseFlags:",
            "      description:",
            "      - The database flags passed to the instance at startup.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        name:",
            "          description:",
            "          - The name of the flag. These flags are passed at instance startup, so include",
            "            both server options and system variables for MySQL. Flags should be specified",
            "            with underscores, not hyphens.",
            "          returned: success",
            "          type: str",
            "        value:",
            "          description:",
            "          - The value of the flag. Booleans should be set to on for true and off for",
            "            false. This field must be omitted if the flag doesn't take a value.",
            "          returned: success",
            "          type: str",
            "    ipConfiguration:",
            "      description:",
            "      - The settings for IP Management. This allows to enable or disable the instance",
            "        IP and manage which external networks can connect to the instance. The IPv4",
            "        address cannot be disabled for Second Generation instances.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        ipv4Enabled:",
            "          description:",
            "          - Whether the instance should be assigned an IP address or not.",
            "          returned: success",
            "          type: bool",
            "        authorizedNetworks:",
            "          description:",
            "          - The list of external networks that are allowed to connect to the instance",
            "            using the IP. In CIDR notation, also known as 'slash' notation (e.g. 192.168.100.0/24).",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            expirationTime:",
            "              description:",
            "              - The time when this access control entry expires in RFC 3339 format,",
            "                for example 2012-11-15T16:19:00.094Z.",
            "              returned: success",
            "              type: str",
            "            name:",
            "              description:",
            "              - An optional label to identify this entry.",
            "              returned: success",
            "              type: str",
            "            value:",
            "              description:",
            "              - The whitelisted value for the access control list. For example, to",
            "                grant access to a client from an external IP (IPv4 or IPv6) address",
            "                or subnet, use that address or subnet here.",
            "              returned: success",
            "              type: str",
            "        requireSsl:",
            "          description:",
            "          - Whether the mysqld should default to 'REQUIRE X509' for users connecting",
            "            over IP.",
            "          returned: success",
            "          type: bool",
            "    tier:",
            "      description:",
            "      - The tier or machine type for this instance, for example db-n1-standard-1.",
            "        For MySQL instances, this field determines whether the instance is Second",
            "        Generation (recommended) or First Generation.",
            "      returned: success",
            "      type: str",
            "    availabilityType:",
            "      description:",
            "      - The availabilityType define if your postgres instance is run zonal or regional.",
            "      returned: success",
            "      type: str",
            "    backupConfiguration:",
            "      description:",
            "      - The daily backup configuration for the instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        enabled:",
            "          description:",
            "          - Enable Autobackup for your instance.",
            "          returned: success",
            "          type: bool",
            "        binaryLogEnabled:",
            "          description:",
            "          - Whether binary log is enabled. If backup configuration is disabled, binary",
            "            log must be disabled as well. MySQL only.",
            "          returned: success",
            "          type: bool",
            "        startTime:",
            "          description:",
            "          - Define the backup start time in UTC (HH:MM) .",
            "          returned: success",
            "          type: str",
            "    settingsVersion:",
            "      description:",
            "      - The version of instance settings. This is a required field for update method",
            "        to make sure concurrent updates are handled properly. During update, use the",
            "        most recent settingsVersion value for this instance and do not try to update",
            "        this value.",
            "      returned: success",
            "      type: int",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            backend_type=dict(type='str'),",
            "            connection_name=dict(type='str'),",
            "            database_version=dict(type='str'),",
            "            failover_replica=dict(type='dict', options=dict(name=dict(type='str'))),",
            "            instance_type=dict(type='str'),",
            "            ipv6_address=dict(type='str'),",
            "            master_instance_name=dict(type='str'),",
            "            max_disk_size=dict(type='int'),",
            "            name=dict(required=True, type='str'),",
            "            region=dict(type='str'),",
            "            replica_configuration=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    failover_target=dict(type='bool'),",
            "                    mysql_replica_configuration=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            ca_certificate=dict(type='str'),",
            "                            client_certificate=dict(type='str'),",
            "                            client_key=dict(type='str'),",
            "                            connect_retry_interval=dict(type='int'),",
            "                            dump_file_path=dict(type='str'),",
            "                            master_heartbeat_period=dict(type='int'),",
            "                            password=dict(type='str'),",
            "                            ssl_cipher=dict(type='str'),",
            "                            username=dict(type='str'),",
            "                            verify_server_certificate=dict(type='bool'),",
            "                        ),",
            "                    ),",
            "                    replica_names=dict(type='list', elements='str'),",
            "                    service_account_email_address=dict(type='str'),",
            "                ),",
            "            ),",
            "            settings=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    database_flags=dict(type='list', elements='dict', options=dict(name=dict(type='str'), value=dict(type='str'))),",
            "                    ip_configuration=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            ipv4_enabled=dict(type='bool'),",
            "                            authorized_networks=dict(",
            "                                type='list', elements='dict', options=dict(expiration_time=dict(type='str'), name=dict(type='str'), value=dict(type='str'))",
            "                            ),",
            "                            require_ssl=dict(type='bool'),",
            "                        ),",
            "                    ),",
            "                    tier=dict(type='str'),",
            "                    availability_type=dict(type='str'),",
            "                    backup_configuration=dict(",
            "                        type='dict', options=dict(enabled=dict(type='bool'), binary_log_enabled=dict(type='bool'), start_time=dict(type='str'))",
            "                    ),",
            "                ),",
            "            ),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/sqlservice.admin']",
            "",
            "    state = module.params['state']",
            "    kind = 'sql#instance'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind, fetch)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    module.fail_json(msg=\"SQL objects can't be updated to ensure data safety\")",
            "",
            "",
            "def delete(module, link, kind, fetch):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'sql#instance',",
            "        u'backendType': module.params.get('backend_type'),",
            "        u'connectionName': module.params.get('connection_name'),",
            "        u'databaseVersion': module.params.get('database_version'),",
            "        u'failoverReplica': InstanceFailoverreplica(module.params.get('failover_replica', {}), module).to_request(),",
            "        u'instanceType': module.params.get('instance_type'),",
            "        u'ipv6Address': module.params.get('ipv6_address'),",
            "        u'masterInstanceName': module.params.get('master_instance_name'),",
            "        u'maxDiskSize': module.params.get('max_disk_size'),",
            "        u'name': module.params.get('name'),",
            "        u'region': module.params.get('region'),",
            "        u'replicaConfiguration': InstanceReplicaconfiguration(module.params.get('replica_configuration', {}), module).to_request(),",
            "        u'settings': InstanceSettings(module.params.get('settings', {}), module).to_request(),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'sql')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/sql/v1beta4/projects/{project}/instances/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/sql/v1beta4/projects/{project}/instances\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    # SQL only: return on 403 if not exist",
            "    if allow_not_found and response.status_code == 403:",
            "        return None",
            "",
            "    try:",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError) as inst:",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % inst)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'backendType': response.get(u'backendType'),",
            "        u'connectionName': response.get(u'connectionName'),",
            "        u'databaseVersion': response.get(u'databaseVersion'),",
            "        u'failoverReplica': InstanceFailoverreplica(response.get(u'failoverReplica', {}), module).from_response(),",
            "        u'instanceType': response.get(u'instanceType'),",
            "        u'ipAddresses': InstanceIpaddressesArray(response.get(u'ipAddresses', []), module).from_response(),",
            "        u'ipv6Address': response.get(u'ipv6Address'),",
            "        u'masterInstanceName': response.get(u'masterInstanceName'),",
            "        u'maxDiskSize': response.get(u'maxDiskSize'),",
            "        u'name': response.get(u'name'),",
            "        u'region': response.get(u'region'),",
            "        u'replicaConfiguration': InstanceReplicaconfiguration(response.get(u'replicaConfiguration', {}), module).from_response(),",
            "        u'settings': InstanceSettings(response.get(u'settings', {}), module).from_response(),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/sql/v1beta4/projects/{project}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'sql#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'sql#instance')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'sql#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class InstanceFailoverreplica(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'name': self.request.get('name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'name': self.request.get(u'name')})",
            "",
            "",
            "class InstanceIpaddressesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'ipAddress': item.get('ip_address'), u'timeToRetire': item.get('time_to_retire'), u'type': item.get('type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'ipAddress': item.get(u'ipAddress'), u'timeToRetire': item.get(u'timeToRetire'), u'type': item.get(u'type')})",
            "",
            "",
            "class InstanceReplicaconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'failoverTarget': self.request.get('failover_target'),",
            "                u'mysqlReplicaConfiguration': InstanceMysqlreplicaconfiguration(self.request.get('mysql_replica_configuration', {}), self.module).to_request(),",
            "                u'replicaNames': self.request.get('replica_names'),",
            "                u'serviceAccountEmailAddress': self.request.get('service_account_email_address'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'failoverTarget': self.request.get(u'failoverTarget'),",
            "                u'mysqlReplicaConfiguration': InstanceMysqlreplicaconfiguration(",
            "                    self.request.get(u'mysqlReplicaConfiguration', {}), self.module",
            "                ).from_response(),",
            "                u'replicaNames': self.request.get(u'replicaNames'),",
            "                u'serviceAccountEmailAddress': self.request.get(u'serviceAccountEmailAddress'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceMysqlreplicaconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'caCertificate': self.request.get('ca_certificate'),",
            "                u'clientCertificate': self.request.get('client_certificate'),",
            "                u'clientKey': self.request.get('client_key'),",
            "                u'connectRetryInterval': self.request.get('connect_retry_interval'),",
            "                u'dumpFilePath': self.request.get('dump_file_path'),",
            "                u'masterHeartbeatPeriod': self.request.get('master_heartbeat_period'),",
            "                u'password': self.request.get('password'),",
            "                u'sslCipher': self.request.get('ssl_cipher'),",
            "                u'username': self.request.get('username'),",
            "                u'verifyServerCertificate': self.request.get('verify_server_certificate'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'caCertificate': self.request.get(u'caCertificate'),",
            "                u'clientCertificate': self.request.get(u'clientCertificate'),",
            "                u'clientKey': self.request.get(u'clientKey'),",
            "                u'connectRetryInterval': self.request.get(u'connectRetryInterval'),",
            "                u'dumpFilePath': self.request.get(u'dumpFilePath'),",
            "                u'masterHeartbeatPeriod': self.request.get(u'masterHeartbeatPeriod'),",
            "                u'password': self.request.get(u'password'),",
            "                u'sslCipher': self.request.get(u'sslCipher'),",
            "                u'username': self.request.get(u'username'),",
            "                u'verifyServerCertificate': self.request.get(u'verifyServerCertificate'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceSettings(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'databaseFlags': InstanceDatabaseflagsArray(self.request.get('database_flags', []), self.module).to_request(),",
            "                u'ipConfiguration': InstanceIpconfiguration(self.request.get('ip_configuration', {}), self.module).to_request(),",
            "                u'tier': self.request.get('tier'),",
            "                u'availabilityType': self.request.get('availability_type'),",
            "                u'backupConfiguration': InstanceBackupconfiguration(self.request.get('backup_configuration', {}), self.module).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'databaseFlags': InstanceDatabaseflagsArray(self.request.get(u'databaseFlags', []), self.module).from_response(),",
            "                u'ipConfiguration': InstanceIpconfiguration(self.request.get(u'ipConfiguration', {}), self.module).from_response(),",
            "                u'tier': self.request.get(u'tier'),",
            "                u'availabilityType': self.request.get(u'availabilityType'),",
            "                u'backupConfiguration': InstanceBackupconfiguration(self.request.get(u'backupConfiguration', {}), self.module).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceDatabaseflagsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'name': item.get('name'), u'value': item.get('value')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'name': item.get(u'name'), u'value': item.get(u'value')})",
            "",
            "",
            "class InstanceIpconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipv4Enabled': self.request.get('ipv4_enabled'),",
            "                u'authorizedNetworks': InstanceAuthorizednetworksArray(self.request.get('authorized_networks', []), self.module).to_request(),",
            "                u'requireSsl': self.request.get('require_ssl'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipv4Enabled': self.request.get(u'ipv4Enabled'),",
            "                u'authorizedNetworks': InstanceAuthorizednetworksArray(self.request.get(u'authorizedNetworks', []), self.module).from_response(),",
            "                u'requireSsl': self.request.get(u'requireSsl'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceAuthorizednetworksArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'expirationTime': item.get('expiration_time'), u'name': item.get('name'), u'value': item.get('value')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'expirationTime': item.get(u'expirationTime'), u'name': item.get(u'name'), u'value': item.get(u'value')})",
            "",
            "",
            "class InstanceBackupconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {u'enabled': self.request.get('enabled'), u'binaryLogEnabled': self.request.get('binary_log_enabled'), u'startTime': self.request.get('start_time')}",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {u'enabled': self.request.get(u'enabled'), u'binaryLogEnabled': self.request.get(u'binaryLogEnabled'), u'startTime': self.request.get(u'startTime')}",
            "        )",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Copyright (C) 2017 Google",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***",
            "#",
            "# ----------------------------------------------------------------------------",
            "#",
            "#     This file is automatically generated by Magic Modules and manual",
            "#     changes will be clobbered when the file is regenerated.",
            "#",
            "#     Please read more about how to change this file at",
            "#     https://www.github.com/GoogleCloudPlatform/magic-modules",
            "#",
            "# ----------------------------------------------------------------------------",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "################################################################################",
            "# Documentation",
            "################################################################################",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': [\"preview\"], 'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: gcp_sql_instance",
            "description:",
            "- Represents a Cloud SQL instance. Cloud SQL instances are SQL databases hosted in",
            "  Google's cloud. The Instances resource provides methods for common configuration",
            "  and management tasks.",
            "short_description: Creates a GCP Instance",
            "version_added: 2.7",
            "author: Google Inc. (@googlecloudplatform)",
            "requirements:",
            "- python >= 2.6",
            "- requests >= 2.18.4",
            "- google-auth >= 1.3.0",
            "options:",
            "  state:",
            "    description:",
            "    - Whether the given object should exist in GCP",
            "    choices:",
            "    - present",
            "    - absent",
            "    default: present",
            "    type: str",
            "  backend_type:",
            "    description:",
            "    - \"* FIRST_GEN: First Generation instance. MySQL only.\"",
            "    - \"* SECOND_GEN: Second Generation instance or PostgreSQL instance.\"",
            "    - \"* EXTERNAL: A database server that is not managed by Google.\"",
            "    - 'Some valid choices include: \"FIRST_GEN\", \"SECOND_GEN\", \"EXTERNAL\"'",
            "    required: false",
            "    type: str",
            "  connection_name:",
            "    description:",
            "    - Connection name of the Cloud SQL instance used in connection strings.",
            "    required: false",
            "    type: str",
            "  database_version:",
            "    description:",
            "    - The database engine type and version. For First Generation instances, can be",
            "      MYSQL_5_5, or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or",
            "      MYSQL_5_7. Defaults to MYSQL_5_6.",
            "    - 'PostgreSQL instances: POSTGRES_9_6 The databaseVersion property can not be",
            "      changed after instance creation.'",
            "    - 'Some valid choices include: \"MYSQL_5_5\", \"MYSQL_5_6\", \"MYSQL_5_7\", \"POSTGRES_9_6\"'",
            "    required: false",
            "    type: str",
            "  failover_replica:",
            "    description:",
            "    - The name and status of the failover replica. This property is applicable only",
            "      to Second Generation instances.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      name:",
            "        description:",
            "        - The name of the failover replica. If specified at instance creation, a failover",
            "          replica is created for the instance. The name doesn't include the project",
            "          ID. This property is applicable only to Second Generation instances.",
            "        required: false",
            "        type: str",
            "  instance_type:",
            "    description:",
            "    - The instance type. This can be one of the following.",
            "    - \"* CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating from a master.\"",
            "    - \"* ON_PREMISES_INSTANCE: An instance running on the customer's premises.\"",
            "    - \"* READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a read-replica.\"",
            "    - 'Some valid choices include: \"CLOUD_SQL_INSTANCE\", \"ON_PREMISES_INSTANCE\", \"READ_REPLICA_INSTANCE\"'",
            "    required: false",
            "    type: str",
            "  ipv6_address:",
            "    description:",
            "    - The IPv6 address assigned to the instance. This property is applicable only",
            "      to First Generation instances.",
            "    required: false",
            "    type: str",
            "  master_instance_name:",
            "    description:",
            "    - The name of the instance which will act as master in the replication setup.",
            "    required: false",
            "    type: str",
            "  max_disk_size:",
            "    description:",
            "    - The maximum disk size of the instance in bytes.",
            "    required: false",
            "    type: int",
            "  name:",
            "    description:",
            "    - Name of the Cloud SQL instance. This does not include the project ID.",
            "    required: true",
            "    type: str",
            "  region:",
            "    description:",
            "    - The geographical region. Defaults to us-central or us-central1 depending on",
            "      the instance type (First Generation or Second Generation/PostgreSQL).",
            "    required: false",
            "    type: str",
            "  replica_configuration:",
            "    description:",
            "    - Configuration specific to failover replicas and read replicas.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      failover_target:",
            "        description:",
            "        - Specifies if the replica is the failover target. If the field is set to",
            "          true the replica will be designated as a failover replica.",
            "        - In case the master instance fails, the replica instance will be promoted",
            "          as the new master instance.",
            "        - Only one replica can be specified as failover target, and the replica has",
            "          to be in different zone with the master instance.",
            "        required: false",
            "        type: bool",
            "      mysql_replica_configuration:",
            "        description:",
            "        - MySQL specific configuration when replicating from a MySQL on-premises master.",
            "          Replication configuration information such as the username, password, certificates,",
            "          and keys are not stored in the instance metadata. The configuration information",
            "          is used only to set up the replication connection and is stored by MySQL",
            "          in a file named master.info in the data directory.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          ca_certificate:",
            "            description:",
            "            - PEM representation of the trusted CA's x509 certificate.",
            "            required: false",
            "            type: str",
            "          client_certificate:",
            "            description:",
            "            - PEM representation of the slave's x509 certificate .",
            "            required: false",
            "            type: str",
            "          client_key:",
            "            description:",
            "            - PEM representation of the slave's private key. The corresponding public",
            "              key is encoded in the client's certificate.",
            "            required: false",
            "            type: str",
            "          connect_retry_interval:",
            "            description:",
            "            - Seconds to wait between connect retries. MySQL's default is 60 seconds.",
            "            required: false",
            "            type: int",
            "          dump_file_path:",
            "            description:",
            "            - Path to a SQL dump file in Google Cloud Storage from which the slave",
            "              instance is to be created. The URI is in the form gs://bucketName/fileName.",
            "              Compressed gzip files (.gz) are also supported. Dumps should have the",
            "              binlog coordinates from which replication should begin. This can be",
            "              accomplished by setting --master-data to 1 when using mysqldump.",
            "            required: false",
            "            type: str",
            "          master_heartbeat_period:",
            "            description:",
            "            - Interval in milliseconds between replication heartbeats.",
            "            required: false",
            "            type: int",
            "          password:",
            "            description:",
            "            - The password for the replication connection.",
            "            required: false",
            "            type: str",
            "          ssl_cipher:",
            "            description:",
            "            - A list of permissible ciphers to use for SSL encryption.",
            "            required: false",
            "            type: str",
            "          username:",
            "            description:",
            "            - The username for the replication connection.",
            "            required: false",
            "            type: str",
            "          verify_server_certificate:",
            "            description:",
            "            - Whether or not to check the master's Common Name value in the certificate",
            "              that it sends during the SSL handshake.",
            "            required: false",
            "            type: bool",
            "      replica_names:",
            "        description:",
            "        - The replicas of the instance.",
            "        required: false",
            "        type: list",
            "      service_account_email_address:",
            "        description:",
            "        - The service account email address assigned to the instance. This property",
            "          is applicable only to Second Generation instances.",
            "        required: false",
            "        type: str",
            "  settings:",
            "    description:",
            "    - The user settings.",
            "    required: false",
            "    type: dict",
            "    suboptions:",
            "      database_flags:",
            "        description:",
            "        - The database flags passed to the instance at startup.",
            "        required: false",
            "        type: list",
            "        version_added: 2.9",
            "        suboptions:",
            "          name:",
            "            description:",
            "            - The name of the flag. These flags are passed at instance startup, so",
            "              include both server options and system variables for MySQL. Flags should",
            "              be specified with underscores, not hyphens.",
            "            required: false",
            "            type: str",
            "          value:",
            "            description:",
            "            - The value of the flag. Booleans should be set to on for true and off",
            "              for false. This field must be omitted if the flag doesn't take a value.",
            "            required: false",
            "            type: str",
            "      ip_configuration:",
            "        description:",
            "        - The settings for IP Management. This allows to enable or disable the instance",
            "          IP and manage which external networks can connect to the instance. The IPv4",
            "          address cannot be disabled for Second Generation instances.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          ipv4_enabled:",
            "            description:",
            "            - Whether the instance should be assigned an IP address or not.",
            "            required: false",
            "            type: bool",
            "          authorized_networks:",
            "            description:",
            "            - The list of external networks that are allowed to connect to the instance",
            "              using the IP. In CIDR notation, also known as 'slash' notation (e.g.",
            "              192.168.100.0/24).",
            "            required: false",
            "            type: list",
            "            suboptions:",
            "              expiration_time:",
            "                description:",
            "                - The time when this access control entry expires in RFC 3339 format,",
            "                  for example 2012-11-15T16:19:00.094Z.",
            "                required: false",
            "                type: str",
            "              name:",
            "                description:",
            "                - An optional label to identify this entry.",
            "                required: false",
            "                type: str",
            "              value:",
            "                description:",
            "                - The whitelisted value for the access control list. For example,",
            "                  to grant access to a client from an external IP (IPv4 or IPv6) address",
            "                  or subnet, use that address or subnet here.",
            "                required: false",
            "                type: str",
            "          require_ssl:",
            "            description:",
            "            - Whether the mysqld should default to 'REQUIRE X509' for users connecting",
            "              over IP.",
            "            required: false",
            "            type: bool",
            "      tier:",
            "        description:",
            "        - The tier or machine type for this instance, for example db-n1-standard-1.",
            "          For MySQL instances, this field determines whether the instance is Second",
            "          Generation (recommended) or First Generation.",
            "        required: false",
            "        type: str",
            "      availability_type:",
            "        description:",
            "        - The availabilityType define if your postgres instance is run zonal or regional.",
            "        - 'Some valid choices include: \"ZONAL\", \"REGIONAL\"'",
            "        required: false",
            "        type: str",
            "      backup_configuration:",
            "        description:",
            "        - The daily backup configuration for the instance.",
            "        required: false",
            "        type: dict",
            "        suboptions:",
            "          enabled:",
            "            description:",
            "            - Enable Autobackup for your instance.",
            "            required: false",
            "            type: bool",
            "          binary_log_enabled:",
            "            description:",
            "            - Whether binary log is enabled. If backup configuration is disabled,",
            "              binary log must be disabled as well. MySQL only.",
            "            required: false",
            "            type: bool",
            "          start_time:",
            "            description:",
            "            - Define the backup start time in UTC (HH:MM) .",
            "            required: false",
            "            type: str",
            "extends_documentation_fragment: gcp",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: create a instance",
            "  gcp_sql_instance:",
            "    name: \"{{resource_name}}-2\"",
            "    settings:",
            "      ip_configuration:",
            "        authorized_networks:",
            "        - name: google dns server",
            "          value: 8.8.8.8/32",
            "      tier: db-n1-standard-1",
            "    region: us-central1",
            "    project: test_project",
            "    auth_kind: serviceaccount",
            "    service_account_file: \"/tmp/auth.pem\"",
            "    state: present",
            "'''",
            "",
            "RETURN = '''",
            "backendType:",
            "  description:",
            "  - \"* FIRST_GEN: First Generation instance. MySQL only.\"",
            "  - \"* SECOND_GEN: Second Generation instance or PostgreSQL instance.\"",
            "  - \"* EXTERNAL: A database server that is not managed by Google.\"",
            "  returned: success",
            "  type: str",
            "connectionName:",
            "  description:",
            "  - Connection name of the Cloud SQL instance used in connection strings.",
            "  returned: success",
            "  type: str",
            "databaseVersion:",
            "  description:",
            "  - The database engine type and version. For First Generation instances, can be MYSQL_5_5,",
            "    or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or MYSQL_5_7.",
            "    Defaults to MYSQL_5_6.",
            "  - 'PostgreSQL instances: POSTGRES_9_6 The databaseVersion property can not be changed",
            "    after instance creation.'",
            "  returned: success",
            "  type: str",
            "failoverReplica:",
            "  description:",
            "  - The name and status of the failover replica. This property is applicable only",
            "    to Second Generation instances.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    available:",
            "      description:",
            "      - The availability status of the failover replica. A false status indicates",
            "        that the failover replica is out of sync. The master can only failover to",
            "        the failover replica when the status is true.",
            "      returned: success",
            "      type: bool",
            "    name:",
            "      description:",
            "      - The name of the failover replica. If specified at instance creation, a failover",
            "        replica is created for the instance. The name doesn't include the project",
            "        ID. This property is applicable only to Second Generation instances.",
            "      returned: success",
            "      type: str",
            "instanceType:",
            "  description:",
            "  - The instance type. This can be one of the following.",
            "  - \"* CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating from a master.\"",
            "  - \"* ON_PREMISES_INSTANCE: An instance running on the customer's premises.\"",
            "  - \"* READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a read-replica.\"",
            "  returned: success",
            "  type: str",
            "ipAddresses:",
            "  description:",
            "  - The assigned IP addresses for the instance.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    ipAddress:",
            "      description:",
            "      - The IP address assigned.",
            "      returned: success",
            "      type: str",
            "    timeToRetire:",
            "      description:",
            "      - The due time for this IP to be retired in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.",
            "        This field is only available when the IP is scheduled to be retired.",
            "      returned: success",
            "      type: str",
            "    type:",
            "      description:",
            "      - The type of this IP address. A PRIMARY address is an address that can accept",
            "        incoming connections. An OUTGOING address is the source address of connections",
            "        originating from the instance, if supported.",
            "      returned: success",
            "      type: str",
            "ipv6Address:",
            "  description:",
            "  - The IPv6 address assigned to the instance. This property is applicable only to",
            "    First Generation instances.",
            "  returned: success",
            "  type: str",
            "masterInstanceName:",
            "  description:",
            "  - The name of the instance which will act as master in the replication setup.",
            "  returned: success",
            "  type: str",
            "maxDiskSize:",
            "  description:",
            "  - The maximum disk size of the instance in bytes.",
            "  returned: success",
            "  type: int",
            "name:",
            "  description:",
            "  - Name of the Cloud SQL instance. This does not include the project ID.",
            "  returned: success",
            "  type: str",
            "region:",
            "  description:",
            "  - The geographical region. Defaults to us-central or us-central1 depending on the",
            "    instance type (First Generation or Second Generation/PostgreSQL).",
            "  returned: success",
            "  type: str",
            "replicaConfiguration:",
            "  description:",
            "  - Configuration specific to failover replicas and read replicas.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    failoverTarget:",
            "      description:",
            "      - Specifies if the replica is the failover target. If the field is set to true",
            "        the replica will be designated as a failover replica.",
            "      - In case the master instance fails, the replica instance will be promoted as",
            "        the new master instance.",
            "      - Only one replica can be specified as failover target, and the replica has",
            "        to be in different zone with the master instance.",
            "      returned: success",
            "      type: bool",
            "    mysqlReplicaConfiguration:",
            "      description:",
            "      - MySQL specific configuration when replicating from a MySQL on-premises master.",
            "        Replication configuration information such as the username, password, certificates,",
            "        and keys are not stored in the instance metadata. The configuration information",
            "        is used only to set up the replication connection and is stored by MySQL in",
            "        a file named master.info in the data directory.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        caCertificate:",
            "          description:",
            "          - PEM representation of the trusted CA's x509 certificate.",
            "          returned: success",
            "          type: str",
            "        clientCertificate:",
            "          description:",
            "          - PEM representation of the slave's x509 certificate .",
            "          returned: success",
            "          type: str",
            "        clientKey:",
            "          description:",
            "          - PEM representation of the slave's private key. The corresponding public",
            "            key is encoded in the client's certificate.",
            "          returned: success",
            "          type: str",
            "        connectRetryInterval:",
            "          description:",
            "          - Seconds to wait between connect retries. MySQL's default is 60 seconds.",
            "          returned: success",
            "          type: int",
            "        dumpFilePath:",
            "          description:",
            "          - Path to a SQL dump file in Google Cloud Storage from which the slave instance",
            "            is to be created. The URI is in the form gs://bucketName/fileName. Compressed",
            "            gzip files (.gz) are also supported. Dumps should have the binlog coordinates",
            "            from which replication should begin. This can be accomplished by setting",
            "            --master-data to 1 when using mysqldump.",
            "          returned: success",
            "          type: str",
            "        masterHeartbeatPeriod:",
            "          description:",
            "          - Interval in milliseconds between replication heartbeats.",
            "          returned: success",
            "          type: int",
            "        password:",
            "          description:",
            "          - The password for the replication connection.",
            "          returned: success",
            "          type: str",
            "        sslCipher:",
            "          description:",
            "          - A list of permissible ciphers to use for SSL encryption.",
            "          returned: success",
            "          type: str",
            "        username:",
            "          description:",
            "          - The username for the replication connection.",
            "          returned: success",
            "          type: str",
            "        verifyServerCertificate:",
            "          description:",
            "          - Whether or not to check the master's Common Name value in the certificate",
            "            that it sends during the SSL handshake.",
            "          returned: success",
            "          type: bool",
            "    replicaNames:",
            "      description:",
            "      - The replicas of the instance.",
            "      returned: success",
            "      type: list",
            "    serviceAccountEmailAddress:",
            "      description:",
            "      - The service account email address assigned to the instance. This property",
            "        is applicable only to Second Generation instances.",
            "      returned: success",
            "      type: str",
            "settings:",
            "  description:",
            "  - The user settings.",
            "  returned: success",
            "  type: complex",
            "  contains:",
            "    databaseFlags:",
            "      description:",
            "      - The database flags passed to the instance at startup.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        name:",
            "          description:",
            "          - The name of the flag. These flags are passed at instance startup, so include",
            "            both server options and system variables for MySQL. Flags should be specified",
            "            with underscores, not hyphens.",
            "          returned: success",
            "          type: str",
            "        value:",
            "          description:",
            "          - The value of the flag. Booleans should be set to on for true and off for",
            "            false. This field must be omitted if the flag doesn't take a value.",
            "          returned: success",
            "          type: str",
            "    ipConfiguration:",
            "      description:",
            "      - The settings for IP Management. This allows to enable or disable the instance",
            "        IP and manage which external networks can connect to the instance. The IPv4",
            "        address cannot be disabled for Second Generation instances.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        ipv4Enabled:",
            "          description:",
            "          - Whether the instance should be assigned an IP address or not.",
            "          returned: success",
            "          type: bool",
            "        authorizedNetworks:",
            "          description:",
            "          - The list of external networks that are allowed to connect to the instance",
            "            using the IP. In CIDR notation, also known as 'slash' notation (e.g. 192.168.100.0/24).",
            "          returned: success",
            "          type: complex",
            "          contains:",
            "            expirationTime:",
            "              description:",
            "              - The time when this access control entry expires in RFC 3339 format,",
            "                for example 2012-11-15T16:19:00.094Z.",
            "              returned: success",
            "              type: str",
            "            name:",
            "              description:",
            "              - An optional label to identify this entry.",
            "              returned: success",
            "              type: str",
            "            value:",
            "              description:",
            "              - The whitelisted value for the access control list. For example, to",
            "                grant access to a client from an external IP (IPv4 or IPv6) address",
            "                or subnet, use that address or subnet here.",
            "              returned: success",
            "              type: str",
            "        requireSsl:",
            "          description:",
            "          - Whether the mysqld should default to 'REQUIRE X509' for users connecting",
            "            over IP.",
            "          returned: success",
            "          type: bool",
            "    tier:",
            "      description:",
            "      - The tier or machine type for this instance, for example db-n1-standard-1.",
            "        For MySQL instances, this field determines whether the instance is Second",
            "        Generation (recommended) or First Generation.",
            "      returned: success",
            "      type: str",
            "    availabilityType:",
            "      description:",
            "      - The availabilityType define if your postgres instance is run zonal or regional.",
            "      returned: success",
            "      type: str",
            "    backupConfiguration:",
            "      description:",
            "      - The daily backup configuration for the instance.",
            "      returned: success",
            "      type: complex",
            "      contains:",
            "        enabled:",
            "          description:",
            "          - Enable Autobackup for your instance.",
            "          returned: success",
            "          type: bool",
            "        binaryLogEnabled:",
            "          description:",
            "          - Whether binary log is enabled. If backup configuration is disabled, binary",
            "            log must be disabled as well. MySQL only.",
            "          returned: success",
            "          type: bool",
            "        startTime:",
            "          description:",
            "          - Define the backup start time in UTC (HH:MM) .",
            "          returned: success",
            "          type: str",
            "    settingsVersion:",
            "      description:",
            "      - The version of instance settings. This is a required field for update method",
            "        to make sure concurrent updates are handled properly. During update, use the",
            "        most recent settingsVersion value for this instance and do not try to update",
            "        this value.",
            "      returned: success",
            "      type: int",
            "'''",
            "",
            "################################################################################",
            "# Imports",
            "################################################################################",
            "",
            "from ansible.module_utils.gcp_utils import navigate_hash, GcpSession, GcpModule, GcpRequest, remove_nones_from_dict, replace_resource_dict",
            "import json",
            "import time",
            "",
            "################################################################################",
            "# Main",
            "################################################################################",
            "",
            "",
            "def main():",
            "    \"\"\"Main function\"\"\"",
            "",
            "    module = GcpModule(",
            "        argument_spec=dict(",
            "            state=dict(default='present', choices=['present', 'absent'], type='str'),",
            "            backend_type=dict(type='str'),",
            "            connection_name=dict(type='str'),",
            "            database_version=dict(type='str'),",
            "            failover_replica=dict(type='dict', options=dict(name=dict(type='str'))),",
            "            instance_type=dict(type='str'),",
            "            ipv6_address=dict(type='str'),",
            "            master_instance_name=dict(type='str'),",
            "            max_disk_size=dict(type='int'),",
            "            name=dict(required=True, type='str'),",
            "            region=dict(type='str'),",
            "            replica_configuration=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    failover_target=dict(type='bool'),",
            "                    mysql_replica_configuration=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            ca_certificate=dict(type='str'),",
            "                            client_certificate=dict(type='str'),",
            "                            client_key=dict(type='str', no_log=True),",
            "                            connect_retry_interval=dict(type='int'),",
            "                            dump_file_path=dict(type='str'),",
            "                            master_heartbeat_period=dict(type='int'),",
            "                            password=dict(type='str'),",
            "                            ssl_cipher=dict(type='str'),",
            "                            username=dict(type='str'),",
            "                            verify_server_certificate=dict(type='bool'),",
            "                        ),",
            "                    ),",
            "                    replica_names=dict(type='list', elements='str'),",
            "                    service_account_email_address=dict(type='str'),",
            "                ),",
            "            ),",
            "            settings=dict(",
            "                type='dict',",
            "                options=dict(",
            "                    database_flags=dict(type='list', elements='dict', options=dict(name=dict(type='str'), value=dict(type='str'))),",
            "                    ip_configuration=dict(",
            "                        type='dict',",
            "                        options=dict(",
            "                            ipv4_enabled=dict(type='bool'),",
            "                            authorized_networks=dict(",
            "                                type='list', elements='dict', options=dict(expiration_time=dict(type='str'), name=dict(type='str'), value=dict(type='str'))",
            "                            ),",
            "                            require_ssl=dict(type='bool'),",
            "                        ),",
            "                    ),",
            "                    tier=dict(type='str'),",
            "                    availability_type=dict(type='str'),",
            "                    backup_configuration=dict(",
            "                        type='dict', options=dict(enabled=dict(type='bool'), binary_log_enabled=dict(type='bool'), start_time=dict(type='str'))",
            "                    ),",
            "                ),",
            "            ),",
            "        )",
            "    )",
            "",
            "    if not module.params['scopes']:",
            "        module.params['scopes'] = ['https://www.googleapis.com/auth/sqlservice.admin']",
            "",
            "    state = module.params['state']",
            "    kind = 'sql#instance'",
            "",
            "    fetch = fetch_resource(module, self_link(module), kind)",
            "    changed = False",
            "",
            "    if fetch:",
            "        if state == 'present':",
            "            if is_different(module, fetch):",
            "                update(module, self_link(module), kind, fetch)",
            "                fetch = fetch_resource(module, self_link(module), kind)",
            "                changed = True",
            "        else:",
            "            delete(module, self_link(module), kind, fetch)",
            "            fetch = {}",
            "            changed = True",
            "    else:",
            "        if state == 'present':",
            "            fetch = create(module, collection(module), kind)",
            "            changed = True",
            "        else:",
            "            fetch = {}",
            "",
            "    fetch.update({'changed': changed})",
            "",
            "    module.exit_json(**fetch)",
            "",
            "",
            "def create(module, link, kind):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.post(link, resource_to_request(module)))",
            "",
            "",
            "def update(module, link, kind, fetch):",
            "    module.fail_json(msg=\"SQL objects can't be updated to ensure data safety\")",
            "",
            "",
            "def delete(module, link, kind, fetch):",
            "    auth = GcpSession(module, 'sql')",
            "    return wait_for_operation(module, auth.delete(link))",
            "",
            "",
            "def resource_to_request(module):",
            "    request = {",
            "        u'kind': 'sql#instance',",
            "        u'backendType': module.params.get('backend_type'),",
            "        u'connectionName': module.params.get('connection_name'),",
            "        u'databaseVersion': module.params.get('database_version'),",
            "        u'failoverReplica': InstanceFailoverreplica(module.params.get('failover_replica', {}), module).to_request(),",
            "        u'instanceType': module.params.get('instance_type'),",
            "        u'ipv6Address': module.params.get('ipv6_address'),",
            "        u'masterInstanceName': module.params.get('master_instance_name'),",
            "        u'maxDiskSize': module.params.get('max_disk_size'),",
            "        u'name': module.params.get('name'),",
            "        u'region': module.params.get('region'),",
            "        u'replicaConfiguration': InstanceReplicaconfiguration(module.params.get('replica_configuration', {}), module).to_request(),",
            "        u'settings': InstanceSettings(module.params.get('settings', {}), module).to_request(),",
            "    }",
            "    return_vals = {}",
            "    for k, v in request.items():",
            "        if v or v is False:",
            "            return_vals[k] = v",
            "",
            "    return return_vals",
            "",
            "",
            "def fetch_resource(module, link, kind, allow_not_found=True):",
            "    auth = GcpSession(module, 'sql')",
            "    return return_if_object(module, auth.get(link), kind, allow_not_found)",
            "",
            "",
            "def self_link(module):",
            "    return \"https://www.googleapis.com/sql/v1beta4/projects/{project}/instances/{name}\".format(**module.params)",
            "",
            "",
            "def collection(module):",
            "    return \"https://www.googleapis.com/sql/v1beta4/projects/{project}/instances\".format(**module.params)",
            "",
            "",
            "def return_if_object(module, response, kind, allow_not_found=False):",
            "    # If not found, return nothing.",
            "    if allow_not_found and response.status_code == 404:",
            "        return None",
            "",
            "    # If no content, return nothing.",
            "    if response.status_code == 204:",
            "        return None",
            "",
            "    # SQL only: return on 403 if not exist",
            "    if allow_not_found and response.status_code == 403:",
            "        return None",
            "",
            "    try:",
            "        result = response.json()",
            "    except getattr(json.decoder, 'JSONDecodeError', ValueError) as inst:",
            "        module.fail_json(msg=\"Invalid JSON response with error: %s\" % inst)",
            "",
            "    if navigate_hash(result, ['error', 'errors']):",
            "        module.fail_json(msg=navigate_hash(result, ['error', 'errors']))",
            "",
            "    return result",
            "",
            "",
            "def is_different(module, response):",
            "    request = resource_to_request(module)",
            "    response = response_to_hash(module, response)",
            "",
            "    # Remove all output-only from response.",
            "    response_vals = {}",
            "    for k, v in response.items():",
            "        if k in request:",
            "            response_vals[k] = v",
            "",
            "    request_vals = {}",
            "    for k, v in request.items():",
            "        if k in response:",
            "            request_vals[k] = v",
            "",
            "    return GcpRequest(request_vals) != GcpRequest(response_vals)",
            "",
            "",
            "# Remove unnecessary properties from the response.",
            "# This is for doing comparisons with Ansible's current parameters.",
            "def response_to_hash(module, response):",
            "    return {",
            "        u'backendType': response.get(u'backendType'),",
            "        u'connectionName': response.get(u'connectionName'),",
            "        u'databaseVersion': response.get(u'databaseVersion'),",
            "        u'failoverReplica': InstanceFailoverreplica(response.get(u'failoverReplica', {}), module).from_response(),",
            "        u'instanceType': response.get(u'instanceType'),",
            "        u'ipAddresses': InstanceIpaddressesArray(response.get(u'ipAddresses', []), module).from_response(),",
            "        u'ipv6Address': response.get(u'ipv6Address'),",
            "        u'masterInstanceName': response.get(u'masterInstanceName'),",
            "        u'maxDiskSize': response.get(u'maxDiskSize'),",
            "        u'name': response.get(u'name'),",
            "        u'region': response.get(u'region'),",
            "        u'replicaConfiguration': InstanceReplicaconfiguration(response.get(u'replicaConfiguration', {}), module).from_response(),",
            "        u'settings': InstanceSettings(response.get(u'settings', {}), module).from_response(),",
            "    }",
            "",
            "",
            "def async_op_url(module, extra_data=None):",
            "    if extra_data is None:",
            "        extra_data = {}",
            "    url = \"https://www.googleapis.com/sql/v1beta4/projects/{project}/operations/{op_id}\"",
            "    combined = extra_data.copy()",
            "    combined.update(module.params)",
            "    return url.format(**combined)",
            "",
            "",
            "def wait_for_operation(module, response):",
            "    op_result = return_if_object(module, response, 'sql#operation')",
            "    if op_result is None:",
            "        return {}",
            "    status = navigate_hash(op_result, ['status'])",
            "    wait_done = wait_for_completion(status, op_result, module)",
            "    return fetch_resource(module, navigate_hash(wait_done, ['targetLink']), 'sql#instance')",
            "",
            "",
            "def wait_for_completion(status, op_result, module):",
            "    op_id = navigate_hash(op_result, ['name'])",
            "    op_uri = async_op_url(module, {'op_id': op_id})",
            "    while status != 'DONE':",
            "        raise_if_errors(op_result, ['error', 'errors'], module)",
            "        time.sleep(1.0)",
            "        op_result = fetch_resource(module, op_uri, 'sql#operation', False)",
            "        status = navigate_hash(op_result, ['status'])",
            "    return op_result",
            "",
            "",
            "def raise_if_errors(response, err_path, module):",
            "    errors = navigate_hash(response, err_path)",
            "    if errors is not None:",
            "        module.fail_json(msg=errors)",
            "",
            "",
            "class InstanceFailoverreplica(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict({u'name': self.request.get('name')})",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict({u'name': self.request.get(u'name')})",
            "",
            "",
            "class InstanceIpaddressesArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'ipAddress': item.get('ip_address'), u'timeToRetire': item.get('time_to_retire'), u'type': item.get('type')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'ipAddress': item.get(u'ipAddress'), u'timeToRetire': item.get(u'timeToRetire'), u'type': item.get(u'type')})",
            "",
            "",
            "class InstanceReplicaconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'failoverTarget': self.request.get('failover_target'),",
            "                u'mysqlReplicaConfiguration': InstanceMysqlreplicaconfiguration(self.request.get('mysql_replica_configuration', {}), self.module).to_request(),",
            "                u'replicaNames': self.request.get('replica_names'),",
            "                u'serviceAccountEmailAddress': self.request.get('service_account_email_address'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'failoverTarget': self.request.get(u'failoverTarget'),",
            "                u'mysqlReplicaConfiguration': InstanceMysqlreplicaconfiguration(",
            "                    self.request.get(u'mysqlReplicaConfiguration', {}), self.module",
            "                ).from_response(),",
            "                u'replicaNames': self.request.get(u'replicaNames'),",
            "                u'serviceAccountEmailAddress': self.request.get(u'serviceAccountEmailAddress'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceMysqlreplicaconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'caCertificate': self.request.get('ca_certificate'),",
            "                u'clientCertificate': self.request.get('client_certificate'),",
            "                u'clientKey': self.request.get('client_key'),",
            "                u'connectRetryInterval': self.request.get('connect_retry_interval'),",
            "                u'dumpFilePath': self.request.get('dump_file_path'),",
            "                u'masterHeartbeatPeriod': self.request.get('master_heartbeat_period'),",
            "                u'password': self.request.get('password'),",
            "                u'sslCipher': self.request.get('ssl_cipher'),",
            "                u'username': self.request.get('username'),",
            "                u'verifyServerCertificate': self.request.get('verify_server_certificate'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'caCertificate': self.request.get(u'caCertificate'),",
            "                u'clientCertificate': self.request.get(u'clientCertificate'),",
            "                u'clientKey': self.request.get(u'clientKey'),",
            "                u'connectRetryInterval': self.request.get(u'connectRetryInterval'),",
            "                u'dumpFilePath': self.request.get(u'dumpFilePath'),",
            "                u'masterHeartbeatPeriod': self.request.get(u'masterHeartbeatPeriod'),",
            "                u'password': self.request.get(u'password'),",
            "                u'sslCipher': self.request.get(u'sslCipher'),",
            "                u'username': self.request.get(u'username'),",
            "                u'verifyServerCertificate': self.request.get(u'verifyServerCertificate'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceSettings(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'databaseFlags': InstanceDatabaseflagsArray(self.request.get('database_flags', []), self.module).to_request(),",
            "                u'ipConfiguration': InstanceIpconfiguration(self.request.get('ip_configuration', {}), self.module).to_request(),",
            "                u'tier': self.request.get('tier'),",
            "                u'availabilityType': self.request.get('availability_type'),",
            "                u'backupConfiguration': InstanceBackupconfiguration(self.request.get('backup_configuration', {}), self.module).to_request(),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'databaseFlags': InstanceDatabaseflagsArray(self.request.get(u'databaseFlags', []), self.module).from_response(),",
            "                u'ipConfiguration': InstanceIpconfiguration(self.request.get(u'ipConfiguration', {}), self.module).from_response(),",
            "                u'tier': self.request.get(u'tier'),",
            "                u'availabilityType': self.request.get(u'availabilityType'),",
            "                u'backupConfiguration': InstanceBackupconfiguration(self.request.get(u'backupConfiguration', {}), self.module).from_response(),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceDatabaseflagsArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'name': item.get('name'), u'value': item.get('value')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'name': item.get(u'name'), u'value': item.get(u'value')})",
            "",
            "",
            "class InstanceIpconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipv4Enabled': self.request.get('ipv4_enabled'),",
            "                u'authorizedNetworks': InstanceAuthorizednetworksArray(self.request.get('authorized_networks', []), self.module).to_request(),",
            "                u'requireSsl': self.request.get('require_ssl'),",
            "            }",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {",
            "                u'ipv4Enabled': self.request.get(u'ipv4Enabled'),",
            "                u'authorizedNetworks': InstanceAuthorizednetworksArray(self.request.get(u'authorizedNetworks', []), self.module).from_response(),",
            "                u'requireSsl': self.request.get(u'requireSsl'),",
            "            }",
            "        )",
            "",
            "",
            "class InstanceAuthorizednetworksArray(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = []",
            "",
            "    def to_request(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._request_for_item(item))",
            "        return items",
            "",
            "    def from_response(self):",
            "        items = []",
            "        for item in self.request:",
            "            items.append(self._response_from_item(item))",
            "        return items",
            "",
            "    def _request_for_item(self, item):",
            "        return remove_nones_from_dict({u'expirationTime': item.get('expiration_time'), u'name': item.get('name'), u'value': item.get('value')})",
            "",
            "    def _response_from_item(self, item):",
            "        return remove_nones_from_dict({u'expirationTime': item.get(u'expirationTime'), u'name': item.get(u'name'), u'value': item.get(u'value')})",
            "",
            "",
            "class InstanceBackupconfiguration(object):",
            "    def __init__(self, request, module):",
            "        self.module = module",
            "        if request:",
            "            self.request = request",
            "        else:",
            "            self.request = {}",
            "",
            "    def to_request(self):",
            "        return remove_nones_from_dict(",
            "            {u'enabled': self.request.get('enabled'), u'binaryLogEnabled': self.request.get('binary_log_enabled'), u'startTime': self.request.get('start_time')}",
            "        )",
            "",
            "    def from_response(self):",
            "        return remove_nones_from_dict(",
            "            {u'enabled': self.request.get(u'enabled'), u'binaryLogEnabled': self.request.get(u'binaryLogEnabled'), u'startTime': self.request.get(u'startTime')}",
            "        )",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "691": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/check_point/cp_mgmt_vpn_community_meshed.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         )),"
            },
            "1": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         shared_secrets=dict(type='list', options=dict("
            },
            "2": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "             external_gateway=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            shared_secret=dict(type='str')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            shared_secret=dict(type='str', no_log=True)"
            },
            "5": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "         )),"
            },
            "6": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "         tags=dict(type='list'),"
            },
            "7": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         use_shared_secret=dict(type='bool'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Ansible module to manage Check Point Firewall (c) 2019",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = \"\"\"",
            "---",
            "module: cp_mgmt_vpn_community_meshed",
            "short_description: Manages vpn-community-meshed objects on Check Point over Web Services API",
            "description:",
            "  - Manages vpn-community-meshed objects on Check Point devices including creating, updating and removing objects.",
            "  - All operations are performed over Web Services API.",
            "version_added: \"2.9\"",
            "author: \"Or Soffer (@chkp-orso)\"",
            "options:",
            "  name:",
            "    description:",
            "      - Object name.",
            "    type: str",
            "    required: True",
            "  encryption_method:",
            "    description:",
            "      - The encryption method to be used.",
            "    type: str",
            "    choices: ['prefer ikev2 but support ikev1', 'ikev2 only', 'ikev1 for ipv4 and ikev2 for ipv6 only']",
            "  encryption_suite:",
            "    description:",
            "      - The encryption suite to be used.",
            "    type: str",
            "    choices: ['suite-b-gcm-256', 'custom', 'vpn b', 'vpn a', 'suite-b-gcm-128']",
            "  gateways:",
            "    description:",
            "      - Collection of Gateway objects identified by the name or UID.",
            "    type: list",
            "  ike_phase_1:",
            "    description:",
            "      - Ike Phase 1 settings. Only applicable when the encryption-suite is set to [custom].",
            "    type: dict",
            "    suboptions:",
            "      data_integrity:",
            "        description:",
            "          - The hash algorithm to be used.",
            "        type: str",
            "        choices: ['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']",
            "      diffie_hellman_group:",
            "        description:",
            "          - The Diffie-Hellman group to be used.",
            "        type: str",
            "        choices: ['group-1', 'group-2', 'group-5', 'group-14', 'group-19', 'group-20']",
            "      encryption_algorithm:",
            "        description:",
            "          - The encryption algorithm to be used.",
            "        type: str",
            "        choices: ['cast', 'aes-256', 'des', 'aes-128', '3des']",
            "  ike_phase_2:",
            "    description:",
            "      - Ike Phase 2 settings. Only applicable when the encryption-suite is set to [custom].",
            "    type: dict",
            "    suboptions:",
            "      data_integrity:",
            "        description:",
            "          - The hash algorithm to be used.",
            "        type: str",
            "        choices: ['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']",
            "      encryption_algorithm:",
            "        description:",
            "          - The encryption algorithm to be used.",
            "        type: str",
            "        choices: ['cast', 'aes-gcm-256', 'cast-40', 'aes-256', 'des', 'aes-128', '3des', 'des-40cp', 'aes-gcm-128', 'none']",
            "  shared_secrets:",
            "    description:",
            "      - Shared secrets for external gateways.",
            "    type: list",
            "    suboptions:",
            "      external_gateway:",
            "        description:",
            "          - External gateway identified by the name or UID.",
            "        type: str",
            "      shared_secret:",
            "        description:",
            "          - Shared secret.",
            "        type: str",
            "  tags:",
            "    description:",
            "      - Collection of tag identifiers.",
            "    type: list",
            "  use_shared_secret:",
            "    description:",
            "      - Indicates whether the shared secret should be used for all external gateways.",
            "    type: bool",
            "  color:",
            "    description:",
            "      - Color of the object. Should be one of existing colors.",
            "    type: str",
            "    choices: ['aquamarine', 'black', 'blue', 'crete blue', 'burlywood', 'cyan', 'dark green', 'khaki', 'orchid', 'dark orange', 'dark sea green',",
            "             'pink', 'turquoise', 'dark blue', 'firebrick', 'brown', 'forest green', 'gold', 'dark gold', 'gray', 'dark gray', 'light green', 'lemon chiffon',",
            "             'coral', 'sea green', 'sky blue', 'magenta', 'purple', 'slate blue', 'violet red', 'navy blue', 'olive', 'orange', 'red', 'sienna', 'yellow']",
            "  comments:",
            "    description:",
            "      - Comments string.",
            "    type: str",
            "  details_level:",
            "    description:",
            "      - The level of detail for some of the fields in the response can vary from showing only the UID value of the object to a fully detailed",
            "        representation of the object.",
            "    type: str",
            "    choices: ['uid', 'standard', 'full']",
            "  ignore_warnings:",
            "    description:",
            "      - Apply changes ignoring warnings.",
            "    type: bool",
            "  ignore_errors:",
            "    description:",
            "      - Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.",
            "    type: bool",
            "extends_documentation_fragment: checkpoint_objects",
            "\"\"\"",
            "",
            "EXAMPLES = \"\"\"",
            "- name: add-vpn-community-meshed",
            "  cp_mgmt_vpn_community_meshed:",
            "    encryption_method: prefer ikev2 but support ikev1",
            "    encryption_suite: custom",
            "    ike_phase_1:",
            "      data_integrity: sha1",
            "      diffie_hellman_group: group 19",
            "      encryption_algorithm: aes-128",
            "    ike_phase_2:",
            "      data_integrity: aes-xcbc",
            "      encryption_algorithm: aes-gcm-128",
            "    name: New_VPN_Community_Meshed_1",
            "    state: present",
            "",
            "- name: set-vpn-community-meshed",
            "  cp_mgmt_vpn_community_meshed:",
            "    encryption_method: ikev2 only",
            "    encryption_suite: custom",
            "    ike_phase_1:",
            "      data_integrity: sha1",
            "      diffie_hellman_group: group 19",
            "      encryption_algorithm: aes-128",
            "    ike_phase_2:",
            "      data_integrity: aes-xcbc",
            "      encryption_algorithm: aes-gcm-128",
            "    name: New_VPN_Community_Meshed_1",
            "    state: present",
            "",
            "- name: delete-vpn-community-meshed",
            "  cp_mgmt_vpn_community_meshed:",
            "    name: New_VPN_Community_Meshed_1",
            "    state: absent",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "cp_mgmt_vpn_community_meshed:",
            "  description: The checkpoint object created or updated.",
            "  returned: always, except when deleting the object.",
            "  type: dict",
            "\"\"\"",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.network.checkpoint.checkpoint import checkpoint_argument_spec_for_objects, api_call",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        name=dict(type='str', required=True),",
            "        encryption_method=dict(type='str', choices=['prefer ikev2 but support ikev1', 'ikev2 only', 'ikev1 for ipv4 and ikev2 for ipv6 only']),",
            "        encryption_suite=dict(type='str', choices=['suite-b-gcm-256', 'custom', 'vpn b', 'vpn a', 'suite-b-gcm-128']),",
            "        gateways=dict(type='list'),",
            "        ike_phase_1=dict(type='dict', options=dict(",
            "            data_integrity=dict(type='str', choices=['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']),",
            "            diffie_hellman_group=dict(type='str', choices=['group-1', 'group-2', 'group-5', 'group-14', 'group-19', 'group-20']),",
            "            encryption_algorithm=dict(type='str', choices=['cast', 'aes-256', 'des', 'aes-128', '3des'])",
            "        )),",
            "        ike_phase_2=dict(type='dict', options=dict(",
            "            data_integrity=dict(type='str', choices=['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']),",
            "            encryption_algorithm=dict(type='str', choices=['cast', 'aes-gcm-256', 'cast-40',",
            "                                                           'aes-256', 'des', 'aes-128', '3des', 'des-40cp', 'aes-gcm-128', 'none'])",
            "        )),",
            "        shared_secrets=dict(type='list', options=dict(",
            "            external_gateway=dict(type='str'),",
            "            shared_secret=dict(type='str')",
            "        )),",
            "        tags=dict(type='list'),",
            "        use_shared_secret=dict(type='bool'),",
            "        color=dict(type='str', choices=['aquamarine', 'black', 'blue', 'crete blue', 'burlywood', 'cyan', 'dark green',",
            "                                        'khaki', 'orchid', 'dark orange', 'dark sea green', 'pink', 'turquoise', 'dark blue', 'firebrick', 'brown',",
            "                                        'forest green', 'gold', 'dark gold', 'gray', 'dark gray', 'light green', 'lemon chiffon', 'coral', 'sea green',",
            "                                        'sky blue', 'magenta', 'purple', 'slate blue', 'violet red', 'navy blue', 'olive', 'orange', 'red', 'sienna',",
            "                                        'yellow']),",
            "        comments=dict(type='str'),",
            "        details_level=dict(type='str', choices=['uid', 'standard', 'full']),",
            "        ignore_warnings=dict(type='bool'),",
            "        ignore_errors=dict(type='bool')",
            "    )",
            "    argument_spec.update(checkpoint_argument_spec_for_objects)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "    api_call_object = 'vpn-community-meshed'",
            "",
            "    result = api_call(module, api_call_object)",
            "    module.exit_json(**result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Ansible module to manage Check Point Firewall (c) 2019",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = \"\"\"",
            "---",
            "module: cp_mgmt_vpn_community_meshed",
            "short_description: Manages vpn-community-meshed objects on Check Point over Web Services API",
            "description:",
            "  - Manages vpn-community-meshed objects on Check Point devices including creating, updating and removing objects.",
            "  - All operations are performed over Web Services API.",
            "version_added: \"2.9\"",
            "author: \"Or Soffer (@chkp-orso)\"",
            "options:",
            "  name:",
            "    description:",
            "      - Object name.",
            "    type: str",
            "    required: True",
            "  encryption_method:",
            "    description:",
            "      - The encryption method to be used.",
            "    type: str",
            "    choices: ['prefer ikev2 but support ikev1', 'ikev2 only', 'ikev1 for ipv4 and ikev2 for ipv6 only']",
            "  encryption_suite:",
            "    description:",
            "      - The encryption suite to be used.",
            "    type: str",
            "    choices: ['suite-b-gcm-256', 'custom', 'vpn b', 'vpn a', 'suite-b-gcm-128']",
            "  gateways:",
            "    description:",
            "      - Collection of Gateway objects identified by the name or UID.",
            "    type: list",
            "  ike_phase_1:",
            "    description:",
            "      - Ike Phase 1 settings. Only applicable when the encryption-suite is set to [custom].",
            "    type: dict",
            "    suboptions:",
            "      data_integrity:",
            "        description:",
            "          - The hash algorithm to be used.",
            "        type: str",
            "        choices: ['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']",
            "      diffie_hellman_group:",
            "        description:",
            "          - The Diffie-Hellman group to be used.",
            "        type: str",
            "        choices: ['group-1', 'group-2', 'group-5', 'group-14', 'group-19', 'group-20']",
            "      encryption_algorithm:",
            "        description:",
            "          - The encryption algorithm to be used.",
            "        type: str",
            "        choices: ['cast', 'aes-256', 'des', 'aes-128', '3des']",
            "  ike_phase_2:",
            "    description:",
            "      - Ike Phase 2 settings. Only applicable when the encryption-suite is set to [custom].",
            "    type: dict",
            "    suboptions:",
            "      data_integrity:",
            "        description:",
            "          - The hash algorithm to be used.",
            "        type: str",
            "        choices: ['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']",
            "      encryption_algorithm:",
            "        description:",
            "          - The encryption algorithm to be used.",
            "        type: str",
            "        choices: ['cast', 'aes-gcm-256', 'cast-40', 'aes-256', 'des', 'aes-128', '3des', 'des-40cp', 'aes-gcm-128', 'none']",
            "  shared_secrets:",
            "    description:",
            "      - Shared secrets for external gateways.",
            "    type: list",
            "    suboptions:",
            "      external_gateway:",
            "        description:",
            "          - External gateway identified by the name or UID.",
            "        type: str",
            "      shared_secret:",
            "        description:",
            "          - Shared secret.",
            "        type: str",
            "  tags:",
            "    description:",
            "      - Collection of tag identifiers.",
            "    type: list",
            "  use_shared_secret:",
            "    description:",
            "      - Indicates whether the shared secret should be used for all external gateways.",
            "    type: bool",
            "  color:",
            "    description:",
            "      - Color of the object. Should be one of existing colors.",
            "    type: str",
            "    choices: ['aquamarine', 'black', 'blue', 'crete blue', 'burlywood', 'cyan', 'dark green', 'khaki', 'orchid', 'dark orange', 'dark sea green',",
            "             'pink', 'turquoise', 'dark blue', 'firebrick', 'brown', 'forest green', 'gold', 'dark gold', 'gray', 'dark gray', 'light green', 'lemon chiffon',",
            "             'coral', 'sea green', 'sky blue', 'magenta', 'purple', 'slate blue', 'violet red', 'navy blue', 'olive', 'orange', 'red', 'sienna', 'yellow']",
            "  comments:",
            "    description:",
            "      - Comments string.",
            "    type: str",
            "  details_level:",
            "    description:",
            "      - The level of detail for some of the fields in the response can vary from showing only the UID value of the object to a fully detailed",
            "        representation of the object.",
            "    type: str",
            "    choices: ['uid', 'standard', 'full']",
            "  ignore_warnings:",
            "    description:",
            "      - Apply changes ignoring warnings.",
            "    type: bool",
            "  ignore_errors:",
            "    description:",
            "      - Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.",
            "    type: bool",
            "extends_documentation_fragment: checkpoint_objects",
            "\"\"\"",
            "",
            "EXAMPLES = \"\"\"",
            "- name: add-vpn-community-meshed",
            "  cp_mgmt_vpn_community_meshed:",
            "    encryption_method: prefer ikev2 but support ikev1",
            "    encryption_suite: custom",
            "    ike_phase_1:",
            "      data_integrity: sha1",
            "      diffie_hellman_group: group 19",
            "      encryption_algorithm: aes-128",
            "    ike_phase_2:",
            "      data_integrity: aes-xcbc",
            "      encryption_algorithm: aes-gcm-128",
            "    name: New_VPN_Community_Meshed_1",
            "    state: present",
            "",
            "- name: set-vpn-community-meshed",
            "  cp_mgmt_vpn_community_meshed:",
            "    encryption_method: ikev2 only",
            "    encryption_suite: custom",
            "    ike_phase_1:",
            "      data_integrity: sha1",
            "      diffie_hellman_group: group 19",
            "      encryption_algorithm: aes-128",
            "    ike_phase_2:",
            "      data_integrity: aes-xcbc",
            "      encryption_algorithm: aes-gcm-128",
            "    name: New_VPN_Community_Meshed_1",
            "    state: present",
            "",
            "- name: delete-vpn-community-meshed",
            "  cp_mgmt_vpn_community_meshed:",
            "    name: New_VPN_Community_Meshed_1",
            "    state: absent",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "cp_mgmt_vpn_community_meshed:",
            "  description: The checkpoint object created or updated.",
            "  returned: always, except when deleting the object.",
            "  type: dict",
            "\"\"\"",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.network.checkpoint.checkpoint import checkpoint_argument_spec_for_objects, api_call",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        name=dict(type='str', required=True),",
            "        encryption_method=dict(type='str', choices=['prefer ikev2 but support ikev1', 'ikev2 only', 'ikev1 for ipv4 and ikev2 for ipv6 only']),",
            "        encryption_suite=dict(type='str', choices=['suite-b-gcm-256', 'custom', 'vpn b', 'vpn a', 'suite-b-gcm-128']),",
            "        gateways=dict(type='list'),",
            "        ike_phase_1=dict(type='dict', options=dict(",
            "            data_integrity=dict(type='str', choices=['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']),",
            "            diffie_hellman_group=dict(type='str', choices=['group-1', 'group-2', 'group-5', 'group-14', 'group-19', 'group-20']),",
            "            encryption_algorithm=dict(type='str', choices=['cast', 'aes-256', 'des', 'aes-128', '3des'])",
            "        )),",
            "        ike_phase_2=dict(type='dict', options=dict(",
            "            data_integrity=dict(type='str', choices=['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']),",
            "            encryption_algorithm=dict(type='str', choices=['cast', 'aes-gcm-256', 'cast-40',",
            "                                                           'aes-256', 'des', 'aes-128', '3des', 'des-40cp', 'aes-gcm-128', 'none'])",
            "        )),",
            "        shared_secrets=dict(type='list', options=dict(",
            "            external_gateway=dict(type='str'),",
            "            shared_secret=dict(type='str', no_log=True)",
            "        )),",
            "        tags=dict(type='list'),",
            "        use_shared_secret=dict(type='bool'),",
            "        color=dict(type='str', choices=['aquamarine', 'black', 'blue', 'crete blue', 'burlywood', 'cyan', 'dark green',",
            "                                        'khaki', 'orchid', 'dark orange', 'dark sea green', 'pink', 'turquoise', 'dark blue', 'firebrick', 'brown',",
            "                                        'forest green', 'gold', 'dark gold', 'gray', 'dark gray', 'light green', 'lemon chiffon', 'coral', 'sea green',",
            "                                        'sky blue', 'magenta', 'purple', 'slate blue', 'violet red', 'navy blue', 'olive', 'orange', 'red', 'sienna',",
            "                                        'yellow']),",
            "        comments=dict(type='str'),",
            "        details_level=dict(type='str', choices=['uid', 'standard', 'full']),",
            "        ignore_warnings=dict(type='bool'),",
            "        ignore_errors=dict(type='bool')",
            "    )",
            "    argument_spec.update(checkpoint_argument_spec_for_objects)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "    api_call_object = 'vpn-community-meshed'",
            "",
            "    result = api_call(module, api_call_object)",
            "    module.exit_json(**result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "205": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/check_point/cp_mgmt_vpn_community_star.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         satellite_gateways=dict(type='list'),"
            },
            "1": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         shared_secrets=dict(type='list', options=dict("
            },
            "2": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "             external_gateway=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            shared_secret=dict(type='str')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            shared_secret=dict(type='str', no_log=True)"
            },
            "5": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "         )),"
            },
            "6": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "         tags=dict(type='list'),"
            },
            "7": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "         use_shared_secret=dict(type='bool'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Ansible module to manage Check Point Firewall (c) 2019",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = \"\"\"",
            "---",
            "module: cp_mgmt_vpn_community_star",
            "short_description: Manages vpn-community-star objects on Check Point over Web Services API",
            "description:",
            "  - Manages vpn-community-star objects on Check Point devices including creating, updating and removing objects.",
            "  - All operations are performed over Web Services API.",
            "version_added: \"2.9\"",
            "author: \"Or Soffer (@chkp-orso)\"",
            "options:",
            "  name:",
            "    description:",
            "      - Object name.",
            "    type: str",
            "    required: True",
            "  center_gateways:",
            "    description:",
            "      - Collection of Gateway objects representing center gateways identified by the name or UID.",
            "    type: list",
            "  encryption_method:",
            "    description:",
            "      - The encryption method to be used.",
            "    type: str",
            "    choices: ['prefer ikev2 but support ikev1', 'ikev2 only', 'ikev1 for ipv4 and ikev2 for ipv6 only']",
            "  encryption_suite:",
            "    description:",
            "      - The encryption suite to be used.",
            "    type: str",
            "    choices: ['suite-b-gcm-256', 'custom', 'vpn b', 'vpn a', 'suite-b-gcm-128']",
            "  ike_phase_1:",
            "    description:",
            "      - Ike Phase 1 settings. Only applicable when the encryption-suite is set to [custom].",
            "    type: dict",
            "    suboptions:",
            "      data_integrity:",
            "        description:",
            "          - The hash algorithm to be used.",
            "        type: str",
            "        choices: ['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']",
            "      diffie_hellman_group:",
            "        description:",
            "          - The Diffie-Hellman group to be used.",
            "        type: str",
            "        choices: ['group-1', 'group-2', 'group-5', 'group-14', 'group-19', 'group-20']",
            "      encryption_algorithm:",
            "        description:",
            "          - The encryption algorithm to be used.",
            "        type: str",
            "        choices: ['cast', 'aes-256', 'des', 'aes-128', '3des']",
            "  ike_phase_2:",
            "    description:",
            "      - Ike Phase 2 settings. Only applicable when the encryption-suite is set to [custom].",
            "    type: dict",
            "    suboptions:",
            "      data_integrity:",
            "        description:",
            "          - The hash algorithm to be used.",
            "        type: str",
            "        choices: ['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']",
            "      encryption_algorithm:",
            "        description:",
            "          - The encryption algorithm to be used.",
            "        type: str",
            "        choices: ['cast', 'aes-gcm-256', 'cast-40', 'aes-256', 'des', 'aes-128', '3des', 'des-40cp', 'aes-gcm-128', 'none']",
            "  mesh_center_gateways:",
            "    description:",
            "      - Indicates whether the meshed community is in center.",
            "    type: bool",
            "  satellite_gateways:",
            "    description:",
            "      - Collection of Gateway objects representing satellite gateways identified by the name or UID.",
            "    type: list",
            "  shared_secrets:",
            "    description:",
            "      - Shared secrets for external gateways.",
            "    type: list",
            "    suboptions:",
            "      external_gateway:",
            "        description:",
            "          - External gateway identified by the name or UID.",
            "        type: str",
            "      shared_secret:",
            "        description:",
            "          - Shared secret.",
            "        type: str",
            "  tags:",
            "    description:",
            "      - Collection of tag identifiers.",
            "    type: list",
            "  use_shared_secret:",
            "    description:",
            "      - Indicates whether the shared secret should be used for all external gateways.",
            "    type: bool",
            "  color:",
            "    description:",
            "      - Color of the object. Should be one of existing colors.",
            "    type: str",
            "    choices: ['aquamarine', 'black', 'blue', 'crete blue', 'burlywood', 'cyan', 'dark green', 'khaki', 'orchid', 'dark orange', 'dark sea green',",
            "             'pink', 'turquoise', 'dark blue', 'firebrick', 'brown', 'forest green', 'gold', 'dark gold', 'gray', 'dark gray', 'light green', 'lemon chiffon',",
            "             'coral', 'sea green', 'sky blue', 'magenta', 'purple', 'slate blue', 'violet red', 'navy blue', 'olive', 'orange', 'red', 'sienna', 'yellow']",
            "  comments:",
            "    description:",
            "      - Comments string.",
            "    type: str",
            "  details_level:",
            "    description:",
            "      - The level of detail for some of the fields in the response can vary from showing only the UID value of the object to a fully detailed",
            "        representation of the object.",
            "    type: str",
            "    choices: ['uid', 'standard', 'full']",
            "  ignore_warnings:",
            "    description:",
            "      - Apply changes ignoring warnings.",
            "    type: bool",
            "  ignore_errors:",
            "    description:",
            "      - Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.",
            "    type: bool",
            "extends_documentation_fragment: checkpoint_objects",
            "\"\"\"",
            "",
            "EXAMPLES = \"\"\"",
            "- name: add-vpn-community-star",
            "  cp_mgmt_vpn_community_star:",
            "    center_gateways: Second_Security_Gateway",
            "    encryption_method: prefer ikev2 but support ikev1",
            "    encryption_suite: custom",
            "    ike_phase_1:",
            "      data_integrity: sha1",
            "      diffie_hellman_group: group 19",
            "      encryption_algorithm: aes-128",
            "    ike_phase_2:",
            "      data_integrity: aes-xcbc",
            "      encryption_algorithm: aes-gcm-128",
            "    name: New_VPN_Community_Star_1",
            "    state: present",
            "",
            "- name: set-vpn-community-star",
            "  cp_mgmt_vpn_community_star:",
            "    encryption_method: ikev2 only",
            "    encryption_suite: custom",
            "    ike_phase_1:",
            "      data_integrity: sha1",
            "      diffie_hellman_group: group 19",
            "      encryption_algorithm: aes-128",
            "    ike_phase_2:",
            "      data_integrity: aes-xcbc",
            "      encryption_algorithm: aes-gcm-128",
            "    name: New_VPN_Community_Star_1",
            "    state: present",
            "",
            "- name: delete-vpn-community-star",
            "  cp_mgmt_vpn_community_star:",
            "    name: New_VPN_Community_Star_1",
            "    state: absent",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "cp_mgmt_vpn_community_star:",
            "  description: The checkpoint object created or updated.",
            "  returned: always, except when deleting the object.",
            "  type: dict",
            "\"\"\"",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.network.checkpoint.checkpoint import checkpoint_argument_spec_for_objects, api_call",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        name=dict(type='str', required=True),",
            "        center_gateways=dict(type='list'),",
            "        encryption_method=dict(type='str', choices=['prefer ikev2 but support ikev1', 'ikev2 only', 'ikev1 for ipv4 and ikev2 for ipv6 only']),",
            "        encryption_suite=dict(type='str', choices=['suite-b-gcm-256', 'custom', 'vpn b', 'vpn a', 'suite-b-gcm-128']),",
            "        ike_phase_1=dict(type='dict', options=dict(",
            "            data_integrity=dict(type='str', choices=['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']),",
            "            diffie_hellman_group=dict(type='str', choices=['group-1', 'group-2', 'group-5', 'group-14', 'group-19', 'group-20']),",
            "            encryption_algorithm=dict(type='str', choices=['cast', 'aes-256', 'des', 'aes-128', '3des'])",
            "        )),",
            "        ike_phase_2=dict(type='dict', options=dict(",
            "            data_integrity=dict(type='str', choices=['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']),",
            "            encryption_algorithm=dict(type='str', choices=['cast', 'aes-gcm-256', 'cast-40',",
            "                                                           'aes-256', 'des', 'aes-128', '3des', 'des-40cp', 'aes-gcm-128', 'none'])",
            "        )),",
            "        mesh_center_gateways=dict(type='bool'),",
            "        satellite_gateways=dict(type='list'),",
            "        shared_secrets=dict(type='list', options=dict(",
            "            external_gateway=dict(type='str'),",
            "            shared_secret=dict(type='str')",
            "        )),",
            "        tags=dict(type='list'),",
            "        use_shared_secret=dict(type='bool'),",
            "        color=dict(type='str', choices=['aquamarine', 'black', 'blue', 'crete blue', 'burlywood', 'cyan', 'dark green',",
            "                                        'khaki', 'orchid', 'dark orange', 'dark sea green', 'pink', 'turquoise', 'dark blue', 'firebrick', 'brown',",
            "                                        'forest green', 'gold', 'dark gold', 'gray', 'dark gray', 'light green', 'lemon chiffon', 'coral', 'sea green',",
            "                                        'sky blue', 'magenta', 'purple', 'slate blue', 'violet red', 'navy blue', 'olive', 'orange', 'red', 'sienna',",
            "                                        'yellow']),",
            "        comments=dict(type='str'),",
            "        details_level=dict(type='str', choices=['uid', 'standard', 'full']),",
            "        ignore_warnings=dict(type='bool'),",
            "        ignore_errors=dict(type='bool')",
            "    )",
            "    argument_spec.update(checkpoint_argument_spec_for_objects)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "    api_call_object = 'vpn-community-star'",
            "",
            "    result = api_call(module, api_call_object)",
            "    module.exit_json(**result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "#",
            "# Ansible module to manage Check Point Firewall (c) 2019",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = \"\"\"",
            "---",
            "module: cp_mgmt_vpn_community_star",
            "short_description: Manages vpn-community-star objects on Check Point over Web Services API",
            "description:",
            "  - Manages vpn-community-star objects on Check Point devices including creating, updating and removing objects.",
            "  - All operations are performed over Web Services API.",
            "version_added: \"2.9\"",
            "author: \"Or Soffer (@chkp-orso)\"",
            "options:",
            "  name:",
            "    description:",
            "      - Object name.",
            "    type: str",
            "    required: True",
            "  center_gateways:",
            "    description:",
            "      - Collection of Gateway objects representing center gateways identified by the name or UID.",
            "    type: list",
            "  encryption_method:",
            "    description:",
            "      - The encryption method to be used.",
            "    type: str",
            "    choices: ['prefer ikev2 but support ikev1', 'ikev2 only', 'ikev1 for ipv4 and ikev2 for ipv6 only']",
            "  encryption_suite:",
            "    description:",
            "      - The encryption suite to be used.",
            "    type: str",
            "    choices: ['suite-b-gcm-256', 'custom', 'vpn b', 'vpn a', 'suite-b-gcm-128']",
            "  ike_phase_1:",
            "    description:",
            "      - Ike Phase 1 settings. Only applicable when the encryption-suite is set to [custom].",
            "    type: dict",
            "    suboptions:",
            "      data_integrity:",
            "        description:",
            "          - The hash algorithm to be used.",
            "        type: str",
            "        choices: ['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']",
            "      diffie_hellman_group:",
            "        description:",
            "          - The Diffie-Hellman group to be used.",
            "        type: str",
            "        choices: ['group-1', 'group-2', 'group-5', 'group-14', 'group-19', 'group-20']",
            "      encryption_algorithm:",
            "        description:",
            "          - The encryption algorithm to be used.",
            "        type: str",
            "        choices: ['cast', 'aes-256', 'des', 'aes-128', '3des']",
            "  ike_phase_2:",
            "    description:",
            "      - Ike Phase 2 settings. Only applicable when the encryption-suite is set to [custom].",
            "    type: dict",
            "    suboptions:",
            "      data_integrity:",
            "        description:",
            "          - The hash algorithm to be used.",
            "        type: str",
            "        choices: ['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']",
            "      encryption_algorithm:",
            "        description:",
            "          - The encryption algorithm to be used.",
            "        type: str",
            "        choices: ['cast', 'aes-gcm-256', 'cast-40', 'aes-256', 'des', 'aes-128', '3des', 'des-40cp', 'aes-gcm-128', 'none']",
            "  mesh_center_gateways:",
            "    description:",
            "      - Indicates whether the meshed community is in center.",
            "    type: bool",
            "  satellite_gateways:",
            "    description:",
            "      - Collection of Gateway objects representing satellite gateways identified by the name or UID.",
            "    type: list",
            "  shared_secrets:",
            "    description:",
            "      - Shared secrets for external gateways.",
            "    type: list",
            "    suboptions:",
            "      external_gateway:",
            "        description:",
            "          - External gateway identified by the name or UID.",
            "        type: str",
            "      shared_secret:",
            "        description:",
            "          - Shared secret.",
            "        type: str",
            "  tags:",
            "    description:",
            "      - Collection of tag identifiers.",
            "    type: list",
            "  use_shared_secret:",
            "    description:",
            "      - Indicates whether the shared secret should be used for all external gateways.",
            "    type: bool",
            "  color:",
            "    description:",
            "      - Color of the object. Should be one of existing colors.",
            "    type: str",
            "    choices: ['aquamarine', 'black', 'blue', 'crete blue', 'burlywood', 'cyan', 'dark green', 'khaki', 'orchid', 'dark orange', 'dark sea green',",
            "             'pink', 'turquoise', 'dark blue', 'firebrick', 'brown', 'forest green', 'gold', 'dark gold', 'gray', 'dark gray', 'light green', 'lemon chiffon',",
            "             'coral', 'sea green', 'sky blue', 'magenta', 'purple', 'slate blue', 'violet red', 'navy blue', 'olive', 'orange', 'red', 'sienna', 'yellow']",
            "  comments:",
            "    description:",
            "      - Comments string.",
            "    type: str",
            "  details_level:",
            "    description:",
            "      - The level of detail for some of the fields in the response can vary from showing only the UID value of the object to a fully detailed",
            "        representation of the object.",
            "    type: str",
            "    choices: ['uid', 'standard', 'full']",
            "  ignore_warnings:",
            "    description:",
            "      - Apply changes ignoring warnings.",
            "    type: bool",
            "  ignore_errors:",
            "    description:",
            "      - Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.",
            "    type: bool",
            "extends_documentation_fragment: checkpoint_objects",
            "\"\"\"",
            "",
            "EXAMPLES = \"\"\"",
            "- name: add-vpn-community-star",
            "  cp_mgmt_vpn_community_star:",
            "    center_gateways: Second_Security_Gateway",
            "    encryption_method: prefer ikev2 but support ikev1",
            "    encryption_suite: custom",
            "    ike_phase_1:",
            "      data_integrity: sha1",
            "      diffie_hellman_group: group 19",
            "      encryption_algorithm: aes-128",
            "    ike_phase_2:",
            "      data_integrity: aes-xcbc",
            "      encryption_algorithm: aes-gcm-128",
            "    name: New_VPN_Community_Star_1",
            "    state: present",
            "",
            "- name: set-vpn-community-star",
            "  cp_mgmt_vpn_community_star:",
            "    encryption_method: ikev2 only",
            "    encryption_suite: custom",
            "    ike_phase_1:",
            "      data_integrity: sha1",
            "      diffie_hellman_group: group 19",
            "      encryption_algorithm: aes-128",
            "    ike_phase_2:",
            "      data_integrity: aes-xcbc",
            "      encryption_algorithm: aes-gcm-128",
            "    name: New_VPN_Community_Star_1",
            "    state: present",
            "",
            "- name: delete-vpn-community-star",
            "  cp_mgmt_vpn_community_star:",
            "    name: New_VPN_Community_Star_1",
            "    state: absent",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "cp_mgmt_vpn_community_star:",
            "  description: The checkpoint object created or updated.",
            "  returned: always, except when deleting the object.",
            "  type: dict",
            "\"\"\"",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.network.checkpoint.checkpoint import checkpoint_argument_spec_for_objects, api_call",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        name=dict(type='str', required=True),",
            "        center_gateways=dict(type='list'),",
            "        encryption_method=dict(type='str', choices=['prefer ikev2 but support ikev1', 'ikev2 only', 'ikev1 for ipv4 and ikev2 for ipv6 only']),",
            "        encryption_suite=dict(type='str', choices=['suite-b-gcm-256', 'custom', 'vpn b', 'vpn a', 'suite-b-gcm-128']),",
            "        ike_phase_1=dict(type='dict', options=dict(",
            "            data_integrity=dict(type='str', choices=['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']),",
            "            diffie_hellman_group=dict(type='str', choices=['group-1', 'group-2', 'group-5', 'group-14', 'group-19', 'group-20']),",
            "            encryption_algorithm=dict(type='str', choices=['cast', 'aes-256', 'des', 'aes-128', '3des'])",
            "        )),",
            "        ike_phase_2=dict(type='dict', options=dict(",
            "            data_integrity=dict(type='str', choices=['aes-xcbc', 'sha1', 'sha256', 'sha384', 'md5']),",
            "            encryption_algorithm=dict(type='str', choices=['cast', 'aes-gcm-256', 'cast-40',",
            "                                                           'aes-256', 'des', 'aes-128', '3des', 'des-40cp', 'aes-gcm-128', 'none'])",
            "        )),",
            "        mesh_center_gateways=dict(type='bool'),",
            "        satellite_gateways=dict(type='list'),",
            "        shared_secrets=dict(type='list', options=dict(",
            "            external_gateway=dict(type='str'),",
            "            shared_secret=dict(type='str', no_log=True)",
            "        )),",
            "        tags=dict(type='list'),",
            "        use_shared_secret=dict(type='bool'),",
            "        color=dict(type='str', choices=['aquamarine', 'black', 'blue', 'crete blue', 'burlywood', 'cyan', 'dark green',",
            "                                        'khaki', 'orchid', 'dark orange', 'dark sea green', 'pink', 'turquoise', 'dark blue', 'firebrick', 'brown',",
            "                                        'forest green', 'gold', 'dark gold', 'gray', 'dark gray', 'light green', 'lemon chiffon', 'coral', 'sea green',",
            "                                        'sky blue', 'magenta', 'purple', 'slate blue', 'violet red', 'navy blue', 'olive', 'orange', 'red', 'sienna',",
            "                                        'yellow']),",
            "        comments=dict(type='str'),",
            "        details_level=dict(type='str', choices=['uid', 'standard', 'full']),",
            "        ignore_warnings=dict(type='bool'),",
            "        ignore_errors=dict(type='bool')",
            "    )",
            "    argument_spec.update(checkpoint_argument_spec_for_objects)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "    api_call_object = 'vpn-community-star'",
            "",
            "    result = api_call(module, api_call_object)",
            "    module.exit_json(**result)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "216": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/cloudengine/ce_vrrp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1314,
                "afterPatchRowNumber": 1314,
                "PatchRowcode": "         holding_multiplier=dict(type='str'),"
            },
            "1": {
                "beforePatchRowNumber": 1315,
                "afterPatchRowNumber": 1315,
                "PatchRowcode": "         auth_mode=dict(type='str', choices=['simple', 'md5', 'none']),"
            },
            "2": {
                "beforePatchRowNumber": 1316,
                "afterPatchRowNumber": 1316,
                "PatchRowcode": "         is_plain=dict(type='bool', default=False),"
            },
            "3": {
                "beforePatchRowNumber": 1317,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        auth_key=dict(type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1317,
                "PatchRowcode": "+        auth_key=dict(type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 1318,
                "afterPatchRowNumber": 1318,
                "PatchRowcode": "         fast_resume=dict(type='str', choices=['enable', 'disable']),"
            },
            "6": {
                "beforePatchRowNumber": 1319,
                "afterPatchRowNumber": 1319,
                "PatchRowcode": "         state=dict(type='str', default='present',"
            },
            "7": {
                "beforePatchRowNumber": 1320,
                "afterPatchRowNumber": 1320,
                "PatchRowcode": "                    choices=['present', 'absent'])"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: ce_vrrp",
            "version_added: \"2.4\"",
            "short_description: Manages VRRP interfaces on HUAWEI CloudEngine devices.",
            "description:",
            "    - Manages VRRP interface attributes on HUAWEI CloudEngine devices.",
            "author:",
            "    - Li Yanfeng (@numone213)",
            "notes:",
            "    - This module requires the netconf system service be enabled on the remote device being managed.",
            "    - Recommended connection is C(netconf).",
            "    - This module also works with C(local) connections for legacy playbooks.",
            "options:",
            "    interface:",
            "        description:",
            "            - Name of an interface. The value is a string of 1 to 63 characters.",
            "    vrid:",
            "        description:",
            "            - VRRP backup group ID.",
            "              The value is an integer ranging from 1 to 255.",
            "        default: present",
            "    virtual_ip :",
            "        description:",
            "            - Virtual IP address. The value is a string of 0 to 255 characters.",
            "    vrrp_type:",
            "        description:",
            "            - Type of a VRRP backup group.",
            "        type: str",
            "        choices: ['normal', 'member', 'admin']",
            "    admin_ignore_if_down:",
            "        description:",
            "            - mVRRP ignores an interface Down event.",
            "        type: bool",
            "        default: 'false'",
            "    admin_vrid:",
            "        description:",
            "            - Tracked mVRRP ID. The value is an integer ranging from 1 to 255.",
            "    admin_interface:",
            "        description:",
            "            - Tracked mVRRP interface name. The value is a string of 1 to 63 characters.",
            "    admin_flowdown:",
            "        description:",
            "            - Disable the flowdown function for service VRRP.",
            "        type: bool",
            "        default: 'false'",
            "    priority:",
            "        description:",
            "            - Configured VRRP priority.",
            "              The value ranges from 1 to 254. The default value is 100. A larger value indicates a higher priority.",
            "    version:",
            "        description:",
            "            - VRRP version. The default version is v2.",
            "        type: str",
            "        choices: ['v2','v3']",
            "    advertise_interval:",
            "        description:",
            "            - Configured interval between sending advertisements, in milliseconds.",
            "              Only the master router sends VRRP advertisements. The default value is 1000 milliseconds.",
            "    preempt_timer_delay:",
            "        description:",
            "            - Preemption delay.",
            "              The value is an integer ranging from 0 to 3600. The default value is 0.",
            "    gratuitous_arp_interval:",
            "        description:",
            "            - Interval at which gratuitous ARP packets are sent, in seconds.",
            "              The value ranges from 30 to 1200.The default value is 300.",
            "    recover_delay:",
            "        description:",
            "            - Delay in recovering after an interface goes Up.",
            "              The delay is used for interface flapping suppression.",
            "              The value is an integer ranging from 0 to 3600.",
            "              The default value is 0 seconds.",
            "    holding_multiplier:",
            "        description:",
            "            - The configured holdMultiplier.The value is an integer ranging from 3 to 10. The default value is 3.",
            "    auth_mode:",
            "        description:",
            "            - Authentication type used for VRRP packet exchanges between virtual routers.",
            "              The values are noAuthentication, simpleTextPassword, md5Authentication.",
            "              The default value is noAuthentication.",
            "        type: str",
            "        choices: ['simple','md5','none']",
            "    is_plain:",
            "        description:",
            "            - Select the display mode of an authentication key.",
            "              By default, an authentication key is displayed in ciphertext.",
            "        type: bool",
            "        default: 'false'",
            "    auth_key:",
            "        description:",
            "            - This object is set based on the authentication type.",
            "              When noAuthentication is specified, the value is empty.",
            "              When simpleTextPassword or md5Authentication is specified, the value is a string of 1 to 8 characters",
            "              in plaintext and displayed as a blank text for security.",
            "    fast_resume:",
            "        description:",
            "            - mVRRP's fast resume mode.",
            "        type: str",
            "        choices: ['enable','disable']",
            "    state:",
            "        description:",
            "            - Specify desired state of the resource.",
            "        type: str",
            "        default: present",
            "        choices: ['present','absent']",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: vrrp module test",
            "  hosts: cloudengine",
            "  connection: local",
            "  gather_facts: no",
            "  vars:",
            "    cli:",
            "      host: \"{{ inventory_hostname }}\"",
            "      port: \"{{ ansible_ssh_port }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      transport: cli",
            "  tasks:",
            "  - name: Set vrrp version",
            "    ce_vrrp:",
            "      version: v3",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp gratuitous-arp interval",
            "    ce_vrrp:",
            "      gratuitous_arp_interval: 40",
            "      mlag_id: 4",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp recover-delay",
            "    ce_vrrp:",
            "      recover_delay: 10",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid virtual-ip",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      virtual_ip: 10.14.2.7",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid admin",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      vrrp_type: admin",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid fast_resume",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      fast_resume: enable",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid holding-multiplier",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      holding_multiplier: 4",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid preempt timer delay",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      preempt_timer_delay: 10",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid admin-vrrp",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      admin_interface: 40GE2/0/9",
            "      admin_vrid: 2",
            "      vrrp_type: member",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid authentication-mode",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      is_plain: true",
            "      auth_mode: simple",
            "      auth_key: aaa",
            "      provider: \"{{ cli }}\"",
            "'''",
            "",
            "RETURN = '''",
            "changed:",
            "    description: check to see if a change was made on the device",
            "    returned: always",
            "    type: bool",
            "    sample: true",
            "proposed:",
            "    description: k/v pairs of parameters passed into module",
            "    returned: always",
            "    type: dict",
            "    sample: {",
            "                \"auth_key\": \"aaa\",",
            "                \"auth_mode\": \"simple\",",
            "                \"interface\": \"40GE2/0/8\",",
            "                \"is_plain\": true,",
            "                \"state\": \"present\",",
            "                \"vrid\": \"1\"",
            "            }",
            "existing:",
            "    description: k/v pairs of existing aaa server",
            "    returned: always",
            "    type: dict",
            "    sample: {",
            "                \"auth_mode\": \"none\",",
            "                \"interface\": \"40GE2/0/8\",",
            "                \"is_plain\": \"false\",",
            "                \"vrid\": \"1\",",
            "                \"vrrp_type\": \"normal\"",
            "            }",
            "end_state:",
            "    description: k/v pairs of aaa params after module execution",
            "    returned: always",
            "    type: dict",
            "    sample: {",
            "                \"auth_mode\": \"simple\",",
            "                \"interface\": \"40GE2/0/8\",",
            "                \"is_plain\": \"true\",",
            "                \"vrid\": \"1\",",
            "                \"vrrp_type\": \"normal\"",
            "    }",
            "updates:",
            "    description: command sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: { \"interface 40GE2/0/8\",",
            "              \"vrrp vrid 1 authentication-mode simple plain aaa\"}",
            "'''",
            "",
            "from xml.etree import ElementTree",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.network.cloudengine.ce import get_nc_config, set_nc_config, ce_argument_spec",
            "",
            "",
            "CE_NC_GET_VRRP_GROUP_INFO = \"\"\"",
            "<filter type=\"subtree\">",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup>",
            "        <ifName>%s</ifName>",
            "        <vrrpId>%s</vrrpId>",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</filter>",
            "\"\"\"",
            "",
            "CE_NC_SET_VRRP_GROUP_INFO_HEAD = \"\"\"",
            "<config>",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup operation=\"merge\">",
            "        <ifName>%s</ifName>",
            "        <vrrpId>%s</vrrpId>",
            "\"\"\"",
            "CE_NC_SET_VRRP_GROUP_INFO_TAIL = \"\"\"",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</config>",
            "\"\"\"",
            "CE_NC_GET_VRRP_GLOBAL_INFO = \"\"\"",
            "<filter type=\"subtree\">",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGlobalCfg>",
            "      <gratuitousArpFlag></gratuitousArpFlag>",
            "      <gratuitousArpTimeOut></gratuitousArpTimeOut>",
            "      <recoverDelay></recoverDelay>",
            "      <version></version>",
            "    </vrrpGlobalCfg>",
            "  </vrrp>",
            "</filter>",
            "\"\"\"",
            "",
            "CE_NC_SET_VRRP_GLOBAL_HEAD = \"\"\"",
            "<config>",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGlobalCfg operation=\"merge\">",
            "\"\"\"",
            "CE_NC_SET_VRRP_GLOBAL_TAIL = \"\"\"",
            "    </vrrpGlobalCfg>",
            "  </vrrp>",
            "</config>",
            "\"\"\"",
            "",
            "CE_NC_GET_VRRP_VIRTUAL_IP_INFO = \"\"\"",
            "<filter type=\"subtree\">",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup>",
            "        <vrrpId>%s</vrrpId>",
            "        <ifName>%s</ifName>",
            "        <virtualIps>",
            "          <virtualIp>",
            "            <virtualIpAddress></virtualIpAddress>",
            "          </virtualIp>",
            "        </virtualIps>",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</filter>",
            "\"\"\"",
            "CE_NC_CREATE_VRRP_VIRTUAL_IP_INFO = \"\"\"",
            "<config>",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup>",
            "        <vrrpId>%s</vrrpId>",
            "        <ifName>%s</ifName>",
            "        <virtualIps>",
            "          <virtualIp operation=\"create\">",
            "            <virtualIpAddress>%s</virtualIpAddress>",
            "          </virtualIp>",
            "        </virtualIps>",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</config>",
            "\"\"\"",
            "CE_NC_DELETE_VRRP_VIRTUAL_IP_INFO = \"\"\"",
            "<config>",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup>",
            "        <vrrpId>%s</vrrpId>",
            "        <ifName>%s</ifName>",
            "        <virtualIps>",
            "          <virtualIp operation=\"delete\">",
            "            <virtualIpAddress>%s</virtualIpAddress>",
            "          </virtualIp>",
            "        </virtualIps>",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</config>",
            "\"\"\"",
            "",
            "",
            "def is_valid_address(address):",
            "    \"\"\"check ip-address is valid\"\"\"",
            "",
            "    if address.find('.') != -1:",
            "        addr_list = address.split('.')",
            "        if len(addr_list) != 4:",
            "            return False",
            "        for each_num in addr_list:",
            "            if not each_num.isdigit():",
            "                return False",
            "            if int(each_num) > 255:",
            "                return False",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def get_interface_type(interface):",
            "    \"\"\"Gets the type of interface, such as 10GE, ETH-TRUNK, VLANIF...\"\"\"",
            "",
            "    if interface is None:",
            "        return None",
            "",
            "    iftype = None",
            "",
            "    if interface.upper().startswith('GE'):",
            "        iftype = 'ge'",
            "    elif interface.upper().startswith('10GE'):",
            "        iftype = '10ge'",
            "    elif interface.upper().startswith('25GE'):",
            "        iftype = '25ge'",
            "    elif interface.upper().startswith('40GE'):",
            "        iftype = '40ge'",
            "    elif interface.upper().startswith('100GE'):",
            "        iftype = '100ge'",
            "    elif interface.upper().startswith('ETH-TRUNK'):",
            "        iftype = 'eth-trunk'",
            "    elif interface.upper().startswith('NULL'):",
            "        iftype = 'null'",
            "    elif interface.upper().startswith('VLANIF'):",
            "        iftype = 'vlanif'",
            "    else:",
            "        return None",
            "",
            "    return iftype.lower()",
            "",
            "",
            "class Vrrp(object):",
            "    \"\"\"",
            "    Manages Manages vrrp information.",
            "    \"\"\"",
            "",
            "    def __init__(self, argument_spec):",
            "        self.spec = argument_spec",
            "        self.module = None",
            "        self.init_module()",
            "",
            "        # module input info",
            "        self.interface = self.module.params['interface']",
            "        self.vrid = self.module.params['vrid']",
            "        self.virtual_ip = self.module.params['virtual_ip']",
            "        self.vrrp_type = self.module.params['vrrp_type']",
            "        self.admin_ignore_if_down = 'false' if self.module.params['admin_ignore_if_down'] is False else 'true'",
            "        self.admin_vrid = self.module.params['admin_vrid']",
            "        self.admin_interface = self.module.params['admin_interface']",
            "        self.admin_flowdown = 'false' if self.module.params['admin_flowdown'] is False else 'true'",
            "        self.priority = self.module.params['priority']",
            "        self.version = self.module.params['version']",
            "        self.advertise_interval = self.module.params['advertise_interval']",
            "        self.preempt_timer_delay = self.module.params['preempt_timer_delay']",
            "        self.gratuitous_arp_interval = self.module.params[",
            "            'gratuitous_arp_interval']",
            "        self.recover_delay = self.module.params['recover_delay']",
            "        self.holding_multiplier = self.module.params['holding_multiplier']",
            "        self.auth_mode = self.module.params['auth_mode']",
            "        self.is_plain = 'false' if self.module.params['is_plain'] is False else 'true'",
            "        self.auth_key = self.module.params['auth_key']",
            "        self.fast_resume = self.module.params['fast_resume']",
            "        self.state = self.module.params['state']",
            "",
            "        # vrrp info",
            "        self.vrrp_global_info = None",
            "        self.virtual_ip_info = None",
            "        self.vrrp_group_info = None",
            "",
            "        # state",
            "        self.changed = False",
            "        self.updates_cmd = list()",
            "        self.results = dict()",
            "        self.existing = dict()",
            "        self.proposed = dict()",
            "        self.end_state = dict()",
            "",
            "    def init_module(self):",
            "        \"\"\" init module \"\"\"",
            "",
            "        self.module = AnsibleModule(",
            "            argument_spec=self.spec, supports_check_mode=True)",
            "",
            "    def get_virtual_ip_info(self):",
            "        \"\"\" get vrrp virtual ip info.\"\"\"",
            "        virtual_ip_info = dict()",
            "        conf_str = CE_NC_GET_VRRP_VIRTUAL_IP_INFO % (self.vrid, self.interface)",
            "        xml_str = get_nc_config(self.module, conf_str)",
            "        if \"<data/>\" in xml_str:",
            "            return virtual_ip_info",
            "        else:",
            "            xml_str = xml_str.replace('\\r', '').replace('\\n', '').\\",
            "                replace('xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"', \"\").\\",
            "                replace('xmlns=\"http://www.huawei.com/netconf/vrp\"', \"\")",
            "            virtual_ip_info[\"vrrpVirtualIpInfos\"] = list()",
            "            root = ElementTree.fromstring(xml_str)",
            "            vrrp_virtual_ip_infos = root.findall(",
            "                \"vrrp/vrrpGroups/vrrpGroup/virtualIps/virtualIp\")",
            "            if vrrp_virtual_ip_infos:",
            "                for vrrp_virtual_ip_info in vrrp_virtual_ip_infos:",
            "                    virtual_ip_dict = dict()",
            "                    for ele in vrrp_virtual_ip_info:",
            "                        if ele.tag in [\"virtualIpAddress\"]:",
            "                            virtual_ip_dict[ele.tag] = ele.text",
            "                    virtual_ip_info[\"vrrpVirtualIpInfos\"].append(",
            "                        virtual_ip_dict)",
            "            return virtual_ip_info",
            "",
            "    def get_vrrp_global_info(self):",
            "        \"\"\" get vrrp global info.\"\"\"",
            "",
            "        vrrp_global_info = dict()",
            "        conf_str = CE_NC_GET_VRRP_GLOBAL_INFO",
            "        xml_str = get_nc_config(self.module, conf_str)",
            "        if \"<data/>\" in xml_str:",
            "            return vrrp_global_info",
            "        else:",
            "            xml_str = xml_str.replace('\\r', '').replace('\\n', '').\\",
            "                replace('xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"', \"\").\\",
            "                replace('xmlns=\"http://www.huawei.com/netconf/vrp\"', \"\")",
            "",
            "            root = ElementTree.fromstring(xml_str)",
            "            global_info = root.findall(",
            "                \"vrrp/vrrpGlobalCfg\")",
            "",
            "            if global_info:",
            "                for tmp in global_info:",
            "                    for site in tmp:",
            "                        if site.tag in [\"gratuitousArpTimeOut\", \"gratuitousArpFlag\", \"recoverDelay\", \"version\"]:",
            "                            vrrp_global_info[site.tag] = site.text",
            "            return vrrp_global_info",
            "",
            "    def get_vrrp_group_info(self):",
            "        \"\"\" get vrrp group info.\"\"\"",
            "",
            "        vrrp_group_info = dict()",
            "        conf_str = CE_NC_GET_VRRP_GROUP_INFO % (self.interface, self.vrid)",
            "        xml_str = get_nc_config(self.module, conf_str)",
            "        if \"<data/>\" in xml_str:",
            "            return vrrp_group_info",
            "        else:",
            "            xml_str = xml_str.replace('\\r', '').replace('\\n', '').\\",
            "                replace('xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"', \"\").\\",
            "                replace('xmlns=\"http://www.huawei.com/netconf/vrp\"', \"\")",
            "",
            "            root = ElementTree.fromstring(xml_str)",
            "            global_info = root.findall(",
            "                \"vrrp/vrrpGroups/vrrpGroup\")",
            "",
            "            if global_info:",
            "                for tmp in global_info:",
            "                    for site in tmp:",
            "                        if site.tag in [\"ifName\", \"vrrpId\", \"priority\", \"advertiseInterval\", \"preemptMode\", \"delayTime\",",
            "                                        \"authenticationMode\", \"authenticationKey\", \"vrrpType\", \"adminVrrpId\",",
            "                                        \"adminIfName\", \"adminIgnoreIfDown\", \"isPlain\", \"unflowdown\", \"fastResume\",",
            "                                        \"holdMultiplier\"]:",
            "                            vrrp_group_info[site.tag] = site.text",
            "            return vrrp_group_info",
            "",
            "    def check_params(self):",
            "        \"\"\"Check all input params\"\"\"",
            "",
            "        # interface check",
            "        if self.interface:",
            "            intf_type = get_interface_type(self.interface)",
            "            if not intf_type:",
            "                self.module.fail_json(",
            "                    msg='Error: Interface name of %s '",
            "                        'is error.' % self.interface)",
            "",
            "        # vrid check",
            "        if self.vrid:",
            "            if not self.vrid.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of vrid is an integer.')",
            "            if int(self.vrid) < 1 or int(self.vrid) > 255:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of vrid ranges from 1 to 255.')",
            "",
            "        # virtual_ip check",
            "        if self.virtual_ip:",
            "            if not is_valid_address(self.virtual_ip):",
            "                self.module.fail_json(",
            "                    msg='Error: The %s is not a valid ip address.' % self.virtual_ip)",
            "",
            "        # admin_vrid check",
            "        if self.admin_vrid:",
            "            if not self.admin_vrid.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of admin_vrid is an integer.')",
            "            if int(self.admin_vrid) < 1 or int(self.admin_vrid) > 255:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of admin_vrid ranges from 1 to 255.')",
            "",
            "        # admin_interface check",
            "        if self.admin_interface:",
            "            intf_type = get_interface_type(self.admin_interface)",
            "            if not intf_type:",
            "                self.module.fail_json(",
            "                    msg='Error: Admin interface name of %s '",
            "                        'is error.' % self.admin_interface)",
            "",
            "        # priority check",
            "        if self.priority:",
            "            if not self.priority.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of priority is an integer.')",
            "            if int(self.priority) < 1 or int(self.priority) > 254:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of priority ranges from 1 to 254. The default value is 100.')",
            "",
            "        # advertise_interval check",
            "        if self.advertise_interval:",
            "            if not self.advertise_interval.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of advertise_interval is an integer.')",
            "            if int(self.advertise_interval) < 1000 or int(self.advertise_interval) > 255000:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of advertise_interval ranges from 1000 to 255000 milliseconds. The default value is 1000 milliseconds.')",
            "            if int(self.advertise_interval) % 1000 != 0:",
            "                self.module.fail_json(",
            "                    msg='Error: The advertisement interval value of VRRP must be a multiple of 1000 milliseconds.')",
            "        # preempt_timer_delay check",
            "        if self.preempt_timer_delay:",
            "            if not self.preempt_timer_delay.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of preempt_timer_delay is an integer.')",
            "            if int(self.preempt_timer_delay) < 1 or int(self.preempt_timer_delay) > 3600:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of preempt_timer_delay ranges from 1 to 3600. The default value is 0.')",
            "",
            "        # holding_multiplier check",
            "        if self.holding_multiplier:",
            "            if not self.holding_multiplier.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of holding_multiplier is an integer.')",
            "            if int(self.holding_multiplier) < 3 or int(self.holding_multiplier) > 10:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of holding_multiplier ranges from 3 to 10. The default value is 3.')",
            "",
            "        # auth_key check",
            "        if self.auth_key:",
            "            if len(self.auth_key) > 16 \\",
            "                    or len(self.auth_key.replace(' ', '')) < 1:",
            "                self.module.fail_json(",
            "                    msg='Error: The length of auth_key is not in the range from 1 to 16.')",
            "",
            "    def is_virtual_ip_change(self):",
            "        \"\"\"whether virtual ip change\"\"\"",
            "",
            "        if not self.virtual_ip_info:",
            "            return True",
            "",
            "        for info in self.virtual_ip_info[\"vrrpVirtualIpInfos\"]:",
            "            if info[\"virtualIpAddress\"] == self.virtual_ip:",
            "                return False",
            "        return True",
            "",
            "    def is_virtual_ip_exist(self):",
            "        \"\"\"whether virtual ip info exist\"\"\"",
            "",
            "        if not self.virtual_ip_info:",
            "            return False",
            "",
            "        for info in self.virtual_ip_info[\"vrrpVirtualIpInfos\"]:",
            "            if info[\"virtualIpAddress\"] == self.virtual_ip:",
            "                return True",
            "        return False",
            "",
            "    def is_vrrp_global_info_change(self):",
            "        \"\"\"whether vrrp global attribute info change\"\"\"",
            "",
            "        if not self.vrrp_global_info:",
            "            return True",
            "",
            "        if self.gratuitous_arp_interval:",
            "            if self.vrrp_global_info[\"gratuitousArpFlag\"] == \"false\":",
            "                self.module.fail_json(msg=\"Error: gratuitousArpFlag is false.\")",
            "            if self.vrrp_global_info[\"gratuitousArpTimeOut\"] != self.gratuitous_arp_interval:",
            "                return True",
            "        if self.recover_delay:",
            "            if self.vrrp_global_info[\"recoverDelay\"] != self.recover_delay:",
            "                return True",
            "        if self.version:",
            "            if self.vrrp_global_info[\"version\"] != self.version:",
            "                return True",
            "        return False",
            "",
            "    def is_vrrp_global_info_exist(self):",
            "        \"\"\"whether vrrp global attribute info exist\"\"\"",
            "",
            "        if self.gratuitous_arp_interval or self.recover_delay or self.version:",
            "            if self.gratuitous_arp_interval:",
            "                if self.vrrp_global_info[\"gratuitousArpFlag\"] == \"false\":",
            "                    self.module.fail_json(",
            "                        msg=\"Error: gratuitousArpFlag is false.\")",
            "                if self.vrrp_global_info[\"gratuitousArpTimeOut\"] != self.gratuitous_arp_interval:",
            "                    return False",
            "            if self.recover_delay:",
            "                if self.vrrp_global_info[\"recoverDelay\"] != self.recover_delay:",
            "                    return False",
            "            if self.version:",
            "                if self.vrrp_global_info[\"version\"] != self.version:",
            "                    return False",
            "            return True",
            "",
            "        return False",
            "",
            "    def is_vrrp_group_info_change(self):",
            "        \"\"\"whether vrrp group attribute info change\"\"\"",
            "        if self.vrrp_type:",
            "            if self.vrrp_group_info[\"vrrpType\"] != self.vrrp_type:",
            "                return True",
            "        if self.admin_ignore_if_down:",
            "            if self.vrrp_group_info[\"adminIgnoreIfDown\"] != self.admin_ignore_if_down:",
            "                return True",
            "        if self.admin_vrid:",
            "            if self.vrrp_group_info[\"adminVrrpId\"] != self.admin_vrid:",
            "                return True",
            "        if self.admin_interface:",
            "            if self.vrrp_group_info[\"adminIfName\"] != self.admin_interface:",
            "                return True",
            "        if self.admin_flowdown:",
            "            if self.vrrp_group_info[\"unflowdown\"] != self.admin_flowdown:",
            "                return True",
            "        if self.priority:",
            "            if self.vrrp_group_info[\"priority\"] != self.priority:",
            "                return True",
            "        if self.fast_resume:",
            "            fast_resume = \"false\"",
            "            if self.fast_resume == \"enable\":",
            "                fast_resume = \"true\"",
            "            if self.vrrp_group_info[\"fastResume\"] != fast_resume:",
            "                return True",
            "        if self.advertise_interval:",
            "            if self.vrrp_group_info[\"advertiseInterval\"] != self.advertise_interval:",
            "                return True",
            "        if self.preempt_timer_delay:",
            "            if self.vrrp_group_info[\"delayTime\"] != self.preempt_timer_delay:",
            "                return True",
            "        if self.holding_multiplier:",
            "            if self.vrrp_group_info[\"holdMultiplier\"] != self.holding_multiplier:",
            "                return True",
            "        if self.auth_mode:",
            "            if self.vrrp_group_info[\"authenticationMode\"] != self.auth_mode:",
            "                return True",
            "        if self.auth_key:",
            "            return True",
            "        if self.is_plain:",
            "            if self.vrrp_group_info[\"isPlain\"] != self.is_plain:",
            "                return True",
            "",
            "        return False",
            "",
            "    def is_vrrp_group_info_exist(self):",
            "        \"\"\"whether vrrp group attribute info exist\"\"\"",
            "",
            "        if self.vrrp_type:",
            "            if self.vrrp_group_info[\"vrrpType\"] != self.vrrp_type:",
            "                return False",
            "        if self.admin_ignore_if_down:",
            "            if self.vrrp_group_info[\"adminIgnoreIfDown\"] != self.admin_ignore_if_down:",
            "                return False",
            "        if self.admin_vrid:",
            "            if self.vrrp_group_info[\"adminVrrpId\"] != self.admin_vrid:",
            "                return False",
            "        if self.admin_interface:",
            "            if self.vrrp_group_info[\"adminIfName\"] != self.admin_interface:",
            "                return False",
            "        if self.admin_flowdown:",
            "            if self.vrrp_group_info[\"unflowdown\"] != self.admin_flowdown:",
            "                return False",
            "        if self.priority:",
            "            if self.vrrp_group_info[\"priority\"] != self.priority:",
            "                return False",
            "        if self.fast_resume:",
            "            fast_resume = \"false\"",
            "            if self.fast_resume == \"enable\":",
            "                fast_resume = \"true\"",
            "            if self.vrrp_group_info[\"fastResume\"] != fast_resume:",
            "                return False",
            "        if self.advertise_interval:",
            "            if self.vrrp_group_info[\"advertiseInterval\"] != self.advertise_interval:",
            "                return False",
            "        if self.preempt_timer_delay:",
            "            if self.vrrp_group_info[\"delayTime\"] != self.preempt_timer_delay:",
            "                return False",
            "        if self.holding_multiplier:",
            "            if self.vrrp_group_info[\"holdMultiplier\"] != self.holding_multiplier:",
            "                return False",
            "        if self.auth_mode:",
            "            if self.vrrp_group_info[\"authenticationMode\"] != self.auth_mode:",
            "                return False",
            "        if self.is_plain:",
            "            if self.vrrp_group_info[\"isPlain\"] != self.is_plain:",
            "                return False",
            "        return True",
            "",
            "    def create_virtual_ip(self):",
            "        \"\"\"create virtual ip info\"\"\"",
            "",
            "        if self.is_virtual_ip_change():",
            "            conf_str = CE_NC_CREATE_VRRP_VIRTUAL_IP_INFO % (",
            "                self.vrid, self.interface, self.virtual_ip)",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: create virtual ip info failed.')",
            "",
            "            self.updates_cmd.append(\"interface %s\" % self.interface)",
            "            self.updates_cmd.append(",
            "                \"vrrp vrid %s virtual-ip %s\" % (self.vrid, self.virtual_ip))",
            "            self.changed = True",
            "",
            "    def delete_virtual_ip(self):",
            "        \"\"\"delete virtual ip info\"\"\"",
            "",
            "        if self.is_virtual_ip_exist():",
            "            conf_str = CE_NC_DELETE_VRRP_VIRTUAL_IP_INFO % (",
            "                self.vrid, self.interface, self.virtual_ip)",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: delete virtual ip info failed.')",
            "",
            "            self.updates_cmd.append(\"interface %s\" % self.interface)",
            "            self.updates_cmd.append(",
            "                \"undo vrrp vrid %s virtual-ip %s \" % (self.vrid, self.virtual_ip))",
            "            self.changed = True",
            "",
            "    def set_vrrp_global(self):",
            "        \"\"\"set vrrp global attribute info\"\"\"",
            "",
            "        if self.is_vrrp_global_info_change():",
            "            conf_str = CE_NC_SET_VRRP_GLOBAL_HEAD",
            "            if self.gratuitous_arp_interval:",
            "                conf_str += \"<gratuitousArpTimeOut>%s</gratuitousArpTimeOut>\" % self.gratuitous_arp_interval",
            "            if self.recover_delay:",
            "                conf_str += \"<recoverDelay>%s</recoverDelay>\" % self.recover_delay",
            "            if self.version:",
            "                conf_str += \"<version>%s</version>\" % self.version",
            "            conf_str += CE_NC_SET_VRRP_GLOBAL_TAIL",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: set vrrp global attribute info failed.')",
            "",
            "            if self.gratuitous_arp_interval:",
            "                self.updates_cmd.append(",
            "                    \"vrrp gratuitous-arp interval %s\" % self.gratuitous_arp_interval)",
            "",
            "            if self.recover_delay:",
            "                self.updates_cmd.append(",
            "                    \"vrrp recover-delay %s\" % self.recover_delay)",
            "",
            "            if self.version:",
            "                version = \"3\"",
            "                if self.version == \"v2\":",
            "                    version = \"2\"",
            "                self.updates_cmd.append(\"vrrp version %s\" % version)",
            "            self.changed = True",
            "",
            "    def delete_vrrp_global(self):",
            "        \"\"\"delete vrrp global attribute info\"\"\"",
            "",
            "        if self.is_vrrp_global_info_exist():",
            "            conf_str = CE_NC_SET_VRRP_GLOBAL_HEAD",
            "            if self.gratuitous_arp_interval:",
            "                if self.gratuitous_arp_interval == \"120\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of gratuitous_arp_interval is 120.')",
            "                gratuitous_arp_interval = \"120\"",
            "                conf_str += \"<gratuitousArpTimeOut>%s</gratuitousArpTimeOut>\" % gratuitous_arp_interval",
            "            if self.recover_delay:",
            "                if self.recover_delay == \"0\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of recover_delay is 0.')",
            "                recover_delay = \"0\"",
            "                conf_str += \"<recoverDelay>%s</recoverDelay>\" % recover_delay",
            "            if self.version:",
            "                if self.version == \"v2\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of version is v2.')",
            "                version = \"v2\"",
            "                conf_str += \"<version>%s</version>\" % version",
            "            conf_str += CE_NC_SET_VRRP_GLOBAL_TAIL",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: set vrrp global attribute info failed.')",
            "            if self.gratuitous_arp_interval:",
            "                self.updates_cmd.append(\"undo vrrp gratuitous-arp interval\")",
            "",
            "            if self.recover_delay:",
            "                self.updates_cmd.append(\"undo vrrp recover-delay\")",
            "",
            "            if self.version == \"v3\":",
            "                self.updates_cmd.append(\"undo vrrp version\")",
            "            self.changed = True",
            "",
            "    def set_vrrp_group(self):",
            "        \"\"\"set vrrp group attribute info\"\"\"",
            "",
            "        if self.is_vrrp_group_info_change():",
            "            conf_str = CE_NC_SET_VRRP_GROUP_INFO_HEAD % (",
            "                self.interface, self.vrid)",
            "            if self.vrrp_type:",
            "                conf_str += \"<vrrpType>%s</vrrpType>\" % self.vrrp_type",
            "            if self.admin_vrid:",
            "                conf_str += \"<adminVrrpId>%s</adminVrrpId>\" % self.admin_vrid",
            "            if self.admin_interface:",
            "                conf_str += \"<adminIfName>%s</adminIfName>\" % self.admin_interface",
            "                if self.admin_flowdown:",
            "                    conf_str += \"<unflowdown>%s</unflowdown>\" % self.admin_flowdown",
            "            if self.priority:",
            "                conf_str += \"<priority>%s</priority>\" % self.priority",
            "            if self.vrrp_type == \"admin\":",
            "                if self.admin_ignore_if_down:",
            "                    conf_str += \"<adminIgnoreIfDown>%s</adminIgnoreIfDown>\" % self.admin_ignore_if_down",
            "            if self.fast_resume:",
            "                fast_resume = \"false\"",
            "                if self.fast_resume == \"enable\":",
            "                    fast_resume = \"true\"",
            "                conf_str += \"<fastResume>%s</fastResume>\" % fast_resume",
            "            if self.advertise_interval:",
            "                conf_str += \"<advertiseInterval>%s</advertiseInterval>\" % self.advertise_interval",
            "            if self.preempt_timer_delay:",
            "                conf_str += \"<delayTime>%s</delayTime>\" % self.preempt_timer_delay",
            "            if self.holding_multiplier:",
            "                conf_str += \"<holdMultiplier>%s</holdMultiplier>\" % self.holding_multiplier",
            "            if self.auth_mode:",
            "                conf_str += \"<authenticationMode>%s</authenticationMode>\" % self.auth_mode",
            "            if self.auth_key:",
            "                conf_str += \"<authenticationKey>%s</authenticationKey>\" % self.auth_key",
            "            if self.auth_mode == \"simple\":",
            "                conf_str += \"<isPlain>%s</isPlain>\" % self.is_plain",
            "",
            "            conf_str += CE_NC_SET_VRRP_GROUP_INFO_TAIL",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: set vrrp group attribute info failed.')",
            "            if self.interface and self.vrid:",
            "                self.updates_cmd.append(\"interface %s\" % self.interface)",
            "                if self.vrrp_type == \"admin\":",
            "                    if self.admin_ignore_if_down == \"true\":",
            "                        self.updates_cmd.append(",
            "                            \"vrrp vrid %s admin ignore-if-down\" % self.vrid)",
            "                    else:",
            "                        self.updates_cmd.append(",
            "                            \"vrrp vrid %s admin\" % self.vrid)",
            "",
            "                if self.priority:",
            "                    self.updates_cmd.append(",
            "                        \"vrrp vrid %s priority %s\" % (self.vrid, self.priority))",
            "",
            "                if self.fast_resume == \"enable\":",
            "                    self.updates_cmd.append(",
            "                        \"vrrp vrid %s fast-resume\" % self.vrid)",
            "                if self.fast_resume == \"disable\":",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s fast-resume\" % self.vrid)",
            "",
            "                if self.advertise_interval:",
            "                    advertise_interval = int(self.advertise_interval) / 1000",
            "                    self.updates_cmd.append(\"vrrp vrid %s timer advertise %s<seconds>\" % (",
            "                        self.vrid, int(advertise_interval)))",
            "",
            "                if self.preempt_timer_delay:",
            "                    self.updates_cmd.append(\"vrrp vrid %s preempt timer delay %s\" % (self.vrid,",
            "                                                                                     self.preempt_timer_delay))",
            "",
            "                if self.holding_multiplier:",
            "                    self.updates_cmd.append(",
            "                        \"vrrp vrid %s holding-multiplier %s\" % (self.vrid, self.holding_multiplier))",
            "",
            "                if self.admin_vrid and self.admin_interface:",
            "                    if self.admin_flowdown == \"true\":",
            "                        self.updates_cmd.append(\"vrrp vrid %s track admin-vrrp interface %s vrid %s unflowdown\" %",
            "                                                (self.vrid, self.admin_interface, self.admin_vrid))",
            "                    else:",
            "                        self.updates_cmd.append(\"vrrp vrid %s track admin-vrrp interface %s vrid %s\" %",
            "                                                (self.vrid, self.admin_interface, self.admin_vrid))",
            "",
            "                if self.auth_mode and self.auth_key:",
            "                    if self.auth_mode == \"simple\":",
            "                        if self.is_plain == \"true\":",
            "                            self.updates_cmd.append(\"vrrp vrid %s authentication-mode simple plain %s\" %",
            "                                                    (self.vrid, self.auth_key))",
            "                        else:",
            "                            self.updates_cmd.append(\"vrrp vrid %s authentication-mode simple cipher %s\" %",
            "                                                    (self.vrid, self.auth_key))",
            "                    if self.auth_mode == \"md5\":",
            "                        self.updates_cmd.append(",
            "                            \"vrrp vrid %s authentication-mode md5 %s\" % (self.vrid, self.auth_key))",
            "                self.changed = True",
            "",
            "    def delete_vrrp_group(self):",
            "        \"\"\"delete vrrp group attribute info\"\"\"",
            "",
            "        if self.is_vrrp_group_info_exist():",
            "            conf_str = CE_NC_SET_VRRP_GROUP_INFO_HEAD % (",
            "                self.interface, self.vrid)",
            "            if self.vrrp_type:",
            "                vrrp_type = self.vrrp_type",
            "                if self.vrrp_type == \"admin\":",
            "                    vrrp_type = \"normal\"",
            "                if self.vrrp_type == \"member\" and self.admin_vrid and self.admin_interface:",
            "                    vrrp_type = \"normal\"",
            "                conf_str += \"<vrrpType>%s</vrrpType>\" % vrrp_type",
            "            if self.priority:",
            "                if self.priority == \"100\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of priority is 100.')",
            "                priority = \"100\"",
            "                conf_str += \"<priority>%s</priority>\" % priority",
            "",
            "            if self.fast_resume:",
            "                fast_resume = \"false\"",
            "                if self.fast_resume == \"enable\":",
            "                    fast_resume = \"true\"",
            "                conf_str += \"<fastResume>%s</fastResume>\" % fast_resume",
            "            if self.advertise_interval:",
            "                if self.advertise_interval == \"1000\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of advertise_interval is 1000.')",
            "                advertise_interval = \"1000\"",
            "                conf_str += \"<advertiseInterval>%s</advertiseInterval>\" % advertise_interval",
            "            if self.preempt_timer_delay:",
            "                if self.preempt_timer_delay == \"0\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of preempt_timer_delay is 0.')",
            "                preempt_timer_delay = \"0\"",
            "                conf_str += \"<delayTime>%s</delayTime>\" % preempt_timer_delay",
            "            if self.holding_multiplier:",
            "                if self.holding_multiplier == \"0\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of holding_multiplier is 3.')",
            "                holding_multiplier = \"3\"",
            "                conf_str += \"<holdMultiplier>%s</holdMultiplier>\" % holding_multiplier",
            "            if self.auth_mode:",
            "                auth_mode = self.auth_mode",
            "                if self.auth_mode == \"md5\" or self.auth_mode == \"simple\":",
            "                    auth_mode = \"none\"",
            "                conf_str += \"<authenticationMode>%s</authenticationMode>\" % auth_mode",
            "",
            "            conf_str += CE_NC_SET_VRRP_GROUP_INFO_TAIL",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: set vrrp global attribute info failed.')",
            "            if self.interface and self.vrid:",
            "                self.updates_cmd.append(\"interface %s\" % self.interface)",
            "                if self.vrrp_type == \"admin\":",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s admin\" % self.vrid)",
            "",
            "                if self.priority:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s priority\" % self.vrid)",
            "",
            "                if self.fast_resume:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s fast-resume\" % self.vrid)",
            "",
            "                if self.advertise_interval:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s timer advertise\" % self.vrid)",
            "",
            "                if self.preempt_timer_delay:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s preempt timer delay\" % self.vrid)",
            "",
            "                if self.holding_multiplier:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s holding-multiplier\" % self.vrid)",
            "",
            "                if self.admin_vrid and self.admin_interface:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s track admin-vrrp\" % self.vrid)",
            "",
            "                if self.auth_mode:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s authentication-mode\" % self.vrid)",
            "                self.changed = True",
            "",
            "    def get_proposed(self):",
            "        \"\"\"get proposed info\"\"\"",
            "",
            "        if self.interface:",
            "            self.proposed[\"interface\"] = self.interface",
            "        if self.vrid:",
            "            self.proposed[\"vrid\"] = self.vrid",
            "        if self.virtual_ip:",
            "            self.proposed[\"virtual_ip\"] = self.virtual_ip",
            "        if self.vrrp_type:",
            "            self.proposed[\"vrrp_type\"] = self.vrrp_type",
            "        if self.admin_vrid:",
            "            self.proposed[\"admin_vrid\"] = self.admin_vrid",
            "        if self.admin_interface:",
            "            self.proposed[\"admin_interface\"] = self.admin_interface",
            "        if self.admin_flowdown:",
            "            self.proposed[\"unflowdown\"] = self.admin_flowdown",
            "        if self.admin_ignore_if_down:",
            "            self.proposed[\"admin_ignore_if_down\"] = self.admin_ignore_if_down",
            "        if self.priority:",
            "            self.proposed[\"priority\"] = self.priority",
            "        if self.version:",
            "            self.proposed[\"version\"] = self.version",
            "        if self.advertise_interval:",
            "            self.proposed[\"advertise_interval\"] = self.advertise_interval",
            "        if self.preempt_timer_delay:",
            "            self.proposed[\"preempt_timer_delay\"] = self.preempt_timer_delay",
            "        if self.gratuitous_arp_interval:",
            "            self.proposed[",
            "                \"gratuitous_arp_interval\"] = self.gratuitous_arp_interval",
            "        if self.recover_delay:",
            "            self.proposed[\"recover_delay\"] = self.recover_delay",
            "        if self.holding_multiplier:",
            "            self.proposed[\"holding_multiplier\"] = self.holding_multiplier",
            "        if self.auth_mode:",
            "            self.proposed[\"auth_mode\"] = self.auth_mode",
            "        if self.is_plain:",
            "            self.proposed[\"is_plain\"] = self.is_plain",
            "        if self.auth_key:",
            "            self.proposed[\"auth_key\"] = self.auth_key",
            "        if self.fast_resume:",
            "            self.proposed[\"fast_resume\"] = self.fast_resume",
            "        if self.state:",
            "            self.proposed[\"state\"] = self.state",
            "",
            "    def get_existing(self):",
            "        \"\"\"get existing info\"\"\"",
            "",
            "        if self.gratuitous_arp_interval:",
            "            self.existing[\"gratuitous_arp_interval\"] = self.vrrp_global_info[",
            "                \"gratuitousArpTimeOut\"]",
            "        if self.version:",
            "            self.existing[\"version\"] = self.vrrp_global_info[\"version\"]",
            "        if self.recover_delay:",
            "            self.existing[\"recover_delay\"] = self.vrrp_global_info[",
            "                \"recoverDelay\"]",
            "",
            "        if self.virtual_ip:",
            "            if self.virtual_ip_info:",
            "                self.existing[\"interface\"] = self.interface",
            "                self.existing[\"vrid\"] = self.vrid",
            "                self.existing[\"virtual_ip_info\"] = self.virtual_ip_info[",
            "                    \"vrrpVirtualIpInfos\"]",
            "",
            "        if self.vrrp_group_info:",
            "            self.existing[\"interface\"] = self.vrrp_group_info[\"ifName\"]",
            "            self.existing[\"vrid\"] = self.vrrp_group_info[\"vrrpId\"]",
            "            self.existing[\"vrrp_type\"] = self.vrrp_group_info[\"vrrpType\"]",
            "            if self.vrrp_type == \"admin\":",
            "                self.existing[\"admin_ignore_if_down\"] = self.vrrp_group_info[",
            "                    \"adminIgnoreIfDown\"]",
            "            if self.admin_vrid and self.admin_interface:",
            "                self.existing[\"admin_vrid\"] = self.vrrp_group_info[",
            "                    \"adminVrrpId\"]",
            "                self.existing[\"admin_interface\"] = self.vrrp_group_info[",
            "                    \"adminIfName\"]",
            "                self.existing[\"admin_flowdown\"] = self.vrrp_group_info[",
            "                    \"unflowdown\"]",
            "            if self.priority:",
            "                self.existing[\"priority\"] = self.vrrp_group_info[\"priority\"]",
            "            if self.advertise_interval:",
            "                self.existing[\"advertise_interval\"] = self.vrrp_group_info[",
            "                    \"advertiseInterval\"]",
            "            if self.preempt_timer_delay:",
            "                self.existing[\"preempt_timer_delay\"] = self.vrrp_group_info[",
            "                    \"delayTime\"]",
            "            if self.holding_multiplier:",
            "                self.existing[\"holding_multiplier\"] = self.vrrp_group_info[",
            "                    \"holdMultiplier\"]",
            "            if self.fast_resume:",
            "                fast_resume_exist = \"disable\"",
            "                fast_resume = self.vrrp_group_info[\"fastResume\"]",
            "                if fast_resume == \"true\":",
            "                    fast_resume_exist = \"enable\"",
            "                self.existing[\"fast_resume\"] = fast_resume_exist",
            "            if self.auth_mode:",
            "                self.existing[\"auth_mode\"] = self.vrrp_group_info[",
            "                    \"authenticationMode\"]",
            "                self.existing[\"is_plain\"] = self.vrrp_group_info[\"isPlain\"]",
            "",
            "    def get_end_state(self):",
            "        \"\"\"get end state info\"\"\"",
            "",
            "        if self.gratuitous_arp_interval or self.version or self.recover_delay:",
            "            self.vrrp_global_info = self.get_vrrp_global_info()",
            "        if self.interface and self.vrid:",
            "            if self.virtual_ip:",
            "                self.virtual_ip_info = self.get_virtual_ip_info()",
            "            if self.virtual_ip_info:",
            "                self.vrrp_group_info = self.get_vrrp_group_info()",
            "",
            "        if self.gratuitous_arp_interval:",
            "            self.end_state[\"gratuitous_arp_interval\"] = self.vrrp_global_info[",
            "                \"gratuitousArpTimeOut\"]",
            "        if self.version:",
            "            self.end_state[\"version\"] = self.vrrp_global_info[\"version\"]",
            "        if self.recover_delay:",
            "            self.end_state[\"recover_delay\"] = self.vrrp_global_info[",
            "                \"recoverDelay\"]",
            "",
            "        if self.virtual_ip:",
            "            if self.virtual_ip_info:",
            "                self.end_state[\"interface\"] = self.interface",
            "                self.end_state[\"vrid\"] = self.vrid",
            "                self.end_state[\"virtual_ip_info\"] = self.virtual_ip_info[",
            "                    \"vrrpVirtualIpInfos\"]",
            "",
            "        if self.vrrp_group_info:",
            "            self.end_state[\"interface\"] = self.vrrp_group_info[\"ifName\"]",
            "            self.end_state[\"vrid\"] = self.vrrp_group_info[\"vrrpId\"]",
            "            self.end_state[\"vrrp_type\"] = self.vrrp_group_info[\"vrrpType\"]",
            "            if self.vrrp_type == \"admin\":",
            "                self.end_state[\"admin_ignore_if_down\"] = self.vrrp_group_info[",
            "                    \"adminIgnoreIfDown\"]",
            "            if self.admin_vrid and self.admin_interface:",
            "                self.end_state[\"admin_vrid\"] = self.vrrp_group_info[",
            "                    \"adminVrrpId\"]",
            "                self.end_state[\"admin_interface\"] = self.vrrp_group_info[",
            "                    \"adminIfName\"]",
            "                self.end_state[\"admin_flowdown\"] = self.vrrp_group_info[",
            "                    \"unflowdown\"]",
            "            if self.priority:",
            "                self.end_state[\"priority\"] = self.vrrp_group_info[\"priority\"]",
            "            if self.advertise_interval:",
            "                self.end_state[\"advertise_interval\"] = self.vrrp_group_info[",
            "                    \"advertiseInterval\"]",
            "            if self.preempt_timer_delay:",
            "                self.end_state[\"preempt_timer_delay\"] = self.vrrp_group_info[",
            "                    \"delayTime\"]",
            "            if self.holding_multiplier:",
            "                self.end_state[\"holding_multiplier\"] = self.vrrp_group_info[",
            "                    \"holdMultiplier\"]",
            "            if self.fast_resume:",
            "                fast_resume_end = \"disable\"",
            "                fast_resume = self.vrrp_group_info[\"fastResume\"]",
            "                if fast_resume == \"true\":",
            "                    fast_resume_end = \"enable\"",
            "                self.end_state[\"fast_resume\"] = fast_resume_end",
            "            if self.auth_mode:",
            "                self.end_state[\"auth_mode\"] = self.vrrp_group_info[",
            "                    \"authenticationMode\"]",
            "                self.end_state[\"is_plain\"] = self.vrrp_group_info[\"isPlain\"]",
            "        if self.existing == self.end_state:",
            "            self.changed = False",
            "",
            "    def work(self):",
            "        \"\"\"worker\"\"\"",
            "",
            "        self.check_params()",
            "        if self.gratuitous_arp_interval or self.version or self.recover_delay:",
            "            self.vrrp_global_info = self.get_vrrp_global_info()",
            "        if self.interface and self.vrid:",
            "            self.virtual_ip_info = self.get_virtual_ip_info()",
            "            if self.virtual_ip_info:",
            "                self.vrrp_group_info = self.get_vrrp_group_info()",
            "        self.get_proposed()",
            "        self.get_existing()",
            "",
            "        if self.gratuitous_arp_interval or self.version or self.recover_delay:",
            "            if self.state == \"present\":",
            "                self.set_vrrp_global()",
            "            else:",
            "                self.delete_vrrp_global()",
            "        else:",
            "            if not self.interface or not self.vrid:",
            "                self.module.fail_json(",
            "                    msg='Error: interface, vrid must be config at the same time.')",
            "",
            "        if self.interface and self.vrid:",
            "            if self.virtual_ip:",
            "                if self.state == \"present\":",
            "                    self.create_virtual_ip()",
            "                else:",
            "                    self.delete_virtual_ip()",
            "            else:",
            "                if not self.vrrp_group_info:",
            "                    self.module.fail_json(",
            "                        msg='Error: The VRRP group does not exist.')",
            "                if self.admin_ignore_if_down == \"true\":",
            "                    if self.vrrp_type != \"admin\":",
            "                        self.module.fail_json(",
            "                            msg='Error: vrrpType must be admin when admin_ignore_if_down is true.')",
            "                if self.admin_interface or self.admin_vrid:",
            "                    if self.vrrp_type != \"member\":",
            "                        self.module.fail_json(",
            "                            msg='Error: it binds a VRRP group to an mVRRP group, vrrp_type must be \"member\".')",
            "                    if not self.vrrp_type or not self.interface or not self.vrid:",
            "                        self.module.fail_json(",
            "                            msg='Error: admin_interface admin_vrid vrrp_type interface vrid must '",
            "                                'be config at the same time.')",
            "                if self.auth_mode == \"md5\" and self.is_plain == \"true\":",
            "                    self.module.fail_json(",
            "                        msg='Error: is_plain can not be True when auth_mode is md5.')",
            "",
            "                if self.state == \"present\":",
            "                    self.set_vrrp_group()",
            "                else:",
            "                    self.delete_vrrp_group()",
            "",
            "        self.get_end_state()",
            "        self.results['changed'] = self.changed",
            "        self.results['proposed'] = self.proposed",
            "        self.results['existing'] = self.existing",
            "        self.results['end_state'] = self.end_state",
            "        if self.changed:",
            "            self.results['updates'] = self.updates_cmd",
            "        else:",
            "            self.results['updates'] = list()",
            "",
            "        self.module.exit_json(**self.results)",
            "",
            "",
            "def main():",
            "    \"\"\" Module main \"\"\"",
            "",
            "    argument_spec = dict(",
            "        interface=dict(type='str'),",
            "        vrid=dict(type='str'),",
            "        virtual_ip=dict(type='str'),",
            "        vrrp_type=dict(type='str', choices=['normal', 'member', 'admin']),",
            "        admin_ignore_if_down=dict(type='bool', default=False),",
            "        admin_vrid=dict(type='str'),",
            "        admin_interface=dict(type='str'),",
            "        admin_flowdown=dict(type='bool', default=False),",
            "        priority=dict(type='str'),",
            "        version=dict(type='str', choices=['v2', 'v3']),",
            "        advertise_interval=dict(type='str'),",
            "        preempt_timer_delay=dict(type='str'),",
            "        gratuitous_arp_interval=dict(type='str'),",
            "        recover_delay=dict(type='str'),",
            "        holding_multiplier=dict(type='str'),",
            "        auth_mode=dict(type='str', choices=['simple', 'md5', 'none']),",
            "        is_plain=dict(type='bool', default=False),",
            "        auth_key=dict(type='str'),",
            "        fast_resume=dict(type='str', choices=['enable', 'disable']),",
            "        state=dict(type='str', default='present',",
            "                   choices=['present', 'absent'])",
            "    )",
            "",
            "    argument_spec.update(ce_argument_spec)",
            "    module = Vrrp(argument_spec=argument_spec)",
            "    module.work()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: ce_vrrp",
            "version_added: \"2.4\"",
            "short_description: Manages VRRP interfaces on HUAWEI CloudEngine devices.",
            "description:",
            "    - Manages VRRP interface attributes on HUAWEI CloudEngine devices.",
            "author:",
            "    - Li Yanfeng (@numone213)",
            "notes:",
            "    - This module requires the netconf system service be enabled on the remote device being managed.",
            "    - Recommended connection is C(netconf).",
            "    - This module also works with C(local) connections for legacy playbooks.",
            "options:",
            "    interface:",
            "        description:",
            "            - Name of an interface. The value is a string of 1 to 63 characters.",
            "    vrid:",
            "        description:",
            "            - VRRP backup group ID.",
            "              The value is an integer ranging from 1 to 255.",
            "        default: present",
            "    virtual_ip :",
            "        description:",
            "            - Virtual IP address. The value is a string of 0 to 255 characters.",
            "    vrrp_type:",
            "        description:",
            "            - Type of a VRRP backup group.",
            "        type: str",
            "        choices: ['normal', 'member', 'admin']",
            "    admin_ignore_if_down:",
            "        description:",
            "            - mVRRP ignores an interface Down event.",
            "        type: bool",
            "        default: 'false'",
            "    admin_vrid:",
            "        description:",
            "            - Tracked mVRRP ID. The value is an integer ranging from 1 to 255.",
            "    admin_interface:",
            "        description:",
            "            - Tracked mVRRP interface name. The value is a string of 1 to 63 characters.",
            "    admin_flowdown:",
            "        description:",
            "            - Disable the flowdown function for service VRRP.",
            "        type: bool",
            "        default: 'false'",
            "    priority:",
            "        description:",
            "            - Configured VRRP priority.",
            "              The value ranges from 1 to 254. The default value is 100. A larger value indicates a higher priority.",
            "    version:",
            "        description:",
            "            - VRRP version. The default version is v2.",
            "        type: str",
            "        choices: ['v2','v3']",
            "    advertise_interval:",
            "        description:",
            "            - Configured interval between sending advertisements, in milliseconds.",
            "              Only the master router sends VRRP advertisements. The default value is 1000 milliseconds.",
            "    preempt_timer_delay:",
            "        description:",
            "            - Preemption delay.",
            "              The value is an integer ranging from 0 to 3600. The default value is 0.",
            "    gratuitous_arp_interval:",
            "        description:",
            "            - Interval at which gratuitous ARP packets are sent, in seconds.",
            "              The value ranges from 30 to 1200.The default value is 300.",
            "    recover_delay:",
            "        description:",
            "            - Delay in recovering after an interface goes Up.",
            "              The delay is used for interface flapping suppression.",
            "              The value is an integer ranging from 0 to 3600.",
            "              The default value is 0 seconds.",
            "    holding_multiplier:",
            "        description:",
            "            - The configured holdMultiplier.The value is an integer ranging from 3 to 10. The default value is 3.",
            "    auth_mode:",
            "        description:",
            "            - Authentication type used for VRRP packet exchanges between virtual routers.",
            "              The values are noAuthentication, simpleTextPassword, md5Authentication.",
            "              The default value is noAuthentication.",
            "        type: str",
            "        choices: ['simple','md5','none']",
            "    is_plain:",
            "        description:",
            "            - Select the display mode of an authentication key.",
            "              By default, an authentication key is displayed in ciphertext.",
            "        type: bool",
            "        default: 'false'",
            "    auth_key:",
            "        description:",
            "            - This object is set based on the authentication type.",
            "              When noAuthentication is specified, the value is empty.",
            "              When simpleTextPassword or md5Authentication is specified, the value is a string of 1 to 8 characters",
            "              in plaintext and displayed as a blank text for security.",
            "    fast_resume:",
            "        description:",
            "            - mVRRP's fast resume mode.",
            "        type: str",
            "        choices: ['enable','disable']",
            "    state:",
            "        description:",
            "            - Specify desired state of the resource.",
            "        type: str",
            "        default: present",
            "        choices: ['present','absent']",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: vrrp module test",
            "  hosts: cloudengine",
            "  connection: local",
            "  gather_facts: no",
            "  vars:",
            "    cli:",
            "      host: \"{{ inventory_hostname }}\"",
            "      port: \"{{ ansible_ssh_port }}\"",
            "      username: \"{{ username }}\"",
            "      password: \"{{ password }}\"",
            "      transport: cli",
            "  tasks:",
            "  - name: Set vrrp version",
            "    ce_vrrp:",
            "      version: v3",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp gratuitous-arp interval",
            "    ce_vrrp:",
            "      gratuitous_arp_interval: 40",
            "      mlag_id: 4",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp recover-delay",
            "    ce_vrrp:",
            "      recover_delay: 10",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid virtual-ip",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      virtual_ip: 10.14.2.7",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid admin",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      vrrp_type: admin",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid fast_resume",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      fast_resume: enable",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid holding-multiplier",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      holding_multiplier: 4",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid preempt timer delay",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      preempt_timer_delay: 10",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid admin-vrrp",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      admin_interface: 40GE2/0/9",
            "      admin_vrid: 2",
            "      vrrp_type: member",
            "      provider: \"{{ cli }}\"",
            "  - name: Set vrrp vrid authentication-mode",
            "    ce_vrrp:",
            "      interface: 40GE2/0/8",
            "      vrid: 1",
            "      is_plain: true",
            "      auth_mode: simple",
            "      auth_key: aaa",
            "      provider: \"{{ cli }}\"",
            "'''",
            "",
            "RETURN = '''",
            "changed:",
            "    description: check to see if a change was made on the device",
            "    returned: always",
            "    type: bool",
            "    sample: true",
            "proposed:",
            "    description: k/v pairs of parameters passed into module",
            "    returned: always",
            "    type: dict",
            "    sample: {",
            "                \"auth_key\": \"aaa\",",
            "                \"auth_mode\": \"simple\",",
            "                \"interface\": \"40GE2/0/8\",",
            "                \"is_plain\": true,",
            "                \"state\": \"present\",",
            "                \"vrid\": \"1\"",
            "            }",
            "existing:",
            "    description: k/v pairs of existing aaa server",
            "    returned: always",
            "    type: dict",
            "    sample: {",
            "                \"auth_mode\": \"none\",",
            "                \"interface\": \"40GE2/0/8\",",
            "                \"is_plain\": \"false\",",
            "                \"vrid\": \"1\",",
            "                \"vrrp_type\": \"normal\"",
            "            }",
            "end_state:",
            "    description: k/v pairs of aaa params after module execution",
            "    returned: always",
            "    type: dict",
            "    sample: {",
            "                \"auth_mode\": \"simple\",",
            "                \"interface\": \"40GE2/0/8\",",
            "                \"is_plain\": \"true\",",
            "                \"vrid\": \"1\",",
            "                \"vrrp_type\": \"normal\"",
            "    }",
            "updates:",
            "    description: command sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: { \"interface 40GE2/0/8\",",
            "              \"vrrp vrid 1 authentication-mode simple plain aaa\"}",
            "'''",
            "",
            "from xml.etree import ElementTree",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.network.cloudengine.ce import get_nc_config, set_nc_config, ce_argument_spec",
            "",
            "",
            "CE_NC_GET_VRRP_GROUP_INFO = \"\"\"",
            "<filter type=\"subtree\">",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup>",
            "        <ifName>%s</ifName>",
            "        <vrrpId>%s</vrrpId>",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</filter>",
            "\"\"\"",
            "",
            "CE_NC_SET_VRRP_GROUP_INFO_HEAD = \"\"\"",
            "<config>",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup operation=\"merge\">",
            "        <ifName>%s</ifName>",
            "        <vrrpId>%s</vrrpId>",
            "\"\"\"",
            "CE_NC_SET_VRRP_GROUP_INFO_TAIL = \"\"\"",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</config>",
            "\"\"\"",
            "CE_NC_GET_VRRP_GLOBAL_INFO = \"\"\"",
            "<filter type=\"subtree\">",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGlobalCfg>",
            "      <gratuitousArpFlag></gratuitousArpFlag>",
            "      <gratuitousArpTimeOut></gratuitousArpTimeOut>",
            "      <recoverDelay></recoverDelay>",
            "      <version></version>",
            "    </vrrpGlobalCfg>",
            "  </vrrp>",
            "</filter>",
            "\"\"\"",
            "",
            "CE_NC_SET_VRRP_GLOBAL_HEAD = \"\"\"",
            "<config>",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGlobalCfg operation=\"merge\">",
            "\"\"\"",
            "CE_NC_SET_VRRP_GLOBAL_TAIL = \"\"\"",
            "    </vrrpGlobalCfg>",
            "  </vrrp>",
            "</config>",
            "\"\"\"",
            "",
            "CE_NC_GET_VRRP_VIRTUAL_IP_INFO = \"\"\"",
            "<filter type=\"subtree\">",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup>",
            "        <vrrpId>%s</vrrpId>",
            "        <ifName>%s</ifName>",
            "        <virtualIps>",
            "          <virtualIp>",
            "            <virtualIpAddress></virtualIpAddress>",
            "          </virtualIp>",
            "        </virtualIps>",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</filter>",
            "\"\"\"",
            "CE_NC_CREATE_VRRP_VIRTUAL_IP_INFO = \"\"\"",
            "<config>",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup>",
            "        <vrrpId>%s</vrrpId>",
            "        <ifName>%s</ifName>",
            "        <virtualIps>",
            "          <virtualIp operation=\"create\">",
            "            <virtualIpAddress>%s</virtualIpAddress>",
            "          </virtualIp>",
            "        </virtualIps>",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</config>",
            "\"\"\"",
            "CE_NC_DELETE_VRRP_VIRTUAL_IP_INFO = \"\"\"",
            "<config>",
            "  <vrrp xmlns=\"http://www.huawei.com/netconf/vrp\" content-version=\"1.0\" format-version=\"1.0\">",
            "    <vrrpGroups>",
            "      <vrrpGroup>",
            "        <vrrpId>%s</vrrpId>",
            "        <ifName>%s</ifName>",
            "        <virtualIps>",
            "          <virtualIp operation=\"delete\">",
            "            <virtualIpAddress>%s</virtualIpAddress>",
            "          </virtualIp>",
            "        </virtualIps>",
            "      </vrrpGroup>",
            "    </vrrpGroups>",
            "  </vrrp>",
            "</config>",
            "\"\"\"",
            "",
            "",
            "def is_valid_address(address):",
            "    \"\"\"check ip-address is valid\"\"\"",
            "",
            "    if address.find('.') != -1:",
            "        addr_list = address.split('.')",
            "        if len(addr_list) != 4:",
            "            return False",
            "        for each_num in addr_list:",
            "            if not each_num.isdigit():",
            "                return False",
            "            if int(each_num) > 255:",
            "                return False",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def get_interface_type(interface):",
            "    \"\"\"Gets the type of interface, such as 10GE, ETH-TRUNK, VLANIF...\"\"\"",
            "",
            "    if interface is None:",
            "        return None",
            "",
            "    iftype = None",
            "",
            "    if interface.upper().startswith('GE'):",
            "        iftype = 'ge'",
            "    elif interface.upper().startswith('10GE'):",
            "        iftype = '10ge'",
            "    elif interface.upper().startswith('25GE'):",
            "        iftype = '25ge'",
            "    elif interface.upper().startswith('40GE'):",
            "        iftype = '40ge'",
            "    elif interface.upper().startswith('100GE'):",
            "        iftype = '100ge'",
            "    elif interface.upper().startswith('ETH-TRUNK'):",
            "        iftype = 'eth-trunk'",
            "    elif interface.upper().startswith('NULL'):",
            "        iftype = 'null'",
            "    elif interface.upper().startswith('VLANIF'):",
            "        iftype = 'vlanif'",
            "    else:",
            "        return None",
            "",
            "    return iftype.lower()",
            "",
            "",
            "class Vrrp(object):",
            "    \"\"\"",
            "    Manages Manages vrrp information.",
            "    \"\"\"",
            "",
            "    def __init__(self, argument_spec):",
            "        self.spec = argument_spec",
            "        self.module = None",
            "        self.init_module()",
            "",
            "        # module input info",
            "        self.interface = self.module.params['interface']",
            "        self.vrid = self.module.params['vrid']",
            "        self.virtual_ip = self.module.params['virtual_ip']",
            "        self.vrrp_type = self.module.params['vrrp_type']",
            "        self.admin_ignore_if_down = 'false' if self.module.params['admin_ignore_if_down'] is False else 'true'",
            "        self.admin_vrid = self.module.params['admin_vrid']",
            "        self.admin_interface = self.module.params['admin_interface']",
            "        self.admin_flowdown = 'false' if self.module.params['admin_flowdown'] is False else 'true'",
            "        self.priority = self.module.params['priority']",
            "        self.version = self.module.params['version']",
            "        self.advertise_interval = self.module.params['advertise_interval']",
            "        self.preempt_timer_delay = self.module.params['preempt_timer_delay']",
            "        self.gratuitous_arp_interval = self.module.params[",
            "            'gratuitous_arp_interval']",
            "        self.recover_delay = self.module.params['recover_delay']",
            "        self.holding_multiplier = self.module.params['holding_multiplier']",
            "        self.auth_mode = self.module.params['auth_mode']",
            "        self.is_plain = 'false' if self.module.params['is_plain'] is False else 'true'",
            "        self.auth_key = self.module.params['auth_key']",
            "        self.fast_resume = self.module.params['fast_resume']",
            "        self.state = self.module.params['state']",
            "",
            "        # vrrp info",
            "        self.vrrp_global_info = None",
            "        self.virtual_ip_info = None",
            "        self.vrrp_group_info = None",
            "",
            "        # state",
            "        self.changed = False",
            "        self.updates_cmd = list()",
            "        self.results = dict()",
            "        self.existing = dict()",
            "        self.proposed = dict()",
            "        self.end_state = dict()",
            "",
            "    def init_module(self):",
            "        \"\"\" init module \"\"\"",
            "",
            "        self.module = AnsibleModule(",
            "            argument_spec=self.spec, supports_check_mode=True)",
            "",
            "    def get_virtual_ip_info(self):",
            "        \"\"\" get vrrp virtual ip info.\"\"\"",
            "        virtual_ip_info = dict()",
            "        conf_str = CE_NC_GET_VRRP_VIRTUAL_IP_INFO % (self.vrid, self.interface)",
            "        xml_str = get_nc_config(self.module, conf_str)",
            "        if \"<data/>\" in xml_str:",
            "            return virtual_ip_info",
            "        else:",
            "            xml_str = xml_str.replace('\\r', '').replace('\\n', '').\\",
            "                replace('xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"', \"\").\\",
            "                replace('xmlns=\"http://www.huawei.com/netconf/vrp\"', \"\")",
            "            virtual_ip_info[\"vrrpVirtualIpInfos\"] = list()",
            "            root = ElementTree.fromstring(xml_str)",
            "            vrrp_virtual_ip_infos = root.findall(",
            "                \"vrrp/vrrpGroups/vrrpGroup/virtualIps/virtualIp\")",
            "            if vrrp_virtual_ip_infos:",
            "                for vrrp_virtual_ip_info in vrrp_virtual_ip_infos:",
            "                    virtual_ip_dict = dict()",
            "                    for ele in vrrp_virtual_ip_info:",
            "                        if ele.tag in [\"virtualIpAddress\"]:",
            "                            virtual_ip_dict[ele.tag] = ele.text",
            "                    virtual_ip_info[\"vrrpVirtualIpInfos\"].append(",
            "                        virtual_ip_dict)",
            "            return virtual_ip_info",
            "",
            "    def get_vrrp_global_info(self):",
            "        \"\"\" get vrrp global info.\"\"\"",
            "",
            "        vrrp_global_info = dict()",
            "        conf_str = CE_NC_GET_VRRP_GLOBAL_INFO",
            "        xml_str = get_nc_config(self.module, conf_str)",
            "        if \"<data/>\" in xml_str:",
            "            return vrrp_global_info",
            "        else:",
            "            xml_str = xml_str.replace('\\r', '').replace('\\n', '').\\",
            "                replace('xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"', \"\").\\",
            "                replace('xmlns=\"http://www.huawei.com/netconf/vrp\"', \"\")",
            "",
            "            root = ElementTree.fromstring(xml_str)",
            "            global_info = root.findall(",
            "                \"vrrp/vrrpGlobalCfg\")",
            "",
            "            if global_info:",
            "                for tmp in global_info:",
            "                    for site in tmp:",
            "                        if site.tag in [\"gratuitousArpTimeOut\", \"gratuitousArpFlag\", \"recoverDelay\", \"version\"]:",
            "                            vrrp_global_info[site.tag] = site.text",
            "            return vrrp_global_info",
            "",
            "    def get_vrrp_group_info(self):",
            "        \"\"\" get vrrp group info.\"\"\"",
            "",
            "        vrrp_group_info = dict()",
            "        conf_str = CE_NC_GET_VRRP_GROUP_INFO % (self.interface, self.vrid)",
            "        xml_str = get_nc_config(self.module, conf_str)",
            "        if \"<data/>\" in xml_str:",
            "            return vrrp_group_info",
            "        else:",
            "            xml_str = xml_str.replace('\\r', '').replace('\\n', '').\\",
            "                replace('xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"', \"\").\\",
            "                replace('xmlns=\"http://www.huawei.com/netconf/vrp\"', \"\")",
            "",
            "            root = ElementTree.fromstring(xml_str)",
            "            global_info = root.findall(",
            "                \"vrrp/vrrpGroups/vrrpGroup\")",
            "",
            "            if global_info:",
            "                for tmp in global_info:",
            "                    for site in tmp:",
            "                        if site.tag in [\"ifName\", \"vrrpId\", \"priority\", \"advertiseInterval\", \"preemptMode\", \"delayTime\",",
            "                                        \"authenticationMode\", \"authenticationKey\", \"vrrpType\", \"adminVrrpId\",",
            "                                        \"adminIfName\", \"adminIgnoreIfDown\", \"isPlain\", \"unflowdown\", \"fastResume\",",
            "                                        \"holdMultiplier\"]:",
            "                            vrrp_group_info[site.tag] = site.text",
            "            return vrrp_group_info",
            "",
            "    def check_params(self):",
            "        \"\"\"Check all input params\"\"\"",
            "",
            "        # interface check",
            "        if self.interface:",
            "            intf_type = get_interface_type(self.interface)",
            "            if not intf_type:",
            "                self.module.fail_json(",
            "                    msg='Error: Interface name of %s '",
            "                        'is error.' % self.interface)",
            "",
            "        # vrid check",
            "        if self.vrid:",
            "            if not self.vrid.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of vrid is an integer.')",
            "            if int(self.vrid) < 1 or int(self.vrid) > 255:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of vrid ranges from 1 to 255.')",
            "",
            "        # virtual_ip check",
            "        if self.virtual_ip:",
            "            if not is_valid_address(self.virtual_ip):",
            "                self.module.fail_json(",
            "                    msg='Error: The %s is not a valid ip address.' % self.virtual_ip)",
            "",
            "        # admin_vrid check",
            "        if self.admin_vrid:",
            "            if not self.admin_vrid.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of admin_vrid is an integer.')",
            "            if int(self.admin_vrid) < 1 or int(self.admin_vrid) > 255:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of admin_vrid ranges from 1 to 255.')",
            "",
            "        # admin_interface check",
            "        if self.admin_interface:",
            "            intf_type = get_interface_type(self.admin_interface)",
            "            if not intf_type:",
            "                self.module.fail_json(",
            "                    msg='Error: Admin interface name of %s '",
            "                        'is error.' % self.admin_interface)",
            "",
            "        # priority check",
            "        if self.priority:",
            "            if not self.priority.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of priority is an integer.')",
            "            if int(self.priority) < 1 or int(self.priority) > 254:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of priority ranges from 1 to 254. The default value is 100.')",
            "",
            "        # advertise_interval check",
            "        if self.advertise_interval:",
            "            if not self.advertise_interval.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of advertise_interval is an integer.')",
            "            if int(self.advertise_interval) < 1000 or int(self.advertise_interval) > 255000:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of advertise_interval ranges from 1000 to 255000 milliseconds. The default value is 1000 milliseconds.')",
            "            if int(self.advertise_interval) % 1000 != 0:",
            "                self.module.fail_json(",
            "                    msg='Error: The advertisement interval value of VRRP must be a multiple of 1000 milliseconds.')",
            "        # preempt_timer_delay check",
            "        if self.preempt_timer_delay:",
            "            if not self.preempt_timer_delay.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of preempt_timer_delay is an integer.')",
            "            if int(self.preempt_timer_delay) < 1 or int(self.preempt_timer_delay) > 3600:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of preempt_timer_delay ranges from 1 to 3600. The default value is 0.')",
            "",
            "        # holding_multiplier check",
            "        if self.holding_multiplier:",
            "            if not self.holding_multiplier.isdigit():",
            "                self.module.fail_json(",
            "                    msg='Error: The value of holding_multiplier is an integer.')",
            "            if int(self.holding_multiplier) < 3 or int(self.holding_multiplier) > 10:",
            "                self.module.fail_json(",
            "                    msg='Error: The value of holding_multiplier ranges from 3 to 10. The default value is 3.')",
            "",
            "        # auth_key check",
            "        if self.auth_key:",
            "            if len(self.auth_key) > 16 \\",
            "                    or len(self.auth_key.replace(' ', '')) < 1:",
            "                self.module.fail_json(",
            "                    msg='Error: The length of auth_key is not in the range from 1 to 16.')",
            "",
            "    def is_virtual_ip_change(self):",
            "        \"\"\"whether virtual ip change\"\"\"",
            "",
            "        if not self.virtual_ip_info:",
            "            return True",
            "",
            "        for info in self.virtual_ip_info[\"vrrpVirtualIpInfos\"]:",
            "            if info[\"virtualIpAddress\"] == self.virtual_ip:",
            "                return False",
            "        return True",
            "",
            "    def is_virtual_ip_exist(self):",
            "        \"\"\"whether virtual ip info exist\"\"\"",
            "",
            "        if not self.virtual_ip_info:",
            "            return False",
            "",
            "        for info in self.virtual_ip_info[\"vrrpVirtualIpInfos\"]:",
            "            if info[\"virtualIpAddress\"] == self.virtual_ip:",
            "                return True",
            "        return False",
            "",
            "    def is_vrrp_global_info_change(self):",
            "        \"\"\"whether vrrp global attribute info change\"\"\"",
            "",
            "        if not self.vrrp_global_info:",
            "            return True",
            "",
            "        if self.gratuitous_arp_interval:",
            "            if self.vrrp_global_info[\"gratuitousArpFlag\"] == \"false\":",
            "                self.module.fail_json(msg=\"Error: gratuitousArpFlag is false.\")",
            "            if self.vrrp_global_info[\"gratuitousArpTimeOut\"] != self.gratuitous_arp_interval:",
            "                return True",
            "        if self.recover_delay:",
            "            if self.vrrp_global_info[\"recoverDelay\"] != self.recover_delay:",
            "                return True",
            "        if self.version:",
            "            if self.vrrp_global_info[\"version\"] != self.version:",
            "                return True",
            "        return False",
            "",
            "    def is_vrrp_global_info_exist(self):",
            "        \"\"\"whether vrrp global attribute info exist\"\"\"",
            "",
            "        if self.gratuitous_arp_interval or self.recover_delay or self.version:",
            "            if self.gratuitous_arp_interval:",
            "                if self.vrrp_global_info[\"gratuitousArpFlag\"] == \"false\":",
            "                    self.module.fail_json(",
            "                        msg=\"Error: gratuitousArpFlag is false.\")",
            "                if self.vrrp_global_info[\"gratuitousArpTimeOut\"] != self.gratuitous_arp_interval:",
            "                    return False",
            "            if self.recover_delay:",
            "                if self.vrrp_global_info[\"recoverDelay\"] != self.recover_delay:",
            "                    return False",
            "            if self.version:",
            "                if self.vrrp_global_info[\"version\"] != self.version:",
            "                    return False",
            "            return True",
            "",
            "        return False",
            "",
            "    def is_vrrp_group_info_change(self):",
            "        \"\"\"whether vrrp group attribute info change\"\"\"",
            "        if self.vrrp_type:",
            "            if self.vrrp_group_info[\"vrrpType\"] != self.vrrp_type:",
            "                return True",
            "        if self.admin_ignore_if_down:",
            "            if self.vrrp_group_info[\"adminIgnoreIfDown\"] != self.admin_ignore_if_down:",
            "                return True",
            "        if self.admin_vrid:",
            "            if self.vrrp_group_info[\"adminVrrpId\"] != self.admin_vrid:",
            "                return True",
            "        if self.admin_interface:",
            "            if self.vrrp_group_info[\"adminIfName\"] != self.admin_interface:",
            "                return True",
            "        if self.admin_flowdown:",
            "            if self.vrrp_group_info[\"unflowdown\"] != self.admin_flowdown:",
            "                return True",
            "        if self.priority:",
            "            if self.vrrp_group_info[\"priority\"] != self.priority:",
            "                return True",
            "        if self.fast_resume:",
            "            fast_resume = \"false\"",
            "            if self.fast_resume == \"enable\":",
            "                fast_resume = \"true\"",
            "            if self.vrrp_group_info[\"fastResume\"] != fast_resume:",
            "                return True",
            "        if self.advertise_interval:",
            "            if self.vrrp_group_info[\"advertiseInterval\"] != self.advertise_interval:",
            "                return True",
            "        if self.preempt_timer_delay:",
            "            if self.vrrp_group_info[\"delayTime\"] != self.preempt_timer_delay:",
            "                return True",
            "        if self.holding_multiplier:",
            "            if self.vrrp_group_info[\"holdMultiplier\"] != self.holding_multiplier:",
            "                return True",
            "        if self.auth_mode:",
            "            if self.vrrp_group_info[\"authenticationMode\"] != self.auth_mode:",
            "                return True",
            "        if self.auth_key:",
            "            return True",
            "        if self.is_plain:",
            "            if self.vrrp_group_info[\"isPlain\"] != self.is_plain:",
            "                return True",
            "",
            "        return False",
            "",
            "    def is_vrrp_group_info_exist(self):",
            "        \"\"\"whether vrrp group attribute info exist\"\"\"",
            "",
            "        if self.vrrp_type:",
            "            if self.vrrp_group_info[\"vrrpType\"] != self.vrrp_type:",
            "                return False",
            "        if self.admin_ignore_if_down:",
            "            if self.vrrp_group_info[\"adminIgnoreIfDown\"] != self.admin_ignore_if_down:",
            "                return False",
            "        if self.admin_vrid:",
            "            if self.vrrp_group_info[\"adminVrrpId\"] != self.admin_vrid:",
            "                return False",
            "        if self.admin_interface:",
            "            if self.vrrp_group_info[\"adminIfName\"] != self.admin_interface:",
            "                return False",
            "        if self.admin_flowdown:",
            "            if self.vrrp_group_info[\"unflowdown\"] != self.admin_flowdown:",
            "                return False",
            "        if self.priority:",
            "            if self.vrrp_group_info[\"priority\"] != self.priority:",
            "                return False",
            "        if self.fast_resume:",
            "            fast_resume = \"false\"",
            "            if self.fast_resume == \"enable\":",
            "                fast_resume = \"true\"",
            "            if self.vrrp_group_info[\"fastResume\"] != fast_resume:",
            "                return False",
            "        if self.advertise_interval:",
            "            if self.vrrp_group_info[\"advertiseInterval\"] != self.advertise_interval:",
            "                return False",
            "        if self.preempt_timer_delay:",
            "            if self.vrrp_group_info[\"delayTime\"] != self.preempt_timer_delay:",
            "                return False",
            "        if self.holding_multiplier:",
            "            if self.vrrp_group_info[\"holdMultiplier\"] != self.holding_multiplier:",
            "                return False",
            "        if self.auth_mode:",
            "            if self.vrrp_group_info[\"authenticationMode\"] != self.auth_mode:",
            "                return False",
            "        if self.is_plain:",
            "            if self.vrrp_group_info[\"isPlain\"] != self.is_plain:",
            "                return False",
            "        return True",
            "",
            "    def create_virtual_ip(self):",
            "        \"\"\"create virtual ip info\"\"\"",
            "",
            "        if self.is_virtual_ip_change():",
            "            conf_str = CE_NC_CREATE_VRRP_VIRTUAL_IP_INFO % (",
            "                self.vrid, self.interface, self.virtual_ip)",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: create virtual ip info failed.')",
            "",
            "            self.updates_cmd.append(\"interface %s\" % self.interface)",
            "            self.updates_cmd.append(",
            "                \"vrrp vrid %s virtual-ip %s\" % (self.vrid, self.virtual_ip))",
            "            self.changed = True",
            "",
            "    def delete_virtual_ip(self):",
            "        \"\"\"delete virtual ip info\"\"\"",
            "",
            "        if self.is_virtual_ip_exist():",
            "            conf_str = CE_NC_DELETE_VRRP_VIRTUAL_IP_INFO % (",
            "                self.vrid, self.interface, self.virtual_ip)",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: delete virtual ip info failed.')",
            "",
            "            self.updates_cmd.append(\"interface %s\" % self.interface)",
            "            self.updates_cmd.append(",
            "                \"undo vrrp vrid %s virtual-ip %s \" % (self.vrid, self.virtual_ip))",
            "            self.changed = True",
            "",
            "    def set_vrrp_global(self):",
            "        \"\"\"set vrrp global attribute info\"\"\"",
            "",
            "        if self.is_vrrp_global_info_change():",
            "            conf_str = CE_NC_SET_VRRP_GLOBAL_HEAD",
            "            if self.gratuitous_arp_interval:",
            "                conf_str += \"<gratuitousArpTimeOut>%s</gratuitousArpTimeOut>\" % self.gratuitous_arp_interval",
            "            if self.recover_delay:",
            "                conf_str += \"<recoverDelay>%s</recoverDelay>\" % self.recover_delay",
            "            if self.version:",
            "                conf_str += \"<version>%s</version>\" % self.version",
            "            conf_str += CE_NC_SET_VRRP_GLOBAL_TAIL",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: set vrrp global attribute info failed.')",
            "",
            "            if self.gratuitous_arp_interval:",
            "                self.updates_cmd.append(",
            "                    \"vrrp gratuitous-arp interval %s\" % self.gratuitous_arp_interval)",
            "",
            "            if self.recover_delay:",
            "                self.updates_cmd.append(",
            "                    \"vrrp recover-delay %s\" % self.recover_delay)",
            "",
            "            if self.version:",
            "                version = \"3\"",
            "                if self.version == \"v2\":",
            "                    version = \"2\"",
            "                self.updates_cmd.append(\"vrrp version %s\" % version)",
            "            self.changed = True",
            "",
            "    def delete_vrrp_global(self):",
            "        \"\"\"delete vrrp global attribute info\"\"\"",
            "",
            "        if self.is_vrrp_global_info_exist():",
            "            conf_str = CE_NC_SET_VRRP_GLOBAL_HEAD",
            "            if self.gratuitous_arp_interval:",
            "                if self.gratuitous_arp_interval == \"120\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of gratuitous_arp_interval is 120.')",
            "                gratuitous_arp_interval = \"120\"",
            "                conf_str += \"<gratuitousArpTimeOut>%s</gratuitousArpTimeOut>\" % gratuitous_arp_interval",
            "            if self.recover_delay:",
            "                if self.recover_delay == \"0\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of recover_delay is 0.')",
            "                recover_delay = \"0\"",
            "                conf_str += \"<recoverDelay>%s</recoverDelay>\" % recover_delay",
            "            if self.version:",
            "                if self.version == \"v2\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of version is v2.')",
            "                version = \"v2\"",
            "                conf_str += \"<version>%s</version>\" % version",
            "            conf_str += CE_NC_SET_VRRP_GLOBAL_TAIL",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: set vrrp global attribute info failed.')",
            "            if self.gratuitous_arp_interval:",
            "                self.updates_cmd.append(\"undo vrrp gratuitous-arp interval\")",
            "",
            "            if self.recover_delay:",
            "                self.updates_cmd.append(\"undo vrrp recover-delay\")",
            "",
            "            if self.version == \"v3\":",
            "                self.updates_cmd.append(\"undo vrrp version\")",
            "            self.changed = True",
            "",
            "    def set_vrrp_group(self):",
            "        \"\"\"set vrrp group attribute info\"\"\"",
            "",
            "        if self.is_vrrp_group_info_change():",
            "            conf_str = CE_NC_SET_VRRP_GROUP_INFO_HEAD % (",
            "                self.interface, self.vrid)",
            "            if self.vrrp_type:",
            "                conf_str += \"<vrrpType>%s</vrrpType>\" % self.vrrp_type",
            "            if self.admin_vrid:",
            "                conf_str += \"<adminVrrpId>%s</adminVrrpId>\" % self.admin_vrid",
            "            if self.admin_interface:",
            "                conf_str += \"<adminIfName>%s</adminIfName>\" % self.admin_interface",
            "                if self.admin_flowdown:",
            "                    conf_str += \"<unflowdown>%s</unflowdown>\" % self.admin_flowdown",
            "            if self.priority:",
            "                conf_str += \"<priority>%s</priority>\" % self.priority",
            "            if self.vrrp_type == \"admin\":",
            "                if self.admin_ignore_if_down:",
            "                    conf_str += \"<adminIgnoreIfDown>%s</adminIgnoreIfDown>\" % self.admin_ignore_if_down",
            "            if self.fast_resume:",
            "                fast_resume = \"false\"",
            "                if self.fast_resume == \"enable\":",
            "                    fast_resume = \"true\"",
            "                conf_str += \"<fastResume>%s</fastResume>\" % fast_resume",
            "            if self.advertise_interval:",
            "                conf_str += \"<advertiseInterval>%s</advertiseInterval>\" % self.advertise_interval",
            "            if self.preempt_timer_delay:",
            "                conf_str += \"<delayTime>%s</delayTime>\" % self.preempt_timer_delay",
            "            if self.holding_multiplier:",
            "                conf_str += \"<holdMultiplier>%s</holdMultiplier>\" % self.holding_multiplier",
            "            if self.auth_mode:",
            "                conf_str += \"<authenticationMode>%s</authenticationMode>\" % self.auth_mode",
            "            if self.auth_key:",
            "                conf_str += \"<authenticationKey>%s</authenticationKey>\" % self.auth_key",
            "            if self.auth_mode == \"simple\":",
            "                conf_str += \"<isPlain>%s</isPlain>\" % self.is_plain",
            "",
            "            conf_str += CE_NC_SET_VRRP_GROUP_INFO_TAIL",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: set vrrp group attribute info failed.')",
            "            if self.interface and self.vrid:",
            "                self.updates_cmd.append(\"interface %s\" % self.interface)",
            "                if self.vrrp_type == \"admin\":",
            "                    if self.admin_ignore_if_down == \"true\":",
            "                        self.updates_cmd.append(",
            "                            \"vrrp vrid %s admin ignore-if-down\" % self.vrid)",
            "                    else:",
            "                        self.updates_cmd.append(",
            "                            \"vrrp vrid %s admin\" % self.vrid)",
            "",
            "                if self.priority:",
            "                    self.updates_cmd.append(",
            "                        \"vrrp vrid %s priority %s\" % (self.vrid, self.priority))",
            "",
            "                if self.fast_resume == \"enable\":",
            "                    self.updates_cmd.append(",
            "                        \"vrrp vrid %s fast-resume\" % self.vrid)",
            "                if self.fast_resume == \"disable\":",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s fast-resume\" % self.vrid)",
            "",
            "                if self.advertise_interval:",
            "                    advertise_interval = int(self.advertise_interval) / 1000",
            "                    self.updates_cmd.append(\"vrrp vrid %s timer advertise %s<seconds>\" % (",
            "                        self.vrid, int(advertise_interval)))",
            "",
            "                if self.preempt_timer_delay:",
            "                    self.updates_cmd.append(\"vrrp vrid %s preempt timer delay %s\" % (self.vrid,",
            "                                                                                     self.preempt_timer_delay))",
            "",
            "                if self.holding_multiplier:",
            "                    self.updates_cmd.append(",
            "                        \"vrrp vrid %s holding-multiplier %s\" % (self.vrid, self.holding_multiplier))",
            "",
            "                if self.admin_vrid and self.admin_interface:",
            "                    if self.admin_flowdown == \"true\":",
            "                        self.updates_cmd.append(\"vrrp vrid %s track admin-vrrp interface %s vrid %s unflowdown\" %",
            "                                                (self.vrid, self.admin_interface, self.admin_vrid))",
            "                    else:",
            "                        self.updates_cmd.append(\"vrrp vrid %s track admin-vrrp interface %s vrid %s\" %",
            "                                                (self.vrid, self.admin_interface, self.admin_vrid))",
            "",
            "                if self.auth_mode and self.auth_key:",
            "                    if self.auth_mode == \"simple\":",
            "                        if self.is_plain == \"true\":",
            "                            self.updates_cmd.append(\"vrrp vrid %s authentication-mode simple plain %s\" %",
            "                                                    (self.vrid, self.auth_key))",
            "                        else:",
            "                            self.updates_cmd.append(\"vrrp vrid %s authentication-mode simple cipher %s\" %",
            "                                                    (self.vrid, self.auth_key))",
            "                    if self.auth_mode == \"md5\":",
            "                        self.updates_cmd.append(",
            "                            \"vrrp vrid %s authentication-mode md5 %s\" % (self.vrid, self.auth_key))",
            "                self.changed = True",
            "",
            "    def delete_vrrp_group(self):",
            "        \"\"\"delete vrrp group attribute info\"\"\"",
            "",
            "        if self.is_vrrp_group_info_exist():",
            "            conf_str = CE_NC_SET_VRRP_GROUP_INFO_HEAD % (",
            "                self.interface, self.vrid)",
            "            if self.vrrp_type:",
            "                vrrp_type = self.vrrp_type",
            "                if self.vrrp_type == \"admin\":",
            "                    vrrp_type = \"normal\"",
            "                if self.vrrp_type == \"member\" and self.admin_vrid and self.admin_interface:",
            "                    vrrp_type = \"normal\"",
            "                conf_str += \"<vrrpType>%s</vrrpType>\" % vrrp_type",
            "            if self.priority:",
            "                if self.priority == \"100\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of priority is 100.')",
            "                priority = \"100\"",
            "                conf_str += \"<priority>%s</priority>\" % priority",
            "",
            "            if self.fast_resume:",
            "                fast_resume = \"false\"",
            "                if self.fast_resume == \"enable\":",
            "                    fast_resume = \"true\"",
            "                conf_str += \"<fastResume>%s</fastResume>\" % fast_resume",
            "            if self.advertise_interval:",
            "                if self.advertise_interval == \"1000\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of advertise_interval is 1000.')",
            "                advertise_interval = \"1000\"",
            "                conf_str += \"<advertiseInterval>%s</advertiseInterval>\" % advertise_interval",
            "            if self.preempt_timer_delay:",
            "                if self.preempt_timer_delay == \"0\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of preempt_timer_delay is 0.')",
            "                preempt_timer_delay = \"0\"",
            "                conf_str += \"<delayTime>%s</delayTime>\" % preempt_timer_delay",
            "            if self.holding_multiplier:",
            "                if self.holding_multiplier == \"0\":",
            "                    self.module.fail_json(",
            "                        msg='Error: The default value of holding_multiplier is 3.')",
            "                holding_multiplier = \"3\"",
            "                conf_str += \"<holdMultiplier>%s</holdMultiplier>\" % holding_multiplier",
            "            if self.auth_mode:",
            "                auth_mode = self.auth_mode",
            "                if self.auth_mode == \"md5\" or self.auth_mode == \"simple\":",
            "                    auth_mode = \"none\"",
            "                conf_str += \"<authenticationMode>%s</authenticationMode>\" % auth_mode",
            "",
            "            conf_str += CE_NC_SET_VRRP_GROUP_INFO_TAIL",
            "            recv_xml = set_nc_config(self.module, conf_str)",
            "            if \"<ok/>\" not in recv_xml:",
            "                self.module.fail_json(",
            "                    msg='Error: set vrrp global attribute info failed.')",
            "            if self.interface and self.vrid:",
            "                self.updates_cmd.append(\"interface %s\" % self.interface)",
            "                if self.vrrp_type == \"admin\":",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s admin\" % self.vrid)",
            "",
            "                if self.priority:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s priority\" % self.vrid)",
            "",
            "                if self.fast_resume:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s fast-resume\" % self.vrid)",
            "",
            "                if self.advertise_interval:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s timer advertise\" % self.vrid)",
            "",
            "                if self.preempt_timer_delay:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s preempt timer delay\" % self.vrid)",
            "",
            "                if self.holding_multiplier:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s holding-multiplier\" % self.vrid)",
            "",
            "                if self.admin_vrid and self.admin_interface:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s track admin-vrrp\" % self.vrid)",
            "",
            "                if self.auth_mode:",
            "                    self.updates_cmd.append(",
            "                        \"undo vrrp vrid %s authentication-mode\" % self.vrid)",
            "                self.changed = True",
            "",
            "    def get_proposed(self):",
            "        \"\"\"get proposed info\"\"\"",
            "",
            "        if self.interface:",
            "            self.proposed[\"interface\"] = self.interface",
            "        if self.vrid:",
            "            self.proposed[\"vrid\"] = self.vrid",
            "        if self.virtual_ip:",
            "            self.proposed[\"virtual_ip\"] = self.virtual_ip",
            "        if self.vrrp_type:",
            "            self.proposed[\"vrrp_type\"] = self.vrrp_type",
            "        if self.admin_vrid:",
            "            self.proposed[\"admin_vrid\"] = self.admin_vrid",
            "        if self.admin_interface:",
            "            self.proposed[\"admin_interface\"] = self.admin_interface",
            "        if self.admin_flowdown:",
            "            self.proposed[\"unflowdown\"] = self.admin_flowdown",
            "        if self.admin_ignore_if_down:",
            "            self.proposed[\"admin_ignore_if_down\"] = self.admin_ignore_if_down",
            "        if self.priority:",
            "            self.proposed[\"priority\"] = self.priority",
            "        if self.version:",
            "            self.proposed[\"version\"] = self.version",
            "        if self.advertise_interval:",
            "            self.proposed[\"advertise_interval\"] = self.advertise_interval",
            "        if self.preempt_timer_delay:",
            "            self.proposed[\"preempt_timer_delay\"] = self.preempt_timer_delay",
            "        if self.gratuitous_arp_interval:",
            "            self.proposed[",
            "                \"gratuitous_arp_interval\"] = self.gratuitous_arp_interval",
            "        if self.recover_delay:",
            "            self.proposed[\"recover_delay\"] = self.recover_delay",
            "        if self.holding_multiplier:",
            "            self.proposed[\"holding_multiplier\"] = self.holding_multiplier",
            "        if self.auth_mode:",
            "            self.proposed[\"auth_mode\"] = self.auth_mode",
            "        if self.is_plain:",
            "            self.proposed[\"is_plain\"] = self.is_plain",
            "        if self.auth_key:",
            "            self.proposed[\"auth_key\"] = self.auth_key",
            "        if self.fast_resume:",
            "            self.proposed[\"fast_resume\"] = self.fast_resume",
            "        if self.state:",
            "            self.proposed[\"state\"] = self.state",
            "",
            "    def get_existing(self):",
            "        \"\"\"get existing info\"\"\"",
            "",
            "        if self.gratuitous_arp_interval:",
            "            self.existing[\"gratuitous_arp_interval\"] = self.vrrp_global_info[",
            "                \"gratuitousArpTimeOut\"]",
            "        if self.version:",
            "            self.existing[\"version\"] = self.vrrp_global_info[\"version\"]",
            "        if self.recover_delay:",
            "            self.existing[\"recover_delay\"] = self.vrrp_global_info[",
            "                \"recoverDelay\"]",
            "",
            "        if self.virtual_ip:",
            "            if self.virtual_ip_info:",
            "                self.existing[\"interface\"] = self.interface",
            "                self.existing[\"vrid\"] = self.vrid",
            "                self.existing[\"virtual_ip_info\"] = self.virtual_ip_info[",
            "                    \"vrrpVirtualIpInfos\"]",
            "",
            "        if self.vrrp_group_info:",
            "            self.existing[\"interface\"] = self.vrrp_group_info[\"ifName\"]",
            "            self.existing[\"vrid\"] = self.vrrp_group_info[\"vrrpId\"]",
            "            self.existing[\"vrrp_type\"] = self.vrrp_group_info[\"vrrpType\"]",
            "            if self.vrrp_type == \"admin\":",
            "                self.existing[\"admin_ignore_if_down\"] = self.vrrp_group_info[",
            "                    \"adminIgnoreIfDown\"]",
            "            if self.admin_vrid and self.admin_interface:",
            "                self.existing[\"admin_vrid\"] = self.vrrp_group_info[",
            "                    \"adminVrrpId\"]",
            "                self.existing[\"admin_interface\"] = self.vrrp_group_info[",
            "                    \"adminIfName\"]",
            "                self.existing[\"admin_flowdown\"] = self.vrrp_group_info[",
            "                    \"unflowdown\"]",
            "            if self.priority:",
            "                self.existing[\"priority\"] = self.vrrp_group_info[\"priority\"]",
            "            if self.advertise_interval:",
            "                self.existing[\"advertise_interval\"] = self.vrrp_group_info[",
            "                    \"advertiseInterval\"]",
            "            if self.preempt_timer_delay:",
            "                self.existing[\"preempt_timer_delay\"] = self.vrrp_group_info[",
            "                    \"delayTime\"]",
            "            if self.holding_multiplier:",
            "                self.existing[\"holding_multiplier\"] = self.vrrp_group_info[",
            "                    \"holdMultiplier\"]",
            "            if self.fast_resume:",
            "                fast_resume_exist = \"disable\"",
            "                fast_resume = self.vrrp_group_info[\"fastResume\"]",
            "                if fast_resume == \"true\":",
            "                    fast_resume_exist = \"enable\"",
            "                self.existing[\"fast_resume\"] = fast_resume_exist",
            "            if self.auth_mode:",
            "                self.existing[\"auth_mode\"] = self.vrrp_group_info[",
            "                    \"authenticationMode\"]",
            "                self.existing[\"is_plain\"] = self.vrrp_group_info[\"isPlain\"]",
            "",
            "    def get_end_state(self):",
            "        \"\"\"get end state info\"\"\"",
            "",
            "        if self.gratuitous_arp_interval or self.version or self.recover_delay:",
            "            self.vrrp_global_info = self.get_vrrp_global_info()",
            "        if self.interface and self.vrid:",
            "            if self.virtual_ip:",
            "                self.virtual_ip_info = self.get_virtual_ip_info()",
            "            if self.virtual_ip_info:",
            "                self.vrrp_group_info = self.get_vrrp_group_info()",
            "",
            "        if self.gratuitous_arp_interval:",
            "            self.end_state[\"gratuitous_arp_interval\"] = self.vrrp_global_info[",
            "                \"gratuitousArpTimeOut\"]",
            "        if self.version:",
            "            self.end_state[\"version\"] = self.vrrp_global_info[\"version\"]",
            "        if self.recover_delay:",
            "            self.end_state[\"recover_delay\"] = self.vrrp_global_info[",
            "                \"recoverDelay\"]",
            "",
            "        if self.virtual_ip:",
            "            if self.virtual_ip_info:",
            "                self.end_state[\"interface\"] = self.interface",
            "                self.end_state[\"vrid\"] = self.vrid",
            "                self.end_state[\"virtual_ip_info\"] = self.virtual_ip_info[",
            "                    \"vrrpVirtualIpInfos\"]",
            "",
            "        if self.vrrp_group_info:",
            "            self.end_state[\"interface\"] = self.vrrp_group_info[\"ifName\"]",
            "            self.end_state[\"vrid\"] = self.vrrp_group_info[\"vrrpId\"]",
            "            self.end_state[\"vrrp_type\"] = self.vrrp_group_info[\"vrrpType\"]",
            "            if self.vrrp_type == \"admin\":",
            "                self.end_state[\"admin_ignore_if_down\"] = self.vrrp_group_info[",
            "                    \"adminIgnoreIfDown\"]",
            "            if self.admin_vrid and self.admin_interface:",
            "                self.end_state[\"admin_vrid\"] = self.vrrp_group_info[",
            "                    \"adminVrrpId\"]",
            "                self.end_state[\"admin_interface\"] = self.vrrp_group_info[",
            "                    \"adminIfName\"]",
            "                self.end_state[\"admin_flowdown\"] = self.vrrp_group_info[",
            "                    \"unflowdown\"]",
            "            if self.priority:",
            "                self.end_state[\"priority\"] = self.vrrp_group_info[\"priority\"]",
            "            if self.advertise_interval:",
            "                self.end_state[\"advertise_interval\"] = self.vrrp_group_info[",
            "                    \"advertiseInterval\"]",
            "            if self.preempt_timer_delay:",
            "                self.end_state[\"preempt_timer_delay\"] = self.vrrp_group_info[",
            "                    \"delayTime\"]",
            "            if self.holding_multiplier:",
            "                self.end_state[\"holding_multiplier\"] = self.vrrp_group_info[",
            "                    \"holdMultiplier\"]",
            "            if self.fast_resume:",
            "                fast_resume_end = \"disable\"",
            "                fast_resume = self.vrrp_group_info[\"fastResume\"]",
            "                if fast_resume == \"true\":",
            "                    fast_resume_end = \"enable\"",
            "                self.end_state[\"fast_resume\"] = fast_resume_end",
            "            if self.auth_mode:",
            "                self.end_state[\"auth_mode\"] = self.vrrp_group_info[",
            "                    \"authenticationMode\"]",
            "                self.end_state[\"is_plain\"] = self.vrrp_group_info[\"isPlain\"]",
            "        if self.existing == self.end_state:",
            "            self.changed = False",
            "",
            "    def work(self):",
            "        \"\"\"worker\"\"\"",
            "",
            "        self.check_params()",
            "        if self.gratuitous_arp_interval or self.version or self.recover_delay:",
            "            self.vrrp_global_info = self.get_vrrp_global_info()",
            "        if self.interface and self.vrid:",
            "            self.virtual_ip_info = self.get_virtual_ip_info()",
            "            if self.virtual_ip_info:",
            "                self.vrrp_group_info = self.get_vrrp_group_info()",
            "        self.get_proposed()",
            "        self.get_existing()",
            "",
            "        if self.gratuitous_arp_interval or self.version or self.recover_delay:",
            "            if self.state == \"present\":",
            "                self.set_vrrp_global()",
            "            else:",
            "                self.delete_vrrp_global()",
            "        else:",
            "            if not self.interface or not self.vrid:",
            "                self.module.fail_json(",
            "                    msg='Error: interface, vrid must be config at the same time.')",
            "",
            "        if self.interface and self.vrid:",
            "            if self.virtual_ip:",
            "                if self.state == \"present\":",
            "                    self.create_virtual_ip()",
            "                else:",
            "                    self.delete_virtual_ip()",
            "            else:",
            "                if not self.vrrp_group_info:",
            "                    self.module.fail_json(",
            "                        msg='Error: The VRRP group does not exist.')",
            "                if self.admin_ignore_if_down == \"true\":",
            "                    if self.vrrp_type != \"admin\":",
            "                        self.module.fail_json(",
            "                            msg='Error: vrrpType must be admin when admin_ignore_if_down is true.')",
            "                if self.admin_interface or self.admin_vrid:",
            "                    if self.vrrp_type != \"member\":",
            "                        self.module.fail_json(",
            "                            msg='Error: it binds a VRRP group to an mVRRP group, vrrp_type must be \"member\".')",
            "                    if not self.vrrp_type or not self.interface or not self.vrid:",
            "                        self.module.fail_json(",
            "                            msg='Error: admin_interface admin_vrid vrrp_type interface vrid must '",
            "                                'be config at the same time.')",
            "                if self.auth_mode == \"md5\" and self.is_plain == \"true\":",
            "                    self.module.fail_json(",
            "                        msg='Error: is_plain can not be True when auth_mode is md5.')",
            "",
            "                if self.state == \"present\":",
            "                    self.set_vrrp_group()",
            "                else:",
            "                    self.delete_vrrp_group()",
            "",
            "        self.get_end_state()",
            "        self.results['changed'] = self.changed",
            "        self.results['proposed'] = self.proposed",
            "        self.results['existing'] = self.existing",
            "        self.results['end_state'] = self.end_state",
            "        if self.changed:",
            "            self.results['updates'] = self.updates_cmd",
            "        else:",
            "            self.results['updates'] = list()",
            "",
            "        self.module.exit_json(**self.results)",
            "",
            "",
            "def main():",
            "    \"\"\" Module main \"\"\"",
            "",
            "    argument_spec = dict(",
            "        interface=dict(type='str'),",
            "        vrid=dict(type='str'),",
            "        virtual_ip=dict(type='str'),",
            "        vrrp_type=dict(type='str', choices=['normal', 'member', 'admin']),",
            "        admin_ignore_if_down=dict(type='bool', default=False),",
            "        admin_vrid=dict(type='str'),",
            "        admin_interface=dict(type='str'),",
            "        admin_flowdown=dict(type='bool', default=False),",
            "        priority=dict(type='str'),",
            "        version=dict(type='str', choices=['v2', 'v3']),",
            "        advertise_interval=dict(type='str'),",
            "        preempt_timer_delay=dict(type='str'),",
            "        gratuitous_arp_interval=dict(type='str'),",
            "        recover_delay=dict(type='str'),",
            "        holding_multiplier=dict(type='str'),",
            "        auth_mode=dict(type='str', choices=['simple', 'md5', 'none']),",
            "        is_plain=dict(type='bool', default=False),",
            "        auth_key=dict(type='str', no_log=True),",
            "        fast_resume=dict(type='str', choices=['enable', 'disable']),",
            "        state=dict(type='str', default='present',",
            "                   choices=['present', 'absent'])",
            "    )",
            "",
            "    argument_spec.update(ce_argument_spec)",
            "    module = Vrrp(argument_spec=argument_spec)",
            "    module.work()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1317": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/itential/iap_start_workflow.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         argument_spec=dict("
            },
            "1": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             iap_port=dict(type='str', required=True),"
            },
            "2": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             iap_fqdn=dict(type='str', required=True),"
            },
            "3": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            token_key=dict(type='str', required=True),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+            token_key=dict(type='str', required=True, no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "             workflow_name=dict(type='str', required=True),"
            },
            "6": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "             description=dict(type='str', required=True),"
            },
            "7": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "             variables=dict(type='dict', required=False),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "",
            "# Copyright: (c) 2018, Itential <opensource@itential.com>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "\"\"\"",
            "This module provides the ability to start a workflow from Itential Automation Platform",
            "\"\"\"",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: iap_start_workflow",
            "version_added: \"2.8\"",
            "author: \"Itential (@cma0) <opensource@itential.com>\"",
            "short_description: Start a workflow in the Itential Automation Platform",
            "description:",
            "  - This will start a specified workflow in the Itential Automation Platform with given arguments.",
            "options:",
            "  iap_port:",
            "    description:",
            "      - Provide the port number for the Itential Automation Platform",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  iap_fqdn:",
            "    description:",
            "      - Provide the fqdn for the Itential Automation Platform",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  token_key:",
            "    description:",
            "      - Token key generated by iap_token module for the Itential Automation Platform",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  workflow_name:",
            "    description:",
            "      - Provide the workflow name",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  description:",
            "    description:",
            "      - Provide the description for the workflow",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  variables:",
            "    description:",
            "      - Provide the values to the job variables",
            "    required: true",
            "    type: dict",
            "    default: null",
            "",
            "  https:",
            "    description:",
            "      - Use HTTPS to connect",
            "      - By default using http",
            "    type: bool",
            "    default: False",
            "",
            "  validate_certs:",
            "    description:",
            "      - If C(no), SSL certificates for the target url will not be validated. This should only be used",
            "        on personally controlled sites using self-signed certificates.",
            "    type: bool",
            "    default: False",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: Start a workflow in the Itential Automation Platform",
            "  iap_start_workflow:",
            "    iap_port: 3000",
            "    iap_fqdn: localhost",
            "    token_key: \"DFSFSFHFGFGF[DSFSFAADAFASD%3D\"",
            "    workflow_name: \"RouterUpgradeWorkflow\"",
            "    description: \"OS-Router-Upgrade\"",
            "    variables: {\"deviceName\":\"ASR9K\"}",
            "  register: result",
            "",
            "- debug: var=result",
            "'''",
            "",
            "RETURN = '''",
            "response:",
            "    description: The result contains the response from the call",
            "    type: dict",
            "    returned: always",
            "msg:",
            "    description: The msg will contain the error code or status of the workflow",
            "    type: str",
            "    returned: always",
            "'''",
            "",
            "# Ansible imports",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.urls import fetch_url",
            "",
            "# Standard library imports",
            "import json",
            "",
            "",
            "def start_workflow(module):",
            "    \"\"\"",
            "    :param module:",
            "    :return: response and msg",
            "    \"\"\"",
            "    # By default this will be http.",
            "    # By default when using https, self signed certificate is used",
            "    # If https needs to pass certificate then use validate_certs as true",
            "    if module.params['https']:",
            "        transport_protocol = 'https'",
            "    else:",
            "        transport_protocol = 'http'",
            "",
            "    application_token = str(module.params['token_key'])",
            "    url = str(transport_protocol) + \"://\" + str(module.params['iap_fqdn']) + \":\" + str(module.params[",
            "        'iap_port']) + \"/workflow_engine/startJobWithOptions/\" \\",
            "        + str(module.params['workflow_name']) + \"?token=\" + str(application_token)",
            "    options = {",
            "        \"variables\": module.params['variables'],",
            "        \"description\": str(module.params['description'])",
            "    }",
            "",
            "    payload = {",
            "        \"workflow\": module.params['workflow_name'],",
            "        \"options\": options",
            "    }",
            "",
            "    json_body = module.jsonify(payload)",
            "    headers = dict()",
            "    headers['Content-Type'] = 'application/json'",
            "",
            "    # Using fetch url instead of requests",
            "    response, info = fetch_url(module, url, data=json_body, headers=headers)",
            "    response_code = str(info['status'])",
            "    if info['status'] not in [200, 201]:",
            "        module.fail_json(msg=\"Failed to connect to Itential Automation Platform. Response code is \" + response_code)",
            "",
            "    # in the event of a successful module execution, you will want to",
            "    # simple AnsibleModule.exit_json(), passing the key/value results",
            "    jsonResponse = json.loads(response.read().decode('utf-8'))",
            "    module.exit_json(changed=True, msg={\"workflow_name\": module.params['workflow_name'], \"status\": \"started\"},",
            "                     response=jsonResponse)",
            "",
            "",
            "def main():",
            "    \"\"\"",
            "    :return: response and msg",
            "    \"\"\"",
            "    # define the available arguments/parameters that a user can pass to",
            "    # the module",
            "    # the AnsibleModule object will be our abstraction working with Ansible",
            "    # this includes instantiation, a couple of common attr would be the",
            "    # args/params passed to the execution, as well as if the module",
            "    # supports check mode",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            iap_port=dict(type='str', required=True),",
            "            iap_fqdn=dict(type='str', required=True),",
            "            token_key=dict(type='str', required=True),",
            "            workflow_name=dict(type='str', required=True),",
            "            description=dict(type='str', required=True),",
            "            variables=dict(type='dict', required=False),",
            "            https=(dict(type='bool', default=False)),",
            "            validate_certs=dict(type='bool', default=False)",
            "        )",
            "    )",
            "    start_workflow(module)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "",
            "# Copyright: (c) 2018, Itential <opensource@itential.com>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "\"\"\"",
            "This module provides the ability to start a workflow from Itential Automation Platform",
            "\"\"\"",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: iap_start_workflow",
            "version_added: \"2.8\"",
            "author: \"Itential (@cma0) <opensource@itential.com>\"",
            "short_description: Start a workflow in the Itential Automation Platform",
            "description:",
            "  - This will start a specified workflow in the Itential Automation Platform with given arguments.",
            "options:",
            "  iap_port:",
            "    description:",
            "      - Provide the port number for the Itential Automation Platform",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  iap_fqdn:",
            "    description:",
            "      - Provide the fqdn for the Itential Automation Platform",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  token_key:",
            "    description:",
            "      - Token key generated by iap_token module for the Itential Automation Platform",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  workflow_name:",
            "    description:",
            "      - Provide the workflow name",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  description:",
            "    description:",
            "      - Provide the description for the workflow",
            "    required: true",
            "    type: str",
            "    default: null",
            "",
            "  variables:",
            "    description:",
            "      - Provide the values to the job variables",
            "    required: true",
            "    type: dict",
            "    default: null",
            "",
            "  https:",
            "    description:",
            "      - Use HTTPS to connect",
            "      - By default using http",
            "    type: bool",
            "    default: False",
            "",
            "  validate_certs:",
            "    description:",
            "      - If C(no), SSL certificates for the target url will not be validated. This should only be used",
            "        on personally controlled sites using self-signed certificates.",
            "    type: bool",
            "    default: False",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: Start a workflow in the Itential Automation Platform",
            "  iap_start_workflow:",
            "    iap_port: 3000",
            "    iap_fqdn: localhost",
            "    token_key: \"DFSFSFHFGFGF[DSFSFAADAFASD%3D\"",
            "    workflow_name: \"RouterUpgradeWorkflow\"",
            "    description: \"OS-Router-Upgrade\"",
            "    variables: {\"deviceName\":\"ASR9K\"}",
            "  register: result",
            "",
            "- debug: var=result",
            "'''",
            "",
            "RETURN = '''",
            "response:",
            "    description: The result contains the response from the call",
            "    type: dict",
            "    returned: always",
            "msg:",
            "    description: The msg will contain the error code or status of the workflow",
            "    type: str",
            "    returned: always",
            "'''",
            "",
            "# Ansible imports",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.urls import fetch_url",
            "",
            "# Standard library imports",
            "import json",
            "",
            "",
            "def start_workflow(module):",
            "    \"\"\"",
            "    :param module:",
            "    :return: response and msg",
            "    \"\"\"",
            "    # By default this will be http.",
            "    # By default when using https, self signed certificate is used",
            "    # If https needs to pass certificate then use validate_certs as true",
            "    if module.params['https']:",
            "        transport_protocol = 'https'",
            "    else:",
            "        transport_protocol = 'http'",
            "",
            "    application_token = str(module.params['token_key'])",
            "    url = str(transport_protocol) + \"://\" + str(module.params['iap_fqdn']) + \":\" + str(module.params[",
            "        'iap_port']) + \"/workflow_engine/startJobWithOptions/\" \\",
            "        + str(module.params['workflow_name']) + \"?token=\" + str(application_token)",
            "    options = {",
            "        \"variables\": module.params['variables'],",
            "        \"description\": str(module.params['description'])",
            "    }",
            "",
            "    payload = {",
            "        \"workflow\": module.params['workflow_name'],",
            "        \"options\": options",
            "    }",
            "",
            "    json_body = module.jsonify(payload)",
            "    headers = dict()",
            "    headers['Content-Type'] = 'application/json'",
            "",
            "    # Using fetch url instead of requests",
            "    response, info = fetch_url(module, url, data=json_body, headers=headers)",
            "    response_code = str(info['status'])",
            "    if info['status'] not in [200, 201]:",
            "        module.fail_json(msg=\"Failed to connect to Itential Automation Platform. Response code is \" + response_code)",
            "",
            "    # in the event of a successful module execution, you will want to",
            "    # simple AnsibleModule.exit_json(), passing the key/value results",
            "    jsonResponse = json.loads(response.read().decode('utf-8'))",
            "    module.exit_json(changed=True, msg={\"workflow_name\": module.params['workflow_name'], \"status\": \"started\"},",
            "                     response=jsonResponse)",
            "",
            "",
            "def main():",
            "    \"\"\"",
            "    :return: response and msg",
            "    \"\"\"",
            "    # define the available arguments/parameters that a user can pass to",
            "    # the module",
            "    # the AnsibleModule object will be our abstraction working with Ansible",
            "    # this includes instantiation, a couple of common attr would be the",
            "    # args/params passed to the execution, as well as if the module",
            "    # supports check mode",
            "    module = AnsibleModule(",
            "        argument_spec=dict(",
            "            iap_port=dict(type='str', required=True),",
            "            iap_fqdn=dict(type='str', required=True),",
            "            token_key=dict(type='str', required=True, no_log=True),",
            "            workflow_name=dict(type='str', required=True),",
            "            description=dict(type='str', required=True),",
            "            variables=dict(type='dict', required=False),",
            "            https=(dict(type='bool', default=False)),",
            "            validate_certs=dict(type='bool', default=False)",
            "        )",
            "    )",
            "    start_workflow(module)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "172": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/netscaler/netscaler_lb_monitor.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 986,
                "afterPatchRowNumber": 986,
                "PatchRowcode": "         secondarypassword=dict(type='str'),"
            },
            "1": {
                "beforePatchRowNumber": 987,
                "afterPatchRowNumber": 987,
                "PatchRowcode": "         logonpointname=dict(type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 988,
                "afterPatchRowNumber": 988,
                "PatchRowcode": "         lasversion=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 989,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        radkey=dict(type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 989,
                "PatchRowcode": "+        radkey=dict(type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 990,
                "afterPatchRowNumber": 990,
                "PatchRowcode": "         radnasid=dict(type='str'),"
            },
            "6": {
                "beforePatchRowNumber": 991,
                "afterPatchRowNumber": 991,
                "PatchRowcode": "         radnasip=dict(type='str'),"
            },
            "7": {
                "beforePatchRowNumber": 992,
                "afterPatchRowNumber": 992,
                "PatchRowcode": "         radaccounttype=dict(type='float'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "#  Copyright (c) 2017 Citrix Systems",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "module: netscaler_lb_monitor",
            "short_description: Manage load balancing monitors",
            "description:",
            "    - Manage load balancing monitors.",
            "    - This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance.",
            "",
            "version_added: \"2.4\"",
            "",
            "author: George Nikolopoulos (@giorgos-nikolopoulos)",
            "",
            "options:",
            "",
            "    monitorname:",
            "        description:",
            "            - >-",
            "                Name for the monitor. Must begin with an ASCII alphanumeric or underscore C(_) character, and must",
            "                contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at C(@), equals",
            "                C(=), and hyphen C(-) characters.",
            "            - \"Minimum length = 1\"",
            "",
            "    type:",
            "        choices:",
            "            - 'PING'",
            "            - 'TCP'",
            "            - 'HTTP'",
            "            - 'TCP-ECV'",
            "            - 'HTTP-ECV'",
            "            - 'UDP-ECV'",
            "            - 'DNS'",
            "            - 'FTP'",
            "            - 'LDNS-PING'",
            "            - 'LDNS-TCP'",
            "            - 'LDNS-DNS'",
            "            - 'RADIUS'",
            "            - 'USER'",
            "            - 'HTTP-INLINE'",
            "            - 'SIP-UDP'",
            "            - 'SIP-TCP'",
            "            - 'LOAD'",
            "            - 'FTP-EXTENDED'",
            "            - 'SMTP'",
            "            - 'SNMP'",
            "            - 'NNTP'",
            "            - 'MYSQL'",
            "            - 'MYSQL-ECV'",
            "            - 'MSSQL-ECV'",
            "            - 'ORACLE-ECV'",
            "            - 'LDAP'",
            "            - 'POP3'",
            "            - 'CITRIX-XML-SERVICE'",
            "            - 'CITRIX-WEB-INTERFACE'",
            "            - 'DNS-TCP'",
            "            - 'RTSP'",
            "            - 'ARP'",
            "            - 'CITRIX-AG'",
            "            - 'CITRIX-AAC-LOGINPAGE'",
            "            - 'CITRIX-AAC-LAS'",
            "            - 'CITRIX-XD-DDC'",
            "            - 'ND6'",
            "            - 'CITRIX-WI-EXTENDED'",
            "            - 'DIAMETER'",
            "            - 'RADIUS_ACCOUNTING'",
            "            - 'STOREFRONT'",
            "            - 'APPC'",
            "            - 'SMPP'",
            "            - 'CITRIX-XNC-ECV'",
            "            - 'CITRIX-XDM'",
            "            - 'CITRIX-STA-SERVICE'",
            "            - 'CITRIX-STA-SERVICE-NHOP'",
            "        description:",
            "            - \"Type of monitor that you want to create.\"",
            "",
            "    action:",
            "        choices:",
            "            - 'NONE'",
            "            - 'LOG'",
            "            - 'DOWN'",
            "        description:",
            "            - >-",
            "                Action to perform when the response to an inline monitor (a monitor of type C(HTTP-INLINE)) indicates",
            "                that the service is down. A service monitored by an inline monitor is considered C(DOWN) if the response",
            "                code is not one of the codes that have been specified for the Response Code parameter.",
            "            - \"Available settings function as follows:\"",
            "            - >-",
            "                * C(NONE) - Do not take any action. However, the show service command and the show lb monitor command",
            "                indicate the total number of responses that were checked and the number of consecutive error",
            "                responses received after the last successful probe.",
            "            - \"* C(LOG) - Log the event in NSLOG or SYSLOG.\"",
            "            - >-",
            "                * C(DOWN) - Mark the service as being down, and then do not direct any traffic to the service until the",
            "                configured down time has expired. Persistent connections to the service are terminated as soon as the",
            "                service is marked as C(DOWN). Also, log the event in NSLOG or SYSLOG.",
            "",
            "    respcode:",
            "        description:",
            "            - >-",
            "                Response codes for which to mark the service as UP. For any other response code, the action performed",
            "                depends on the monitor type. C(HTTP) monitors and C(RADIUS) monitors mark the service as C(DOWN), while",
            "                C(HTTP-INLINE) monitors perform the action indicated by the Action parameter.",
            "",
            "    httprequest:",
            "        description:",
            "            - \"HTTP request to send to the server (for example, C(\\\\\"HEAD /file.html\\\\\")).\"",
            "",
            "    rtsprequest:",
            "        description:",
            "            - \"RTSP request to send to the server (for example, C(\\\\\"OPTIONS *\\\\\")).\"",
            "",
            "    customheaders:",
            "        description:",
            "            - \"Custom header string to include in the monitoring probes.\"",
            "",
            "    maxforwards:",
            "        description:",
            "            - >-",
            "                Maximum number of hops that the SIP request used for monitoring can traverse to reach the server.",
            "                Applicable only to monitors of type C(SIP-UDP).",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(255)\"",
            "",
            "    sipmethod:",
            "        choices:",
            "            - 'OPTIONS'",
            "            - 'INVITE'",
            "            - 'REGISTER'",
            "        description:",
            "            - \"SIP method to use for the query. Applicable only to monitors of type C(SIP-UDP).\"",
            "",
            "    sipuri:",
            "        description:",
            "            - >-",
            "                SIP URI string to send to the service (for example, C(sip:sip.test)). Applicable only to monitors of",
            "                type C(SIP-UDP).",
            "            - \"Minimum length = 1\"",
            "",
            "    sipreguri:",
            "        description:",
            "            - >-",
            "                SIP user to be registered. Applicable only if the monitor is of type C(SIP-UDP) and the SIP Method",
            "                parameter is set to C(REGISTER).",
            "            - \"Minimum length = 1\"",
            "",
            "    send:",
            "        description:",
            "            - \"String to send to the service. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.\"",
            "",
            "    recv:",
            "        description:",
            "            - >-",
            "                String expected from the server for the service to be marked as UP. Applicable to C(TCP-ECV), C(HTTP-ECV),",
            "                and C(UDP-ECV) monitors.",
            "",
            "    query:",
            "        description:",
            "            - \"Domain name to resolve as part of monitoring the DNS service (for example, C(example.com)).\"",
            "",
            "    querytype:",
            "        choices:",
            "            - 'Address'",
            "            - 'Zone'",
            "            - 'AAAA'",
            "        description:",
            "            - >-",
            "                Type of DNS record for which to send monitoring queries. Set to C(Address) for querying A records, C(AAAA)",
            "                for querying AAAA records, and C(Zone) for querying the SOA record.",
            "",
            "    scriptname:",
            "        description:",
            "            - >-",
            "                Path and name of the script to execute. The script must be available on the NetScaler appliance, in",
            "                the /nsconfig/monitors/ directory.",
            "            - \"Minimum length = 1\"",
            "",
            "    scriptargs:",
            "        description:",
            "            - \"String of arguments for the script. The string is copied verbatim into the request.\"",
            "",
            "    dispatcherip:",
            "        description:",
            "            - \"IP address of the dispatcher to which to send the probe.\"",
            "",
            "    dispatcherport:",
            "        description:",
            "            - \"Port number on which the dispatcher listens for the monitoring probe.\"",
            "",
            "    username:",
            "        description:",
            "            - >-",
            "                User name with which to probe the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG),",
            "                C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC) or C(CITRIX-XDM) server.",
            "            - \"Minimum length = 1\"",
            "",
            "    password:",
            "        description:",
            "            - >-",
            "                Password that is required for logging on to the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3),",
            "                C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC-ECV) or C(CITRIX-XDM) server. Used in",
            "                conjunction with the user name specified for the C(username) parameter.",
            "            - \"Minimum length = 1\"",
            "",
            "    secondarypassword:",
            "        description:",
            "            - >-",
            "                Secondary password that users might have to provide to log on to the Access Gateway server.",
            "                Applicable to C(CITRIX-AG) monitors.",
            "",
            "    logonpointname:",
            "        description:",
            "            - >-",
            "                Name of the logon point that is configured for the Citrix Access Gateway Advanced Access Control",
            "                software. Required if you want to monitor the associated login page or Logon Agent. Applicable to",
            "                C(CITRIX-AAC-LAS) and C(CITRIX-AAC-LOGINPAGE) monitors.",
            "",
            "    lasversion:",
            "        description:",
            "            - >-",
            "                Version number of the Citrix Advanced Access Control Logon Agent. Required by the C(CITRIX-AAC-LAS)",
            "                monitor.",
            "",
            "    radkey:",
            "        description:",
            "            - >-",
            "                Authentication key (shared secret text string) for RADIUS clients and servers to exchange. Applicable",
            "                to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).",
            "            - \"Minimum length = 1\"",
            "",
            "    radnasid:",
            "        description:",
            "            - \"NAS-Identifier to send in the Access-Request packet. Applicable to monitors of type C(RADIUS).\"",
            "            - \"Minimum length = 1\"",
            "",
            "    radnasip:",
            "        description:",
            "            - >-",
            "                Network Access Server (NAS) IP address to use as the source IP address when monitoring a RADIUS",
            "                server. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).",
            "",
            "    radaccounttype:",
            "        description:",
            "            - \"Account Type to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).\"",
            "            - \"Minimum value = 0\"",
            "            - \"Maximum value = 15\"",
            "",
            "    radframedip:",
            "        description:",
            "            - \"Source ip with which the packet will go out . Applicable to monitors of type C(RADIUS_ACCOUNTING).\"",
            "",
            "    radapn:",
            "        description:",
            "            - >-",
            "                Called Station Id to be used in Account Request Packet. Applicable to monitors of type",
            "                C(RADIUS_ACCOUNTING).",
            "            - \"Minimum length = 1\"",
            "",
            "    radmsisdn:",
            "        description:",
            "            - >-",
            "                Calling Stations Id to be used in Account Request Packet. Applicable to monitors of type",
            "                C(RADIUS_ACCOUNTING).",
            "            - \"Minimum length = 1\"",
            "",
            "    radaccountsession:",
            "        description:",
            "            - >-",
            "                Account Session ID to be used in Account Request Packet. Applicable to monitors of type",
            "                C(RADIUS_ACCOUNTING).",
            "            - \"Minimum length = 1\"",
            "",
            "    lrtm:",
            "        choices:",
            "            - 'enabled'",
            "            - 'disabled'",
            "        description:",
            "            - >-",
            "                Calculate the least response times for bound services. If this parameter is not enabled, the",
            "                appliance does not learn the response times of the bound services. Also used for LRTM load balancing.",
            "",
            "    deviation:",
            "        description:",
            "            - >-",
            "                Time value added to the learned average response time in dynamic response time monitoring (DRTM).",
            "                When a deviation is specified, the appliance learns the average response time of bound services and",
            "                adds the deviation to the average. The final value is then continually adjusted to accommodate",
            "                response time variations over time. Specified in milliseconds, seconds, or minutes.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(20939)\"",
            "",
            "    units1:",
            "        choices:",
            "            - 'SEC'",
            "            - 'MSEC'",
            "            - 'MIN'",
            "        description:",
            "            - \"Unit of measurement for the Deviation parameter. Cannot be changed after the monitor is created.\"",
            "",
            "    interval:",
            "        description:",
            "            - \"Time interval between two successive probes. Must be greater than the value of Response Time-out.\"",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(20940)\"",
            "",
            "    units3:",
            "        choices:",
            "            - 'SEC'",
            "            - 'MSEC'",
            "            - 'MIN'",
            "        description:",
            "            - \"monitor interval units.\"",
            "",
            "    resptimeout:",
            "        description:",
            "            - >-",
            "                Amount of time for which the appliance must wait before it marks a probe as FAILED. Must be less than",
            "                the value specified for the Interval parameter.",
            "            - >-",
            "                Note: For C(UDP-ECV) monitors for which a receive string is not configured, response timeout does not",
            "                apply. For C(UDP-ECV) monitors with no receive string, probe failure is indicated by an ICMP port",
            "                unreachable error received from the service.",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(20939)\"",
            "",
            "    units4:",
            "        choices:",
            "            - 'SEC'",
            "            - 'MSEC'",
            "            - 'MIN'",
            "        description:",
            "            - \"monitor response timeout units.\"",
            "",
            "    resptimeoutthresh:",
            "        description:",
            "            - >-",
            "                Response time threshold, specified as a percentage of the Response Time-out parameter. If the",
            "                response to a monitor probe has not arrived when the threshold is reached, the appliance generates an",
            "                SNMP trap called monRespTimeoutAboveThresh. After the response time returns to a value below the",
            "                threshold, the appliance generates a monRespTimeoutBelowThresh SNMP trap. For the traps to be",
            "                generated, the \"MONITOR-RTO-THRESHOLD\" alarm must also be enabled.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(100)\"",
            "",
            "    retries:",
            "        description:",
            "            - >-",
            "                Maximum number of probes to send to establish the state of a service for which a monitoring probe",
            "                failed.",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(127)\"",
            "",
            "    failureretries:",
            "        description:",
            "            - >-",
            "                Number of retries that must fail, out of the number specified for the Retries parameter, for a",
            "                service to be marked as DOWN. For example, if the Retries parameter is set to 10 and the Failure",
            "                Retries parameter is set to 6, out of the ten probes sent, at least six probes must fail if the",
            "                service is to be marked as DOWN. The default value of 0 means that all the retries must fail if the",
            "                service is to be marked as DOWN.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(32)\"",
            "",
            "    alertretries:",
            "        description:",
            "            - >-",
            "                Number of consecutive probe failures after which the appliance generates an SNMP trap called",
            "                monProbeFailed.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(32)\"",
            "",
            "    successretries:",
            "        description:",
            "            - \"Number of consecutive successful probes required to transition a service's state from DOWN to UP.\"",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(32)\"",
            "",
            "    downtime:",
            "        description:",
            "            - >-",
            "                Time duration for which to wait before probing a service that has been marked as DOWN. Expressed in",
            "                milliseconds, seconds, or minutes.",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(20939)\"",
            "",
            "    units2:",
            "        choices:",
            "            - 'SEC'",
            "            - 'MSEC'",
            "            - 'MIN'",
            "        description:",
            "            - \"Unit of measurement for the Down Time parameter. Cannot be changed after the monitor is created.\"",
            "",
            "    destip:",
            "        description:",
            "            - >-",
            "                IP address of the service to which to send probes. If the parameter is set to 0, the IP address of",
            "                the server to which the monitor is bound is considered the destination IP address.",
            "",
            "    destport:",
            "        description:",
            "            - >-",
            "                TCP or UDP port to which to send the probe. If the parameter is set to 0, the port number of the",
            "                service to which the monitor is bound is considered the destination port. For a monitor of type C(USER),",
            "                however, the destination port is the port number that is included in the HTTP request sent to the",
            "                dispatcher. Does not apply to monitors of type C(PING).",
            "",
            "    state:",
            "        choices:",
            "            - 'enabled'",
            "            - 'disabled'",
            "        description:",
            "            - >-",
            "                State of the monitor. The C(disabled) setting disables not only the monitor being configured, but all",
            "                monitors of the same type, until the parameter is set to C(enabled). If the monitor is bound to a",
            "                service, the state of the monitor is not taken into account when the state of the service is",
            "                determined.",
            "",
            "    reverse:",
            "        description:",
            "            - >-",
            "                Mark a service as DOWN, instead of UP, when probe criteria are satisfied, and as UP instead of DOWN",
            "                when probe criteria are not satisfied.",
            "        type: bool",
            "",
            "    transparent:",
            "        description:",
            "            - >-",
            "                The monitor is bound to a transparent device such as a firewall or router. The state of a transparent",
            "                device depends on the responsiveness of the services behind it. If a transparent device is being",
            "                monitored, a destination IP address must be specified. The probe is sent to the specified IP address",
            "                by using the MAC address of the transparent device.",
            "        type: bool",
            "",
            "    iptunnel:",
            "        description:",
            "            - >-",
            "                Send the monitoring probe to the service through an IP tunnel. A destination IP address must be",
            "                specified.",
            "        type: bool",
            "",
            "    tos:",
            "        description:",
            "            - \"Probe the service by encoding the destination IP address in the IP TOS (6) bits.\"",
            "        type: bool",
            "",
            "    tosid:",
            "        description:",
            "            - \"The TOS ID of the specified destination IP. Applicable only when the TOS parameter is set.\"",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(63)\"",
            "",
            "    secure:",
            "        description:",
            "            - >-",
            "                Use a secure SSL connection when monitoring a service. Applicable only to TCP based monitors. The",
            "                secure option cannot be used with a C(CITRIX-AG) monitor, because a CITRIX-AG monitor uses a secure",
            "                connection by default.",
            "        type: bool",
            "",
            "    validatecred:",
            "        description:",
            "            - >-",
            "                Validate the credentials of the Xen Desktop DDC server user. Applicable to monitors of type",
            "                C(CITRIX-XD-DDC).",
            "        type: bool",
            "",
            "    domain:",
            "        description:",
            "            - >-",
            "                Domain in which the XenDesktop Desktop Delivery Controller (DDC) servers or Web Interface servers are",
            "                present. Required by C(CITRIX-XD-DDC) and C(CITRIX-WI-EXTENDED) monitors for logging on to the DDC servers",
            "                and Web Interface servers, respectively.",
            "",
            "    ipaddress:",
            "        description:",
            "            - >-",
            "                Set of IP addresses expected in the monitoring response from the DNS server, if the record type is A",
            "                or AAAA. Applicable to C(DNS) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    group:",
            "        description:",
            "            - >-",
            "                Name of a newsgroup available on the NNTP service that is to be monitored. The appliance periodically",
            "                generates an NNTP query for the name of the newsgroup and evaluates the response. If the newsgroup is",
            "                found on the server, the service is marked as UP. If the newsgroup does not exist or if the search",
            "                fails, the service is marked as DOWN. Applicable to NNTP monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    filename:",
            "        description:",
            "            - >-",
            "                Name of a file on the FTP server. The appliance monitors the FTP service by periodically checking the",
            "                existence of the file on the server. Applicable to C(FTP-EXTENDED) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    basedn:",
            "        description:",
            "            - >-",
            "                The base distinguished name of the LDAP service, from where the LDAP server can begin the search for",
            "                the attributes in the monitoring query. Required for C(LDAP) service monitoring.",
            "            - \"Minimum length = 1\"",
            "",
            "    binddn:",
            "        description:",
            "            - >-",
            "                The distinguished name with which an LDAP monitor can perform the Bind operation on the LDAP server.",
            "                Optional. Applicable to C(LDAP) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    filter:",
            "        description:",
            "            - \"Filter criteria for the LDAP query. Optional.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    attribute:",
            "        description:",
            "            - >-",
            "                Attribute to evaluate when the LDAP server responds to the query. Success or failure of the",
            "                monitoring probe depends on whether the attribute exists in the response. Optional.",
            "            - \"Minimum length = 1\"",
            "",
            "    database:",
            "        description:",
            "            - \"Name of the database to connect to during authentication.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    oraclesid:",
            "        description:",
            "            - \"Name of the service identifier that is used to connect to the Oracle database during authentication.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    sqlquery:",
            "        description:",
            "            - >-",
            "                SQL query for a C(MYSQL-ECV) or C(MSSQL-ECV) monitor. Sent to the database server after the server",
            "                authenticates the connection.",
            "            - \"Minimum length = 1\"",
            "",
            "    evalrule:",
            "        description:",
            "            - >-",
            "                Default syntax expression that evaluates the database server's response to a MYSQL-ECV or MSSQL-ECV",
            "                monitoring query. Must produce a Boolean result. The result determines the state of the server. If",
            "                the expression returns TRUE, the probe succeeds.",
            "            - >-",
            "                For example, if you want the appliance to evaluate the error message to determine the state of the",
            "                server, use the rule C(MYSQL.RES.ROW(10) .TEXT_ELEM(2).EQ(\"MySQL\")).",
            "",
            "    mssqlprotocolversion:",
            "        choices:",
            "            - '70'",
            "            - '2000'",
            "            - '2000SP1'",
            "            - '2005'",
            "            - '2008'",
            "            - '2008R2'",
            "            - '2012'",
            "            - '2014'",
            "        description:",
            "            - \"Version of MSSQL server that is to be monitored.\"",
            "",
            "    Snmpoid:",
            "        description:",
            "            - \"SNMP OID for C(SNMP) monitors.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    snmpcommunity:",
            "        description:",
            "            - \"Community name for C(SNMP) monitors.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    snmpthreshold:",
            "        description:",
            "            - \"Threshold for C(SNMP) monitors.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    snmpversion:",
            "        choices:",
            "            - 'V1'",
            "            - 'V2'",
            "        description:",
            "            - \"SNMP version to be used for C(SNMP) monitors.\"",
            "",
            "    metrictable:",
            "        description:",
            "            - \"Metric table to which to bind metrics.\"",
            "            - \"Minimum length = 1\"",
            "            - \"Maximum length = 99\"",
            "",
            "    application:",
            "        description:",
            "            - >-",
            "                Name of the application used to determine the state of the service. Applicable to monitors of type",
            "                C(CITRIX-XML-SERVICE).",
            "            - \"Minimum length = 1\"",
            "",
            "    sitepath:",
            "        description:",
            "            - >-",
            "                URL of the logon page. For monitors of type C(CITRIX-WEB-INTERFACE), to monitor a dynamic page under the",
            "                site path, terminate the site path with a slash C(/). Applicable to C(CITRIX-WEB-INTERFACE),",
            "                C(CITRIX-WI-EXTENDED) and C(CITRIX-XDM) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    storename:",
            "        description:",
            "            - >-",
            "                Store Name. For monitors of type C(STOREFRONT), C(storename) is an optional argument defining storefront",
            "                service store name. Applicable to C(STOREFRONT) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    storefrontacctservice:",
            "        description:",
            "            - >-",
            "                Enable/Disable probing for Account Service. Applicable only to Store Front monitors. For",
            "                multi-tenancy configuration users my skip account service.",
            "        type: bool",
            "",
            "    hostname:",
            "        description:",
            "            - \"Hostname in the FQDN format (Example: C(porche.cars.org)). Applicable to C(STOREFRONT) monitors.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    netprofile:",
            "        description:",
            "            - \"Name of the network profile.\"",
            "            - \"Minimum length = 1\"",
            "            - \"Maximum length = 127\"",
            "",
            "    originhost:",
            "        description:",
            "            - >-",
            "                Origin-Host value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "            - \"Minimum length = 1\"",
            "",
            "    originrealm:",
            "        description:",
            "            - >-",
            "                Origin-Realm value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "            - \"Minimum length = 1\"",
            "",
            "    hostipaddress:",
            "        description:",
            "            - >-",
            "                Host-IP-Address value for the Capabilities-Exchange-Request (CER) message to use for monitoring",
            "                Diameter servers. If Host-IP-Address is not specified, the appliance inserts the mapped IP (MIP)",
            "                address or subnet IP (SNIP) address from which the CER request (the monitoring probe) is sent.",
            "            - \"Minimum length = 1\"",
            "",
            "    vendorid:",
            "        description:",
            "            - >-",
            "                Vendor-Id value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "",
            "    productname:",
            "        description:",
            "            - >-",
            "                Product-Name value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "            - \"Minimum length = 1\"",
            "",
            "    firmwarerevision:",
            "        description:",
            "            - >-",
            "                Firmware-Revision value for the Capabilities-Exchange-Request (CER) message to use for monitoring",
            "                Diameter servers.",
            "",
            "    authapplicationid:",
            "        description:",
            "            - >-",
            "                List of Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER)",
            "                message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a",
            "                monitoring CER message.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    acctapplicationid:",
            "        description:",
            "            - >-",
            "                List of Acct-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER)",
            "                message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a",
            "                monitoring message.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    inbandsecurityid:",
            "        choices:",
            "            - 'NO_INBAND_SECURITY'",
            "            - 'TLS'",
            "        description:",
            "            - >-",
            "                Inband-Security-Id for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "",
            "    supportedvendorids:",
            "        description:",
            "            - >-",
            "                List of Supported-Vendor-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER)",
            "                message to use for monitoring Diameter servers. A maximum eight of these AVPs are supported in a",
            "                monitoring message.",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    vendorspecificvendorid:",
            "        description:",
            "            - >-",
            "                Vendor-Id to use in the Vendor-Specific-Application-Id grouped attribute-value pair (AVP) in the",
            "                monitoring CER message. To specify Auth-Application-Id or Acct-Application-Id in",
            "                Vendor-Specific-Application-Id, use vendorSpecificAuthApplicationIds or",
            "                vendorSpecificAcctApplicationIds, respectively. Only one Vendor-Id is supported for all the",
            "                Vendor-Specific-Application-Id AVPs in a CER monitoring message.",
            "            - \"Minimum value = 1\"",
            "",
            "    vendorspecificauthapplicationids:",
            "        description:",
            "            - >-",
            "                List of Vendor-Specific-Auth-Application-Id attribute value pairs (AVPs) for the",
            "                Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of",
            "                eight of these AVPs are supported in a monitoring message. The specified value is combined with the",
            "                value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER",
            "                monitoring message.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    vendorspecificacctapplicationids:",
            "        description:",
            "            - >-",
            "                List of Vendor-Specific-Acct-Application-Id attribute value pairs (AVPs) to use for monitoring",
            "                Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The",
            "                specified value is combined with the value of vendorSpecificVendorId to obtain the",
            "                Vendor-Specific-Application-Id AVP in the CER monitoring message.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    kcdaccount:",
            "        description:",
            "            - \"KCD Account used by C(MSSQL) monitor.\"",
            "            - \"Minimum length = 1\"",
            "            - \"Maximum length = 32\"",
            "",
            "    storedb:",
            "        choices:",
            "            - 'enabled'",
            "            - 'disabled'",
            "        description:",
            "            - >-",
            "                Store the database list populated with the responses to monitor probes. Used in database specific",
            "                load balancing if C(MSSQL-ECV)/C(MYSQL-ECV) monitor is configured.",
            "",
            "    storefrontcheckbackendservices:",
            "        description:",
            "            - >-",
            "                This option will enable monitoring of services running on storefront server. Storefront services are",
            "                monitored by probing to a Windows service that runs on the Storefront server and exposes details of",
            "                which storefront services are running.",
            "        type: bool",
            "",
            "    trofscode:",
            "        description:",
            "            - \"Code expected when the server is under maintenance.\"",
            "",
            "    trofsstring:",
            "        description:",
            "            - >-",
            "                String expected from the server for the service to be marked as trofs. Applicable to HTTP-ECV/TCP-ECV",
            "                monitors.",
            "",
            "extends_documentation_fragment: netscaler",
            "requirements:",
            "    - nitro python sdk",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: Set lb monitor",
            "  local_action:",
            "    nsip: 172.18.0.2",
            "    nitro_user: nsroot",
            "    nitro_pass: nsroot",
            "    validate_certs: no",
            "",
            "",
            "    module: netscaler_lb_monitor",
            "    state: present",
            "",
            "    monitorname: monitor_1",
            "    type: HTTP-INLINE",
            "    action: DOWN",
            "    respcode: ['400']",
            "'''",
            "",
            "RETURN = '''",
            "loglines:",
            "    description: list of logged messages by the module",
            "    returned: always",
            "    type: list",
            "    sample: ['message 1', 'message 2']",
            "",
            "msg:",
            "    description: Message detailing the failure reason",
            "    returned: failure",
            "    type: str",
            "    sample: \"Action does not exist\"",
            "",
            "diff:",
            "    description: List of differences between the actual configured object and the configuration specified in the module",
            "    returned: failure",
            "    type: dict",
            "    sample: { 'targetlbvserver': 'difference. ours: (str) server1 other: (str) server2' }",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "from ansible.module_utils.network.netscaler.netscaler import (",
            "    ConfigProxy,",
            "    get_nitro_client,",
            "    netscaler_common_arguments,",
            "    log,",
            "    loglines,",
            "    ensure_feature_is_enabled,",
            "    get_immutables_intersection",
            ")",
            "",
            "try:",
            "    from nssrc.com.citrix.netscaler.nitro.resource.config.lb.lbmonitor import lbmonitor",
            "    from nssrc.com.citrix.netscaler.nitro.exception.nitro_exception import nitro_exception",
            "    PYTHON_SDK_IMPORTED = True",
            "except ImportError as e:",
            "    PYTHON_SDK_IMPORTED = False",
            "",
            "",
            "def lbmonitor_exists(client, module):",
            "    log('Checking if monitor exists')",
            "    if lbmonitor.count_filtered(client, 'monitorname:%s' % module.params['monitorname']) > 0:",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "def lbmonitor_identical(client, module, lbmonitor_proxy):",
            "    log('Checking if monitor is identical')",
            "",
            "    count = lbmonitor.count_filtered(client, 'monitorname:%s' % module.params['monitorname'])",
            "    if count == 0:",
            "        return False",
            "",
            "    lbmonitor_list = lbmonitor.get_filtered(client, 'monitorname:%s' % module.params['monitorname'])",
            "    diff_dict = lbmonitor_proxy.diff_object(lbmonitor_list[0])",
            "",
            "    # Skipping hashed fields since the cannot be compared directly",
            "    hashed_fields = [",
            "        'password',",
            "        'secondarypassword',",
            "        'radkey',",
            "    ]",
            "    for key in hashed_fields:",
            "        if key in diff_dict:",
            "            del diff_dict[key]",
            "",
            "    if diff_dict == {}:",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "def diff_list(client, module, lbmonitor_proxy):",
            "    monitor_list = lbmonitor.get_filtered(client, 'monitorname:%s' % module.params['monitorname'])",
            "    return lbmonitor_proxy.diff_object(monitor_list[0])",
            "",
            "",
            "def main():",
            "",
            "    module_specific_arguments = dict(",
            "",
            "        monitorname=dict(type='str'),",
            "",
            "        type=dict(",
            "            type='str',",
            "            choices=[",
            "                'PING',",
            "                'TCP',",
            "                'HTTP',",
            "                'TCP-ECV',",
            "                'HTTP-ECV',",
            "                'UDP-ECV',",
            "                'DNS',",
            "                'FTP',",
            "                'LDNS-PING',",
            "                'LDNS-TCP',",
            "                'LDNS-DNS',",
            "                'RADIUS',",
            "                'USER',",
            "                'HTTP-INLINE',",
            "                'SIP-UDP',",
            "                'SIP-TCP',",
            "                'LOAD',",
            "                'FTP-EXTENDED',",
            "                'SMTP',",
            "                'SNMP',",
            "                'NNTP',",
            "                'MYSQL',",
            "                'MYSQL-ECV',",
            "                'MSSQL-ECV',",
            "                'ORACLE-ECV',",
            "                'LDAP',",
            "                'POP3',",
            "                'CITRIX-XML-SERVICE',",
            "                'CITRIX-WEB-INTERFACE',",
            "                'DNS-TCP',",
            "                'RTSP',",
            "                'ARP',",
            "                'CITRIX-AG',",
            "                'CITRIX-AAC-LOGINPAGE',",
            "                'CITRIX-AAC-LAS',",
            "                'CITRIX-XD-DDC',",
            "                'ND6',",
            "                'CITRIX-WI-EXTENDED',",
            "                'DIAMETER',",
            "                'RADIUS_ACCOUNTING',",
            "                'STOREFRONT',",
            "                'APPC',",
            "                'SMPP',",
            "                'CITRIX-XNC-ECV',",
            "                'CITRIX-XDM',",
            "                'CITRIX-STA-SERVICE',",
            "                'CITRIX-STA-SERVICE-NHOP',",
            "            ]",
            "        ),",
            "",
            "        action=dict(",
            "            type='str',",
            "            choices=[",
            "                'NONE',",
            "                'LOG',",
            "                'DOWN',",
            "            ]",
            "        ),",
            "        respcode=dict(type='list'),",
            "        httprequest=dict(type='str'),",
            "        rtsprequest=dict(type='str'),",
            "        customheaders=dict(type='str'),",
            "        maxforwards=dict(type='float'),",
            "        sipmethod=dict(",
            "            type='str',",
            "            choices=[",
            "                'OPTIONS',",
            "                'INVITE',",
            "                'REGISTER',",
            "            ]",
            "        ),",
            "        sipuri=dict(type='str'),",
            "        sipreguri=dict(type='str'),",
            "        send=dict(type='str'),",
            "        recv=dict(type='str'),",
            "        query=dict(type='str'),",
            "        querytype=dict(",
            "            type='str',",
            "            choices=[",
            "                'Address',",
            "                'Zone',",
            "                'AAAA',",
            "            ]",
            "        ),",
            "        scriptname=dict(type='str'),",
            "        scriptargs=dict(type='str'),",
            "        dispatcherip=dict(type='str'),",
            "        dispatcherport=dict(type='int'),",
            "        username=dict(type='str'),",
            "        password=dict(type='str'),",
            "        secondarypassword=dict(type='str'),",
            "        logonpointname=dict(type='str'),",
            "        lasversion=dict(type='str'),",
            "        radkey=dict(type='str'),",
            "        radnasid=dict(type='str'),",
            "        radnasip=dict(type='str'),",
            "        radaccounttype=dict(type='float'),",
            "        radframedip=dict(type='str'),",
            "        radapn=dict(type='str'),",
            "        radmsisdn=dict(type='str'),",
            "        radaccountsession=dict(type='str'),",
            "        lrtm=dict(",
            "            type='str',",
            "            choices=[",
            "                'enabled',",
            "                'disabled',",
            "            ]",
            "        ),",
            "        deviation=dict(type='float'),",
            "        units1=dict(",
            "            type='str',",
            "            choices=[",
            "                'SEC',",
            "                'MSEC',",
            "                'MIN',",
            "            ]",
            "        ),",
            "        interval=dict(type='int'),",
            "        units3=dict(",
            "            type='str',",
            "            choices=[",
            "                'SEC',",
            "                'MSEC',",
            "                'MIN',",
            "            ]",
            "        ),",
            "        resptimeout=dict(type='int'),",
            "        units4=dict(",
            "            type='str',",
            "            choices=[",
            "                'SEC',",
            "                'MSEC',",
            "                'MIN',",
            "            ]",
            "        ),",
            "        resptimeoutthresh=dict(type='float'),",
            "        retries=dict(type='int'),",
            "        failureretries=dict(type='int'),",
            "        alertretries=dict(type='int'),",
            "        successretries=dict(type='int'),",
            "        downtime=dict(type='int'),",
            "        units2=dict(",
            "            type='str',",
            "            choices=[",
            "                'SEC',",
            "                'MSEC',",
            "                'MIN',",
            "            ]",
            "        ),",
            "        destip=dict(type='str'),",
            "        destport=dict(type='int'),",
            "        reverse=dict(type='bool'),",
            "        transparent=dict(type='bool'),",
            "        iptunnel=dict(type='bool'),",
            "        tos=dict(type='bool'),",
            "        tosid=dict(type='float'),",
            "        secure=dict(type='bool'),",
            "        validatecred=dict(type='bool'),",
            "        domain=dict(type='str'),",
            "        ipaddress=dict(type='list'),",
            "        group=dict(type='str'),",
            "        filename=dict(type='str'),",
            "        basedn=dict(type='str'),",
            "        binddn=dict(type='str'),",
            "        filter=dict(type='str'),",
            "        attribute=dict(type='str'),",
            "        database=dict(type='str'),",
            "        oraclesid=dict(type='str'),",
            "        sqlquery=dict(type='str'),",
            "        evalrule=dict(type='str'),",
            "        mssqlprotocolversion=dict(",
            "            type='str',",
            "            choices=[",
            "                '70',",
            "                '2000',",
            "                '2000SP1',",
            "                '2005',",
            "                '2008',",
            "                '2008R2',",
            "                '2012',",
            "                '2014',",
            "            ]",
            "        ),",
            "        Snmpoid=dict(type='str'),",
            "        snmpcommunity=dict(type='str'),",
            "        snmpthreshold=dict(type='str'),",
            "        snmpversion=dict(",
            "            type='str',",
            "            choices=[",
            "                'V1',",
            "                'V2',",
            "            ]",
            "        ),",
            "        application=dict(type='str'),",
            "        sitepath=dict(type='str'),",
            "        storename=dict(type='str'),",
            "        storefrontacctservice=dict(type='bool'),",
            "        hostname=dict(type='str'),",
            "        netprofile=dict(type='str'),",
            "        originhost=dict(type='str'),",
            "        originrealm=dict(type='str'),",
            "        hostipaddress=dict(type='str'),",
            "        vendorid=dict(type='float'),",
            "        productname=dict(type='str'),",
            "        firmwarerevision=dict(type='float'),",
            "        authapplicationid=dict(type='list'),",
            "        acctapplicationid=dict(type='list'),",
            "        inbandsecurityid=dict(",
            "            type='str',",
            "            choices=[",
            "                'NO_INBAND_SECURITY',",
            "                'TLS',",
            "            ]",
            "        ),",
            "        supportedvendorids=dict(type='list'),",
            "        vendorspecificvendorid=dict(type='float'),",
            "        vendorspecificauthapplicationids=dict(type='list'),",
            "        vendorspecificacctapplicationids=dict(type='list'),",
            "        storedb=dict(",
            "            type='str',",
            "            choices=[",
            "                'enabled',",
            "                'disabled',",
            "            ]",
            "        ),",
            "        storefrontcheckbackendservices=dict(type='bool'),",
            "        trofscode=dict(type='float'),",
            "        trofsstring=dict(type='str'),",
            "    )",
            "",
            "    hand_inserted_arguments = dict()",
            "",
            "    argument_spec = dict()",
            "    argument_spec.update(module_specific_arguments)",
            "    argument_spec.update(netscaler_common_arguments)",
            "    argument_spec.update(hand_inserted_arguments)",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=argument_spec,",
            "        supports_check_mode=True,",
            "    )",
            "",
            "    module_result = dict(",
            "        changed=False,",
            "        failed=False,",
            "        loglines=loglines,",
            "    )",
            "",
            "    # Fail the module if imports failed",
            "    if not PYTHON_SDK_IMPORTED:",
            "        module.fail_json(msg='Could not load nitro python sdk', **module_result)",
            "",
            "    # Fallthrough to rest of execution",
            "    client = get_nitro_client(module)",
            "",
            "    try:",
            "        client.login()",
            "    except nitro_exception as e:",
            "        msg = \"nitro exception during login. errorcode=%s, message=%s\" % (str(e.errorcode), e.message)",
            "        module.fail_json(msg=msg)",
            "    except Exception as e:",
            "        if str(type(e)) == \"<class 'requests.exceptions.ConnectionError'>\":",
            "            module.fail_json(msg='Connection error %s' % str(e))",
            "        elif str(type(e)) == \"<class 'requests.exceptions.SSLError'>\":",
            "            module.fail_json(msg='SSL Error %s' % str(e))",
            "        else:",
            "            module.fail_json(msg='Unexpected error during login %s' % str(e))",
            "",
            "    # Instantiate lb monitor object",
            "    readwrite_attrs = [",
            "        'monitorname',",
            "        'type',",
            "        'action',",
            "        'respcode',",
            "        'httprequest',",
            "        'rtsprequest',",
            "        'customheaders',",
            "        'maxforwards',",
            "        'sipmethod',",
            "        'sipuri',",
            "        'sipreguri',",
            "        'send',",
            "        'recv',",
            "        'query',",
            "        'querytype',",
            "        'scriptname',",
            "        'scriptargs',",
            "        'dispatcherip',",
            "        'dispatcherport',",
            "        'username',",
            "        'password',",
            "        'secondarypassword',",
            "        'logonpointname',",
            "        'lasversion',",
            "        'radkey',",
            "        'radnasid',",
            "        'radnasip',",
            "        'radaccounttype',",
            "        'radframedip',",
            "        'radapn',",
            "        'radmsisdn',",
            "        'radaccountsession',",
            "        'lrtm',",
            "        'deviation',",
            "        'units1',",
            "        'interval',",
            "        'units3',",
            "        'resptimeout',",
            "        'units4',",
            "        'resptimeoutthresh',",
            "        'retries',",
            "        'failureretries',",
            "        'alertretries',",
            "        'successretries',",
            "        'downtime',",
            "        'units2',",
            "        'destip',",
            "        'destport',",
            "        'reverse',",
            "        'transparent',",
            "        'iptunnel',",
            "        'tos',",
            "        'tosid',",
            "        'secure',",
            "        'validatecred',",
            "        'domain',",
            "        'ipaddress',",
            "        'group',",
            "        'filename',",
            "        'basedn',",
            "        'binddn',",
            "        'filter',",
            "        'attribute',",
            "        'database',",
            "        'oraclesid',",
            "        'sqlquery',",
            "        'evalrule',",
            "        'mssqlprotocolversion',",
            "        'Snmpoid',",
            "        'snmpcommunity',",
            "        'snmpthreshold',",
            "        'snmpversion',",
            "        'application',",
            "        'sitepath',",
            "        'storename',",
            "        'storefrontacctservice',",
            "        'netprofile',",
            "        'originhost',",
            "        'originrealm',",
            "        'hostipaddress',",
            "        'vendorid',",
            "        'productname',",
            "        'firmwarerevision',",
            "        'authapplicationid',",
            "        'acctapplicationid',",
            "        'inbandsecurityid',",
            "        'supportedvendorids',",
            "        'vendorspecificvendorid',",
            "        'vendorspecificauthapplicationids',",
            "        'vendorspecificacctapplicationids',",
            "        'storedb',",
            "        'storefrontcheckbackendservices',",
            "        'trofscode',",
            "        'trofsstring',",
            "    ]",
            "",
            "    readonly_attrs = [",
            "        'lrtmconf',",
            "        'lrtmconfstr',",
            "        'dynamicresponsetimeout',",
            "        'dynamicinterval',",
            "        'multimetrictable',",
            "        'dup_state',",
            "        'dup_weight',",
            "        'weight',",
            "    ]",
            "",
            "    immutable_attrs = [",
            "        'monitorname',",
            "        'type',",
            "        'units1',",
            "        'units3',",
            "        'units4',",
            "        'units2',",
            "        'Snmpoid',",
            "        'hostname',",
            "        'servicename',",
            "        'servicegroupname',",
            "    ]",
            "",
            "    transforms = {",
            "        'storefrontcheckbackendservices': ['bool_yes_no'],",
            "        'secure': ['bool_yes_no'],",
            "        'tos': ['bool_yes_no'],",
            "        'validatecred': ['bool_yes_no'],",
            "        'storefrontacctservice': ['bool_yes_no'],",
            "        'iptunnel': ['bool_yes_no'],",
            "        'transparent': ['bool_yes_no'],",
            "        'reverse': ['bool_yes_no'],",
            "        'lrtm': [lambda v: v.upper()],",
            "        'storedb': [lambda v: v.upper()],",
            "    }",
            "",
            "    lbmonitor_proxy = ConfigProxy(",
            "        actual=lbmonitor(),",
            "        client=client,",
            "        attribute_values_dict=module.params,",
            "        readwrite_attrs=readwrite_attrs,",
            "        readonly_attrs=readonly_attrs,",
            "        immutable_attrs=immutable_attrs,",
            "        transforms=transforms,",
            "    )",
            "",
            "    try:",
            "        ensure_feature_is_enabled(client, 'LB')",
            "",
            "        if module.params['state'] == 'present':",
            "            log('Applying actions for state present')",
            "            if not lbmonitor_exists(client, module):",
            "                if not module.check_mode:",
            "                    log('Adding monitor')",
            "                    lbmonitor_proxy.add()",
            "                    if module.params['save_config']:",
            "                        client.save_config()",
            "                module_result['changed'] = True",
            "            elif not lbmonitor_identical(client, module, lbmonitor_proxy):",
            "",
            "                # Check if we try to change value of immutable attributes",
            "                immutables_changed = get_immutables_intersection(lbmonitor_proxy, diff_list(client, module, lbmonitor_proxy).keys())",
            "                if immutables_changed != []:",
            "                    diff = diff_list(client, module, lbmonitor_proxy)",
            "                    msg = 'Cannot update immutable attributes %s' % (immutables_changed,)",
            "                    module.fail_json(msg=msg, diff=diff, **module_result)",
            "",
            "                if not module.check_mode:",
            "                    log('Updating monitor')",
            "                    lbmonitor_proxy.update()",
            "                    if module.params['save_config']:",
            "                        client.save_config()",
            "                module_result['changed'] = True",
            "            else:",
            "                log('Doing nothing for monitor')",
            "                module_result['changed'] = False",
            "",
            "            # Sanity check for result",
            "            log('Sanity checks for state present')",
            "            if not module.check_mode:",
            "                if not lbmonitor_exists(client, module):",
            "                    module.fail_json(msg='lb monitor does not exist', **module_result)",
            "                if not lbmonitor_identical(client, module, lbmonitor_proxy):",
            "                    module.fail_json(",
            "                        msg='lb monitor is not configured correctly',",
            "                        diff=diff_list(client, module, lbmonitor_proxy),",
            "                        **module_result",
            "                    )",
            "",
            "        elif module.params['state'] == 'absent':",
            "            log('Applying actions for state absent')",
            "            if lbmonitor_exists(client, module):",
            "                if not module.check_mode:",
            "                    lbmonitor_proxy.delete()",
            "                    if module.params['save_config']:",
            "                        client.save_config()",
            "                module_result['changed'] = True",
            "            else:",
            "                module_result['changed'] = False",
            "",
            "            # Sanity check for result",
            "            log('Sanity checks for state absent')",
            "            if not module.check_mode:",
            "                if lbmonitor_exists(client, module):",
            "                    module.fail_json(msg='lb monitor still exists', **module_result)",
            "",
            "        module_result['actual_attributes'] = lbmonitor_proxy.get_actual_rw_attributes(filter='monitorname')",
            "    except nitro_exception as e:",
            "        msg = \"nitro exception errorcode=%s, message=%s\" % (str(e.errorcode), e.message)",
            "        module.fail_json(msg=msg, **module_result)",
            "",
            "    client.logout()",
            "",
            "    module.exit_json(**module_result)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "#  Copyright (c) 2017 Citrix Systems",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "module: netscaler_lb_monitor",
            "short_description: Manage load balancing monitors",
            "description:",
            "    - Manage load balancing monitors.",
            "    - This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance.",
            "",
            "version_added: \"2.4\"",
            "",
            "author: George Nikolopoulos (@giorgos-nikolopoulos)",
            "",
            "options:",
            "",
            "    monitorname:",
            "        description:",
            "            - >-",
            "                Name for the monitor. Must begin with an ASCII alphanumeric or underscore C(_) character, and must",
            "                contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at C(@), equals",
            "                C(=), and hyphen C(-) characters.",
            "            - \"Minimum length = 1\"",
            "",
            "    type:",
            "        choices:",
            "            - 'PING'",
            "            - 'TCP'",
            "            - 'HTTP'",
            "            - 'TCP-ECV'",
            "            - 'HTTP-ECV'",
            "            - 'UDP-ECV'",
            "            - 'DNS'",
            "            - 'FTP'",
            "            - 'LDNS-PING'",
            "            - 'LDNS-TCP'",
            "            - 'LDNS-DNS'",
            "            - 'RADIUS'",
            "            - 'USER'",
            "            - 'HTTP-INLINE'",
            "            - 'SIP-UDP'",
            "            - 'SIP-TCP'",
            "            - 'LOAD'",
            "            - 'FTP-EXTENDED'",
            "            - 'SMTP'",
            "            - 'SNMP'",
            "            - 'NNTP'",
            "            - 'MYSQL'",
            "            - 'MYSQL-ECV'",
            "            - 'MSSQL-ECV'",
            "            - 'ORACLE-ECV'",
            "            - 'LDAP'",
            "            - 'POP3'",
            "            - 'CITRIX-XML-SERVICE'",
            "            - 'CITRIX-WEB-INTERFACE'",
            "            - 'DNS-TCP'",
            "            - 'RTSP'",
            "            - 'ARP'",
            "            - 'CITRIX-AG'",
            "            - 'CITRIX-AAC-LOGINPAGE'",
            "            - 'CITRIX-AAC-LAS'",
            "            - 'CITRIX-XD-DDC'",
            "            - 'ND6'",
            "            - 'CITRIX-WI-EXTENDED'",
            "            - 'DIAMETER'",
            "            - 'RADIUS_ACCOUNTING'",
            "            - 'STOREFRONT'",
            "            - 'APPC'",
            "            - 'SMPP'",
            "            - 'CITRIX-XNC-ECV'",
            "            - 'CITRIX-XDM'",
            "            - 'CITRIX-STA-SERVICE'",
            "            - 'CITRIX-STA-SERVICE-NHOP'",
            "        description:",
            "            - \"Type of monitor that you want to create.\"",
            "",
            "    action:",
            "        choices:",
            "            - 'NONE'",
            "            - 'LOG'",
            "            - 'DOWN'",
            "        description:",
            "            - >-",
            "                Action to perform when the response to an inline monitor (a monitor of type C(HTTP-INLINE)) indicates",
            "                that the service is down. A service monitored by an inline monitor is considered C(DOWN) if the response",
            "                code is not one of the codes that have been specified for the Response Code parameter.",
            "            - \"Available settings function as follows:\"",
            "            - >-",
            "                * C(NONE) - Do not take any action. However, the show service command and the show lb monitor command",
            "                indicate the total number of responses that were checked and the number of consecutive error",
            "                responses received after the last successful probe.",
            "            - \"* C(LOG) - Log the event in NSLOG or SYSLOG.\"",
            "            - >-",
            "                * C(DOWN) - Mark the service as being down, and then do not direct any traffic to the service until the",
            "                configured down time has expired. Persistent connections to the service are terminated as soon as the",
            "                service is marked as C(DOWN). Also, log the event in NSLOG or SYSLOG.",
            "",
            "    respcode:",
            "        description:",
            "            - >-",
            "                Response codes for which to mark the service as UP. For any other response code, the action performed",
            "                depends on the monitor type. C(HTTP) monitors and C(RADIUS) monitors mark the service as C(DOWN), while",
            "                C(HTTP-INLINE) monitors perform the action indicated by the Action parameter.",
            "",
            "    httprequest:",
            "        description:",
            "            - \"HTTP request to send to the server (for example, C(\\\\\"HEAD /file.html\\\\\")).\"",
            "",
            "    rtsprequest:",
            "        description:",
            "            - \"RTSP request to send to the server (for example, C(\\\\\"OPTIONS *\\\\\")).\"",
            "",
            "    customheaders:",
            "        description:",
            "            - \"Custom header string to include in the monitoring probes.\"",
            "",
            "    maxforwards:",
            "        description:",
            "            - >-",
            "                Maximum number of hops that the SIP request used for monitoring can traverse to reach the server.",
            "                Applicable only to monitors of type C(SIP-UDP).",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(255)\"",
            "",
            "    sipmethod:",
            "        choices:",
            "            - 'OPTIONS'",
            "            - 'INVITE'",
            "            - 'REGISTER'",
            "        description:",
            "            - \"SIP method to use for the query. Applicable only to monitors of type C(SIP-UDP).\"",
            "",
            "    sipuri:",
            "        description:",
            "            - >-",
            "                SIP URI string to send to the service (for example, C(sip:sip.test)). Applicable only to monitors of",
            "                type C(SIP-UDP).",
            "            - \"Minimum length = 1\"",
            "",
            "    sipreguri:",
            "        description:",
            "            - >-",
            "                SIP user to be registered. Applicable only if the monitor is of type C(SIP-UDP) and the SIP Method",
            "                parameter is set to C(REGISTER).",
            "            - \"Minimum length = 1\"",
            "",
            "    send:",
            "        description:",
            "            - \"String to send to the service. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.\"",
            "",
            "    recv:",
            "        description:",
            "            - >-",
            "                String expected from the server for the service to be marked as UP. Applicable to C(TCP-ECV), C(HTTP-ECV),",
            "                and C(UDP-ECV) monitors.",
            "",
            "    query:",
            "        description:",
            "            - \"Domain name to resolve as part of monitoring the DNS service (for example, C(example.com)).\"",
            "",
            "    querytype:",
            "        choices:",
            "            - 'Address'",
            "            - 'Zone'",
            "            - 'AAAA'",
            "        description:",
            "            - >-",
            "                Type of DNS record for which to send monitoring queries. Set to C(Address) for querying A records, C(AAAA)",
            "                for querying AAAA records, and C(Zone) for querying the SOA record.",
            "",
            "    scriptname:",
            "        description:",
            "            - >-",
            "                Path and name of the script to execute. The script must be available on the NetScaler appliance, in",
            "                the /nsconfig/monitors/ directory.",
            "            - \"Minimum length = 1\"",
            "",
            "    scriptargs:",
            "        description:",
            "            - \"String of arguments for the script. The string is copied verbatim into the request.\"",
            "",
            "    dispatcherip:",
            "        description:",
            "            - \"IP address of the dispatcher to which to send the probe.\"",
            "",
            "    dispatcherport:",
            "        description:",
            "            - \"Port number on which the dispatcher listens for the monitoring probe.\"",
            "",
            "    username:",
            "        description:",
            "            - >-",
            "                User name with which to probe the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG),",
            "                C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC) or C(CITRIX-XDM) server.",
            "            - \"Minimum length = 1\"",
            "",
            "    password:",
            "        description:",
            "            - >-",
            "                Password that is required for logging on to the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3),",
            "                C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC-ECV) or C(CITRIX-XDM) server. Used in",
            "                conjunction with the user name specified for the C(username) parameter.",
            "            - \"Minimum length = 1\"",
            "",
            "    secondarypassword:",
            "        description:",
            "            - >-",
            "                Secondary password that users might have to provide to log on to the Access Gateway server.",
            "                Applicable to C(CITRIX-AG) monitors.",
            "",
            "    logonpointname:",
            "        description:",
            "            - >-",
            "                Name of the logon point that is configured for the Citrix Access Gateway Advanced Access Control",
            "                software. Required if you want to monitor the associated login page or Logon Agent. Applicable to",
            "                C(CITRIX-AAC-LAS) and C(CITRIX-AAC-LOGINPAGE) monitors.",
            "",
            "    lasversion:",
            "        description:",
            "            - >-",
            "                Version number of the Citrix Advanced Access Control Logon Agent. Required by the C(CITRIX-AAC-LAS)",
            "                monitor.",
            "",
            "    radkey:",
            "        description:",
            "            - >-",
            "                Authentication key (shared secret text string) for RADIUS clients and servers to exchange. Applicable",
            "                to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).",
            "            - \"Minimum length = 1\"",
            "",
            "    radnasid:",
            "        description:",
            "            - \"NAS-Identifier to send in the Access-Request packet. Applicable to monitors of type C(RADIUS).\"",
            "            - \"Minimum length = 1\"",
            "",
            "    radnasip:",
            "        description:",
            "            - >-",
            "                Network Access Server (NAS) IP address to use as the source IP address when monitoring a RADIUS",
            "                server. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).",
            "",
            "    radaccounttype:",
            "        description:",
            "            - \"Account Type to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).\"",
            "            - \"Minimum value = 0\"",
            "            - \"Maximum value = 15\"",
            "",
            "    radframedip:",
            "        description:",
            "            - \"Source ip with which the packet will go out . Applicable to monitors of type C(RADIUS_ACCOUNTING).\"",
            "",
            "    radapn:",
            "        description:",
            "            - >-",
            "                Called Station Id to be used in Account Request Packet. Applicable to monitors of type",
            "                C(RADIUS_ACCOUNTING).",
            "            - \"Minimum length = 1\"",
            "",
            "    radmsisdn:",
            "        description:",
            "            - >-",
            "                Calling Stations Id to be used in Account Request Packet. Applicable to monitors of type",
            "                C(RADIUS_ACCOUNTING).",
            "            - \"Minimum length = 1\"",
            "",
            "    radaccountsession:",
            "        description:",
            "            - >-",
            "                Account Session ID to be used in Account Request Packet. Applicable to monitors of type",
            "                C(RADIUS_ACCOUNTING).",
            "            - \"Minimum length = 1\"",
            "",
            "    lrtm:",
            "        choices:",
            "            - 'enabled'",
            "            - 'disabled'",
            "        description:",
            "            - >-",
            "                Calculate the least response times for bound services. If this parameter is not enabled, the",
            "                appliance does not learn the response times of the bound services. Also used for LRTM load balancing.",
            "",
            "    deviation:",
            "        description:",
            "            - >-",
            "                Time value added to the learned average response time in dynamic response time monitoring (DRTM).",
            "                When a deviation is specified, the appliance learns the average response time of bound services and",
            "                adds the deviation to the average. The final value is then continually adjusted to accommodate",
            "                response time variations over time. Specified in milliseconds, seconds, or minutes.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(20939)\"",
            "",
            "    units1:",
            "        choices:",
            "            - 'SEC'",
            "            - 'MSEC'",
            "            - 'MIN'",
            "        description:",
            "            - \"Unit of measurement for the Deviation parameter. Cannot be changed after the monitor is created.\"",
            "",
            "    interval:",
            "        description:",
            "            - \"Time interval between two successive probes. Must be greater than the value of Response Time-out.\"",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(20940)\"",
            "",
            "    units3:",
            "        choices:",
            "            - 'SEC'",
            "            - 'MSEC'",
            "            - 'MIN'",
            "        description:",
            "            - \"monitor interval units.\"",
            "",
            "    resptimeout:",
            "        description:",
            "            - >-",
            "                Amount of time for which the appliance must wait before it marks a probe as FAILED. Must be less than",
            "                the value specified for the Interval parameter.",
            "            - >-",
            "                Note: For C(UDP-ECV) monitors for which a receive string is not configured, response timeout does not",
            "                apply. For C(UDP-ECV) monitors with no receive string, probe failure is indicated by an ICMP port",
            "                unreachable error received from the service.",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(20939)\"",
            "",
            "    units4:",
            "        choices:",
            "            - 'SEC'",
            "            - 'MSEC'",
            "            - 'MIN'",
            "        description:",
            "            - \"monitor response timeout units.\"",
            "",
            "    resptimeoutthresh:",
            "        description:",
            "            - >-",
            "                Response time threshold, specified as a percentage of the Response Time-out parameter. If the",
            "                response to a monitor probe has not arrived when the threshold is reached, the appliance generates an",
            "                SNMP trap called monRespTimeoutAboveThresh. After the response time returns to a value below the",
            "                threshold, the appliance generates a monRespTimeoutBelowThresh SNMP trap. For the traps to be",
            "                generated, the \"MONITOR-RTO-THRESHOLD\" alarm must also be enabled.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(100)\"",
            "",
            "    retries:",
            "        description:",
            "            - >-",
            "                Maximum number of probes to send to establish the state of a service for which a monitoring probe",
            "                failed.",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(127)\"",
            "",
            "    failureretries:",
            "        description:",
            "            - >-",
            "                Number of retries that must fail, out of the number specified for the Retries parameter, for a",
            "                service to be marked as DOWN. For example, if the Retries parameter is set to 10 and the Failure",
            "                Retries parameter is set to 6, out of the ten probes sent, at least six probes must fail if the",
            "                service is to be marked as DOWN. The default value of 0 means that all the retries must fail if the",
            "                service is to be marked as DOWN.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(32)\"",
            "",
            "    alertretries:",
            "        description:",
            "            - >-",
            "                Number of consecutive probe failures after which the appliance generates an SNMP trap called",
            "                monProbeFailed.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(32)\"",
            "",
            "    successretries:",
            "        description:",
            "            - \"Number of consecutive successful probes required to transition a service's state from DOWN to UP.\"",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(32)\"",
            "",
            "    downtime:",
            "        description:",
            "            - >-",
            "                Time duration for which to wait before probing a service that has been marked as DOWN. Expressed in",
            "                milliseconds, seconds, or minutes.",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(20939)\"",
            "",
            "    units2:",
            "        choices:",
            "            - 'SEC'",
            "            - 'MSEC'",
            "            - 'MIN'",
            "        description:",
            "            - \"Unit of measurement for the Down Time parameter. Cannot be changed after the monitor is created.\"",
            "",
            "    destip:",
            "        description:",
            "            - >-",
            "                IP address of the service to which to send probes. If the parameter is set to 0, the IP address of",
            "                the server to which the monitor is bound is considered the destination IP address.",
            "",
            "    destport:",
            "        description:",
            "            - >-",
            "                TCP or UDP port to which to send the probe. If the parameter is set to 0, the port number of the",
            "                service to which the monitor is bound is considered the destination port. For a monitor of type C(USER),",
            "                however, the destination port is the port number that is included in the HTTP request sent to the",
            "                dispatcher. Does not apply to monitors of type C(PING).",
            "",
            "    state:",
            "        choices:",
            "            - 'enabled'",
            "            - 'disabled'",
            "        description:",
            "            - >-",
            "                State of the monitor. The C(disabled) setting disables not only the monitor being configured, but all",
            "                monitors of the same type, until the parameter is set to C(enabled). If the monitor is bound to a",
            "                service, the state of the monitor is not taken into account when the state of the service is",
            "                determined.",
            "",
            "    reverse:",
            "        description:",
            "            - >-",
            "                Mark a service as DOWN, instead of UP, when probe criteria are satisfied, and as UP instead of DOWN",
            "                when probe criteria are not satisfied.",
            "        type: bool",
            "",
            "    transparent:",
            "        description:",
            "            - >-",
            "                The monitor is bound to a transparent device such as a firewall or router. The state of a transparent",
            "                device depends on the responsiveness of the services behind it. If a transparent device is being",
            "                monitored, a destination IP address must be specified. The probe is sent to the specified IP address",
            "                by using the MAC address of the transparent device.",
            "        type: bool",
            "",
            "    iptunnel:",
            "        description:",
            "            - >-",
            "                Send the monitoring probe to the service through an IP tunnel. A destination IP address must be",
            "                specified.",
            "        type: bool",
            "",
            "    tos:",
            "        description:",
            "            - \"Probe the service by encoding the destination IP address in the IP TOS (6) bits.\"",
            "        type: bool",
            "",
            "    tosid:",
            "        description:",
            "            - \"The TOS ID of the specified destination IP. Applicable only when the TOS parameter is set.\"",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(63)\"",
            "",
            "    secure:",
            "        description:",
            "            - >-",
            "                Use a secure SSL connection when monitoring a service. Applicable only to TCP based monitors. The",
            "                secure option cannot be used with a C(CITRIX-AG) monitor, because a CITRIX-AG monitor uses a secure",
            "                connection by default.",
            "        type: bool",
            "",
            "    validatecred:",
            "        description:",
            "            - >-",
            "                Validate the credentials of the Xen Desktop DDC server user. Applicable to monitors of type",
            "                C(CITRIX-XD-DDC).",
            "        type: bool",
            "",
            "    domain:",
            "        description:",
            "            - >-",
            "                Domain in which the XenDesktop Desktop Delivery Controller (DDC) servers or Web Interface servers are",
            "                present. Required by C(CITRIX-XD-DDC) and C(CITRIX-WI-EXTENDED) monitors for logging on to the DDC servers",
            "                and Web Interface servers, respectively.",
            "",
            "    ipaddress:",
            "        description:",
            "            - >-",
            "                Set of IP addresses expected in the monitoring response from the DNS server, if the record type is A",
            "                or AAAA. Applicable to C(DNS) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    group:",
            "        description:",
            "            - >-",
            "                Name of a newsgroup available on the NNTP service that is to be monitored. The appliance periodically",
            "                generates an NNTP query for the name of the newsgroup and evaluates the response. If the newsgroup is",
            "                found on the server, the service is marked as UP. If the newsgroup does not exist or if the search",
            "                fails, the service is marked as DOWN. Applicable to NNTP monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    filename:",
            "        description:",
            "            - >-",
            "                Name of a file on the FTP server. The appliance monitors the FTP service by periodically checking the",
            "                existence of the file on the server. Applicable to C(FTP-EXTENDED) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    basedn:",
            "        description:",
            "            - >-",
            "                The base distinguished name of the LDAP service, from where the LDAP server can begin the search for",
            "                the attributes in the monitoring query. Required for C(LDAP) service monitoring.",
            "            - \"Minimum length = 1\"",
            "",
            "    binddn:",
            "        description:",
            "            - >-",
            "                The distinguished name with which an LDAP monitor can perform the Bind operation on the LDAP server.",
            "                Optional. Applicable to C(LDAP) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    filter:",
            "        description:",
            "            - \"Filter criteria for the LDAP query. Optional.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    attribute:",
            "        description:",
            "            - >-",
            "                Attribute to evaluate when the LDAP server responds to the query. Success or failure of the",
            "                monitoring probe depends on whether the attribute exists in the response. Optional.",
            "            - \"Minimum length = 1\"",
            "",
            "    database:",
            "        description:",
            "            - \"Name of the database to connect to during authentication.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    oraclesid:",
            "        description:",
            "            - \"Name of the service identifier that is used to connect to the Oracle database during authentication.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    sqlquery:",
            "        description:",
            "            - >-",
            "                SQL query for a C(MYSQL-ECV) or C(MSSQL-ECV) monitor. Sent to the database server after the server",
            "                authenticates the connection.",
            "            - \"Minimum length = 1\"",
            "",
            "    evalrule:",
            "        description:",
            "            - >-",
            "                Default syntax expression that evaluates the database server's response to a MYSQL-ECV or MSSQL-ECV",
            "                monitoring query. Must produce a Boolean result. The result determines the state of the server. If",
            "                the expression returns TRUE, the probe succeeds.",
            "            - >-",
            "                For example, if you want the appliance to evaluate the error message to determine the state of the",
            "                server, use the rule C(MYSQL.RES.ROW(10) .TEXT_ELEM(2).EQ(\"MySQL\")).",
            "",
            "    mssqlprotocolversion:",
            "        choices:",
            "            - '70'",
            "            - '2000'",
            "            - '2000SP1'",
            "            - '2005'",
            "            - '2008'",
            "            - '2008R2'",
            "            - '2012'",
            "            - '2014'",
            "        description:",
            "            - \"Version of MSSQL server that is to be monitored.\"",
            "",
            "    Snmpoid:",
            "        description:",
            "            - \"SNMP OID for C(SNMP) monitors.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    snmpcommunity:",
            "        description:",
            "            - \"Community name for C(SNMP) monitors.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    snmpthreshold:",
            "        description:",
            "            - \"Threshold for C(SNMP) monitors.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    snmpversion:",
            "        choices:",
            "            - 'V1'",
            "            - 'V2'",
            "        description:",
            "            - \"SNMP version to be used for C(SNMP) monitors.\"",
            "",
            "    metrictable:",
            "        description:",
            "            - \"Metric table to which to bind metrics.\"",
            "            - \"Minimum length = 1\"",
            "            - \"Maximum length = 99\"",
            "",
            "    application:",
            "        description:",
            "            - >-",
            "                Name of the application used to determine the state of the service. Applicable to monitors of type",
            "                C(CITRIX-XML-SERVICE).",
            "            - \"Minimum length = 1\"",
            "",
            "    sitepath:",
            "        description:",
            "            - >-",
            "                URL of the logon page. For monitors of type C(CITRIX-WEB-INTERFACE), to monitor a dynamic page under the",
            "                site path, terminate the site path with a slash C(/). Applicable to C(CITRIX-WEB-INTERFACE),",
            "                C(CITRIX-WI-EXTENDED) and C(CITRIX-XDM) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    storename:",
            "        description:",
            "            - >-",
            "                Store Name. For monitors of type C(STOREFRONT), C(storename) is an optional argument defining storefront",
            "                service store name. Applicable to C(STOREFRONT) monitors.",
            "            - \"Minimum length = 1\"",
            "",
            "    storefrontacctservice:",
            "        description:",
            "            - >-",
            "                Enable/Disable probing for Account Service. Applicable only to Store Front monitors. For",
            "                multi-tenancy configuration users my skip account service.",
            "        type: bool",
            "",
            "    hostname:",
            "        description:",
            "            - \"Hostname in the FQDN format (Example: C(porche.cars.org)). Applicable to C(STOREFRONT) monitors.\"",
            "            - \"Minimum length = 1\"",
            "",
            "    netprofile:",
            "        description:",
            "            - \"Name of the network profile.\"",
            "            - \"Minimum length = 1\"",
            "            - \"Maximum length = 127\"",
            "",
            "    originhost:",
            "        description:",
            "            - >-",
            "                Origin-Host value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "            - \"Minimum length = 1\"",
            "",
            "    originrealm:",
            "        description:",
            "            - >-",
            "                Origin-Realm value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "            - \"Minimum length = 1\"",
            "",
            "    hostipaddress:",
            "        description:",
            "            - >-",
            "                Host-IP-Address value for the Capabilities-Exchange-Request (CER) message to use for monitoring",
            "                Diameter servers. If Host-IP-Address is not specified, the appliance inserts the mapped IP (MIP)",
            "                address or subnet IP (SNIP) address from which the CER request (the monitoring probe) is sent.",
            "            - \"Minimum length = 1\"",
            "",
            "    vendorid:",
            "        description:",
            "            - >-",
            "                Vendor-Id value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "",
            "    productname:",
            "        description:",
            "            - >-",
            "                Product-Name value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "            - \"Minimum length = 1\"",
            "",
            "    firmwarerevision:",
            "        description:",
            "            - >-",
            "                Firmware-Revision value for the Capabilities-Exchange-Request (CER) message to use for monitoring",
            "                Diameter servers.",
            "",
            "    authapplicationid:",
            "        description:",
            "            - >-",
            "                List of Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER)",
            "                message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a",
            "                monitoring CER message.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    acctapplicationid:",
            "        description:",
            "            - >-",
            "                List of Acct-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER)",
            "                message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a",
            "                monitoring message.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    inbandsecurityid:",
            "        choices:",
            "            - 'NO_INBAND_SECURITY'",
            "            - 'TLS'",
            "        description:",
            "            - >-",
            "                Inband-Security-Id for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter",
            "                servers.",
            "",
            "    supportedvendorids:",
            "        description:",
            "            - >-",
            "                List of Supported-Vendor-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER)",
            "                message to use for monitoring Diameter servers. A maximum eight of these AVPs are supported in a",
            "                monitoring message.",
            "            - \"Minimum value = C(1)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    vendorspecificvendorid:",
            "        description:",
            "            - >-",
            "                Vendor-Id to use in the Vendor-Specific-Application-Id grouped attribute-value pair (AVP) in the",
            "                monitoring CER message. To specify Auth-Application-Id or Acct-Application-Id in",
            "                Vendor-Specific-Application-Id, use vendorSpecificAuthApplicationIds or",
            "                vendorSpecificAcctApplicationIds, respectively. Only one Vendor-Id is supported for all the",
            "                Vendor-Specific-Application-Id AVPs in a CER monitoring message.",
            "            - \"Minimum value = 1\"",
            "",
            "    vendorspecificauthapplicationids:",
            "        description:",
            "            - >-",
            "                List of Vendor-Specific-Auth-Application-Id attribute value pairs (AVPs) for the",
            "                Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of",
            "                eight of these AVPs are supported in a monitoring message. The specified value is combined with the",
            "                value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER",
            "                monitoring message.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    vendorspecificacctapplicationids:",
            "        description:",
            "            - >-",
            "                List of Vendor-Specific-Acct-Application-Id attribute value pairs (AVPs) to use for monitoring",
            "                Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The",
            "                specified value is combined with the value of vendorSpecificVendorId to obtain the",
            "                Vendor-Specific-Application-Id AVP in the CER monitoring message.",
            "            - \"Minimum value = C(0)\"",
            "            - \"Maximum value = C(4294967295)\"",
            "",
            "    kcdaccount:",
            "        description:",
            "            - \"KCD Account used by C(MSSQL) monitor.\"",
            "            - \"Minimum length = 1\"",
            "            - \"Maximum length = 32\"",
            "",
            "    storedb:",
            "        choices:",
            "            - 'enabled'",
            "            - 'disabled'",
            "        description:",
            "            - >-",
            "                Store the database list populated with the responses to monitor probes. Used in database specific",
            "                load balancing if C(MSSQL-ECV)/C(MYSQL-ECV) monitor is configured.",
            "",
            "    storefrontcheckbackendservices:",
            "        description:",
            "            - >-",
            "                This option will enable monitoring of services running on storefront server. Storefront services are",
            "                monitored by probing to a Windows service that runs on the Storefront server and exposes details of",
            "                which storefront services are running.",
            "        type: bool",
            "",
            "    trofscode:",
            "        description:",
            "            - \"Code expected when the server is under maintenance.\"",
            "",
            "    trofsstring:",
            "        description:",
            "            - >-",
            "                String expected from the server for the service to be marked as trofs. Applicable to HTTP-ECV/TCP-ECV",
            "                monitors.",
            "",
            "extends_documentation_fragment: netscaler",
            "requirements:",
            "    - nitro python sdk",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: Set lb monitor",
            "  local_action:",
            "    nsip: 172.18.0.2",
            "    nitro_user: nsroot",
            "    nitro_pass: nsroot",
            "    validate_certs: no",
            "",
            "",
            "    module: netscaler_lb_monitor",
            "    state: present",
            "",
            "    monitorname: monitor_1",
            "    type: HTTP-INLINE",
            "    action: DOWN",
            "    respcode: ['400']",
            "'''",
            "",
            "RETURN = '''",
            "loglines:",
            "    description: list of logged messages by the module",
            "    returned: always",
            "    type: list",
            "    sample: ['message 1', 'message 2']",
            "",
            "msg:",
            "    description: Message detailing the failure reason",
            "    returned: failure",
            "    type: str",
            "    sample: \"Action does not exist\"",
            "",
            "diff:",
            "    description: List of differences between the actual configured object and the configuration specified in the module",
            "    returned: failure",
            "    type: dict",
            "    sample: { 'targetlbvserver': 'difference. ours: (str) server1 other: (str) server2' }",
            "'''",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "from ansible.module_utils.network.netscaler.netscaler import (",
            "    ConfigProxy,",
            "    get_nitro_client,",
            "    netscaler_common_arguments,",
            "    log,",
            "    loglines,",
            "    ensure_feature_is_enabled,",
            "    get_immutables_intersection",
            ")",
            "",
            "try:",
            "    from nssrc.com.citrix.netscaler.nitro.resource.config.lb.lbmonitor import lbmonitor",
            "    from nssrc.com.citrix.netscaler.nitro.exception.nitro_exception import nitro_exception",
            "    PYTHON_SDK_IMPORTED = True",
            "except ImportError as e:",
            "    PYTHON_SDK_IMPORTED = False",
            "",
            "",
            "def lbmonitor_exists(client, module):",
            "    log('Checking if monitor exists')",
            "    if lbmonitor.count_filtered(client, 'monitorname:%s' % module.params['monitorname']) > 0:",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "def lbmonitor_identical(client, module, lbmonitor_proxy):",
            "    log('Checking if monitor is identical')",
            "",
            "    count = lbmonitor.count_filtered(client, 'monitorname:%s' % module.params['monitorname'])",
            "    if count == 0:",
            "        return False",
            "",
            "    lbmonitor_list = lbmonitor.get_filtered(client, 'monitorname:%s' % module.params['monitorname'])",
            "    diff_dict = lbmonitor_proxy.diff_object(lbmonitor_list[0])",
            "",
            "    # Skipping hashed fields since the cannot be compared directly",
            "    hashed_fields = [",
            "        'password',",
            "        'secondarypassword',",
            "        'radkey',",
            "    ]",
            "    for key in hashed_fields:",
            "        if key in diff_dict:",
            "            del diff_dict[key]",
            "",
            "    if diff_dict == {}:",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "def diff_list(client, module, lbmonitor_proxy):",
            "    monitor_list = lbmonitor.get_filtered(client, 'monitorname:%s' % module.params['monitorname'])",
            "    return lbmonitor_proxy.diff_object(monitor_list[0])",
            "",
            "",
            "def main():",
            "",
            "    module_specific_arguments = dict(",
            "",
            "        monitorname=dict(type='str'),",
            "",
            "        type=dict(",
            "            type='str',",
            "            choices=[",
            "                'PING',",
            "                'TCP',",
            "                'HTTP',",
            "                'TCP-ECV',",
            "                'HTTP-ECV',",
            "                'UDP-ECV',",
            "                'DNS',",
            "                'FTP',",
            "                'LDNS-PING',",
            "                'LDNS-TCP',",
            "                'LDNS-DNS',",
            "                'RADIUS',",
            "                'USER',",
            "                'HTTP-INLINE',",
            "                'SIP-UDP',",
            "                'SIP-TCP',",
            "                'LOAD',",
            "                'FTP-EXTENDED',",
            "                'SMTP',",
            "                'SNMP',",
            "                'NNTP',",
            "                'MYSQL',",
            "                'MYSQL-ECV',",
            "                'MSSQL-ECV',",
            "                'ORACLE-ECV',",
            "                'LDAP',",
            "                'POP3',",
            "                'CITRIX-XML-SERVICE',",
            "                'CITRIX-WEB-INTERFACE',",
            "                'DNS-TCP',",
            "                'RTSP',",
            "                'ARP',",
            "                'CITRIX-AG',",
            "                'CITRIX-AAC-LOGINPAGE',",
            "                'CITRIX-AAC-LAS',",
            "                'CITRIX-XD-DDC',",
            "                'ND6',",
            "                'CITRIX-WI-EXTENDED',",
            "                'DIAMETER',",
            "                'RADIUS_ACCOUNTING',",
            "                'STOREFRONT',",
            "                'APPC',",
            "                'SMPP',",
            "                'CITRIX-XNC-ECV',",
            "                'CITRIX-XDM',",
            "                'CITRIX-STA-SERVICE',",
            "                'CITRIX-STA-SERVICE-NHOP',",
            "            ]",
            "        ),",
            "",
            "        action=dict(",
            "            type='str',",
            "            choices=[",
            "                'NONE',",
            "                'LOG',",
            "                'DOWN',",
            "            ]",
            "        ),",
            "        respcode=dict(type='list'),",
            "        httprequest=dict(type='str'),",
            "        rtsprequest=dict(type='str'),",
            "        customheaders=dict(type='str'),",
            "        maxforwards=dict(type='float'),",
            "        sipmethod=dict(",
            "            type='str',",
            "            choices=[",
            "                'OPTIONS',",
            "                'INVITE',",
            "                'REGISTER',",
            "            ]",
            "        ),",
            "        sipuri=dict(type='str'),",
            "        sipreguri=dict(type='str'),",
            "        send=dict(type='str'),",
            "        recv=dict(type='str'),",
            "        query=dict(type='str'),",
            "        querytype=dict(",
            "            type='str',",
            "            choices=[",
            "                'Address',",
            "                'Zone',",
            "                'AAAA',",
            "            ]",
            "        ),",
            "        scriptname=dict(type='str'),",
            "        scriptargs=dict(type='str'),",
            "        dispatcherip=dict(type='str'),",
            "        dispatcherport=dict(type='int'),",
            "        username=dict(type='str'),",
            "        password=dict(type='str'),",
            "        secondarypassword=dict(type='str'),",
            "        logonpointname=dict(type='str'),",
            "        lasversion=dict(type='str'),",
            "        radkey=dict(type='str', no_log=True),",
            "        radnasid=dict(type='str'),",
            "        radnasip=dict(type='str'),",
            "        radaccounttype=dict(type='float'),",
            "        radframedip=dict(type='str'),",
            "        radapn=dict(type='str'),",
            "        radmsisdn=dict(type='str'),",
            "        radaccountsession=dict(type='str'),",
            "        lrtm=dict(",
            "            type='str',",
            "            choices=[",
            "                'enabled',",
            "                'disabled',",
            "            ]",
            "        ),",
            "        deviation=dict(type='float'),",
            "        units1=dict(",
            "            type='str',",
            "            choices=[",
            "                'SEC',",
            "                'MSEC',",
            "                'MIN',",
            "            ]",
            "        ),",
            "        interval=dict(type='int'),",
            "        units3=dict(",
            "            type='str',",
            "            choices=[",
            "                'SEC',",
            "                'MSEC',",
            "                'MIN',",
            "            ]",
            "        ),",
            "        resptimeout=dict(type='int'),",
            "        units4=dict(",
            "            type='str',",
            "            choices=[",
            "                'SEC',",
            "                'MSEC',",
            "                'MIN',",
            "            ]",
            "        ),",
            "        resptimeoutthresh=dict(type='float'),",
            "        retries=dict(type='int'),",
            "        failureretries=dict(type='int'),",
            "        alertretries=dict(type='int'),",
            "        successretries=dict(type='int'),",
            "        downtime=dict(type='int'),",
            "        units2=dict(",
            "            type='str',",
            "            choices=[",
            "                'SEC',",
            "                'MSEC',",
            "                'MIN',",
            "            ]",
            "        ),",
            "        destip=dict(type='str'),",
            "        destport=dict(type='int'),",
            "        reverse=dict(type='bool'),",
            "        transparent=dict(type='bool'),",
            "        iptunnel=dict(type='bool'),",
            "        tos=dict(type='bool'),",
            "        tosid=dict(type='float'),",
            "        secure=dict(type='bool'),",
            "        validatecred=dict(type='bool'),",
            "        domain=dict(type='str'),",
            "        ipaddress=dict(type='list'),",
            "        group=dict(type='str'),",
            "        filename=dict(type='str'),",
            "        basedn=dict(type='str'),",
            "        binddn=dict(type='str'),",
            "        filter=dict(type='str'),",
            "        attribute=dict(type='str'),",
            "        database=dict(type='str'),",
            "        oraclesid=dict(type='str'),",
            "        sqlquery=dict(type='str'),",
            "        evalrule=dict(type='str'),",
            "        mssqlprotocolversion=dict(",
            "            type='str',",
            "            choices=[",
            "                '70',",
            "                '2000',",
            "                '2000SP1',",
            "                '2005',",
            "                '2008',",
            "                '2008R2',",
            "                '2012',",
            "                '2014',",
            "            ]",
            "        ),",
            "        Snmpoid=dict(type='str'),",
            "        snmpcommunity=dict(type='str'),",
            "        snmpthreshold=dict(type='str'),",
            "        snmpversion=dict(",
            "            type='str',",
            "            choices=[",
            "                'V1',",
            "                'V2',",
            "            ]",
            "        ),",
            "        application=dict(type='str'),",
            "        sitepath=dict(type='str'),",
            "        storename=dict(type='str'),",
            "        storefrontacctservice=dict(type='bool'),",
            "        hostname=dict(type='str'),",
            "        netprofile=dict(type='str'),",
            "        originhost=dict(type='str'),",
            "        originrealm=dict(type='str'),",
            "        hostipaddress=dict(type='str'),",
            "        vendorid=dict(type='float'),",
            "        productname=dict(type='str'),",
            "        firmwarerevision=dict(type='float'),",
            "        authapplicationid=dict(type='list'),",
            "        acctapplicationid=dict(type='list'),",
            "        inbandsecurityid=dict(",
            "            type='str',",
            "            choices=[",
            "                'NO_INBAND_SECURITY',",
            "                'TLS',",
            "            ]",
            "        ),",
            "        supportedvendorids=dict(type='list'),",
            "        vendorspecificvendorid=dict(type='float'),",
            "        vendorspecificauthapplicationids=dict(type='list'),",
            "        vendorspecificacctapplicationids=dict(type='list'),",
            "        storedb=dict(",
            "            type='str',",
            "            choices=[",
            "                'enabled',",
            "                'disabled',",
            "            ]",
            "        ),",
            "        storefrontcheckbackendservices=dict(type='bool'),",
            "        trofscode=dict(type='float'),",
            "        trofsstring=dict(type='str'),",
            "    )",
            "",
            "    hand_inserted_arguments = dict()",
            "",
            "    argument_spec = dict()",
            "    argument_spec.update(module_specific_arguments)",
            "    argument_spec.update(netscaler_common_arguments)",
            "    argument_spec.update(hand_inserted_arguments)",
            "",
            "    module = AnsibleModule(",
            "        argument_spec=argument_spec,",
            "        supports_check_mode=True,",
            "    )",
            "",
            "    module_result = dict(",
            "        changed=False,",
            "        failed=False,",
            "        loglines=loglines,",
            "    )",
            "",
            "    # Fail the module if imports failed",
            "    if not PYTHON_SDK_IMPORTED:",
            "        module.fail_json(msg='Could not load nitro python sdk', **module_result)",
            "",
            "    # Fallthrough to rest of execution",
            "    client = get_nitro_client(module)",
            "",
            "    try:",
            "        client.login()",
            "    except nitro_exception as e:",
            "        msg = \"nitro exception during login. errorcode=%s, message=%s\" % (str(e.errorcode), e.message)",
            "        module.fail_json(msg=msg)",
            "    except Exception as e:",
            "        if str(type(e)) == \"<class 'requests.exceptions.ConnectionError'>\":",
            "            module.fail_json(msg='Connection error %s' % str(e))",
            "        elif str(type(e)) == \"<class 'requests.exceptions.SSLError'>\":",
            "            module.fail_json(msg='SSL Error %s' % str(e))",
            "        else:",
            "            module.fail_json(msg='Unexpected error during login %s' % str(e))",
            "",
            "    # Instantiate lb monitor object",
            "    readwrite_attrs = [",
            "        'monitorname',",
            "        'type',",
            "        'action',",
            "        'respcode',",
            "        'httprequest',",
            "        'rtsprequest',",
            "        'customheaders',",
            "        'maxforwards',",
            "        'sipmethod',",
            "        'sipuri',",
            "        'sipreguri',",
            "        'send',",
            "        'recv',",
            "        'query',",
            "        'querytype',",
            "        'scriptname',",
            "        'scriptargs',",
            "        'dispatcherip',",
            "        'dispatcherport',",
            "        'username',",
            "        'password',",
            "        'secondarypassword',",
            "        'logonpointname',",
            "        'lasversion',",
            "        'radkey',",
            "        'radnasid',",
            "        'radnasip',",
            "        'radaccounttype',",
            "        'radframedip',",
            "        'radapn',",
            "        'radmsisdn',",
            "        'radaccountsession',",
            "        'lrtm',",
            "        'deviation',",
            "        'units1',",
            "        'interval',",
            "        'units3',",
            "        'resptimeout',",
            "        'units4',",
            "        'resptimeoutthresh',",
            "        'retries',",
            "        'failureretries',",
            "        'alertretries',",
            "        'successretries',",
            "        'downtime',",
            "        'units2',",
            "        'destip',",
            "        'destport',",
            "        'reverse',",
            "        'transparent',",
            "        'iptunnel',",
            "        'tos',",
            "        'tosid',",
            "        'secure',",
            "        'validatecred',",
            "        'domain',",
            "        'ipaddress',",
            "        'group',",
            "        'filename',",
            "        'basedn',",
            "        'binddn',",
            "        'filter',",
            "        'attribute',",
            "        'database',",
            "        'oraclesid',",
            "        'sqlquery',",
            "        'evalrule',",
            "        'mssqlprotocolversion',",
            "        'Snmpoid',",
            "        'snmpcommunity',",
            "        'snmpthreshold',",
            "        'snmpversion',",
            "        'application',",
            "        'sitepath',",
            "        'storename',",
            "        'storefrontacctservice',",
            "        'netprofile',",
            "        'originhost',",
            "        'originrealm',",
            "        'hostipaddress',",
            "        'vendorid',",
            "        'productname',",
            "        'firmwarerevision',",
            "        'authapplicationid',",
            "        'acctapplicationid',",
            "        'inbandsecurityid',",
            "        'supportedvendorids',",
            "        'vendorspecificvendorid',",
            "        'vendorspecificauthapplicationids',",
            "        'vendorspecificacctapplicationids',",
            "        'storedb',",
            "        'storefrontcheckbackendservices',",
            "        'trofscode',",
            "        'trofsstring',",
            "    ]",
            "",
            "    readonly_attrs = [",
            "        'lrtmconf',",
            "        'lrtmconfstr',",
            "        'dynamicresponsetimeout',",
            "        'dynamicinterval',",
            "        'multimetrictable',",
            "        'dup_state',",
            "        'dup_weight',",
            "        'weight',",
            "    ]",
            "",
            "    immutable_attrs = [",
            "        'monitorname',",
            "        'type',",
            "        'units1',",
            "        'units3',",
            "        'units4',",
            "        'units2',",
            "        'Snmpoid',",
            "        'hostname',",
            "        'servicename',",
            "        'servicegroupname',",
            "    ]",
            "",
            "    transforms = {",
            "        'storefrontcheckbackendservices': ['bool_yes_no'],",
            "        'secure': ['bool_yes_no'],",
            "        'tos': ['bool_yes_no'],",
            "        'validatecred': ['bool_yes_no'],",
            "        'storefrontacctservice': ['bool_yes_no'],",
            "        'iptunnel': ['bool_yes_no'],",
            "        'transparent': ['bool_yes_no'],",
            "        'reverse': ['bool_yes_no'],",
            "        'lrtm': [lambda v: v.upper()],",
            "        'storedb': [lambda v: v.upper()],",
            "    }",
            "",
            "    lbmonitor_proxy = ConfigProxy(",
            "        actual=lbmonitor(),",
            "        client=client,",
            "        attribute_values_dict=module.params,",
            "        readwrite_attrs=readwrite_attrs,",
            "        readonly_attrs=readonly_attrs,",
            "        immutable_attrs=immutable_attrs,",
            "        transforms=transforms,",
            "    )",
            "",
            "    try:",
            "        ensure_feature_is_enabled(client, 'LB')",
            "",
            "        if module.params['state'] == 'present':",
            "            log('Applying actions for state present')",
            "            if not lbmonitor_exists(client, module):",
            "                if not module.check_mode:",
            "                    log('Adding monitor')",
            "                    lbmonitor_proxy.add()",
            "                    if module.params['save_config']:",
            "                        client.save_config()",
            "                module_result['changed'] = True",
            "            elif not lbmonitor_identical(client, module, lbmonitor_proxy):",
            "",
            "                # Check if we try to change value of immutable attributes",
            "                immutables_changed = get_immutables_intersection(lbmonitor_proxy, diff_list(client, module, lbmonitor_proxy).keys())",
            "                if immutables_changed != []:",
            "                    diff = diff_list(client, module, lbmonitor_proxy)",
            "                    msg = 'Cannot update immutable attributes %s' % (immutables_changed,)",
            "                    module.fail_json(msg=msg, diff=diff, **module_result)",
            "",
            "                if not module.check_mode:",
            "                    log('Updating monitor')",
            "                    lbmonitor_proxy.update()",
            "                    if module.params['save_config']:",
            "                        client.save_config()",
            "                module_result['changed'] = True",
            "            else:",
            "                log('Doing nothing for monitor')",
            "                module_result['changed'] = False",
            "",
            "            # Sanity check for result",
            "            log('Sanity checks for state present')",
            "            if not module.check_mode:",
            "                if not lbmonitor_exists(client, module):",
            "                    module.fail_json(msg='lb monitor does not exist', **module_result)",
            "                if not lbmonitor_identical(client, module, lbmonitor_proxy):",
            "                    module.fail_json(",
            "                        msg='lb monitor is not configured correctly',",
            "                        diff=diff_list(client, module, lbmonitor_proxy),",
            "                        **module_result",
            "                    )",
            "",
            "        elif module.params['state'] == 'absent':",
            "            log('Applying actions for state absent')",
            "            if lbmonitor_exists(client, module):",
            "                if not module.check_mode:",
            "                    lbmonitor_proxy.delete()",
            "                    if module.params['save_config']:",
            "                        client.save_config()",
            "                module_result['changed'] = True",
            "            else:",
            "                module_result['changed'] = False",
            "",
            "            # Sanity check for result",
            "            log('Sanity checks for state absent')",
            "            if not module.check_mode:",
            "                if lbmonitor_exists(client, module):",
            "                    module.fail_json(msg='lb monitor still exists', **module_result)",
            "",
            "        module_result['actual_attributes'] = lbmonitor_proxy.get_actual_rw_attributes(filter='monitorname')",
            "    except nitro_exception as e:",
            "        msg = \"nitro exception errorcode=%s, message=%s\" % (str(e.errorcode), e.message)",
            "        module.fail_json(msg=msg, **module_result)",
            "",
            "    client.logout()",
            "",
            "    module.exit_json(**module_result)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "989": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/nxos/nxos_aaa_server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " def main():"
            },
            "1": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "     argument_spec = dict("
            },
            "2": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         server_type=dict(type='str', choices=['radius', 'tacacs'], required=True),"
            },
            "3": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        global_key=dict(type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        global_key=dict(type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         encrypt_type=dict(type='str', choices=['0', '7']),"
            },
            "6": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         deadtime=dict(type='str'),"
            },
            "7": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         server_timeout=dict(type='str'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'network'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "",
            "module: nxos_aaa_server",
            "extends_documentation_fragment: nxos",
            "version_added: \"2.2\"",
            "short_description: Manages AAA server global configuration.",
            "description:",
            "    - Manages AAA server global configuration",
            "author:",
            "    - Jason Edelman (@jedelman8)",
            "notes:",
            "    - Tested against NXOSv 7.3.(0)D1(1) on VIRL",
            "    - The server_type parameter is always required.",
            "    - If encrypt_type is not supplied, the global AAA server key will be",
            "      stored as encrypted (type 7).",
            "    - Changes to the global AAA server key with encrypt_type=0",
            "      are not idempotent.",
            "    - state=default will set the supplied parameters to their default values.",
            "      The parameters that you want to default must also be set to default.",
            "      If global_key=default, the global key will be removed.",
            "options:",
            "    server_type:",
            "        description:",
            "            - The server type is either radius or tacacs.",
            "        required: true",
            "        choices: ['radius', 'tacacs']",
            "    global_key:",
            "        description:",
            "            - Global AAA shared secret or keyword 'default'.",
            "    encrypt_type:",
            "        description:",
            "            - The state of encryption applied to the entered global key.",
            "              O clear text, 7 encrypted. Type-6 encryption is not supported.",
            "        choices: ['0', '7']",
            "    deadtime:",
            "        description:",
            "            - Duration for which a non-reachable AAA server is skipped,",
            "              in minutes or keyword 'default.",
            "              Range is 1-1440. Device default is 0.",
            "    server_timeout:",
            "        description:",
            "            - Global AAA server timeout period, in seconds or keyword 'default.",
            "              Range is 1-60. Device default is 5.",
            "    directed_request:",
            "        description:",
            "            - Enables direct authentication requests to AAA server or keyword 'default'",
            "              Device default is disabled.",
            "        choices: ['enabled', 'disabled']",
            "    state:",
            "        description:",
            "            - Manage the state of the resource.",
            "        default: present",
            "        choices: ['present','default']",
            "'''",
            "",
            "EXAMPLES = '''",
            "# Radius Server Basic settings",
            "  - name: \"Radius Server Basic settings\"",
            "    nxos_aaa_server:",
            "        server_type: radius",
            "        server_timeout: 9",
            "        deadtime: 20",
            "        directed_request: enabled",
            "",
            "# Tacacs Server Basic settings",
            "  - name: \"Tacacs Server Basic settings\"",
            "    nxos_aaa_server:",
            "        server_type: tacacs",
            "        server_timeout: 8",
            "        deadtime: 19",
            "        directed_request: disabled",
            "",
            "# Setting Global Key",
            "  - name: \"AAA Server Global Key\"",
            "    nxos_aaa_server:",
            "        server_type: radius",
            "        global_key: test_key",
            "'''",
            "",
            "RETURN = '''",
            "commands:",
            "    description: command sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: [\"radius-server deadtime 22\", \"radius-server timeout 11\",",
            "             \"radius-server directed-request\"]",
            "'''",
            "import re",
            "",
            "from ansible.module_utils.network.nxos.nxos import load_config, run_commands",
            "from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "",
            "PARAM_TO_DEFAULT_KEYMAP = {",
            "    'server_timeout': '5',",
            "    'deadtime': '0',",
            "    'directed_request': 'disabled',",
            "}",
            "",
            "",
            "def execute_show_command(command, module):",
            "    command = {",
            "        'command': command,",
            "        'output': 'text',",
            "    }",
            "",
            "    return run_commands(module, command)",
            "",
            "",
            "def flatten_list(command_lists):",
            "    flat_command_list = []",
            "    for command in command_lists:",
            "        if isinstance(command, list):",
            "            flat_command_list.extend(command)",
            "        else:",
            "            flat_command_list.append(command)",
            "    return flat_command_list",
            "",
            "",
            "def get_aaa_server_info(server_type, module):",
            "    aaa_server_info = {}",
            "    server_command = 'show {0}-server'.format(server_type)",
            "    request_command = 'show {0}-server directed-request'.format(server_type)",
            "    global_key_command = 'show run | sec {0}'.format(server_type)",
            "    aaa_regex = r'.*{0}-server\\skey\\s\\d\\s+(?P<key>\\S+).*'.format(server_type)",
            "",
            "    server_body = execute_show_command(server_command, module)[0]",
            "",
            "    split_server = server_body.splitlines()",
            "",
            "    for line in split_server:",
            "        if line.startswith('timeout'):",
            "            aaa_server_info['server_timeout'] = line.split(':')[1]",
            "",
            "        elif line.startswith('deadtime'):",
            "            aaa_server_info['deadtime'] = line.split(':')[1]",
            "",
            "    request_body = execute_show_command(request_command, module)[0]",
            "",
            "    if bool(request_body):",
            "        aaa_server_info['directed_request'] = request_body.replace('\\n', '')",
            "    else:",
            "        aaa_server_info['directed_request'] = 'disabled'",
            "",
            "    key_body = execute_show_command(global_key_command, module)[0]",
            "",
            "    try:",
            "        match_global_key = re.match(aaa_regex, key_body, re.DOTALL)",
            "        group_key = match_global_key.groupdict()",
            "        aaa_server_info['global_key'] = group_key[\"key\"].replace('\\\"', '')",
            "    except (AttributeError, TypeError):",
            "        aaa_server_info['global_key'] = None",
            "",
            "    return aaa_server_info",
            "",
            "",
            "def config_aaa_server(params, server_type):",
            "    cmds = []",
            "",
            "    deadtime = params.get('deadtime')",
            "    server_timeout = params.get('server_timeout')",
            "    directed_request = params.get('directed_request')",
            "    encrypt_type = params.get('encrypt_type', '7')",
            "    global_key = params.get('global_key')",
            "",
            "    if deadtime is not None:",
            "        cmds.append('{0}-server deadtime {1}'.format(server_type, deadtime))",
            "",
            "    if server_timeout is not None:",
            "        cmds.append('{0}-server timeout {1}'.format(server_type, server_timeout))",
            "",
            "    if directed_request is not None:",
            "        if directed_request == 'enabled':",
            "            cmds.append('{0}-server directed-request'.format(server_type))",
            "        elif directed_request == 'disabled':",
            "            cmds.append('no {0}-server directed-request'.format(server_type))",
            "",
            "    if global_key is not None:",
            "        cmds.append('{0}-server key {1} {2}'.format(server_type, encrypt_type,",
            "                                                    global_key))",
            "",
            "    return cmds",
            "",
            "",
            "def default_aaa_server(existing, params, server_type):",
            "    cmds = []",
            "",
            "    deadtime = params.get('deadtime')",
            "    server_timeout = params.get('server_timeout')",
            "    directed_request = params.get('directed_request')",
            "    global_key = params.get('global_key')",
            "    existing_key = existing.get('global_key')",
            "",
            "    if deadtime is not None and existing.get('deadtime') != PARAM_TO_DEFAULT_KEYMAP['deadtime']:",
            "        cmds.append('no {0}-server deadtime 1'.format(server_type))",
            "",
            "    if server_timeout is not None and existing.get('server_timeout') != PARAM_TO_DEFAULT_KEYMAP['server_timeout']:",
            "        cmds.append('no {0}-server timeout 1'.format(server_type))",
            "",
            "    if directed_request is not None and existing.get('directed_request') != PARAM_TO_DEFAULT_KEYMAP['directed_request']:",
            "        cmds.append('no {0}-server directed-request'.format(server_type))",
            "",
            "    if global_key is not None and existing_key is not None:",
            "        cmds.append('no {0}-server key 7 {1}'.format(server_type, existing_key))",
            "",
            "    return cmds",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        server_type=dict(type='str', choices=['radius', 'tacacs'], required=True),",
            "        global_key=dict(type='str'),",
            "        encrypt_type=dict(type='str', choices=['0', '7']),",
            "        deadtime=dict(type='str'),",
            "        server_timeout=dict(type='str'),",
            "        directed_request=dict(type='str', choices=['enabled', 'disabled', 'default']),",
            "        state=dict(choices=['default', 'present'], default='present'),",
            "    )",
            "",
            "    argument_spec.update(nxos_argument_spec)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "",
            "    warnings = list()",
            "    check_args(module, warnings)",
            "    results = {'changed': False, 'commands': [], 'warnings': warnings}",
            "",
            "    server_type = module.params['server_type']",
            "    global_key = module.params['global_key']",
            "    encrypt_type = module.params['encrypt_type']",
            "    deadtime = module.params['deadtime']",
            "    server_timeout = module.params['server_timeout']",
            "    directed_request = module.params['directed_request']",
            "    state = module.params['state']",
            "",
            "    if encrypt_type and not global_key:",
            "        module.fail_json(msg='encrypt_type must be used with global_key.')",
            "",
            "    args = dict(server_type=server_type, global_key=global_key,",
            "                encrypt_type=encrypt_type, deadtime=deadtime,",
            "                server_timeout=server_timeout, directed_request=directed_request)",
            "",
            "    proposed = dict((k, v) for k, v in args.items() if v is not None)",
            "",
            "    existing = get_aaa_server_info(server_type, module)",
            "",
            "    commands = []",
            "    if state == 'present':",
            "        if deadtime:",
            "            try:",
            "                if int(deadtime) < 0 or int(deadtime) > 1440:",
            "                    raise ValueError",
            "            except ValueError:",
            "                module.fail_json(",
            "                    msg='deadtime must be an integer between 0 and 1440')",
            "",
            "        if server_timeout:",
            "            try:",
            "                if int(server_timeout) < 1 or int(server_timeout) > 60:",
            "                    raise ValueError",
            "            except ValueError:",
            "                module.fail_json(",
            "                    msg='server_timeout must be an integer between 1 and 60')",
            "",
            "        delta = dict(set(proposed.items()).difference(",
            "            existing.items()))",
            "        if delta:",
            "            command = config_aaa_server(delta, server_type)",
            "            if command:",
            "                commands.append(command)",
            "",
            "    elif state == 'default':",
            "        for key, value in proposed.items():",
            "            if key != 'server_type' and value != 'default':",
            "                module.fail_json(",
            "                    msg='Parameters must be set to \"default\"'",
            "                        'when state=default')",
            "        command = default_aaa_server(existing, proposed, server_type)",
            "        if command:",
            "            commands.append(command)",
            "",
            "    cmds = flatten_list(commands)",
            "    if cmds:",
            "        results['changed'] = True",
            "        if not module.check_mode:",
            "            load_config(module, cmds)",
            "        if 'configure' in cmds:",
            "            cmds.pop(0)",
            "        results['commands'] = cmds",
            "",
            "    module.exit_json(**results)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'network'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "",
            "module: nxos_aaa_server",
            "extends_documentation_fragment: nxos",
            "version_added: \"2.2\"",
            "short_description: Manages AAA server global configuration.",
            "description:",
            "    - Manages AAA server global configuration",
            "author:",
            "    - Jason Edelman (@jedelman8)",
            "notes:",
            "    - Tested against NXOSv 7.3.(0)D1(1) on VIRL",
            "    - The server_type parameter is always required.",
            "    - If encrypt_type is not supplied, the global AAA server key will be",
            "      stored as encrypted (type 7).",
            "    - Changes to the global AAA server key with encrypt_type=0",
            "      are not idempotent.",
            "    - state=default will set the supplied parameters to their default values.",
            "      The parameters that you want to default must also be set to default.",
            "      If global_key=default, the global key will be removed.",
            "options:",
            "    server_type:",
            "        description:",
            "            - The server type is either radius or tacacs.",
            "        required: true",
            "        choices: ['radius', 'tacacs']",
            "    global_key:",
            "        description:",
            "            - Global AAA shared secret or keyword 'default'.",
            "    encrypt_type:",
            "        description:",
            "            - The state of encryption applied to the entered global key.",
            "              O clear text, 7 encrypted. Type-6 encryption is not supported.",
            "        choices: ['0', '7']",
            "    deadtime:",
            "        description:",
            "            - Duration for which a non-reachable AAA server is skipped,",
            "              in minutes or keyword 'default.",
            "              Range is 1-1440. Device default is 0.",
            "    server_timeout:",
            "        description:",
            "            - Global AAA server timeout period, in seconds or keyword 'default.",
            "              Range is 1-60. Device default is 5.",
            "    directed_request:",
            "        description:",
            "            - Enables direct authentication requests to AAA server or keyword 'default'",
            "              Device default is disabled.",
            "        choices: ['enabled', 'disabled']",
            "    state:",
            "        description:",
            "            - Manage the state of the resource.",
            "        default: present",
            "        choices: ['present','default']",
            "'''",
            "",
            "EXAMPLES = '''",
            "# Radius Server Basic settings",
            "  - name: \"Radius Server Basic settings\"",
            "    nxos_aaa_server:",
            "        server_type: radius",
            "        server_timeout: 9",
            "        deadtime: 20",
            "        directed_request: enabled",
            "",
            "# Tacacs Server Basic settings",
            "  - name: \"Tacacs Server Basic settings\"",
            "    nxos_aaa_server:",
            "        server_type: tacacs",
            "        server_timeout: 8",
            "        deadtime: 19",
            "        directed_request: disabled",
            "",
            "# Setting Global Key",
            "  - name: \"AAA Server Global Key\"",
            "    nxos_aaa_server:",
            "        server_type: radius",
            "        global_key: test_key",
            "'''",
            "",
            "RETURN = '''",
            "commands:",
            "    description: command sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: [\"radius-server deadtime 22\", \"radius-server timeout 11\",",
            "             \"radius-server directed-request\"]",
            "'''",
            "import re",
            "",
            "from ansible.module_utils.network.nxos.nxos import load_config, run_commands",
            "from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "",
            "PARAM_TO_DEFAULT_KEYMAP = {",
            "    'server_timeout': '5',",
            "    'deadtime': '0',",
            "    'directed_request': 'disabled',",
            "}",
            "",
            "",
            "def execute_show_command(command, module):",
            "    command = {",
            "        'command': command,",
            "        'output': 'text',",
            "    }",
            "",
            "    return run_commands(module, command)",
            "",
            "",
            "def flatten_list(command_lists):",
            "    flat_command_list = []",
            "    for command in command_lists:",
            "        if isinstance(command, list):",
            "            flat_command_list.extend(command)",
            "        else:",
            "            flat_command_list.append(command)",
            "    return flat_command_list",
            "",
            "",
            "def get_aaa_server_info(server_type, module):",
            "    aaa_server_info = {}",
            "    server_command = 'show {0}-server'.format(server_type)",
            "    request_command = 'show {0}-server directed-request'.format(server_type)",
            "    global_key_command = 'show run | sec {0}'.format(server_type)",
            "    aaa_regex = r'.*{0}-server\\skey\\s\\d\\s+(?P<key>\\S+).*'.format(server_type)",
            "",
            "    server_body = execute_show_command(server_command, module)[0]",
            "",
            "    split_server = server_body.splitlines()",
            "",
            "    for line in split_server:",
            "        if line.startswith('timeout'):",
            "            aaa_server_info['server_timeout'] = line.split(':')[1]",
            "",
            "        elif line.startswith('deadtime'):",
            "            aaa_server_info['deadtime'] = line.split(':')[1]",
            "",
            "    request_body = execute_show_command(request_command, module)[0]",
            "",
            "    if bool(request_body):",
            "        aaa_server_info['directed_request'] = request_body.replace('\\n', '')",
            "    else:",
            "        aaa_server_info['directed_request'] = 'disabled'",
            "",
            "    key_body = execute_show_command(global_key_command, module)[0]",
            "",
            "    try:",
            "        match_global_key = re.match(aaa_regex, key_body, re.DOTALL)",
            "        group_key = match_global_key.groupdict()",
            "        aaa_server_info['global_key'] = group_key[\"key\"].replace('\\\"', '')",
            "    except (AttributeError, TypeError):",
            "        aaa_server_info['global_key'] = None",
            "",
            "    return aaa_server_info",
            "",
            "",
            "def config_aaa_server(params, server_type):",
            "    cmds = []",
            "",
            "    deadtime = params.get('deadtime')",
            "    server_timeout = params.get('server_timeout')",
            "    directed_request = params.get('directed_request')",
            "    encrypt_type = params.get('encrypt_type', '7')",
            "    global_key = params.get('global_key')",
            "",
            "    if deadtime is not None:",
            "        cmds.append('{0}-server deadtime {1}'.format(server_type, deadtime))",
            "",
            "    if server_timeout is not None:",
            "        cmds.append('{0}-server timeout {1}'.format(server_type, server_timeout))",
            "",
            "    if directed_request is not None:",
            "        if directed_request == 'enabled':",
            "            cmds.append('{0}-server directed-request'.format(server_type))",
            "        elif directed_request == 'disabled':",
            "            cmds.append('no {0}-server directed-request'.format(server_type))",
            "",
            "    if global_key is not None:",
            "        cmds.append('{0}-server key {1} {2}'.format(server_type, encrypt_type,",
            "                                                    global_key))",
            "",
            "    return cmds",
            "",
            "",
            "def default_aaa_server(existing, params, server_type):",
            "    cmds = []",
            "",
            "    deadtime = params.get('deadtime')",
            "    server_timeout = params.get('server_timeout')",
            "    directed_request = params.get('directed_request')",
            "    global_key = params.get('global_key')",
            "    existing_key = existing.get('global_key')",
            "",
            "    if deadtime is not None and existing.get('deadtime') != PARAM_TO_DEFAULT_KEYMAP['deadtime']:",
            "        cmds.append('no {0}-server deadtime 1'.format(server_type))",
            "",
            "    if server_timeout is not None and existing.get('server_timeout') != PARAM_TO_DEFAULT_KEYMAP['server_timeout']:",
            "        cmds.append('no {0}-server timeout 1'.format(server_type))",
            "",
            "    if directed_request is not None and existing.get('directed_request') != PARAM_TO_DEFAULT_KEYMAP['directed_request']:",
            "        cmds.append('no {0}-server directed-request'.format(server_type))",
            "",
            "    if global_key is not None and existing_key is not None:",
            "        cmds.append('no {0}-server key 7 {1}'.format(server_type, existing_key))",
            "",
            "    return cmds",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        server_type=dict(type='str', choices=['radius', 'tacacs'], required=True),",
            "        global_key=dict(type='str', no_log=True),",
            "        encrypt_type=dict(type='str', choices=['0', '7']),",
            "        deadtime=dict(type='str'),",
            "        server_timeout=dict(type='str'),",
            "        directed_request=dict(type='str', choices=['enabled', 'disabled', 'default']),",
            "        state=dict(choices=['default', 'present'], default='present'),",
            "    )",
            "",
            "    argument_spec.update(nxos_argument_spec)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "",
            "    warnings = list()",
            "    check_args(module, warnings)",
            "    results = {'changed': False, 'commands': [], 'warnings': warnings}",
            "",
            "    server_type = module.params['server_type']",
            "    global_key = module.params['global_key']",
            "    encrypt_type = module.params['encrypt_type']",
            "    deadtime = module.params['deadtime']",
            "    server_timeout = module.params['server_timeout']",
            "    directed_request = module.params['directed_request']",
            "    state = module.params['state']",
            "",
            "    if encrypt_type and not global_key:",
            "        module.fail_json(msg='encrypt_type must be used with global_key.')",
            "",
            "    args = dict(server_type=server_type, global_key=global_key,",
            "                encrypt_type=encrypt_type, deadtime=deadtime,",
            "                server_timeout=server_timeout, directed_request=directed_request)",
            "",
            "    proposed = dict((k, v) for k, v in args.items() if v is not None)",
            "",
            "    existing = get_aaa_server_info(server_type, module)",
            "",
            "    commands = []",
            "    if state == 'present':",
            "        if deadtime:",
            "            try:",
            "                if int(deadtime) < 0 or int(deadtime) > 1440:",
            "                    raise ValueError",
            "            except ValueError:",
            "                module.fail_json(",
            "                    msg='deadtime must be an integer between 0 and 1440')",
            "",
            "        if server_timeout:",
            "            try:",
            "                if int(server_timeout) < 1 or int(server_timeout) > 60:",
            "                    raise ValueError",
            "            except ValueError:",
            "                module.fail_json(",
            "                    msg='server_timeout must be an integer between 1 and 60')",
            "",
            "        delta = dict(set(proposed.items()).difference(",
            "            existing.items()))",
            "        if delta:",
            "            command = config_aaa_server(delta, server_type)",
            "            if command:",
            "                commands.append(command)",
            "",
            "    elif state == 'default':",
            "        for key, value in proposed.items():",
            "            if key != 'server_type' and value != 'default':",
            "                module.fail_json(",
            "                    msg='Parameters must be set to \"default\"'",
            "                        'when state=default')",
            "        command = default_aaa_server(existing, proposed, server_type)",
            "        if command:",
            "            commands.append(command)",
            "",
            "    cmds = flatten_list(commands)",
            "    if cmds:",
            "        results['changed'] = True",
            "        if not module.check_mode:",
            "            load_config(module, cmds)",
            "        if 'configure' in cmds:",
            "            cmds.pop(0)",
            "        results['commands'] = cmds",
            "",
            "    module.exit_json(**results)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "237": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/nxos/nxos_pim_interface.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 482,
                "afterPatchRowNumber": 482,
                "PatchRowcode": "         interface=dict(type='str', required=True),"
            },
            "1": {
                "beforePatchRowNumber": 483,
                "afterPatchRowNumber": 483,
                "PatchRowcode": "         sparse=dict(type='bool', default=False),"
            },
            "2": {
                "beforePatchRowNumber": 484,
                "afterPatchRowNumber": 484,
                "PatchRowcode": "         dr_prio=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 485,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        hello_auth_key=dict(type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+        hello_auth_key=dict(type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 486,
                "afterPatchRowNumber": 486,
                "PatchRowcode": "         hello_interval=dict(type='int'),"
            },
            "6": {
                "beforePatchRowNumber": 487,
                "afterPatchRowNumber": 487,
                "PatchRowcode": "         jp_policy_out=dict(type='str'),"
            },
            "7": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": 488,
                "PatchRowcode": "         jp_policy_in=dict(type='str'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'network'}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: nxos_pim_interface",
            "extends_documentation_fragment: nxos",
            "version_added: \"2.2\"",
            "short_description: Manages PIM interface configuration.",
            "description:",
            "  - Manages PIM interface configuration settings.",
            "author:",
            "  - Jason Edelman (@jedelman8)",
            "notes:",
            "  - Tested against NXOSv 7.3.(0)D1(1) on VIRL",
            "  - When C(state=default), supported params will be reset to a default state.",
            "    These include C(dr_prio), C(hello_auth_key), C(hello_interval), C(jp_policy_out),",
            "    C(jp_policy_in), C(jp_type_in), C(jp_type_out), C(border), C(neighbor_policy),",
            "    C(neighbor_type).",
            "  - The C(hello_auth_key) param is not idempotent.",
            "  - C(hello_auth_key) only supports clear text passwords.",
            "  - When C(state=absent), pim interface configuration will be set to defaults and pim-sm",
            "    will be disabled on the interface.",
            "  - PIM must be enabled on the device to use this module.",
            "  - This module is for Layer 3 interfaces.",
            "options:",
            "  interface:",
            "    description:",
            "      - Full name of the interface such as Ethernet1/33.",
            "    type: str",
            "    required: true",
            "  sparse:",
            "    description:",
            "      - Enable/disable sparse-mode on the interface.",
            "    type: bool",
            "    default: no",
            "  bfd:",
            "    description:",
            "      - Enables BFD for PIM at the interface level. This overrides the bfd variable set at the pim global level.",
            "      - Valid values are 'enable', 'disable' or 'default'.",
            "      - \"Dependency: 'feature bfd'\"",
            "    version_added: \"2.9\"",
            "    type: str",
            "    choices: ['enable', 'disable', 'default']",
            "  dr_prio:",
            "    description:",
            "      - Configures priority for PIM DR election on interface.",
            "    type: str",
            "  hello_auth_key:",
            "    description:",
            "      - Authentication for hellos on this interface.",
            "    type: str",
            "  hello_interval:",
            "    description:",
            "      - Hello interval in milliseconds for this interface.",
            "    type: int",
            "  jp_policy_out:",
            "    description:",
            "      - Policy for join-prune messages (outbound).",
            "    type: str",
            "  jp_policy_in:",
            "    description:",
            "      - Policy for join-prune messages (inbound).",
            "    type: str",
            "  jp_type_out:",
            "    description:",
            "      - Type of policy mapped to C(jp_policy_out).",
            "    type: str",
            "    choices: [ prefix, routemap ]",
            "  jp_type_in:",
            "    description:",
            "      - Type of policy mapped to C(jp_policy_in).",
            "    type: str",
            "    choices: [ prefix, routemap ]",
            "  border:",
            "    description:",
            "      - Configures interface to be a boundary of a PIM domain.",
            "    type: bool",
            "    default: no",
            "  neighbor_policy:",
            "    description:",
            "      - Configures a neighbor policy for filtering adjacencies.",
            "    type: str",
            "  neighbor_type:",
            "    description:",
            "      - Type of policy mapped to neighbor_policy.",
            "    type: str",
            "    choices: [ prefix, routemap ]",
            "  state:",
            "    description:",
            "      - Manages desired state of the resource.",
            "    type: str",
            "    choices: [ present, default ]",
            "    default: present",
            "'''",
            "EXAMPLES = r'''",
            "- name: Ensure PIM is not running on the interface",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    state: absent",
            "",
            "- name: Ensure the interface has pim-sm enabled with the appropriate priority and hello interval",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    dr_prio: 10",
            "    hello_interval: 40",
            "    state: present",
            "",
            "- name: Ensure join-prune policies exist",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    jp_policy_in: JPIN",
            "    jp_policy_out: JPOUT",
            "    jp_type_in: routemap",
            "    jp_type_out: routemap",
            "",
            "- name: disable bfd on the interface",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    bfd: disable",
            "",
            "- name: Ensure defaults are in place",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    state: default",
            "'''",
            "",
            "RETURN = r'''",
            "commands:",
            "    description: command sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: [\"interface eth1/33\",",
            "             \"ip pim neighbor-policy test\",",
            "             \"ip pim bfd-instance disable\",",
            "             \"ip pim neighbor-policy test\"",
            "            ]",
            "'''",
            "",
            "import re",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands",
            "from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args",
            "from ansible.module_utils.network.nxos.nxos import get_interface_type",
            "from ansible.module_utils.six import string_types",
            "",
            "",
            "PARAM_TO_COMMAND_KEYMAP = {",
            "    'interface': '',",
            "    'bfd': 'ip pim bfd-instance',",
            "    'sparse': 'ip pim sparse-mode',",
            "    'dr_prio': 'ip pim dr-priority {0}',",
            "    'hello_interval': 'ip pim hello-interval {0}',",
            "    'hello_auth_key': 'ip pim hello-authentication ah-md5 {0}',",
            "    'border': 'ip pim border',",
            "    'jp_policy_out': 'ip pim jp-policy prefix-list {0} out',",
            "    'jp_policy_in': 'ip pim jp-policy prefix-list {0} in',",
            "    'jp_type_in': '',",
            "    'jp_type_out': '',",
            "    'neighbor_policy': 'ip pim neighbor-policy prefix-list {0}',",
            "    'neighbor_type': '',",
            "}",
            "",
            "PARAM_TO_DEFAULT_KEYMAP = {",
            "    'bfd': 'default',",
            "    'dr_prio': '1',",
            "    'hello_interval': '30000',",
            "    'sparse': False,",
            "    'border': False,",
            "    'hello_auth_key': False,",
            "}",
            "",
            "BFD_KEYMAP = {",
            "    None: None,",
            "    'default': 'no ip pim bfd-instance',",
            "    'disable': 'ip pim bfd-instance disable',",
            "    'enable': 'ip pim bfd-instance',",
            "}",
            "",
            "",
            "def execute_show_command(command, module, text=False):",
            "    if text:",
            "        cmds = [{",
            "            'command': command,",
            "            'output': 'text'",
            "        }]",
            "    else:",
            "        cmds = [{",
            "            'command': command,",
            "            'output': 'json'",
            "        }]",
            "",
            "    return run_commands(module, cmds)",
            "",
            "",
            "def flatten_list(command_lists):",
            "    flat_command_list = []",
            "    for command in command_lists:",
            "        if isinstance(command, list):",
            "            flat_command_list.extend(command)",
            "        else:",
            "            flat_command_list.append(command)",
            "    return flat_command_list",
            "",
            "",
            "def local_existing(gexisting):",
            "    jp_bidir = False",
            "    isauth = False",
            "    if gexisting:",
            "        jp_bidir = gexisting.get('jp_bidir')",
            "        isauth = gexisting.get('isauth')",
            "        if jp_bidir and isauth:",
            "            gexisting.pop('jp_bidir')",
            "            gexisting.pop('isauth')",
            "",
            "    return gexisting, jp_bidir, isauth",
            "",
            "",
            "def get_interface_mode(interface, intf_type, module):",
            "    mode = 'unknown'",
            "    command = 'show interface {0}'.format(interface)",
            "    body = execute_show_command(command, module)",
            "",
            "    try:",
            "        interface_table = body[0]['TABLE_interface']['ROW_interface']",
            "    except (KeyError, AttributeError, IndexError):",
            "        return mode",
            "",
            "    if intf_type in ['ethernet', 'portchannel']:",
            "        mode = str(interface_table.get('eth_mode', 'layer3'))",
            "        if mode in ['access', 'trunk']:",
            "            mode = 'layer2'",
            "        elif mode == 'routed':",
            "            mode = 'layer3'",
            "    elif intf_type in ['loopback', 'svi']:",
            "        mode = 'layer3'",
            "    return mode",
            "",
            "",
            "def get_pim_interface(module, interface):",
            "    pim_interface = {}",
            "    body = get_config(module, flags=['interface {0}'.format(interface)])",
            "",
            "    pim_interface['bfd'] = 'default'",
            "    pim_interface['neighbor_type'] = None",
            "    pim_interface['neighbor_policy'] = None",
            "    pim_interface['jp_policy_in'] = None",
            "    pim_interface['jp_policy_out'] = None",
            "    pim_interface['jp_type_in'] = None",
            "    pim_interface['jp_type_out'] = None",
            "    pim_interface['jp_bidir'] = False",
            "    pim_interface['isauth'] = False",
            "",
            "    if body:",
            "        all_lines = body.splitlines()",
            "",
            "        for each in all_lines:",
            "            if 'jp-policy' in each:",
            "                policy_name = \\",
            "                    re.search(r'ip pim jp-policy(?: prefix-list)? (\\S+)(?: \\S+)?', each).group(1)",
            "                if 'prefix-list' in each:",
            "                    ptype = 'prefix'",
            "                else:",
            "                    ptype = 'routemap'",
            "                if 'out' in each:",
            "                    pim_interface['jp_policy_out'] = policy_name",
            "                    pim_interface['jp_type_out'] = ptype",
            "                elif 'in' in each:",
            "                    pim_interface['jp_policy_in'] = policy_name",
            "                    pim_interface['jp_type_in'] = ptype",
            "                else:",
            "                    pim_interface['jp_policy_in'] = policy_name",
            "                    pim_interface['jp_policy_out'] = policy_name",
            "                    pim_interface['jp_bidir'] = True",
            "            elif 'neighbor-policy' in each:",
            "                pim_interface['neighbor_policy'] = \\",
            "                    re.search(r'ip pim neighbor-policy(?: prefix-list)? (\\S+)', each).group(1)",
            "                if 'prefix-list' in each:",
            "                    pim_interface['neighbor_type'] = 'prefix'",
            "                else:",
            "                    pim_interface['neighbor_type'] = 'routemap'",
            "            elif 'ah-md5' in each:",
            "                pim_interface['isauth'] = True",
            "            elif 'sparse-mode' in each:",
            "                pim_interface['sparse'] = True",
            "            elif 'bfd-instance' in each:",
            "                value = 'default'",
            "                m = re.search(r'ip pim bfd-instance(?P<disable> disable)?', each)",
            "                if m:",
            "                    pim_interface['bfd'] = 'disable' if m.group('disable') else 'enable'",
            "            elif 'border' in each:",
            "                pim_interface['border'] = True",
            "            elif 'hello-interval' in each:",
            "                pim_interface['hello_interval'] = \\",
            "                    re.search(r'ip pim hello-interval (\\d+)', body).group(1)",
            "            elif 'dr-priority' in each:",
            "                pim_interface['dr_prio'] = \\",
            "                    re.search(r'ip pim dr-priority (\\d+)', body).group(1)",
            "",
            "    return pim_interface",
            "",
            "",
            "def fix_delta(delta, existing):",
            "    for key in list(delta):",
            "        if key in ['dr_prio', 'hello_interval', 'sparse', 'border']:",
            "            if delta.get(key) == PARAM_TO_DEFAULT_KEYMAP.get(key) and existing.get(key) is None:",
            "                delta.pop(key)",
            "    return delta",
            "",
            "",
            "def config_pim_interface(delta, existing, jp_bidir, isauth):",
            "    command = None",
            "    commands = []",
            "",
            "    delta = fix_delta(delta, existing)",
            "",
            "    if jp_bidir:",
            "        if delta.get('jp_policy_in') or delta.get('jp_policy_out'):",
            "            if existing.get('jp_type_in') == 'prefix':",
            "                command = 'no ip pim jp-policy prefix-list {0}'.format(existing.get('jp_policy_in'))",
            "            else:",
            "                command = 'no ip pim jp-policy {0}'.format(existing.get('jp_policy_in'))",
            "            if command:",
            "                commands.append(command)",
            "",
            "    for k, v in delta.items():",
            "        if k in ['bfd', 'dr_prio', 'hello_interval', 'hello_auth_key', 'border',",
            "                 'sparse']:",
            "            if k == 'bfd':",
            "                command = BFD_KEYMAP[v]",
            "            elif v:",
            "                command = PARAM_TO_COMMAND_KEYMAP.get(k).format(v)",
            "            elif k == 'hello_auth_key':",
            "                if isauth:",
            "                    command = 'no ip pim hello-authentication ah-md5'",
            "            else:",
            "                command = 'no ' + PARAM_TO_COMMAND_KEYMAP.get(k).format(v)",
            "",
            "            if command:",
            "                commands.append(command)",
            "        elif k in ['neighbor_policy', 'jp_policy_in', 'jp_policy_out',",
            "                   'neighbor_type']:",
            "            if k in ['neighbor_policy', 'neighbor_type']:",
            "                temp = delta.get('neighbor_policy') or existing.get(",
            "                    'neighbor_policy')",
            "                if delta.get('neighbor_type') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif delta.get('neighbor_type') == 'routemap':",
            "                    command = 'ip pim neighbor-policy {0}'.format(temp)",
            "                elif existing.get('neighbor_type') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif existing.get('neighbor_type') == 'routemap':",
            "                    command = 'ip pim neighbor-policy {0}'.format(temp)",
            "            elif k in ['jp_policy_in', 'jp_type_in']:",
            "                temp = delta.get('jp_policy_in') or existing.get(",
            "                    'jp_policy_in')",
            "                if delta.get('jp_type_in') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif delta.get('jp_type_in') == 'routemap':",
            "                    command = 'ip pim jp-policy {0} in'.format(temp)",
            "                elif existing.get('jp_type_in') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif existing.get('jp_type_in') == 'routemap':",
            "                    command = 'ip pim jp-policy {0} in'.format(temp)",
            "            elif k in ['jp_policy_out', 'jp_type_out']:",
            "                temp = delta.get('jp_policy_out') or existing.get(",
            "                    'jp_policy_out')",
            "                if delta.get('jp_type_out') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif delta.get('jp_type_out') == 'routemap':",
            "                    command = 'ip pim jp-policy {0} out'.format(temp)",
            "                elif existing.get('jp_type_out') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif existing.get('jp_type_out') == 'routemap':",
            "                    command = 'ip pim jp-policy {0} out'.format(temp)",
            "            if command:",
            "                commands.append(command)",
            "        command = None",
            "",
            "    if 'no ip pim sparse-mode' in commands:",
            "        # sparse is long-running on some platforms, process it last",
            "        commands.remove('no ip pim sparse-mode')",
            "        commands.append('no ip pim sparse-mode')",
            "    return commands",
            "",
            "",
            "def get_pim_interface_defaults():",
            "",
            "    args = dict(dr_prio=PARAM_TO_DEFAULT_KEYMAP.get('dr_prio'),",
            "                bfd=PARAM_TO_DEFAULT_KEYMAP.get('bfd'),",
            "                border=PARAM_TO_DEFAULT_KEYMAP.get('border'),",
            "                sparse=PARAM_TO_DEFAULT_KEYMAP.get('sparse'),",
            "                hello_interval=PARAM_TO_DEFAULT_KEYMAP.get('hello_interval'),",
            "                hello_auth_key=PARAM_TO_DEFAULT_KEYMAP.get('hello_auth_key'))",
            "",
            "    default = dict((param, value) for (param, value) in args.items()",
            "                   if value is not None)",
            "",
            "    return default",
            "",
            "",
            "def default_pim_interface_policies(existing, jp_bidir):",
            "    commands = []",
            "",
            "    if jp_bidir:",
            "        if existing.get('jp_policy_in') or existing.get('jp_policy_out'):",
            "            if existing.get('jp_type_in') == 'prefix':",
            "                command = 'no ip pim jp-policy prefix-list {0}'.format(existing.get('jp_policy_in'))",
            "        if command:",
            "            commands.append(command)",
            "",
            "    elif not jp_bidir:",
            "        command = None",
            "        for k in existing:",
            "            if k == 'jp_policy_in':",
            "                if existing.get('jp_policy_in'):",
            "                    if existing.get('jp_type_in') == 'prefix':",
            "                        command = 'no ip pim jp-policy prefix-list {0} in'.format(",
            "                            existing.get('jp_policy_in')",
            "                        )",
            "                    else:",
            "                        command = 'no ip pim jp-policy {0} in'.format(",
            "                            existing.get('jp_policy_in')",
            "                        )",
            "            elif k == 'jp_policy_out':",
            "                if existing.get('jp_policy_out'):",
            "                    if existing.get('jp_type_out') == 'prefix':",
            "                        command = 'no ip pim jp-policy prefix-list {0} out'.format(",
            "                            existing.get('jp_policy_out')",
            "                        )",
            "                    else:",
            "                        command = 'no ip pim jp-policy {0} out'.format(",
            "                            existing.get('jp_policy_out')",
            "                        )",
            "            if command:",
            "                commands.append(command)",
            "            command = None",
            "",
            "    if existing.get('neighbor_policy'):",
            "        command = 'no ip pim neighbor-policy'",
            "        commands.append(command)",
            "",
            "    return commands",
            "",
            "",
            "def config_pim_interface_defaults(existing, jp_bidir, isauth):",
            "    command = []",
            "",
            "    # returns a dict",
            "    defaults = get_pim_interface_defaults()",
            "    delta = dict(set(defaults.items()).difference(",
            "        existing.items()))",
            "    if delta:",
            "        # returns a list",
            "        command = config_pim_interface(delta, existing,",
            "                                       jp_bidir, isauth)",
            "    comm = default_pim_interface_policies(existing, jp_bidir)",
            "    if comm:",
            "        for each in comm:",
            "            command.append(each)",
            "",
            "    return command",
            "",
            "",
            "def normalize_proposed_values(proposed):",
            "    keys = proposed.keys()",
            "    if 'bfd' in keys:",
            "        # bfd is a tri-state string: enable, disable, default",
            "        proposed['bfd'] = proposed['bfd'].lower()",
            "    if 'hello_interval' in keys:",
            "        proposed['hello_interval'] = str(proposed['hello_interval'] * 1000)",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        interface=dict(type='str', required=True),",
            "        sparse=dict(type='bool', default=False),",
            "        dr_prio=dict(type='str'),",
            "        hello_auth_key=dict(type='str'),",
            "        hello_interval=dict(type='int'),",
            "        jp_policy_out=dict(type='str'),",
            "        jp_policy_in=dict(type='str'),",
            "        jp_type_out=dict(type='str', choices=['prefix', 'routemap']),",
            "        jp_type_in=dict(type='str', choices=['prefix', 'routemap']),",
            "        bfd=dict(type='str', choices=['enable', 'disable', 'default']),",
            "        border=dict(type='bool', default=False),",
            "        neighbor_policy=dict(type='str'),",
            "        neighbor_type=dict(type='str', choices=['prefix', 'routemap']),",
            "        state=dict(type='str', default='present', choices=['absent', 'default', 'present']),",
            "    )",
            "    argument_spec.update(nxos_argument_spec)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "",
            "    warnings = list()",
            "    check_args(module, warnings)",
            "    results = {'changed': False, 'commands': [], 'warnings': warnings}",
            "",
            "    state = module.params['state']",
            "    interface = module.params['interface']",
            "    jp_type_in = module.params['jp_type_in']",
            "    jp_type_out = module.params['jp_type_out']",
            "    jp_policy_in = module.params['jp_policy_in']",
            "    jp_policy_out = module.params['jp_policy_out']",
            "    neighbor_policy = module.params['neighbor_policy']",
            "    neighbor_type = module.params['neighbor_type']",
            "    hello_interval = module.params['hello_interval']",
            "",
            "    intf_type = get_interface_type(interface)",
            "    if get_interface_mode(interface, intf_type, module) == 'layer2':",
            "        module.fail_json(msg='this module only works on Layer 3 interfaces.')",
            "",
            "    if jp_policy_in:",
            "        if not jp_type_in:",
            "            module.fail_json(msg='jp_type_in required when using jp_policy_in.')",
            "    if jp_policy_out:",
            "        if not jp_type_out:",
            "            module.fail_json(msg='jp_type_out required when using jp_policy_out.')",
            "    if neighbor_policy:",
            "        if not neighbor_type:",
            "            module.fail_json(msg='neighbor_type required when using neighbor_policy.')",
            "",
            "    get_existing = get_pim_interface(module, interface)",
            "    existing, jp_bidir, isauth = local_existing(get_existing)",
            "",
            "    args = PARAM_TO_COMMAND_KEYMAP.keys()",
            "    proposed = dict((k, v) for k, v in module.params.items()",
            "                    if v is not None and k in args)",
            "    normalize_proposed_values(proposed)",
            "",
            "    delta = dict(set(proposed.items()).difference(existing.items()))",
            "",
            "    commands = []",
            "    if state == 'present':",
            "        if delta:",
            "            command = config_pim_interface(delta, existing, jp_bidir, isauth)",
            "            if command:",
            "                commands.append(command)",
            "    elif state == 'default' or state == 'absent':",
            "        defaults = config_pim_interface_defaults(existing, jp_bidir, isauth)",
            "        if defaults:",
            "            commands.append(defaults)",
            "",
            "    if commands:",
            "        commands.insert(0, ['interface {0}'.format(interface)])",
            "",
            "    cmds = flatten_list(commands)",
            "    if cmds:",
            "        results['changed'] = True",
            "        if not module.check_mode:",
            "            load_config(module, cmds)",
            "        if 'configure' in cmds:",
            "            cmds.pop(0)",
            "",
            "    results['commands'] = cmds",
            "",
            "    module.exit_json(**results)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'network'}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: nxos_pim_interface",
            "extends_documentation_fragment: nxos",
            "version_added: \"2.2\"",
            "short_description: Manages PIM interface configuration.",
            "description:",
            "  - Manages PIM interface configuration settings.",
            "author:",
            "  - Jason Edelman (@jedelman8)",
            "notes:",
            "  - Tested against NXOSv 7.3.(0)D1(1) on VIRL",
            "  - When C(state=default), supported params will be reset to a default state.",
            "    These include C(dr_prio), C(hello_auth_key), C(hello_interval), C(jp_policy_out),",
            "    C(jp_policy_in), C(jp_type_in), C(jp_type_out), C(border), C(neighbor_policy),",
            "    C(neighbor_type).",
            "  - The C(hello_auth_key) param is not idempotent.",
            "  - C(hello_auth_key) only supports clear text passwords.",
            "  - When C(state=absent), pim interface configuration will be set to defaults and pim-sm",
            "    will be disabled on the interface.",
            "  - PIM must be enabled on the device to use this module.",
            "  - This module is for Layer 3 interfaces.",
            "options:",
            "  interface:",
            "    description:",
            "      - Full name of the interface such as Ethernet1/33.",
            "    type: str",
            "    required: true",
            "  sparse:",
            "    description:",
            "      - Enable/disable sparse-mode on the interface.",
            "    type: bool",
            "    default: no",
            "  bfd:",
            "    description:",
            "      - Enables BFD for PIM at the interface level. This overrides the bfd variable set at the pim global level.",
            "      - Valid values are 'enable', 'disable' or 'default'.",
            "      - \"Dependency: 'feature bfd'\"",
            "    version_added: \"2.9\"",
            "    type: str",
            "    choices: ['enable', 'disable', 'default']",
            "  dr_prio:",
            "    description:",
            "      - Configures priority for PIM DR election on interface.",
            "    type: str",
            "  hello_auth_key:",
            "    description:",
            "      - Authentication for hellos on this interface.",
            "    type: str",
            "  hello_interval:",
            "    description:",
            "      - Hello interval in milliseconds for this interface.",
            "    type: int",
            "  jp_policy_out:",
            "    description:",
            "      - Policy for join-prune messages (outbound).",
            "    type: str",
            "  jp_policy_in:",
            "    description:",
            "      - Policy for join-prune messages (inbound).",
            "    type: str",
            "  jp_type_out:",
            "    description:",
            "      - Type of policy mapped to C(jp_policy_out).",
            "    type: str",
            "    choices: [ prefix, routemap ]",
            "  jp_type_in:",
            "    description:",
            "      - Type of policy mapped to C(jp_policy_in).",
            "    type: str",
            "    choices: [ prefix, routemap ]",
            "  border:",
            "    description:",
            "      - Configures interface to be a boundary of a PIM domain.",
            "    type: bool",
            "    default: no",
            "  neighbor_policy:",
            "    description:",
            "      - Configures a neighbor policy for filtering adjacencies.",
            "    type: str",
            "  neighbor_type:",
            "    description:",
            "      - Type of policy mapped to neighbor_policy.",
            "    type: str",
            "    choices: [ prefix, routemap ]",
            "  state:",
            "    description:",
            "      - Manages desired state of the resource.",
            "    type: str",
            "    choices: [ present, default ]",
            "    default: present",
            "'''",
            "EXAMPLES = r'''",
            "- name: Ensure PIM is not running on the interface",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    state: absent",
            "",
            "- name: Ensure the interface has pim-sm enabled with the appropriate priority and hello interval",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    dr_prio: 10",
            "    hello_interval: 40",
            "    state: present",
            "",
            "- name: Ensure join-prune policies exist",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    jp_policy_in: JPIN",
            "    jp_policy_out: JPOUT",
            "    jp_type_in: routemap",
            "    jp_type_out: routemap",
            "",
            "- name: disable bfd on the interface",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    bfd: disable",
            "",
            "- name: Ensure defaults are in place",
            "  nxos_pim_interface:",
            "    interface: eth1/33",
            "    state: default",
            "'''",
            "",
            "RETURN = r'''",
            "commands:",
            "    description: command sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: [\"interface eth1/33\",",
            "             \"ip pim neighbor-policy test\",",
            "             \"ip pim bfd-instance disable\",",
            "             \"ip pim neighbor-policy test\"",
            "            ]",
            "'''",
            "",
            "import re",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands",
            "from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args",
            "from ansible.module_utils.network.nxos.nxos import get_interface_type",
            "from ansible.module_utils.six import string_types",
            "",
            "",
            "PARAM_TO_COMMAND_KEYMAP = {",
            "    'interface': '',",
            "    'bfd': 'ip pim bfd-instance',",
            "    'sparse': 'ip pim sparse-mode',",
            "    'dr_prio': 'ip pim dr-priority {0}',",
            "    'hello_interval': 'ip pim hello-interval {0}',",
            "    'hello_auth_key': 'ip pim hello-authentication ah-md5 {0}',",
            "    'border': 'ip pim border',",
            "    'jp_policy_out': 'ip pim jp-policy prefix-list {0} out',",
            "    'jp_policy_in': 'ip pim jp-policy prefix-list {0} in',",
            "    'jp_type_in': '',",
            "    'jp_type_out': '',",
            "    'neighbor_policy': 'ip pim neighbor-policy prefix-list {0}',",
            "    'neighbor_type': '',",
            "}",
            "",
            "PARAM_TO_DEFAULT_KEYMAP = {",
            "    'bfd': 'default',",
            "    'dr_prio': '1',",
            "    'hello_interval': '30000',",
            "    'sparse': False,",
            "    'border': False,",
            "    'hello_auth_key': False,",
            "}",
            "",
            "BFD_KEYMAP = {",
            "    None: None,",
            "    'default': 'no ip pim bfd-instance',",
            "    'disable': 'ip pim bfd-instance disable',",
            "    'enable': 'ip pim bfd-instance',",
            "}",
            "",
            "",
            "def execute_show_command(command, module, text=False):",
            "    if text:",
            "        cmds = [{",
            "            'command': command,",
            "            'output': 'text'",
            "        }]",
            "    else:",
            "        cmds = [{",
            "            'command': command,",
            "            'output': 'json'",
            "        }]",
            "",
            "    return run_commands(module, cmds)",
            "",
            "",
            "def flatten_list(command_lists):",
            "    flat_command_list = []",
            "    for command in command_lists:",
            "        if isinstance(command, list):",
            "            flat_command_list.extend(command)",
            "        else:",
            "            flat_command_list.append(command)",
            "    return flat_command_list",
            "",
            "",
            "def local_existing(gexisting):",
            "    jp_bidir = False",
            "    isauth = False",
            "    if gexisting:",
            "        jp_bidir = gexisting.get('jp_bidir')",
            "        isauth = gexisting.get('isauth')",
            "        if jp_bidir and isauth:",
            "            gexisting.pop('jp_bidir')",
            "            gexisting.pop('isauth')",
            "",
            "    return gexisting, jp_bidir, isauth",
            "",
            "",
            "def get_interface_mode(interface, intf_type, module):",
            "    mode = 'unknown'",
            "    command = 'show interface {0}'.format(interface)",
            "    body = execute_show_command(command, module)",
            "",
            "    try:",
            "        interface_table = body[0]['TABLE_interface']['ROW_interface']",
            "    except (KeyError, AttributeError, IndexError):",
            "        return mode",
            "",
            "    if intf_type in ['ethernet', 'portchannel']:",
            "        mode = str(interface_table.get('eth_mode', 'layer3'))",
            "        if mode in ['access', 'trunk']:",
            "            mode = 'layer2'",
            "        elif mode == 'routed':",
            "            mode = 'layer3'",
            "    elif intf_type in ['loopback', 'svi']:",
            "        mode = 'layer3'",
            "    return mode",
            "",
            "",
            "def get_pim_interface(module, interface):",
            "    pim_interface = {}",
            "    body = get_config(module, flags=['interface {0}'.format(interface)])",
            "",
            "    pim_interface['bfd'] = 'default'",
            "    pim_interface['neighbor_type'] = None",
            "    pim_interface['neighbor_policy'] = None",
            "    pim_interface['jp_policy_in'] = None",
            "    pim_interface['jp_policy_out'] = None",
            "    pim_interface['jp_type_in'] = None",
            "    pim_interface['jp_type_out'] = None",
            "    pim_interface['jp_bidir'] = False",
            "    pim_interface['isauth'] = False",
            "",
            "    if body:",
            "        all_lines = body.splitlines()",
            "",
            "        for each in all_lines:",
            "            if 'jp-policy' in each:",
            "                policy_name = \\",
            "                    re.search(r'ip pim jp-policy(?: prefix-list)? (\\S+)(?: \\S+)?', each).group(1)",
            "                if 'prefix-list' in each:",
            "                    ptype = 'prefix'",
            "                else:",
            "                    ptype = 'routemap'",
            "                if 'out' in each:",
            "                    pim_interface['jp_policy_out'] = policy_name",
            "                    pim_interface['jp_type_out'] = ptype",
            "                elif 'in' in each:",
            "                    pim_interface['jp_policy_in'] = policy_name",
            "                    pim_interface['jp_type_in'] = ptype",
            "                else:",
            "                    pim_interface['jp_policy_in'] = policy_name",
            "                    pim_interface['jp_policy_out'] = policy_name",
            "                    pim_interface['jp_bidir'] = True",
            "            elif 'neighbor-policy' in each:",
            "                pim_interface['neighbor_policy'] = \\",
            "                    re.search(r'ip pim neighbor-policy(?: prefix-list)? (\\S+)', each).group(1)",
            "                if 'prefix-list' in each:",
            "                    pim_interface['neighbor_type'] = 'prefix'",
            "                else:",
            "                    pim_interface['neighbor_type'] = 'routemap'",
            "            elif 'ah-md5' in each:",
            "                pim_interface['isauth'] = True",
            "            elif 'sparse-mode' in each:",
            "                pim_interface['sparse'] = True",
            "            elif 'bfd-instance' in each:",
            "                value = 'default'",
            "                m = re.search(r'ip pim bfd-instance(?P<disable> disable)?', each)",
            "                if m:",
            "                    pim_interface['bfd'] = 'disable' if m.group('disable') else 'enable'",
            "            elif 'border' in each:",
            "                pim_interface['border'] = True",
            "            elif 'hello-interval' in each:",
            "                pim_interface['hello_interval'] = \\",
            "                    re.search(r'ip pim hello-interval (\\d+)', body).group(1)",
            "            elif 'dr-priority' in each:",
            "                pim_interface['dr_prio'] = \\",
            "                    re.search(r'ip pim dr-priority (\\d+)', body).group(1)",
            "",
            "    return pim_interface",
            "",
            "",
            "def fix_delta(delta, existing):",
            "    for key in list(delta):",
            "        if key in ['dr_prio', 'hello_interval', 'sparse', 'border']:",
            "            if delta.get(key) == PARAM_TO_DEFAULT_KEYMAP.get(key) and existing.get(key) is None:",
            "                delta.pop(key)",
            "    return delta",
            "",
            "",
            "def config_pim_interface(delta, existing, jp_bidir, isauth):",
            "    command = None",
            "    commands = []",
            "",
            "    delta = fix_delta(delta, existing)",
            "",
            "    if jp_bidir:",
            "        if delta.get('jp_policy_in') or delta.get('jp_policy_out'):",
            "            if existing.get('jp_type_in') == 'prefix':",
            "                command = 'no ip pim jp-policy prefix-list {0}'.format(existing.get('jp_policy_in'))",
            "            else:",
            "                command = 'no ip pim jp-policy {0}'.format(existing.get('jp_policy_in'))",
            "            if command:",
            "                commands.append(command)",
            "",
            "    for k, v in delta.items():",
            "        if k in ['bfd', 'dr_prio', 'hello_interval', 'hello_auth_key', 'border',",
            "                 'sparse']:",
            "            if k == 'bfd':",
            "                command = BFD_KEYMAP[v]",
            "            elif v:",
            "                command = PARAM_TO_COMMAND_KEYMAP.get(k).format(v)",
            "            elif k == 'hello_auth_key':",
            "                if isauth:",
            "                    command = 'no ip pim hello-authentication ah-md5'",
            "            else:",
            "                command = 'no ' + PARAM_TO_COMMAND_KEYMAP.get(k).format(v)",
            "",
            "            if command:",
            "                commands.append(command)",
            "        elif k in ['neighbor_policy', 'jp_policy_in', 'jp_policy_out',",
            "                   'neighbor_type']:",
            "            if k in ['neighbor_policy', 'neighbor_type']:",
            "                temp = delta.get('neighbor_policy') or existing.get(",
            "                    'neighbor_policy')",
            "                if delta.get('neighbor_type') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif delta.get('neighbor_type') == 'routemap':",
            "                    command = 'ip pim neighbor-policy {0}'.format(temp)",
            "                elif existing.get('neighbor_type') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif existing.get('neighbor_type') == 'routemap':",
            "                    command = 'ip pim neighbor-policy {0}'.format(temp)",
            "            elif k in ['jp_policy_in', 'jp_type_in']:",
            "                temp = delta.get('jp_policy_in') or existing.get(",
            "                    'jp_policy_in')",
            "                if delta.get('jp_type_in') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif delta.get('jp_type_in') == 'routemap':",
            "                    command = 'ip pim jp-policy {0} in'.format(temp)",
            "                elif existing.get('jp_type_in') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif existing.get('jp_type_in') == 'routemap':",
            "                    command = 'ip pim jp-policy {0} in'.format(temp)",
            "            elif k in ['jp_policy_out', 'jp_type_out']:",
            "                temp = delta.get('jp_policy_out') or existing.get(",
            "                    'jp_policy_out')",
            "                if delta.get('jp_type_out') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif delta.get('jp_type_out') == 'routemap':",
            "                    command = 'ip pim jp-policy {0} out'.format(temp)",
            "                elif existing.get('jp_type_out') == 'prefix':",
            "                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)",
            "                elif existing.get('jp_type_out') == 'routemap':",
            "                    command = 'ip pim jp-policy {0} out'.format(temp)",
            "            if command:",
            "                commands.append(command)",
            "        command = None",
            "",
            "    if 'no ip pim sparse-mode' in commands:",
            "        # sparse is long-running on some platforms, process it last",
            "        commands.remove('no ip pim sparse-mode')",
            "        commands.append('no ip pim sparse-mode')",
            "    return commands",
            "",
            "",
            "def get_pim_interface_defaults():",
            "",
            "    args = dict(dr_prio=PARAM_TO_DEFAULT_KEYMAP.get('dr_prio'),",
            "                bfd=PARAM_TO_DEFAULT_KEYMAP.get('bfd'),",
            "                border=PARAM_TO_DEFAULT_KEYMAP.get('border'),",
            "                sparse=PARAM_TO_DEFAULT_KEYMAP.get('sparse'),",
            "                hello_interval=PARAM_TO_DEFAULT_KEYMAP.get('hello_interval'),",
            "                hello_auth_key=PARAM_TO_DEFAULT_KEYMAP.get('hello_auth_key'))",
            "",
            "    default = dict((param, value) for (param, value) in args.items()",
            "                   if value is not None)",
            "",
            "    return default",
            "",
            "",
            "def default_pim_interface_policies(existing, jp_bidir):",
            "    commands = []",
            "",
            "    if jp_bidir:",
            "        if existing.get('jp_policy_in') or existing.get('jp_policy_out'):",
            "            if existing.get('jp_type_in') == 'prefix':",
            "                command = 'no ip pim jp-policy prefix-list {0}'.format(existing.get('jp_policy_in'))",
            "        if command:",
            "            commands.append(command)",
            "",
            "    elif not jp_bidir:",
            "        command = None",
            "        for k in existing:",
            "            if k == 'jp_policy_in':",
            "                if existing.get('jp_policy_in'):",
            "                    if existing.get('jp_type_in') == 'prefix':",
            "                        command = 'no ip pim jp-policy prefix-list {0} in'.format(",
            "                            existing.get('jp_policy_in')",
            "                        )",
            "                    else:",
            "                        command = 'no ip pim jp-policy {0} in'.format(",
            "                            existing.get('jp_policy_in')",
            "                        )",
            "            elif k == 'jp_policy_out':",
            "                if existing.get('jp_policy_out'):",
            "                    if existing.get('jp_type_out') == 'prefix':",
            "                        command = 'no ip pim jp-policy prefix-list {0} out'.format(",
            "                            existing.get('jp_policy_out')",
            "                        )",
            "                    else:",
            "                        command = 'no ip pim jp-policy {0} out'.format(",
            "                            existing.get('jp_policy_out')",
            "                        )",
            "            if command:",
            "                commands.append(command)",
            "            command = None",
            "",
            "    if existing.get('neighbor_policy'):",
            "        command = 'no ip pim neighbor-policy'",
            "        commands.append(command)",
            "",
            "    return commands",
            "",
            "",
            "def config_pim_interface_defaults(existing, jp_bidir, isauth):",
            "    command = []",
            "",
            "    # returns a dict",
            "    defaults = get_pim_interface_defaults()",
            "    delta = dict(set(defaults.items()).difference(",
            "        existing.items()))",
            "    if delta:",
            "        # returns a list",
            "        command = config_pim_interface(delta, existing,",
            "                                       jp_bidir, isauth)",
            "    comm = default_pim_interface_policies(existing, jp_bidir)",
            "    if comm:",
            "        for each in comm:",
            "            command.append(each)",
            "",
            "    return command",
            "",
            "",
            "def normalize_proposed_values(proposed):",
            "    keys = proposed.keys()",
            "    if 'bfd' in keys:",
            "        # bfd is a tri-state string: enable, disable, default",
            "        proposed['bfd'] = proposed['bfd'].lower()",
            "    if 'hello_interval' in keys:",
            "        proposed['hello_interval'] = str(proposed['hello_interval'] * 1000)",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        interface=dict(type='str', required=True),",
            "        sparse=dict(type='bool', default=False),",
            "        dr_prio=dict(type='str'),",
            "        hello_auth_key=dict(type='str', no_log=True),",
            "        hello_interval=dict(type='int'),",
            "        jp_policy_out=dict(type='str'),",
            "        jp_policy_in=dict(type='str'),",
            "        jp_type_out=dict(type='str', choices=['prefix', 'routemap']),",
            "        jp_type_in=dict(type='str', choices=['prefix', 'routemap']),",
            "        bfd=dict(type='str', choices=['enable', 'disable', 'default']),",
            "        border=dict(type='bool', default=False),",
            "        neighbor_policy=dict(type='str'),",
            "        neighbor_type=dict(type='str', choices=['prefix', 'routemap']),",
            "        state=dict(type='str', default='present', choices=['absent', 'default', 'present']),",
            "    )",
            "    argument_spec.update(nxos_argument_spec)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "",
            "    warnings = list()",
            "    check_args(module, warnings)",
            "    results = {'changed': False, 'commands': [], 'warnings': warnings}",
            "",
            "    state = module.params['state']",
            "    interface = module.params['interface']",
            "    jp_type_in = module.params['jp_type_in']",
            "    jp_type_out = module.params['jp_type_out']",
            "    jp_policy_in = module.params['jp_policy_in']",
            "    jp_policy_out = module.params['jp_policy_out']",
            "    neighbor_policy = module.params['neighbor_policy']",
            "    neighbor_type = module.params['neighbor_type']",
            "    hello_interval = module.params['hello_interval']",
            "",
            "    intf_type = get_interface_type(interface)",
            "    if get_interface_mode(interface, intf_type, module) == 'layer2':",
            "        module.fail_json(msg='this module only works on Layer 3 interfaces.')",
            "",
            "    if jp_policy_in:",
            "        if not jp_type_in:",
            "            module.fail_json(msg='jp_type_in required when using jp_policy_in.')",
            "    if jp_policy_out:",
            "        if not jp_type_out:",
            "            module.fail_json(msg='jp_type_out required when using jp_policy_out.')",
            "    if neighbor_policy:",
            "        if not neighbor_type:",
            "            module.fail_json(msg='neighbor_type required when using neighbor_policy.')",
            "",
            "    get_existing = get_pim_interface(module, interface)",
            "    existing, jp_bidir, isauth = local_existing(get_existing)",
            "",
            "    args = PARAM_TO_COMMAND_KEYMAP.keys()",
            "    proposed = dict((k, v) for k, v in module.params.items()",
            "                    if v is not None and k in args)",
            "    normalize_proposed_values(proposed)",
            "",
            "    delta = dict(set(proposed.items()).difference(existing.items()))",
            "",
            "    commands = []",
            "    if state == 'present':",
            "        if delta:",
            "            command = config_pim_interface(delta, existing, jp_bidir, isauth)",
            "            if command:",
            "                commands.append(command)",
            "    elif state == 'default' or state == 'absent':",
            "        defaults = config_pim_interface_defaults(existing, jp_bidir, isauth)",
            "        if defaults:",
            "            commands.append(defaults)",
            "",
            "    if commands:",
            "        commands.insert(0, ['interface {0}'.format(interface)])",
            "",
            "    cmds = flatten_list(commands)",
            "    if cmds:",
            "        results['changed'] = True",
            "        if not module.check_mode:",
            "            load_config(module, cmds)",
            "        if 'configure' in cmds:",
            "            cmds.pop(0)",
            "",
            "    results['commands'] = cmds",
            "",
            "    module.exit_json(**results)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "485": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/nxos/nxos_snmp_user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "     argument_spec = dict("
            },
            "1": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "         user=dict(required=True, type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         group=dict(type='str'),"
            },
            "3": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pwd=dict(type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+        pwd=dict(type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         privacy=dict(type='str'),"
            },
            "6": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "         authentication=dict(choices=['md5', 'sha']),"
            },
            "7": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "         encrypt=dict(type='bool'),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'network'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: nxos_snmp_user",
            "extends_documentation_fragment: nxos",
            "version_added: \"2.2\"",
            "short_description: Manages SNMP users for monitoring.",
            "description:",
            "    - Manages SNMP user configuration.",
            "author:",
            "    - Jason Edelman (@jedelman8)",
            "notes:",
            "    - Tested against NXOSv 7.3.(0)D1(1) on VIRL",
            "    - Authentication parameters not idempotent.",
            "options:",
            "    user:",
            "        description:",
            "            - Name of the user.",
            "        required: true",
            "    group:",
            "        description:",
            "            - Group to which the user will belong to.",
            "              If state = present, and the user is existing,",
            "              the group is added to the user. If the user",
            "              is not existing, user entry is created with this",
            "              group argument.",
            "              If state = absent, only the group is removed from the",
            "              user entry. However, to maintain backward compatibility,",
            "              if the existing user belongs to only one group, and if",
            "              group argument is same as the existing user's group,",
            "              then the user entry also is deleted.",
            "    authentication:",
            "        description:",
            "            - Authentication parameters for the user.",
            "        choices: ['md5', 'sha']",
            "    pwd:",
            "        description:",
            "            - Authentication password when using md5 or sha.",
            "              This is not idempotent",
            "    privacy:",
            "        description:",
            "            - Privacy password for the user.",
            "              This is not idempotent",
            "    encrypt:",
            "        description:",
            "            - Enables AES-128 bit encryption when using privacy password.",
            "        type: bool",
            "    state:",
            "        description:",
            "            - Manage the state of the resource.",
            "        default: present",
            "        choices: ['present','absent']",
            "'''",
            "",
            "EXAMPLES = '''",
            "- nxos_snmp_user:",
            "    user: ntc",
            "    group: network-operator",
            "    authentication: md5",
            "    pwd: test_password",
            "'''",
            "",
            "RETURN = '''",
            "commands:",
            "    description: commands sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: [\"snmp-server user ntc network-operator auth md5 test_password\"]",
            "'''",
            "",
            "import re",
            "",
            "from ansible.module_utils.network.nxos.nxos import load_config, run_commands",
            "from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "",
            "def execute_show_command(command, module, text=False):",
            "    command = {",
            "        'command': command,",
            "        'output': 'json',",
            "    }",
            "    if text:",
            "        command['output'] = 'text'",
            "",
            "    return run_commands(module, command)",
            "",
            "",
            "def flatten_list(command_lists):",
            "    flat_command_list = []",
            "    for command in command_lists:",
            "        if isinstance(command, list):",
            "            flat_command_list.extend(command)",
            "        else:",
            "            flat_command_list.append(command)",
            "    return flat_command_list",
            "",
            "",
            "def get_snmp_groups(module):",
            "    data = execute_show_command('show snmp group', module)[0]",
            "    group_list = []",
            "",
            "    try:",
            "        group_table = data['TABLE_role']['ROW_role']",
            "        for group in group_table:",
            "            group_list.append(group['role_name'])",
            "    except (KeyError, AttributeError):",
            "        return group_list",
            "",
            "    return group_list",
            "",
            "",
            "def get_snmp_user(user, module):",
            "    command = 'show snmp user {0}'.format(user)",
            "    body = execute_show_command(command, module, text=True)",
            "    body_text = body[0]",
            "",
            "    if 'No such entry' not in body[0]:",
            "        body = execute_show_command(command, module)",
            "",
            "    resource = {}",
            "    try:",
            "        # The TABLE and ROW keys differ between NXOS platforms.",
            "        if body[0].get('TABLE_snmp_user'):",
            "            tablekey = 'TABLE_snmp_user'",
            "            rowkey = 'ROW_snmp_user'",
            "            tablegrpkey = 'TABLE_snmp_group_names'",
            "            rowgrpkey = 'ROW_snmp_group_names'",
            "            authkey = 'auth_protocol'",
            "            privkey = 'priv_protocol'",
            "            grpkey = 'group_names'",
            "        elif body[0].get('TABLE_snmp_users'):",
            "            tablekey = 'TABLE_snmp_users'",
            "            rowkey = 'ROW_snmp_users'",
            "            tablegrpkey = 'TABLE_groups'",
            "            rowgrpkey = 'ROW_groups'",
            "            authkey = 'auth'",
            "            privkey = 'priv'",
            "            grpkey = 'group'",
            "",
            "        rt = body[0][tablekey][rowkey]",
            "        # on some older platforms, all groups except the 1st one",
            "        # are in list elements by themselves and they are",
            "        # indexed by 'user'. This is due to a platform bug.",
            "        # Get first element if rt is a list due to the bug",
            "        # or if there is no bug, parse rt directly",
            "        if isinstance(rt, list):",
            "            resource_table = rt[0]",
            "        else:",
            "            resource_table = rt",
            "",
            "        resource['user'] = user",
            "        resource['authentication'] = str(resource_table[authkey]).strip()",
            "        encrypt = str(resource_table[privkey]).strip()",
            "        if encrypt.startswith('aes'):",
            "            resource['encrypt'] = 'aes-128'",
            "        else:",
            "            resource['encrypt'] = 'none'",
            "",
            "        groups = []",
            "        if tablegrpkey in resource_table:",
            "            group_table = resource_table[tablegrpkey][rowgrpkey]",
            "            try:",
            "                for group in group_table:",
            "                    groups.append(str(group[grpkey]).strip())",
            "            except TypeError:",
            "                groups.append(str(group_table[grpkey]).strip())",
            "",
            "            # Now for the platform bug case, get the groups",
            "            if isinstance(rt, list):",
            "                # remove 1st element from the list as this is parsed already",
            "                rt.pop(0)",
            "                # iterate through other elements indexed by",
            "                # 'user' and add it to groups.",
            "                for each in rt:",
            "                    groups.append(each['user'].strip())",
            "",
            "        # Some 'F' platforms use 'group' key instead",
            "        elif 'group' in resource_table:",
            "            # single group is a string, multiple groups in a list",
            "            groups = resource_table['group']",
            "            if isinstance(groups, str):",
            "                groups = [groups]",
            "",
            "        resource['group'] = groups",
            "",
            "    except (KeyError, AttributeError, IndexError, TypeError):",
            "        if not resource and body_text and 'No such entry' not in body_text:",
            "            # 6K and other platforms may not return structured output;",
            "            # attempt to get state from text output",
            "            resource = get_non_structured_snmp_user(body_text)",
            "",
            "    return resource",
            "",
            "",
            "def get_non_structured_snmp_user(body_text):",
            "    # This method is a workaround for platforms that don't support structured",
            "    # output for 'show snmp user <foo>'. This workaround may not work on all",
            "    # platforms. Sample non-struct output:",
            "    #",
            "    # User                Auth  Priv(enforce) Groups              acl_filter",
            "    # ____                ____  _____________ ______              __________",
            "    # sample1             no    no            network-admin       ipv4:my_acl",
            "    #                                         network-operator",
            "    #                                         priv-11",
            "    #         -OR-",
            "    # sample2             md5   des(no)       priv-15",
            "    #         -OR-",
            "    # sample3             md5   aes-128(no)   network-admin",
            "    resource = {}",
            "    output = body_text.rsplit('__________')[-1]",
            "    pat = re.compile(r'^(?P<user>\\S+)\\s+'",
            "                     r'(?P<auth>\\S+)\\s+'",
            "                     r'(?P<priv>[\\w\\d-]+)(?P<enforce>\\([\\w\\d-]+\\))*\\s+'",
            "                     r'(?P<group>\\S+)',",
            "                     re.M)",
            "    m = re.search(pat, output)",
            "    if not m:",
            "        return resource",
            "    resource['user'] = m.group('user')",
            "    resource['auth'] = m.group('auth')",
            "    resource['encrypt'] = 'aes-128' if 'aes' in str(m.group('priv')) else 'none'",
            "",
            "    resource['group'] = [m.group('group')]",
            "    more_groups = re.findall(r'^\\s+([\\w\\d-]+)\\s*$', output, re.M)",
            "    if more_groups:",
            "        resource['group'] += more_groups",
            "",
            "    return resource",
            "",
            "",
            "def remove_snmp_user(user, group=None):",
            "    if group:",
            "        return ['no snmp-server user {0} {1}'.format(user, group)]",
            "    else:",
            "        return ['no snmp-server user {0}'.format(user)]",
            "",
            "",
            "def config_snmp_user(proposed, user, reset):",
            "    if reset:",
            "        commands = remove_snmp_user(user)",
            "    else:",
            "        commands = []",
            "",
            "    if proposed.get('group'):",
            "        cmd = 'snmp-server user {0} {group}'.format(user, **proposed)",
            "    else:",
            "        cmd = 'snmp-server user {0}'.format(user)",
            "",
            "    auth = proposed.get('authentication', None)",
            "    pwd = proposed.get('pwd', None)",
            "",
            "    if auth and pwd:",
            "        cmd += ' auth {authentication} {pwd}'.format(**proposed)",
            "",
            "    encrypt = proposed.get('encrypt', None)",
            "    privacy = proposed.get('privacy', None)",
            "",
            "    if encrypt and privacy:",
            "        cmd += ' priv {encrypt} {privacy}'.format(**proposed)",
            "    elif privacy:",
            "        cmd += ' priv {privacy}'.format(**proposed)",
            "",
            "    if cmd:",
            "        commands.append(cmd)",
            "",
            "    return commands",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        user=dict(required=True, type='str'),",
            "        group=dict(type='str'),",
            "        pwd=dict(type='str'),",
            "        privacy=dict(type='str'),",
            "        authentication=dict(choices=['md5', 'sha']),",
            "        encrypt=dict(type='bool'),",
            "        state=dict(choices=['absent', 'present'], default='present'),",
            "    )",
            "",
            "    argument_spec.update(nxos_argument_spec)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec,",
            "                           required_together=[['authentication', 'pwd'],",
            "                                              ['encrypt', 'privacy']],",
            "                           supports_check_mode=True)",
            "",
            "    warnings = list()",
            "    check_args(module, warnings)",
            "    results = {'changed': False, 'commands': [], 'warnings': warnings}",
            "",
            "    user = module.params['user']",
            "    group = module.params['group']",
            "    pwd = module.params['pwd']",
            "    privacy = module.params['privacy']",
            "    encrypt = module.params['encrypt']",
            "    authentication = module.params['authentication']",
            "    state = module.params['state']",
            "",
            "    if privacy and encrypt:",
            "        if not pwd and authentication:",
            "            module.fail_json(msg='pwd and authentication must be provided '",
            "                                 'when using privacy and encrypt')",
            "",
            "    if group and group not in get_snmp_groups(module):",
            "        module.fail_json(msg='group not configured yet on switch.')",
            "",
            "    existing = get_snmp_user(user, module)",
            "",
            "    if state == 'present' and existing:",
            "        if group:",
            "            if group not in existing['group']:",
            "                existing['group'] = None",
            "            else:",
            "                existing['group'] = group",
            "        else:",
            "            existing['group'] = None",
            "",
            "    commands = []",
            "",
            "    if state == 'absent' and existing:",
            "        if group:",
            "            if group in existing['group']:",
            "                if len(existing['group']) == 1:",
            "                    commands.append(remove_snmp_user(user))",
            "                else:",
            "                    commands.append(remove_snmp_user(user, group))",
            "        else:",
            "            commands.append(remove_snmp_user(user))",
            "",
            "    elif state == 'present':",
            "        reset = False",
            "",
            "        args = dict(user=user, pwd=pwd, group=group, privacy=privacy,",
            "                    encrypt=encrypt, authentication=authentication)",
            "        proposed = dict((k, v) for k, v in args.items() if v is not None)",
            "",
            "        if not existing:",
            "            if encrypt:",
            "                proposed['encrypt'] = 'aes-128'",
            "            commands.append(config_snmp_user(proposed, user, reset))",
            "",
            "        elif existing:",
            "            if encrypt and not existing['encrypt'].startswith('aes'):",
            "                reset = True",
            "                proposed['encrypt'] = 'aes-128'",
            "",
            "            delta = dict(set(proposed.items()).difference(existing.items()))",
            "",
            "            if delta.get('pwd'):",
            "                delta['authentication'] = authentication",
            "",
            "            if delta and encrypt:",
            "                delta['encrypt'] = 'aes-128'",
            "",
            "            if delta:",
            "                command = config_snmp_user(delta, user, reset)",
            "                commands.append(command)",
            "",
            "    cmds = flatten_list(commands)",
            "    if cmds:",
            "        results['changed'] = True",
            "        if not module.check_mode:",
            "            load_config(module, cmds)",
            "",
            "        if 'configure' in cmds:",
            "            cmds.pop(0)",
            "        results['commands'] = cmds",
            "",
            "    module.exit_json(**results)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'network'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: nxos_snmp_user",
            "extends_documentation_fragment: nxos",
            "version_added: \"2.2\"",
            "short_description: Manages SNMP users for monitoring.",
            "description:",
            "    - Manages SNMP user configuration.",
            "author:",
            "    - Jason Edelman (@jedelman8)",
            "notes:",
            "    - Tested against NXOSv 7.3.(0)D1(1) on VIRL",
            "    - Authentication parameters not idempotent.",
            "options:",
            "    user:",
            "        description:",
            "            - Name of the user.",
            "        required: true",
            "    group:",
            "        description:",
            "            - Group to which the user will belong to.",
            "              If state = present, and the user is existing,",
            "              the group is added to the user. If the user",
            "              is not existing, user entry is created with this",
            "              group argument.",
            "              If state = absent, only the group is removed from the",
            "              user entry. However, to maintain backward compatibility,",
            "              if the existing user belongs to only one group, and if",
            "              group argument is same as the existing user's group,",
            "              then the user entry also is deleted.",
            "    authentication:",
            "        description:",
            "            - Authentication parameters for the user.",
            "        choices: ['md5', 'sha']",
            "    pwd:",
            "        description:",
            "            - Authentication password when using md5 or sha.",
            "              This is not idempotent",
            "    privacy:",
            "        description:",
            "            - Privacy password for the user.",
            "              This is not idempotent",
            "    encrypt:",
            "        description:",
            "            - Enables AES-128 bit encryption when using privacy password.",
            "        type: bool",
            "    state:",
            "        description:",
            "            - Manage the state of the resource.",
            "        default: present",
            "        choices: ['present','absent']",
            "'''",
            "",
            "EXAMPLES = '''",
            "- nxos_snmp_user:",
            "    user: ntc",
            "    group: network-operator",
            "    authentication: md5",
            "    pwd: test_password",
            "'''",
            "",
            "RETURN = '''",
            "commands:",
            "    description: commands sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: [\"snmp-server user ntc network-operator auth md5 test_password\"]",
            "'''",
            "",
            "import re",
            "",
            "from ansible.module_utils.network.nxos.nxos import load_config, run_commands",
            "from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "",
            "def execute_show_command(command, module, text=False):",
            "    command = {",
            "        'command': command,",
            "        'output': 'json',",
            "    }",
            "    if text:",
            "        command['output'] = 'text'",
            "",
            "    return run_commands(module, command)",
            "",
            "",
            "def flatten_list(command_lists):",
            "    flat_command_list = []",
            "    for command in command_lists:",
            "        if isinstance(command, list):",
            "            flat_command_list.extend(command)",
            "        else:",
            "            flat_command_list.append(command)",
            "    return flat_command_list",
            "",
            "",
            "def get_snmp_groups(module):",
            "    data = execute_show_command('show snmp group', module)[0]",
            "    group_list = []",
            "",
            "    try:",
            "        group_table = data['TABLE_role']['ROW_role']",
            "        for group in group_table:",
            "            group_list.append(group['role_name'])",
            "    except (KeyError, AttributeError):",
            "        return group_list",
            "",
            "    return group_list",
            "",
            "",
            "def get_snmp_user(user, module):",
            "    command = 'show snmp user {0}'.format(user)",
            "    body = execute_show_command(command, module, text=True)",
            "    body_text = body[0]",
            "",
            "    if 'No such entry' not in body[0]:",
            "        body = execute_show_command(command, module)",
            "",
            "    resource = {}",
            "    try:",
            "        # The TABLE and ROW keys differ between NXOS platforms.",
            "        if body[0].get('TABLE_snmp_user'):",
            "            tablekey = 'TABLE_snmp_user'",
            "            rowkey = 'ROW_snmp_user'",
            "            tablegrpkey = 'TABLE_snmp_group_names'",
            "            rowgrpkey = 'ROW_snmp_group_names'",
            "            authkey = 'auth_protocol'",
            "            privkey = 'priv_protocol'",
            "            grpkey = 'group_names'",
            "        elif body[0].get('TABLE_snmp_users'):",
            "            tablekey = 'TABLE_snmp_users'",
            "            rowkey = 'ROW_snmp_users'",
            "            tablegrpkey = 'TABLE_groups'",
            "            rowgrpkey = 'ROW_groups'",
            "            authkey = 'auth'",
            "            privkey = 'priv'",
            "            grpkey = 'group'",
            "",
            "        rt = body[0][tablekey][rowkey]",
            "        # on some older platforms, all groups except the 1st one",
            "        # are in list elements by themselves and they are",
            "        # indexed by 'user'. This is due to a platform bug.",
            "        # Get first element if rt is a list due to the bug",
            "        # or if there is no bug, parse rt directly",
            "        if isinstance(rt, list):",
            "            resource_table = rt[0]",
            "        else:",
            "            resource_table = rt",
            "",
            "        resource['user'] = user",
            "        resource['authentication'] = str(resource_table[authkey]).strip()",
            "        encrypt = str(resource_table[privkey]).strip()",
            "        if encrypt.startswith('aes'):",
            "            resource['encrypt'] = 'aes-128'",
            "        else:",
            "            resource['encrypt'] = 'none'",
            "",
            "        groups = []",
            "        if tablegrpkey in resource_table:",
            "            group_table = resource_table[tablegrpkey][rowgrpkey]",
            "            try:",
            "                for group in group_table:",
            "                    groups.append(str(group[grpkey]).strip())",
            "            except TypeError:",
            "                groups.append(str(group_table[grpkey]).strip())",
            "",
            "            # Now for the platform bug case, get the groups",
            "            if isinstance(rt, list):",
            "                # remove 1st element from the list as this is parsed already",
            "                rt.pop(0)",
            "                # iterate through other elements indexed by",
            "                # 'user' and add it to groups.",
            "                for each in rt:",
            "                    groups.append(each['user'].strip())",
            "",
            "        # Some 'F' platforms use 'group' key instead",
            "        elif 'group' in resource_table:",
            "            # single group is a string, multiple groups in a list",
            "            groups = resource_table['group']",
            "            if isinstance(groups, str):",
            "                groups = [groups]",
            "",
            "        resource['group'] = groups",
            "",
            "    except (KeyError, AttributeError, IndexError, TypeError):",
            "        if not resource and body_text and 'No such entry' not in body_text:",
            "            # 6K and other platforms may not return structured output;",
            "            # attempt to get state from text output",
            "            resource = get_non_structured_snmp_user(body_text)",
            "",
            "    return resource",
            "",
            "",
            "def get_non_structured_snmp_user(body_text):",
            "    # This method is a workaround for platforms that don't support structured",
            "    # output for 'show snmp user <foo>'. This workaround may not work on all",
            "    # platforms. Sample non-struct output:",
            "    #",
            "    # User                Auth  Priv(enforce) Groups              acl_filter",
            "    # ____                ____  _____________ ______              __________",
            "    # sample1             no    no            network-admin       ipv4:my_acl",
            "    #                                         network-operator",
            "    #                                         priv-11",
            "    #         -OR-",
            "    # sample2             md5   des(no)       priv-15",
            "    #         -OR-",
            "    # sample3             md5   aes-128(no)   network-admin",
            "    resource = {}",
            "    output = body_text.rsplit('__________')[-1]",
            "    pat = re.compile(r'^(?P<user>\\S+)\\s+'",
            "                     r'(?P<auth>\\S+)\\s+'",
            "                     r'(?P<priv>[\\w\\d-]+)(?P<enforce>\\([\\w\\d-]+\\))*\\s+'",
            "                     r'(?P<group>\\S+)',",
            "                     re.M)",
            "    m = re.search(pat, output)",
            "    if not m:",
            "        return resource",
            "    resource['user'] = m.group('user')",
            "    resource['auth'] = m.group('auth')",
            "    resource['encrypt'] = 'aes-128' if 'aes' in str(m.group('priv')) else 'none'",
            "",
            "    resource['group'] = [m.group('group')]",
            "    more_groups = re.findall(r'^\\s+([\\w\\d-]+)\\s*$', output, re.M)",
            "    if more_groups:",
            "        resource['group'] += more_groups",
            "",
            "    return resource",
            "",
            "",
            "def remove_snmp_user(user, group=None):",
            "    if group:",
            "        return ['no snmp-server user {0} {1}'.format(user, group)]",
            "    else:",
            "        return ['no snmp-server user {0}'.format(user)]",
            "",
            "",
            "def config_snmp_user(proposed, user, reset):",
            "    if reset:",
            "        commands = remove_snmp_user(user)",
            "    else:",
            "        commands = []",
            "",
            "    if proposed.get('group'):",
            "        cmd = 'snmp-server user {0} {group}'.format(user, **proposed)",
            "    else:",
            "        cmd = 'snmp-server user {0}'.format(user)",
            "",
            "    auth = proposed.get('authentication', None)",
            "    pwd = proposed.get('pwd', None)",
            "",
            "    if auth and pwd:",
            "        cmd += ' auth {authentication} {pwd}'.format(**proposed)",
            "",
            "    encrypt = proposed.get('encrypt', None)",
            "    privacy = proposed.get('privacy', None)",
            "",
            "    if encrypt and privacy:",
            "        cmd += ' priv {encrypt} {privacy}'.format(**proposed)",
            "    elif privacy:",
            "        cmd += ' priv {privacy}'.format(**proposed)",
            "",
            "    if cmd:",
            "        commands.append(cmd)",
            "",
            "    return commands",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        user=dict(required=True, type='str'),",
            "        group=dict(type='str'),",
            "        pwd=dict(type='str', no_log=True),",
            "        privacy=dict(type='str'),",
            "        authentication=dict(choices=['md5', 'sha']),",
            "        encrypt=dict(type='bool'),",
            "        state=dict(choices=['absent', 'present'], default='present'),",
            "    )",
            "",
            "    argument_spec.update(nxos_argument_spec)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec,",
            "                           required_together=[['authentication', 'pwd'],",
            "                                              ['encrypt', 'privacy']],",
            "                           supports_check_mode=True)",
            "",
            "    warnings = list()",
            "    check_args(module, warnings)",
            "    results = {'changed': False, 'commands': [], 'warnings': warnings}",
            "",
            "    user = module.params['user']",
            "    group = module.params['group']",
            "    pwd = module.params['pwd']",
            "    privacy = module.params['privacy']",
            "    encrypt = module.params['encrypt']",
            "    authentication = module.params['authentication']",
            "    state = module.params['state']",
            "",
            "    if privacy and encrypt:",
            "        if not pwd and authentication:",
            "            module.fail_json(msg='pwd and authentication must be provided '",
            "                                 'when using privacy and encrypt')",
            "",
            "    if group and group not in get_snmp_groups(module):",
            "        module.fail_json(msg='group not configured yet on switch.')",
            "",
            "    existing = get_snmp_user(user, module)",
            "",
            "    if state == 'present' and existing:",
            "        if group:",
            "            if group not in existing['group']:",
            "                existing['group'] = None",
            "            else:",
            "                existing['group'] = group",
            "        else:",
            "            existing['group'] = None",
            "",
            "    commands = []",
            "",
            "    if state == 'absent' and existing:",
            "        if group:",
            "            if group in existing['group']:",
            "                if len(existing['group']) == 1:",
            "                    commands.append(remove_snmp_user(user))",
            "                else:",
            "                    commands.append(remove_snmp_user(user, group))",
            "        else:",
            "            commands.append(remove_snmp_user(user))",
            "",
            "    elif state == 'present':",
            "        reset = False",
            "",
            "        args = dict(user=user, pwd=pwd, group=group, privacy=privacy,",
            "                    encrypt=encrypt, authentication=authentication)",
            "        proposed = dict((k, v) for k, v in args.items() if v is not None)",
            "",
            "        if not existing:",
            "            if encrypt:",
            "                proposed['encrypt'] = 'aes-128'",
            "            commands.append(config_snmp_user(proposed, user, reset))",
            "",
            "        elif existing:",
            "            if encrypt and not existing['encrypt'].startswith('aes'):",
            "                reset = True",
            "                proposed['encrypt'] = 'aes-128'",
            "",
            "            delta = dict(set(proposed.items()).difference(existing.items()))",
            "",
            "            if delta.get('pwd'):",
            "                delta['authentication'] = authentication",
            "",
            "            if delta and encrypt:",
            "                delta['encrypt'] = 'aes-128'",
            "",
            "            if delta:",
            "                command = config_snmp_user(delta, user, reset)",
            "                commands.append(command)",
            "",
            "    cmds = flatten_list(commands)",
            "    if cmds:",
            "        results['changed'] = True",
            "        if not module.check_mode:",
            "            load_config(module, cmds)",
            "",
            "        if 'configure' in cmds:",
            "            cmds.pop(0)",
            "        results['commands'] = cmds",
            "",
            "    module.exit_json(**results)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "296": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/network/nxos/nxos_vrrp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "         admin_state=dict(required=False, type='str',"
            },
            "1": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "                          choices=['shutdown', 'no shutdown', 'default'],"
            },
            "2": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "                          default='shutdown'),"
            },
            "3": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        authentication=dict(required=False, type='str'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        authentication=dict(required=False, type='str', no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         state=dict(choices=['absent', 'present'], required=False, default='present')"
            },
            "6": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "     )"
            },
            "7": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "     argument_spec.update(nxos_argument_spec)"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'network'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: nxos_vrrp",
            "extends_documentation_fragment: nxos",
            "version_added: \"2.1\"",
            "short_description: Manages VRRP configuration on NX-OS switches.",
            "description:",
            "    - Manages VRRP configuration on NX-OS switches.",
            "author:",
            "    - Jason Edelman (@jedelman8)",
            "    - Gabriele Gerbino (@GGabriele)",
            "notes:",
            "    - Tested against NXOSv 7.3.(0)D1(1) on VIRL",
            "    - VRRP feature needs to be enabled first on the system.",
            "    - SVIs must exist before using this module.",
            "    - Interface must be a L3 port before using this module.",
            "    - C(state=absent) removes the VRRP group if it exists on the device.",
            "    - VRRP cannot be configured on loopback interfaces.",
            "options:",
            "    group:",
            "        description:",
            "            - VRRP group number.",
            "        required: true",
            "    interface:",
            "        description:",
            "            - Full name of interface that is being managed for VRRP.",
            "        required: true",
            "    interval:",
            "        description:",
            "            - Time interval between advertisement or 'default' keyword",
            "        required: false",
            "        default: 1",
            "        version_added: 2.6",
            "    priority:",
            "        description:",
            "            - VRRP priority or 'default' keyword",
            "        default: 100",
            "    preempt:",
            "        description:",
            "            - Enable/Disable preempt.",
            "        type: bool",
            "        default: 'yes'",
            "    vip:",
            "        description:",
            "            - VRRP virtual IP address or 'default' keyword",
            "    authentication:",
            "        description:",
            "            - Clear text authentication string or 'default' keyword",
            "    admin_state:",
            "        description:",
            "            - Used to enable or disable the VRRP process.",
            "        choices: ['shutdown', 'no shutdown', 'default']",
            "        default: shutdown",
            "    state:",
            "        description:",
            "            - Specify desired state of the resource.",
            "        default: present",
            "        choices: ['present','absent']",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: Ensure vrrp group 100 and vip 10.1.100.1 is on vlan10",
            "  nxos_vrrp:",
            "    interface: vlan10",
            "    group: 100",
            "    vip: 10.1.100.1",
            "",
            "- name: Ensure removal of the vrrp group config",
            "  # vip is required to ensure the user knows what they are removing",
            "  nxos_vrrp:",
            "    interface: vlan10",
            "    group: 100",
            "    vip: 10.1.100.1",
            "    state: absent",
            "",
            "- name: Re-config with more params",
            "  nxos_vrrp:",
            "    interface: vlan10",
            "    group: 100",
            "    vip: 10.1.100.1",
            "    preempt: false",
            "    priority: 130",
            "    authentication: AUTHKEY",
            "'''",
            "",
            "RETURN = '''",
            "commands:",
            "    description: commands sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: [\"interface vlan10\", \"vrrp 150\", \"address 10.1.15.1\",",
            "            \"authentication text testing\", \"no shutdown\"]",
            "'''",
            "",
            "from ansible.module_utils.network.nxos.nxos import load_config, run_commands",
            "from ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec",
            "from ansible.module_utils.network.nxos.nxos import get_interface_type",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "",
            "PARAM_TO_DEFAULT_KEYMAP = {",
            "    'priority': '100',",
            "    'interval': '1',",
            "    'vip': '0.0.0.0',",
            "    'admin_state': 'shutdown',",
            "}",
            "",
            "",
            "def execute_show_command(command, module):",
            "    if 'show run' not in command:",
            "        output = 'json'",
            "    else:",
            "        output = 'text'",
            "",
            "    commands = [{",
            "        'command': command,",
            "        'output': output,",
            "    }]",
            "    return run_commands(module, commands)[0]",
            "",
            "",
            "def apply_key_map(key_map, table):",
            "    new_dict = {}",
            "    for key, value in table.items():",
            "        new_key = key_map.get(key)",
            "        if new_key:",
            "            if value:",
            "                new_dict[new_key] = str(value)",
            "            else:",
            "                new_dict[new_key] = value",
            "    return new_dict",
            "",
            "",
            "def is_default(interface, module):",
            "    command = 'show run interface {0}'.format(interface)",
            "",
            "    try:",
            "        body = execute_show_command(command, module)",
            "        if 'invalid' in body.lower():",
            "            return 'DNE'",
            "        else:",
            "            raw_list = body.split('\\n')",
            "            if raw_list[-1].startswith('interface'):",
            "                return True",
            "            else:",
            "                return False",
            "    except (KeyError):",
            "        return 'DNE'",
            "",
            "",
            "def get_interface_mode(interface, intf_type, module):",
            "    command = 'show interface {0}'.format(interface)",
            "    interface = {}",
            "    mode = 'unknown'",
            "    body = execute_show_command(command, module)",
            "    interface_table = body['TABLE_interface']['ROW_interface']",
            "    name = interface_table.get('interface')",
            "",
            "    if intf_type in ['ethernet', 'portchannel']:",
            "        mode = str(interface_table.get('eth_mode', 'layer3'))",
            "",
            "        if mode == 'access' or mode == 'trunk':",
            "            mode = 'layer2'",
            "    elif intf_type == 'svi':",
            "        mode = 'layer3'",
            "",
            "    return mode, name",
            "",
            "",
            "def get_vrr_status(group, module, interface):",
            "    command = 'show run all | section interface.{0}$'.format(interface)",
            "    body = execute_show_command(command, module)",
            "    vrf_index = None",
            "    admin_state = 'shutdown'",
            "",
            "    if body:",
            "        splitted_body = body.splitlines()",
            "        for index in range(0, len(splitted_body) - 1):",
            "            if splitted_body[index].strip() == 'vrrp {0}'.format(group):",
            "                vrf_index = index",
            "        vrf_section = splitted_body[vrf_index::]",
            "",
            "        for line in vrf_section:",
            "            if line.strip() == 'no shutdown':",
            "                admin_state = 'no shutdown'",
            "                break",
            "",
            "    return admin_state",
            "",
            "",
            "def get_existing_vrrp(interface, group, module, name):",
            "    command = 'show vrrp detail interface {0}'.format(interface)",
            "    body = execute_show_command(command, module)",
            "    vrrp = {}",
            "",
            "    vrrp_key = {",
            "        'sh_group_id': 'group',",
            "        'sh_vip_addr': 'vip',",
            "        'sh_priority': 'priority',",
            "        'sh_group_preempt': 'preempt',",
            "        'sh_auth_text': 'authentication',",
            "        'sh_adv_interval': 'interval'",
            "    }",
            "",
            "    try:",
            "        vrrp_table = body['TABLE_vrrp_group']",
            "    except (AttributeError, IndexError, TypeError):",
            "        return {}",
            "",
            "    if isinstance(vrrp_table, dict):",
            "        vrrp_table = [vrrp_table]",
            "",
            "    for each_vrrp in vrrp_table:",
            "        vrrp_row = each_vrrp['ROW_vrrp_group']",
            "        parsed_vrrp = apply_key_map(vrrp_key, vrrp_row)",
            "",
            "        if parsed_vrrp['preempt'] == 'Disable':",
            "            parsed_vrrp['preempt'] = False",
            "        elif parsed_vrrp['preempt'] == 'Enable':",
            "            parsed_vrrp['preempt'] = True",
            "",
            "        if parsed_vrrp['group'] == group:",
            "            parsed_vrrp['admin_state'] = get_vrr_status(group, module, name)",
            "            return parsed_vrrp",
            "",
            "    return vrrp",
            "",
            "",
            "def get_commands_config_vrrp(delta, existing, group):",
            "    commands = []",
            "",
            "    CMDS = {",
            "        'priority': 'priority {0}',",
            "        'preempt': 'preempt',",
            "        'vip': 'address {0}',",
            "        'interval': 'advertisement-interval {0}',",
            "        'auth': 'authentication text {0}',",
            "        'admin_state': '{0}',",
            "    }",
            "",
            "    for arg in ['vip', 'priority', 'interval', 'admin_state']:",
            "        val = delta.get(arg)",
            "        if val == 'default':",
            "            val = PARAM_TO_DEFAULT_KEYMAP.get(arg)",
            "            if val != existing.get(arg):",
            "                commands.append((CMDS.get(arg)).format(val))",
            "        elif val:",
            "            commands.append((CMDS.get(arg)).format(val))",
            "",
            "    preempt = delta.get('preempt')",
            "    auth = delta.get('authentication')",
            "",
            "    if preempt:",
            "        commands.append(CMDS.get('preempt'))",
            "    elif preempt is False:",
            "        commands.append('no ' + CMDS.get('preempt'))",
            "    if auth:",
            "        if auth != 'default':",
            "            commands.append((CMDS.get('auth')).format(auth))",
            "        elif existing.get('authentication'):",
            "            commands.append('no authentication')",
            "",
            "    if commands:",
            "        commands.insert(0, 'vrrp {0}'.format(group))",
            "",
            "    return commands",
            "",
            "",
            "def flatten_list(command_lists):",
            "    flat_command_list = []",
            "    for command in command_lists:",
            "        if isinstance(command, list):",
            "            flat_command_list.extend(command)",
            "        else:",
            "            flat_command_list.append(command)",
            "    return flat_command_list",
            "",
            "",
            "def validate_params(param, module):",
            "    value = module.params[param]",
            "",
            "    if param == 'group':",
            "        try:",
            "            if (int(value) < 1 or int(value) > 255):",
            "                raise ValueError",
            "        except ValueError:",
            "            module.fail_json(msg=\"Warning! 'group' must be an integer between\"",
            "                                 \" 1 and 255\", group=value)",
            "    elif param == 'priority':",
            "        try:",
            "            if (int(value) < 1 or int(value) > 254):",
            "                raise ValueError",
            "        except ValueError:",
            "            module.fail_json(msg=\"Warning! 'priority' must be an integer \"",
            "                                 \"between 1 and 254\", priority=value)",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        group=dict(required=True, type='str'),",
            "        interface=dict(required=True),",
            "        interval=dict(required=False, type='str'),",
            "        priority=dict(required=False, type='str'),",
            "        preempt=dict(required=False, type='bool'),",
            "        vip=dict(required=False, type='str'),",
            "        admin_state=dict(required=False, type='str',",
            "                         choices=['shutdown', 'no shutdown', 'default'],",
            "                         default='shutdown'),",
            "        authentication=dict(required=False, type='str'),",
            "        state=dict(choices=['absent', 'present'], required=False, default='present')",
            "    )",
            "    argument_spec.update(nxos_argument_spec)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "",
            "    warnings = list()",
            "    results = {'changed': False, 'commands': [], 'warnings': warnings}",
            "",
            "    state = module.params['state']",
            "    interface = module.params['interface'].lower()",
            "    group = module.params['group']",
            "    priority = module.params['priority']",
            "    interval = module.params['interval']",
            "    preempt = module.params['preempt']",
            "    vip = module.params['vip']",
            "    authentication = module.params['authentication']",
            "    admin_state = module.params['admin_state']",
            "",
            "    device_info = get_capabilities(module)",
            "    network_api = device_info.get('network_api', 'nxapi')",
            "",
            "    if state == 'present' and not vip:",
            "        module.fail_json(msg='the \"vip\" param is required when state=present')",
            "",
            "    intf_type = get_interface_type(interface)",
            "    if (intf_type != 'ethernet' and network_api == 'cliconf'):",
            "        if is_default(interface, module) == 'DNE':",
            "            module.fail_json(msg='That interface does not exist yet. Create '",
            "                                 'it first.', interface=interface)",
            "        if intf_type == 'loopback':",
            "            module.fail_json(msg=\"Loopback interfaces don't support VRRP.\",",
            "                             interface=interface)",
            "",
            "    mode, name = get_interface_mode(interface, intf_type, module)",
            "    if mode == 'layer2':",
            "        module.fail_json(msg='That interface is a layer2 port.\\nMake it '",
            "                             'a layer 3 port first.', interface=interface)",
            "",
            "    args = dict(group=group, priority=priority, preempt=preempt,",
            "                vip=vip, authentication=authentication, interval=interval,",
            "                admin_state=admin_state)",
            "",
            "    proposed = dict((k, v) for k, v in args.items() if v is not None)",
            "    existing = get_existing_vrrp(interface, group, module, name)",
            "",
            "    changed = False",
            "    end_state = existing",
            "    commands = []",
            "",
            "    if state == 'present':",
            "        delta = dict(",
            "            set(proposed.items()).difference(existing.items()))",
            "        if delta:",
            "            command = get_commands_config_vrrp(delta, existing, group)",
            "            if command:",
            "                commands.append(command)",
            "    elif state == 'absent':",
            "        if existing:",
            "            commands.append(['no vrrp {0}'.format(group)])",
            "",
            "    if commands:",
            "        commands.insert(0, ['interface {0}'.format(interface)])",
            "        commands = flatten_list(commands)",
            "        results['commands'] = commands",
            "        results['changed'] = True",
            "        if not module.check_mode:",
            "            load_config(module, commands)",
            "            if 'configure' in commands:",
            "                commands.pop(0)",
            "",
            "    module.exit_json(**results)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'network'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "---",
            "module: nxos_vrrp",
            "extends_documentation_fragment: nxos",
            "version_added: \"2.1\"",
            "short_description: Manages VRRP configuration on NX-OS switches.",
            "description:",
            "    - Manages VRRP configuration on NX-OS switches.",
            "author:",
            "    - Jason Edelman (@jedelman8)",
            "    - Gabriele Gerbino (@GGabriele)",
            "notes:",
            "    - Tested against NXOSv 7.3.(0)D1(1) on VIRL",
            "    - VRRP feature needs to be enabled first on the system.",
            "    - SVIs must exist before using this module.",
            "    - Interface must be a L3 port before using this module.",
            "    - C(state=absent) removes the VRRP group if it exists on the device.",
            "    - VRRP cannot be configured on loopback interfaces.",
            "options:",
            "    group:",
            "        description:",
            "            - VRRP group number.",
            "        required: true",
            "    interface:",
            "        description:",
            "            - Full name of interface that is being managed for VRRP.",
            "        required: true",
            "    interval:",
            "        description:",
            "            - Time interval between advertisement or 'default' keyword",
            "        required: false",
            "        default: 1",
            "        version_added: 2.6",
            "    priority:",
            "        description:",
            "            - VRRP priority or 'default' keyword",
            "        default: 100",
            "    preempt:",
            "        description:",
            "            - Enable/Disable preempt.",
            "        type: bool",
            "        default: 'yes'",
            "    vip:",
            "        description:",
            "            - VRRP virtual IP address or 'default' keyword",
            "    authentication:",
            "        description:",
            "            - Clear text authentication string or 'default' keyword",
            "    admin_state:",
            "        description:",
            "            - Used to enable or disable the VRRP process.",
            "        choices: ['shutdown', 'no shutdown', 'default']",
            "        default: shutdown",
            "    state:",
            "        description:",
            "            - Specify desired state of the resource.",
            "        default: present",
            "        choices: ['present','absent']",
            "'''",
            "",
            "EXAMPLES = '''",
            "- name: Ensure vrrp group 100 and vip 10.1.100.1 is on vlan10",
            "  nxos_vrrp:",
            "    interface: vlan10",
            "    group: 100",
            "    vip: 10.1.100.1",
            "",
            "- name: Ensure removal of the vrrp group config",
            "  # vip is required to ensure the user knows what they are removing",
            "  nxos_vrrp:",
            "    interface: vlan10",
            "    group: 100",
            "    vip: 10.1.100.1",
            "    state: absent",
            "",
            "- name: Re-config with more params",
            "  nxos_vrrp:",
            "    interface: vlan10",
            "    group: 100",
            "    vip: 10.1.100.1",
            "    preempt: false",
            "    priority: 130",
            "    authentication: AUTHKEY",
            "'''",
            "",
            "RETURN = '''",
            "commands:",
            "    description: commands sent to the device",
            "    returned: always",
            "    type: list",
            "    sample: [\"interface vlan10\", \"vrrp 150\", \"address 10.1.15.1\",",
            "            \"authentication text testing\", \"no shutdown\"]",
            "'''",
            "",
            "from ansible.module_utils.network.nxos.nxos import load_config, run_commands",
            "from ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec",
            "from ansible.module_utils.network.nxos.nxos import get_interface_type",
            "from ansible.module_utils.basic import AnsibleModule",
            "",
            "",
            "PARAM_TO_DEFAULT_KEYMAP = {",
            "    'priority': '100',",
            "    'interval': '1',",
            "    'vip': '0.0.0.0',",
            "    'admin_state': 'shutdown',",
            "}",
            "",
            "",
            "def execute_show_command(command, module):",
            "    if 'show run' not in command:",
            "        output = 'json'",
            "    else:",
            "        output = 'text'",
            "",
            "    commands = [{",
            "        'command': command,",
            "        'output': output,",
            "    }]",
            "    return run_commands(module, commands)[0]",
            "",
            "",
            "def apply_key_map(key_map, table):",
            "    new_dict = {}",
            "    for key, value in table.items():",
            "        new_key = key_map.get(key)",
            "        if new_key:",
            "            if value:",
            "                new_dict[new_key] = str(value)",
            "            else:",
            "                new_dict[new_key] = value",
            "    return new_dict",
            "",
            "",
            "def is_default(interface, module):",
            "    command = 'show run interface {0}'.format(interface)",
            "",
            "    try:",
            "        body = execute_show_command(command, module)",
            "        if 'invalid' in body.lower():",
            "            return 'DNE'",
            "        else:",
            "            raw_list = body.split('\\n')",
            "            if raw_list[-1].startswith('interface'):",
            "                return True",
            "            else:",
            "                return False",
            "    except (KeyError):",
            "        return 'DNE'",
            "",
            "",
            "def get_interface_mode(interface, intf_type, module):",
            "    command = 'show interface {0}'.format(interface)",
            "    interface = {}",
            "    mode = 'unknown'",
            "    body = execute_show_command(command, module)",
            "    interface_table = body['TABLE_interface']['ROW_interface']",
            "    name = interface_table.get('interface')",
            "",
            "    if intf_type in ['ethernet', 'portchannel']:",
            "        mode = str(interface_table.get('eth_mode', 'layer3'))",
            "",
            "        if mode == 'access' or mode == 'trunk':",
            "            mode = 'layer2'",
            "    elif intf_type == 'svi':",
            "        mode = 'layer3'",
            "",
            "    return mode, name",
            "",
            "",
            "def get_vrr_status(group, module, interface):",
            "    command = 'show run all | section interface.{0}$'.format(interface)",
            "    body = execute_show_command(command, module)",
            "    vrf_index = None",
            "    admin_state = 'shutdown'",
            "",
            "    if body:",
            "        splitted_body = body.splitlines()",
            "        for index in range(0, len(splitted_body) - 1):",
            "            if splitted_body[index].strip() == 'vrrp {0}'.format(group):",
            "                vrf_index = index",
            "        vrf_section = splitted_body[vrf_index::]",
            "",
            "        for line in vrf_section:",
            "            if line.strip() == 'no shutdown':",
            "                admin_state = 'no shutdown'",
            "                break",
            "",
            "    return admin_state",
            "",
            "",
            "def get_existing_vrrp(interface, group, module, name):",
            "    command = 'show vrrp detail interface {0}'.format(interface)",
            "    body = execute_show_command(command, module)",
            "    vrrp = {}",
            "",
            "    vrrp_key = {",
            "        'sh_group_id': 'group',",
            "        'sh_vip_addr': 'vip',",
            "        'sh_priority': 'priority',",
            "        'sh_group_preempt': 'preempt',",
            "        'sh_auth_text': 'authentication',",
            "        'sh_adv_interval': 'interval'",
            "    }",
            "",
            "    try:",
            "        vrrp_table = body['TABLE_vrrp_group']",
            "    except (AttributeError, IndexError, TypeError):",
            "        return {}",
            "",
            "    if isinstance(vrrp_table, dict):",
            "        vrrp_table = [vrrp_table]",
            "",
            "    for each_vrrp in vrrp_table:",
            "        vrrp_row = each_vrrp['ROW_vrrp_group']",
            "        parsed_vrrp = apply_key_map(vrrp_key, vrrp_row)",
            "",
            "        if parsed_vrrp['preempt'] == 'Disable':",
            "            parsed_vrrp['preempt'] = False",
            "        elif parsed_vrrp['preempt'] == 'Enable':",
            "            parsed_vrrp['preempt'] = True",
            "",
            "        if parsed_vrrp['group'] == group:",
            "            parsed_vrrp['admin_state'] = get_vrr_status(group, module, name)",
            "            return parsed_vrrp",
            "",
            "    return vrrp",
            "",
            "",
            "def get_commands_config_vrrp(delta, existing, group):",
            "    commands = []",
            "",
            "    CMDS = {",
            "        'priority': 'priority {0}',",
            "        'preempt': 'preempt',",
            "        'vip': 'address {0}',",
            "        'interval': 'advertisement-interval {0}',",
            "        'auth': 'authentication text {0}',",
            "        'admin_state': '{0}',",
            "    }",
            "",
            "    for arg in ['vip', 'priority', 'interval', 'admin_state']:",
            "        val = delta.get(arg)",
            "        if val == 'default':",
            "            val = PARAM_TO_DEFAULT_KEYMAP.get(arg)",
            "            if val != existing.get(arg):",
            "                commands.append((CMDS.get(arg)).format(val))",
            "        elif val:",
            "            commands.append((CMDS.get(arg)).format(val))",
            "",
            "    preempt = delta.get('preempt')",
            "    auth = delta.get('authentication')",
            "",
            "    if preempt:",
            "        commands.append(CMDS.get('preempt'))",
            "    elif preempt is False:",
            "        commands.append('no ' + CMDS.get('preempt'))",
            "    if auth:",
            "        if auth != 'default':",
            "            commands.append((CMDS.get('auth')).format(auth))",
            "        elif existing.get('authentication'):",
            "            commands.append('no authentication')",
            "",
            "    if commands:",
            "        commands.insert(0, 'vrrp {0}'.format(group))",
            "",
            "    return commands",
            "",
            "",
            "def flatten_list(command_lists):",
            "    flat_command_list = []",
            "    for command in command_lists:",
            "        if isinstance(command, list):",
            "            flat_command_list.extend(command)",
            "        else:",
            "            flat_command_list.append(command)",
            "    return flat_command_list",
            "",
            "",
            "def validate_params(param, module):",
            "    value = module.params[param]",
            "",
            "    if param == 'group':",
            "        try:",
            "            if (int(value) < 1 or int(value) > 255):",
            "                raise ValueError",
            "        except ValueError:",
            "            module.fail_json(msg=\"Warning! 'group' must be an integer between\"",
            "                                 \" 1 and 255\", group=value)",
            "    elif param == 'priority':",
            "        try:",
            "            if (int(value) < 1 or int(value) > 254):",
            "                raise ValueError",
            "        except ValueError:",
            "            module.fail_json(msg=\"Warning! 'priority' must be an integer \"",
            "                                 \"between 1 and 254\", priority=value)",
            "",
            "",
            "def main():",
            "    argument_spec = dict(",
            "        group=dict(required=True, type='str'),",
            "        interface=dict(required=True),",
            "        interval=dict(required=False, type='str'),",
            "        priority=dict(required=False, type='str'),",
            "        preempt=dict(required=False, type='bool'),",
            "        vip=dict(required=False, type='str'),",
            "        admin_state=dict(required=False, type='str',",
            "                         choices=['shutdown', 'no shutdown', 'default'],",
            "                         default='shutdown'),",
            "        authentication=dict(required=False, type='str', no_log=True),",
            "        state=dict(choices=['absent', 'present'], required=False, default='present')",
            "    )",
            "    argument_spec.update(nxos_argument_spec)",
            "",
            "    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)",
            "",
            "    warnings = list()",
            "    results = {'changed': False, 'commands': [], 'warnings': warnings}",
            "",
            "    state = module.params['state']",
            "    interface = module.params['interface'].lower()",
            "    group = module.params['group']",
            "    priority = module.params['priority']",
            "    interval = module.params['interval']",
            "    preempt = module.params['preempt']",
            "    vip = module.params['vip']",
            "    authentication = module.params['authentication']",
            "    admin_state = module.params['admin_state']",
            "",
            "    device_info = get_capabilities(module)",
            "    network_api = device_info.get('network_api', 'nxapi')",
            "",
            "    if state == 'present' and not vip:",
            "        module.fail_json(msg='the \"vip\" param is required when state=present')",
            "",
            "    intf_type = get_interface_type(interface)",
            "    if (intf_type != 'ethernet' and network_api == 'cliconf'):",
            "        if is_default(interface, module) == 'DNE':",
            "            module.fail_json(msg='That interface does not exist yet. Create '",
            "                                 'it first.', interface=interface)",
            "        if intf_type == 'loopback':",
            "            module.fail_json(msg=\"Loopback interfaces don't support VRRP.\",",
            "                             interface=interface)",
            "",
            "    mode, name = get_interface_mode(interface, intf_type, module)",
            "    if mode == 'layer2':",
            "        module.fail_json(msg='That interface is a layer2 port.\\nMake it '",
            "                             'a layer 3 port first.', interface=interface)",
            "",
            "    args = dict(group=group, priority=priority, preempt=preempt,",
            "                vip=vip, authentication=authentication, interval=interval,",
            "                admin_state=admin_state)",
            "",
            "    proposed = dict((k, v) for k, v in args.items() if v is not None)",
            "    existing = get_existing_vrrp(interface, group, module, name)",
            "",
            "    changed = False",
            "    end_state = existing",
            "    commands = []",
            "",
            "    if state == 'present':",
            "        delta = dict(",
            "            set(proposed.items()).difference(existing.items()))",
            "        if delta:",
            "            command = get_commands_config_vrrp(delta, existing, group)",
            "            if command:",
            "                commands.append(command)",
            "    elif state == 'absent':",
            "        if existing:",
            "            commands.append(['no vrrp {0}'.format(group)])",
            "",
            "    if commands:",
            "        commands.insert(0, ['interface {0}'.format(interface)])",
            "        commands = flatten_list(commands)",
            "        results['commands'] = commands",
            "        results['changed'] = True",
            "        if not module.check_mode:",
            "            load_config(module, commands)",
            "            if 'configure' in commands:",
            "                commands.pop(0)",
            "",
            "    module.exit_json(**results)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "333": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/storage/netapp/_sf_account_manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "             account_id=dict(required=False, type='int', default=None),"
            },
            "1": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "             new_name=dict(required=False, type='str', default=None),"
            },
            "3": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            initiator_secret=dict(required=False, type='str'),"
            },
            "4": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            target_secret=dict(required=False, type='str'),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+            initiator_secret=dict(required=False, type='str', no_log=True),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+            target_secret=dict(required=False, type='str', no_log=True),"
            },
            "7": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "             attributes=dict(required=False, type='dict'),"
            },
            "8": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             status=dict(required=False, type='str'),"
            },
            "9": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         ))"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "",
            "# (c) 2017, NetApp, Inc",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['deprecated'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "",
            "module: sf_account_manager",
            "deprecated:",
            "  removed_in: \"2.11\"",
            "  why: This Module has been replaced",
            "  alternative: please use M(na_elementsw_account)",
            "short_description: Manage SolidFire accounts",
            "extends_documentation_fragment:",
            "    - netapp.solidfire",
            "version_added: '2.3'",
            "author: Sumit Kumar (@timuster) <sumit4@netapp.com>",
            "description:",
            "- Create, destroy, or update accounts on SolidFire",
            "",
            "options:",
            "",
            "    state:",
            "        description:",
            "        - Whether the specified account should exist or not.",
            "        required: true",
            "        choices: ['present', 'absent']",
            "",
            "    name:",
            "        description:",
            "        - Unique username for this account. (May be 1 to 64 characters in length).",
            "        required: true",
            "",
            "    new_name:",
            "        description:",
            "        - New name for the user account.",
            "",
            "    initiator_secret:",
            "        description:",
            "        - CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.",
            "        - The CHAP initiator secrets must be unique and cannot be the same as the target CHAP secret.",
            "        - If not specified, a random secret is created.",
            "",
            "    target_secret:",
            "        description:",
            "        - CHAP secret to use for the target (mutual CHAP authentication).",
            "        - Should be 12-16 characters long and impenetrable.",
            "        - The CHAP target secrets must be unique and cannot be the same as the initiator CHAP secret.",
            "        - If not specified, a random secret is created.",
            "",
            "    attributes:",
            "        description: List of Name/Value pairs in JSON object format.",
            "",
            "    account_id:",
            "        description:",
            "        - The ID of the account to manage or update.",
            "",
            "    status:",
            "        description:",
            "        - Status of the account.",
            "",
            "'''",
            "",
            "EXAMPLES = \"\"\"",
            "- name: Create Account",
            "  sf_account_manager:",
            "    hostname: \"{{ solidfire_hostname }}\"",
            "    username: \"{{ solidfire_username }}\"",
            "    password: \"{{ solidfire_password }}\"",
            "    state: present",
            "    name: TenantA",
            "",
            "- name: Modify Account",
            "  sf_account_manager:",
            "    hostname: \"{{ solidfire_hostname }}\"",
            "    username: \"{{ solidfire_username }}\"",
            "    password: \"{{ solidfire_password }}\"",
            "    state: present",
            "    name: TenantA",
            "    new_name: TenantA-Renamed",
            "",
            "- name: Delete Account",
            "  sf_account_manager:",
            "    hostname: \"{{ solidfire_hostname }}\"",
            "    username: \"{{ solidfire_username }}\"",
            "    password: \"{{ solidfire_password }}\"",
            "    state: absent",
            "    name: TenantA-Renamed",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "",
            "\"\"\"",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils._text import to_native",
            "import ansible.module_utils.netapp as netapp_utils",
            "",
            "",
            "HAS_SF_SDK = netapp_utils.has_sf_sdk()",
            "",
            "",
            "class SolidFireAccount(object):",
            "",
            "    def __init__(self):",
            "        self.argument_spec = netapp_utils.ontap_sf_host_argument_spec()",
            "        self.argument_spec.update(dict(",
            "            state=dict(required=True, choices=['present', 'absent']),",
            "            name=dict(required=True, type='str'),",
            "            account_id=dict(required=False, type='int', default=None),",
            "",
            "            new_name=dict(required=False, type='str', default=None),",
            "            initiator_secret=dict(required=False, type='str'),",
            "            target_secret=dict(required=False, type='str'),",
            "            attributes=dict(required=False, type='dict'),",
            "            status=dict(required=False, type='str'),",
            "        ))",
            "",
            "        self.module = AnsibleModule(",
            "            argument_spec=self.argument_spec,",
            "            supports_check_mode=True",
            "        )",
            "",
            "        p = self.module.params",
            "",
            "        # set up state variables",
            "        self.state = p['state']",
            "        self.name = p['name']",
            "        self.account_id = p['account_id']",
            "",
            "        self.new_name = p['new_name']",
            "        self.initiator_secret = p['initiator_secret']",
            "        self.target_secret = p['target_secret']",
            "        self.attributes = p['attributes']",
            "        self.status = p['status']",
            "",
            "        if HAS_SF_SDK is False:",
            "            self.module.fail_json(msg=\"Unable to import the SolidFire Python SDK\")",
            "        else:",
            "            self.sfe = netapp_utils.create_sf_connection(module=self.module)",
            "",
            "    def get_account(self):",
            "        \"\"\"",
            "            Return account object if found",
            "",
            "            :return: Details about the account. None if not found.",
            "            :rtype: dict",
            "        \"\"\"",
            "        account_list = self.sfe.list_accounts()",
            "",
            "        for account in account_list.accounts:",
            "            if account.username == self.name:",
            "                # Update self.account_id:",
            "                if self.account_id is not None:",
            "                    if account.account_id == self.account_id:",
            "                        return account",
            "                else:",
            "                    self.account_id = account.account_id",
            "                    return account",
            "        return None",
            "",
            "    def create_account(self):",
            "        try:",
            "            self.sfe.add_account(username=self.name,",
            "                                 initiator_secret=self.initiator_secret,",
            "                                 target_secret=self.target_secret,",
            "                                 attributes=self.attributes)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error creating account %s: %s)' % (self.name, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def delete_account(self):",
            "        try:",
            "            self.sfe.remove_account(account_id=self.account_id)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error deleting account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def update_account(self):",
            "        try:",
            "            self.sfe.modify_account(account_id=self.account_id,",
            "                                    username=self.new_name,",
            "                                    status=self.status,",
            "                                    initiator_secret=self.initiator_secret,",
            "                                    target_secret=self.target_secret,",
            "                                    attributes=self.attributes)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error updating account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def apply(self):",
            "        changed = False",
            "        account_exists = False",
            "        update_account = False",
            "        account_detail = self.get_account()",
            "",
            "        if account_detail:",
            "            account_exists = True",
            "",
            "            if self.state == 'absent':",
            "                changed = True",
            "",
            "            elif self.state == 'present':",
            "                # Check if we need to update the account",
            "",
            "                if account_detail.username is not None and self.new_name is not None and \\",
            "                        account_detail.username != self.new_name:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.status is not None and self.status is not None \\",
            "                        and account_detail.status != self.status:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.initiator_secret is not None and self.initiator_secret is not None \\",
            "                        and account_detail.initiator_secret != self.initiator_secret:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.target_secret is not None and self.target_secret is not None \\",
            "                        and account_detail.target_secret != self.target_secret:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.attributes is not None and self.attributes is not None \\",
            "                        and account_detail.attributes != self.attributes:",
            "                    update_account = True",
            "                    changed = True",
            "        else:",
            "            if self.state == 'present':",
            "                changed = True",
            "",
            "        if changed:",
            "            if self.module.check_mode:",
            "                pass",
            "            else:",
            "                if self.state == 'present':",
            "                    if not account_exists:",
            "                        self.create_account()",
            "                    elif update_account:",
            "                        self.update_account()",
            "",
            "                elif self.state == 'absent':",
            "                    self.delete_account()",
            "",
            "        self.module.exit_json(changed=changed)",
            "",
            "",
            "def main():",
            "    v = SolidFireAccount()",
            "    v.apply()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "",
            "# (c) 2017, NetApp, Inc",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['deprecated'],",
            "                    'supported_by': 'community'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "",
            "module: sf_account_manager",
            "deprecated:",
            "  removed_in: \"2.11\"",
            "  why: This Module has been replaced",
            "  alternative: please use M(na_elementsw_account)",
            "short_description: Manage SolidFire accounts",
            "extends_documentation_fragment:",
            "    - netapp.solidfire",
            "version_added: '2.3'",
            "author: Sumit Kumar (@timuster) <sumit4@netapp.com>",
            "description:",
            "- Create, destroy, or update accounts on SolidFire",
            "",
            "options:",
            "",
            "    state:",
            "        description:",
            "        - Whether the specified account should exist or not.",
            "        required: true",
            "        choices: ['present', 'absent']",
            "",
            "    name:",
            "        description:",
            "        - Unique username for this account. (May be 1 to 64 characters in length).",
            "        required: true",
            "",
            "    new_name:",
            "        description:",
            "        - New name for the user account.",
            "",
            "    initiator_secret:",
            "        description:",
            "        - CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.",
            "        - The CHAP initiator secrets must be unique and cannot be the same as the target CHAP secret.",
            "        - If not specified, a random secret is created.",
            "",
            "    target_secret:",
            "        description:",
            "        - CHAP secret to use for the target (mutual CHAP authentication).",
            "        - Should be 12-16 characters long and impenetrable.",
            "        - The CHAP target secrets must be unique and cannot be the same as the initiator CHAP secret.",
            "        - If not specified, a random secret is created.",
            "",
            "    attributes:",
            "        description: List of Name/Value pairs in JSON object format.",
            "",
            "    account_id:",
            "        description:",
            "        - The ID of the account to manage or update.",
            "",
            "    status:",
            "        description:",
            "        - Status of the account.",
            "",
            "'''",
            "",
            "EXAMPLES = \"\"\"",
            "- name: Create Account",
            "  sf_account_manager:",
            "    hostname: \"{{ solidfire_hostname }}\"",
            "    username: \"{{ solidfire_username }}\"",
            "    password: \"{{ solidfire_password }}\"",
            "    state: present",
            "    name: TenantA",
            "",
            "- name: Modify Account",
            "  sf_account_manager:",
            "    hostname: \"{{ solidfire_hostname }}\"",
            "    username: \"{{ solidfire_username }}\"",
            "    password: \"{{ solidfire_password }}\"",
            "    state: present",
            "    name: TenantA",
            "    new_name: TenantA-Renamed",
            "",
            "- name: Delete Account",
            "  sf_account_manager:",
            "    hostname: \"{{ solidfire_hostname }}\"",
            "    username: \"{{ solidfire_username }}\"",
            "    password: \"{{ solidfire_password }}\"",
            "    state: absent",
            "    name: TenantA-Renamed",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "",
            "\"\"\"",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils._text import to_native",
            "import ansible.module_utils.netapp as netapp_utils",
            "",
            "",
            "HAS_SF_SDK = netapp_utils.has_sf_sdk()",
            "",
            "",
            "class SolidFireAccount(object):",
            "",
            "    def __init__(self):",
            "        self.argument_spec = netapp_utils.ontap_sf_host_argument_spec()",
            "        self.argument_spec.update(dict(",
            "            state=dict(required=True, choices=['present', 'absent']),",
            "            name=dict(required=True, type='str'),",
            "            account_id=dict(required=False, type='int', default=None),",
            "",
            "            new_name=dict(required=False, type='str', default=None),",
            "            initiator_secret=dict(required=False, type='str', no_log=True),",
            "            target_secret=dict(required=False, type='str', no_log=True),",
            "            attributes=dict(required=False, type='dict'),",
            "            status=dict(required=False, type='str'),",
            "        ))",
            "",
            "        self.module = AnsibleModule(",
            "            argument_spec=self.argument_spec,",
            "            supports_check_mode=True",
            "        )",
            "",
            "        p = self.module.params",
            "",
            "        # set up state variables",
            "        self.state = p['state']",
            "        self.name = p['name']",
            "        self.account_id = p['account_id']",
            "",
            "        self.new_name = p['new_name']",
            "        self.initiator_secret = p['initiator_secret']",
            "        self.target_secret = p['target_secret']",
            "        self.attributes = p['attributes']",
            "        self.status = p['status']",
            "",
            "        if HAS_SF_SDK is False:",
            "            self.module.fail_json(msg=\"Unable to import the SolidFire Python SDK\")",
            "        else:",
            "            self.sfe = netapp_utils.create_sf_connection(module=self.module)",
            "",
            "    def get_account(self):",
            "        \"\"\"",
            "            Return account object if found",
            "",
            "            :return: Details about the account. None if not found.",
            "            :rtype: dict",
            "        \"\"\"",
            "        account_list = self.sfe.list_accounts()",
            "",
            "        for account in account_list.accounts:",
            "            if account.username == self.name:",
            "                # Update self.account_id:",
            "                if self.account_id is not None:",
            "                    if account.account_id == self.account_id:",
            "                        return account",
            "                else:",
            "                    self.account_id = account.account_id",
            "                    return account",
            "        return None",
            "",
            "    def create_account(self):",
            "        try:",
            "            self.sfe.add_account(username=self.name,",
            "                                 initiator_secret=self.initiator_secret,",
            "                                 target_secret=self.target_secret,",
            "                                 attributes=self.attributes)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error creating account %s: %s)' % (self.name, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def delete_account(self):",
            "        try:",
            "            self.sfe.remove_account(account_id=self.account_id)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error deleting account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def update_account(self):",
            "        try:",
            "            self.sfe.modify_account(account_id=self.account_id,",
            "                                    username=self.new_name,",
            "                                    status=self.status,",
            "                                    initiator_secret=self.initiator_secret,",
            "                                    target_secret=self.target_secret,",
            "                                    attributes=self.attributes)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error updating account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def apply(self):",
            "        changed = False",
            "        account_exists = False",
            "        update_account = False",
            "        account_detail = self.get_account()",
            "",
            "        if account_detail:",
            "            account_exists = True",
            "",
            "            if self.state == 'absent':",
            "                changed = True",
            "",
            "            elif self.state == 'present':",
            "                # Check if we need to update the account",
            "",
            "                if account_detail.username is not None and self.new_name is not None and \\",
            "                        account_detail.username != self.new_name:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.status is not None and self.status is not None \\",
            "                        and account_detail.status != self.status:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.initiator_secret is not None and self.initiator_secret is not None \\",
            "                        and account_detail.initiator_secret != self.initiator_secret:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.target_secret is not None and self.target_secret is not None \\",
            "                        and account_detail.target_secret != self.target_secret:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.attributes is not None and self.attributes is not None \\",
            "                        and account_detail.attributes != self.attributes:",
            "                    update_account = True",
            "                    changed = True",
            "        else:",
            "            if self.state == 'present':",
            "                changed = True",
            "",
            "        if changed:",
            "            if self.module.check_mode:",
            "                pass",
            "            else:",
            "                if self.state == 'present':",
            "                    if not account_exists:",
            "                        self.create_account()",
            "                    elif update_account:",
            "                        self.update_account()",
            "",
            "                elif self.state == 'absent':",
            "                    self.delete_account()",
            "",
            "        self.module.exit_json(changed=changed)",
            "",
            "",
            "def main():",
            "    v = SolidFireAccount()",
            "    v.apply()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "123": [
                "SolidFireAccount",
                "__init__"
            ],
            "124": [
                "SolidFireAccount",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/storage/netapp/na_elementsw_account.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             state=dict(required=True, choices=['present', 'absent']),"
            },
            "1": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             element_username=dict(required=True, aliases=[\"account_id\"], type='str'),"
            },
            "2": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "             from_name=dict(required=False, default=None),"
            },
            "3": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            initiator_secret=dict(required=False, type='str'),"
            },
            "4": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            target_secret=dict(required=False, type='str'),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            initiator_secret=dict(required=False, type='str', no_log=True),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+            target_secret=dict(required=False, type='str', no_log=True),"
            },
            "7": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             attributes=dict(required=False, type='dict'),"
            },
            "8": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "             status=dict(required=False, type='str'),"
            },
            "9": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         ))"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "",
            "# (c) 2018, NetApp, Inc",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "\"\"\"",
            "Element Software Account Manager",
            "\"\"\"",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "",
            "module: na_elementsw_account",
            "",
            "short_description: NetApp Element Software Manage Accounts",
            "extends_documentation_fragment:",
            "    - netapp.solidfire",
            "version_added: '2.7'",
            "author: NetApp Ansible Team (@carchi8py) <ng-ansibleteam@netapp.com>",
            "description:",
            "- Create, destroy, or update accounts on Element SW",
            "",
            "options:",
            "",
            "    state:",
            "        description:",
            "        - Whether the specified account should exist or not.",
            "        required: true",
            "        choices: ['present', 'absent']",
            "",
            "    element_username:",
            "        description:",
            "        - Unique username for this account. (May be 1 to 64 characters in length).",
            "        required: true",
            "        aliases:",
            "        - account_id",
            "",
            "    from_name:",
            "        description:",
            "        - ID or Name of the account to rename.",
            "        - Required to create an account called 'element_username' by renaming 'from_name'.",
            "        version_added: '2.8'",
            "",
            "    initiator_secret:",
            "        description:",
            "        - CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.",
            "        - The CHAP initiator secrets must be unique and cannot be the same as the target CHAP secret.",
            "        - If not specified, a random secret is created.",
            "",
            "    target_secret:",
            "        description:",
            "        - CHAP secret to use for the target (mutual CHAP authentication).",
            "        - Should be 12-16 characters long and impenetrable.",
            "        - The CHAP target secrets must be unique and cannot be the same as the initiator CHAP secret.",
            "        - If not specified, a random secret is created.",
            "",
            "    attributes:",
            "        description: List of Name/Value pairs in JSON object format.",
            "",
            "    status:",
            "        description:",
            "        - Status of the account.",
            "",
            "'''",
            "",
            "EXAMPLES = \"\"\"",
            "- name: Create Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: present",
            "    element_username: TenantA",
            "",
            "- name: Modify Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: present",
            "    status: locked",
            "    element_username: TenantA",
            "",
            "- name: Rename Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: present",
            "    element_username: TenantA_Renamed",
            "    from_name: TenantA",
            "",
            "- name: Rename and modify Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: present",
            "    status: locked",
            "    element_username: TenantA_Renamed",
            "    from_name: TenantA",
            "",
            "- name: Delete Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: absent",
            "    element_username: TenantA_Renamed",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "",
            "\"\"\"",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils._text import to_native",
            "import ansible.module_utils.netapp as netapp_utils",
            "from ansible.module_utils.netapp_elementsw_module import NaElementSWModule",
            "",
            "",
            "HAS_SF_SDK = netapp_utils.has_sf_sdk()",
            "",
            "",
            "class ElementSWAccount(object):",
            "    \"\"\"",
            "    Element SW Account",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.argument_spec = netapp_utils.ontap_sf_host_argument_spec()",
            "        self.argument_spec.update(dict(",
            "            state=dict(required=True, choices=['present', 'absent']),",
            "            element_username=dict(required=True, aliases=[\"account_id\"], type='str'),",
            "            from_name=dict(required=False, default=None),",
            "            initiator_secret=dict(required=False, type='str'),",
            "            target_secret=dict(required=False, type='str'),",
            "            attributes=dict(required=False, type='dict'),",
            "            status=dict(required=False, type='str'),",
            "        ))",
            "",
            "        self.module = AnsibleModule(",
            "            argument_spec=self.argument_spec,",
            "            supports_check_mode=True",
            "        )",
            "",
            "        params = self.module.params",
            "",
            "        # set up state variables",
            "        self.state = params.get('state')",
            "        self.element_username = params.get('element_username')",
            "        self.from_name = params.get('from_name')",
            "        self.initiator_secret = params.get('initiator_secret')",
            "        self.target_secret = params.get('target_secret')",
            "        self.attributes = params.get('attributes')",
            "        self.status = params.get('status')",
            "",
            "        if HAS_SF_SDK is False:",
            "            self.module.fail_json(msg=\"Unable to import the Element SW Python SDK\")",
            "        else:",
            "            self.sfe = netapp_utils.create_sf_connection(module=self.module)",
            "",
            "        self.elementsw_helper = NaElementSWModule(self.sfe)",
            "",
            "        # add telemetry attributes",
            "        if self.attributes is not None:",
            "            self.attributes.update(self.elementsw_helper.set_element_attributes(source='na_elementsw_account'))",
            "        else:",
            "            self.attributes = self.elementsw_helper.set_element_attributes(source='na_elementsw_account')",
            "",
            "    def get_account(self, username):",
            "        \"\"\"",
            "        Get Account",
            "            :description: Get Account object from account id or name",
            "",
            "            :return: Details about the account. None if not found.",
            "            :rtype: object (Account object)",
            "        \"\"\"",
            "",
            "        account_list = self.sfe.list_accounts()",
            "",
            "        for account in account_list.accounts:",
            "            # Check and get account object for a given name",
            "            if str(account.account_id) == username:",
            "                return account",
            "            elif account.username == username:",
            "                return account",
            "        return None",
            "",
            "    def create_account(self):",
            "        \"\"\"",
            "        Create the Account",
            "        \"\"\"",
            "        try:",
            "            self.sfe.add_account(username=self.element_username,",
            "                                 initiator_secret=self.initiator_secret,",
            "                                 target_secret=self.target_secret,",
            "                                 attributes=self.attributes)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error creating account %s: %s' % (self.element_username, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def delete_account(self):",
            "        \"\"\"",
            "        Delete the Account",
            "        \"\"\"",
            "        try:",
            "            self.sfe.remove_account(account_id=self.account_id)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error deleting account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def rename_account(self):",
            "        \"\"\"",
            "        Rename the Account",
            "        \"\"\"",
            "        try:",
            "            self.sfe.modify_account(account_id=self.account_id,",
            "                                    username=self.element_username,",
            "                                    status=self.status,",
            "                                    initiator_secret=self.initiator_secret,",
            "                                    target_secret=self.target_secret,",
            "                                    attributes=self.attributes)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error renaming account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def update_account(self):",
            "        \"\"\"",
            "        Update the Account if account already exists",
            "        \"\"\"",
            "        try:",
            "            self.sfe.modify_account(account_id=self.account_id,",
            "                                    status=self.status,",
            "                                    initiator_secret=self.initiator_secret,",
            "                                    target_secret=self.target_secret,",
            "                                    attributes=self.attributes)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error updating account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def apply(self):",
            "        \"\"\"",
            "        Process the account operation on the Element OS Cluster",
            "        \"\"\"",
            "        changed = False",
            "        update_account = False",
            "        account_detail = self.get_account(self.element_username)",
            "",
            "        if account_detail is None and self.state == 'present':",
            "            changed = True",
            "",
            "        elif account_detail is not None:",
            "            # If account found",
            "            self.account_id = account_detail.account_id",
            "",
            "            if self.state == 'absent':",
            "                changed = True",
            "            else:",
            "                # If state - present, check for any parameter of existing account needs modification.",
            "                if account_detail.username is not None and self.element_username is not None and \\",
            "                        account_detail.username != self.element_username:",
            "                    update_account = True",
            "                    changed = True",
            "                elif account_detail.status is not None and self.status is not None \\",
            "                        and account_detail.status != self.status:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.initiator_secret is not None and self.initiator_secret is not None \\",
            "                        and account_detail.initiator_secret != self.initiator_secret:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.target_secret is not None and self.target_secret is not None \\",
            "                        and account_detail.target_secret != self.target_secret:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.attributes is not None and self.attributes is not None \\",
            "                        and account_detail.attributes != self.attributes:",
            "                    update_account = True",
            "                    changed = True",
            "        if changed:",
            "            if self.module.check_mode:",
            "                # Skipping the changes",
            "                pass",
            "            else:",
            "                if self.state == 'present':",
            "                    if update_account:",
            "                        self.update_account()",
            "                    else:",
            "                        if self.from_name is not None:",
            "                            # If from_name is defined",
            "                            account_exists = self.get_account(self.from_name)",
            "                            if account_exists is not None:",
            "                                # If resource pointed by from_name exists, rename the account to name",
            "                                self.account_id = account_exists.account_id",
            "                                self.rename_account()",
            "                            else:",
            "                                # If resource pointed by from_name does not exists, error out",
            "                                self.module.fail_json(msg=\"Resource does not exist : %s\" % self.from_name)",
            "                        else:",
            "                            # If from_name is not defined, create from scratch.",
            "                            self.create_account()",
            "                elif self.state == 'absent':",
            "                    self.delete_account()",
            "",
            "        self.module.exit_json(changed=changed)",
            "",
            "",
            "def main():",
            "    \"\"\"",
            "    Main function",
            "    \"\"\"",
            "    na_elementsw_account = ElementSWAccount()",
            "    na_elementsw_account.apply()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "",
            "# (c) 2018, NetApp, Inc",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "\"\"\"",
            "Element Software Account Manager",
            "\"\"\"",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {'metadata_version': '1.1',",
            "                    'status': ['preview'],",
            "                    'supported_by': 'certified'}",
            "",
            "",
            "DOCUMENTATION = '''",
            "",
            "module: na_elementsw_account",
            "",
            "short_description: NetApp Element Software Manage Accounts",
            "extends_documentation_fragment:",
            "    - netapp.solidfire",
            "version_added: '2.7'",
            "author: NetApp Ansible Team (@carchi8py) <ng-ansibleteam@netapp.com>",
            "description:",
            "- Create, destroy, or update accounts on Element SW",
            "",
            "options:",
            "",
            "    state:",
            "        description:",
            "        - Whether the specified account should exist or not.",
            "        required: true",
            "        choices: ['present', 'absent']",
            "",
            "    element_username:",
            "        description:",
            "        - Unique username for this account. (May be 1 to 64 characters in length).",
            "        required: true",
            "        aliases:",
            "        - account_id",
            "",
            "    from_name:",
            "        description:",
            "        - ID or Name of the account to rename.",
            "        - Required to create an account called 'element_username' by renaming 'from_name'.",
            "        version_added: '2.8'",
            "",
            "    initiator_secret:",
            "        description:",
            "        - CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.",
            "        - The CHAP initiator secrets must be unique and cannot be the same as the target CHAP secret.",
            "        - If not specified, a random secret is created.",
            "",
            "    target_secret:",
            "        description:",
            "        - CHAP secret to use for the target (mutual CHAP authentication).",
            "        - Should be 12-16 characters long and impenetrable.",
            "        - The CHAP target secrets must be unique and cannot be the same as the initiator CHAP secret.",
            "        - If not specified, a random secret is created.",
            "",
            "    attributes:",
            "        description: List of Name/Value pairs in JSON object format.",
            "",
            "    status:",
            "        description:",
            "        - Status of the account.",
            "",
            "'''",
            "",
            "EXAMPLES = \"\"\"",
            "- name: Create Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: present",
            "    element_username: TenantA",
            "",
            "- name: Modify Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: present",
            "    status: locked",
            "    element_username: TenantA",
            "",
            "- name: Rename Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: present",
            "    element_username: TenantA_Renamed",
            "    from_name: TenantA",
            "",
            "- name: Rename and modify Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: present",
            "    status: locked",
            "    element_username: TenantA_Renamed",
            "    from_name: TenantA",
            "",
            "- name: Delete Account",
            "  na_elementsw_account:",
            "    hostname: \"{{ elementsw_hostname }}\"",
            "    username: \"{{ elementsw_username }}\"",
            "    password: \"{{ elementsw_password }}\"",
            "    state: absent",
            "    element_username: TenantA_Renamed",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "",
            "\"\"\"",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule",
            "from ansible.module_utils._text import to_native",
            "import ansible.module_utils.netapp as netapp_utils",
            "from ansible.module_utils.netapp_elementsw_module import NaElementSWModule",
            "",
            "",
            "HAS_SF_SDK = netapp_utils.has_sf_sdk()",
            "",
            "",
            "class ElementSWAccount(object):",
            "    \"\"\"",
            "    Element SW Account",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.argument_spec = netapp_utils.ontap_sf_host_argument_spec()",
            "        self.argument_spec.update(dict(",
            "            state=dict(required=True, choices=['present', 'absent']),",
            "            element_username=dict(required=True, aliases=[\"account_id\"], type='str'),",
            "            from_name=dict(required=False, default=None),",
            "            initiator_secret=dict(required=False, type='str', no_log=True),",
            "            target_secret=dict(required=False, type='str', no_log=True),",
            "            attributes=dict(required=False, type='dict'),",
            "            status=dict(required=False, type='str'),",
            "        ))",
            "",
            "        self.module = AnsibleModule(",
            "            argument_spec=self.argument_spec,",
            "            supports_check_mode=True",
            "        )",
            "",
            "        params = self.module.params",
            "",
            "        # set up state variables",
            "        self.state = params.get('state')",
            "        self.element_username = params.get('element_username')",
            "        self.from_name = params.get('from_name')",
            "        self.initiator_secret = params.get('initiator_secret')",
            "        self.target_secret = params.get('target_secret')",
            "        self.attributes = params.get('attributes')",
            "        self.status = params.get('status')",
            "",
            "        if HAS_SF_SDK is False:",
            "            self.module.fail_json(msg=\"Unable to import the Element SW Python SDK\")",
            "        else:",
            "            self.sfe = netapp_utils.create_sf_connection(module=self.module)",
            "",
            "        self.elementsw_helper = NaElementSWModule(self.sfe)",
            "",
            "        # add telemetry attributes",
            "        if self.attributes is not None:",
            "            self.attributes.update(self.elementsw_helper.set_element_attributes(source='na_elementsw_account'))",
            "        else:",
            "            self.attributes = self.elementsw_helper.set_element_attributes(source='na_elementsw_account')",
            "",
            "    def get_account(self, username):",
            "        \"\"\"",
            "        Get Account",
            "            :description: Get Account object from account id or name",
            "",
            "            :return: Details about the account. None if not found.",
            "            :rtype: object (Account object)",
            "        \"\"\"",
            "",
            "        account_list = self.sfe.list_accounts()",
            "",
            "        for account in account_list.accounts:",
            "            # Check and get account object for a given name",
            "            if str(account.account_id) == username:",
            "                return account",
            "            elif account.username == username:",
            "                return account",
            "        return None",
            "",
            "    def create_account(self):",
            "        \"\"\"",
            "        Create the Account",
            "        \"\"\"",
            "        try:",
            "            self.sfe.add_account(username=self.element_username,",
            "                                 initiator_secret=self.initiator_secret,",
            "                                 target_secret=self.target_secret,",
            "                                 attributes=self.attributes)",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error creating account %s: %s' % (self.element_username, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def delete_account(self):",
            "        \"\"\"",
            "        Delete the Account",
            "        \"\"\"",
            "        try:",
            "            self.sfe.remove_account(account_id=self.account_id)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error deleting account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def rename_account(self):",
            "        \"\"\"",
            "        Rename the Account",
            "        \"\"\"",
            "        try:",
            "            self.sfe.modify_account(account_id=self.account_id,",
            "                                    username=self.element_username,",
            "                                    status=self.status,",
            "                                    initiator_secret=self.initiator_secret,",
            "                                    target_secret=self.target_secret,",
            "                                    attributes=self.attributes)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error renaming account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def update_account(self):",
            "        \"\"\"",
            "        Update the Account if account already exists",
            "        \"\"\"",
            "        try:",
            "            self.sfe.modify_account(account_id=self.account_id,",
            "                                    status=self.status,",
            "                                    initiator_secret=self.initiator_secret,",
            "                                    target_secret=self.target_secret,",
            "                                    attributes=self.attributes)",
            "",
            "        except Exception as e:",
            "            self.module.fail_json(msg='Error updating account %s: %s' % (self.account_id, to_native(e)),",
            "                                  exception=traceback.format_exc())",
            "",
            "    def apply(self):",
            "        \"\"\"",
            "        Process the account operation on the Element OS Cluster",
            "        \"\"\"",
            "        changed = False",
            "        update_account = False",
            "        account_detail = self.get_account(self.element_username)",
            "",
            "        if account_detail is None and self.state == 'present':",
            "            changed = True",
            "",
            "        elif account_detail is not None:",
            "            # If account found",
            "            self.account_id = account_detail.account_id",
            "",
            "            if self.state == 'absent':",
            "                changed = True",
            "            else:",
            "                # If state - present, check for any parameter of existing account needs modification.",
            "                if account_detail.username is not None and self.element_username is not None and \\",
            "                        account_detail.username != self.element_username:",
            "                    update_account = True",
            "                    changed = True",
            "                elif account_detail.status is not None and self.status is not None \\",
            "                        and account_detail.status != self.status:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.initiator_secret is not None and self.initiator_secret is not None \\",
            "                        and account_detail.initiator_secret != self.initiator_secret:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.target_secret is not None and self.target_secret is not None \\",
            "                        and account_detail.target_secret != self.target_secret:",
            "                    update_account = True",
            "                    changed = True",
            "",
            "                elif account_detail.attributes is not None and self.attributes is not None \\",
            "                        and account_detail.attributes != self.attributes:",
            "                    update_account = True",
            "                    changed = True",
            "        if changed:",
            "            if self.module.check_mode:",
            "                # Skipping the changes",
            "                pass",
            "            else:",
            "                if self.state == 'present':",
            "                    if update_account:",
            "                        self.update_account()",
            "                    else:",
            "                        if self.from_name is not None:",
            "                            # If from_name is defined",
            "                            account_exists = self.get_account(self.from_name)",
            "                            if account_exists is not None:",
            "                                # If resource pointed by from_name exists, rename the account to name",
            "                                self.account_id = account_exists.account_id",
            "                                self.rename_account()",
            "                            else:",
            "                                # If resource pointed by from_name does not exists, error out",
            "                                self.module.fail_json(msg=\"Resource does not exist : %s\" % self.from_name)",
            "                        else:",
            "                            # If from_name is not defined, create from scratch.",
            "                            self.create_account()",
            "                elif self.state == 'absent':",
            "                    self.delete_account()",
            "",
            "        self.module.exit_json(changed=changed)",
            "",
            "",
            "def main():",
            "    \"\"\"",
            "    Main function",
            "    \"\"\"",
            "    na_elementsw_account = ElementSWAccount()",
            "    na_elementsw_account.apply()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "145": [
                "ElementSWAccount",
                "__init__"
            ],
            "146": [
                "ElementSWAccount",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/web_infrastructure/sophos_utm/utm_proxy_auth_profile.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 319,
                "PatchRowcode": "             backend_user_suffix=dict(type='str', required=False, default=\"\"),"
            },
            "1": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "             comment=dict(type='str', required=False, default=\"\"),"
            },
            "2": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "             frontend_cookie=dict(type='str', required=False),"
            },
            "3": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            frontend_cookie_secret=dict(type='str', required=False),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+            frontend_cookie_secret=dict(type='str', required=False, no_log=True),"
            },
            "5": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "             frontend_form=dict(type='str', required=False),"
            },
            "6": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "             frontend_form_template=dict(type='str', required=False, default=\"\"),"
            },
            "7": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "             frontend_login=dict(type='str', required=False),"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "",
            "# Copyright: (c) 2018, Stephan Schwarz <stearz@gmx.de>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {",
            "    'metadata_version': '1.1',",
            "    'status': ['preview'],",
            "    'supported_by': 'community'",
            "}",
            "",
            "DOCUMENTATION = \"\"\"",
            "---",
            "module: utm_proxy_auth_profile",
            "",
            "author:",
            "    - Stephan Schwarz (@stearz)",
            "",
            "short_description: create, update or destroy reverse_proxy auth_profile entry in Sophos UTM",
            "",
            "description:",
            "    - Create, update or destroy a reverse_proxy auth_profile entry in SOPHOS UTM.",
            "    - This module needs to have the REST Ability of the UTM to be activated.",
            "",
            "version_added: \"2.8\"",
            "",
            "options:",
            "    name:",
            "        description:",
            "          - The name of the object. Will be used to identify the entry",
            "        required: true",
            "    aaa:",
            "        description:",
            "          - List of references to utm_aaa objects (allowed users or groups)",
            "        required: true",
            "    basic_prompt:",
            "        description:",
            "          - The message in the basic authentication prompt",
            "        required: true",
            "    backend_mode:",
            "        description:",
            "          - Specifies if the backend server needs authentication ([Basic|None])",
            "        default: None",
            "        choices:",
            "          - Basic",
            "          - None",
            "    backend_strip_basic_auth:",
            "        description:",
            "          - Should the login data be stripped when proxying the request to the backend host",
            "        type: bool",
            "        default: True",
            "        choices:",
            "          - True",
            "          - False",
            "    backend_user_prefix:",
            "        description:",
            "          - Prefix string to prepend to the username for backend authentication",
            "        default: \"\"",
            "    backend_user_suffix:",
            "        description:",
            "          - Suffix string to append to the username for backend authentication",
            "        default: \"\"",
            "    comment:",
            "        description:",
            "          - Optional comment string",
            "        default: \"\"",
            "    frontend_cookie:",
            "        description:",
            "          - Frontend cookie name",
            "    frontend_cookie_secret:",
            "        description:",
            "          - Frontend cookie secret",
            "    frontend_form:",
            "        description:",
            "          - Frontend authentication form name",
            "    frontend_form_template:",
            "        description:",
            "          - Frontend authentication form template",
            "        default: \"\"",
            "    frontend_login:",
            "        description:",
            "          - Frontend login name",
            "    frontend_logout:",
            "        description:",
            "          - Frontend logout name",
            "    frontend_mode:",
            "        description:",
            "          - Frontend authentication mode (Form|Basic)",
            "        default: Basic",
            "        choices:",
            "          - Basic",
            "          - Form",
            "    frontend_realm:",
            "        description:",
            "          - Frontend authentication realm",
            "    frontend_session_allow_persistency:",
            "        description:",
            "          - Allow session persistency",
            "        type: bool",
            "        default: False",
            "        choices:",
            "          - True",
            "          - False",
            "    frontend_session_lifetime:",
            "        description:",
            "          - session lifetime",
            "        required: true",
            "    frontend_session_lifetime_limited:",
            "        description:",
            "          - Specifies if limitation of session lifetime is active",
            "        type: bool",
            "        default: True",
            "        choices:",
            "          - True",
            "          - False",
            "    frontend_session_lifetime_scope:",
            "        description:",
            "          - scope for frontend_session_lifetime (days|hours|minutes)",
            "        default: hours",
            "        choices:",
            "          - days",
            "          - hours",
            "          - minutes",
            "    frontend_session_timeout:",
            "        description:",
            "          - session timeout",
            "        required: true",
            "    frontend_session_timeout_enabled:",
            "        description:",
            "          - Specifies if session timeout is active",
            "        type: bool",
            "        default: True",
            "        choices:",
            "          - True",
            "          - False",
            "    frontend_session_timeout_scope:",
            "        description:",
            "          - scope for frontend_session_timeout (days|hours|minutes)",
            "        default: minutes",
            "        choices:",
            "          - days",
            "          - hours",
            "          - minutes",
            "    logout_delegation_urls:",
            "        description:",
            "          - List of logout URLs that logouts are delegated to",
            "        default: []",
            "    logout_mode:",
            "        description:",
            "          - Mode of logout (None|Delegation)",
            "        default: None",
            "        choices:",
            "          - None",
            "          - Delegation",
            "    redirect_to_requested_url:",
            "        description:",
            "          - Should a redirect to the requested URL be made",
            "        type: bool",
            "        default: False",
            "        choices:",
            "          - True",
            "          - False",
            "",
            "extends_documentation_fragment:",
            "    - utm",
            "\"\"\"",
            "",
            "EXAMPLES = \"\"\"",
            "- name: Create UTM proxy_auth_profile",
            "  utm_proxy_auth_profile:",
            "    utm_host: sophos.host.name",
            "    utm_token: abcdefghijklmno1234",
            "    name: TestAuthProfileEntry",
            "    aaa: [REF_OBJECT_STRING,REF_ANOTHEROBJECT_STRING]",
            "    basic_prompt: \"Authentication required: Please login\"",
            "    frontend_session_lifetime: 1",
            "    frontend_session_timeout: 1",
            "    state: present",
            "",
            "- name: Remove UTM proxy_auth_profile",
            "  utm_proxy_auth_profile:",
            "    utm_host: sophos.host.name",
            "    utm_token: abcdefghijklmno1234",
            "    name: TestAuthProfileEntry",
            "    state: absent",
            "",
            "- name: Read UTM proxy_auth_profile",
            "  utm_proxy_auth_profile:",
            "    utm_host: sophos.host.name",
            "    utm_token: abcdefghijklmno1234",
            "    name: TestAuthProfileEntry",
            "    state: info",
            "",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "result:",
            "    description: The utm object that was created",
            "    returned: success",
            "    type: complex",
            "    contains:",
            "        _ref:",
            "            description: The reference name of the object",
            "            type: str",
            "        _locked:",
            "            description: Whether or not the object is currently locked",
            "            type: bool",
            "        _type:",
            "            description: The type of the object",
            "            type: str",
            "        name:",
            "            description: The name of the object",
            "            type: str",
            "        aaa:",
            "            description: List of references to utm_aaa objects (allowed users or groups)",
            "            type: list",
            "        basic_prompt:",
            "            description: The message in the basic authentication prompt",
            "            type: str",
            "        backend_mode:",
            "            description: Specifies if the backend server needs authentication ([Basic|None])",
            "            type: str",
            "        backend_strip_basic_auth:",
            "            description: Should the login data be stripped when proxying the request to the backend host",
            "            type: bool",
            "        backend_user_prefix:",
            "            description: Prefix string to prepend to the username for backend authentication",
            "            type: str",
            "        backend_user_suffix:",
            "            description: Suffix string to append to the username for backend authentication",
            "            type: str",
            "        comment:",
            "            description: Optional comment string",
            "            type: str",
            "        frontend_cookie:",
            "            description: Frontend cookie name",
            "            type: str",
            "        frontend_cookie_secret:",
            "            description: Frontend cookie secret",
            "            type: str",
            "        frontend_form:",
            "            description: Frontend authentication form name",
            "            type: str",
            "        frontend_form_template:",
            "            description: Frontend authentication form template",
            "            type: str",
            "        frontend_login:",
            "            description: Frontend login name",
            "            type: str",
            "        frontend_logout:",
            "            description: Frontend logout name",
            "            type: str",
            "        frontend_mode:",
            "            description: Frontend authentication mode (Form|Basic)",
            "            type: str",
            "        frontend_realm:",
            "            description: Frontend authentication realm",
            "            type: str",
            "        frontend_session_allow_persistency:",
            "            description: Allow session persistency",
            "            type: bool",
            "        frontend_session_lifetime:",
            "            description: session lifetime",
            "            type: int",
            "        frontend_session_lifetime_limited:",
            "            description: Specifies if limitation of session lifetime is active",
            "            type: bool",
            "        frontend_session_lifetime_scope:",
            "            description: scope for frontend_session_lifetime (days|hours|minutes)",
            "            type: str",
            "        frontend_session_timeout:",
            "            description: session timeout",
            "            type: int",
            "        frontend_session_timeout_enabled:",
            "            description: Specifies if session timeout is active",
            "            type: bool",
            "        frontend_session_timeout_scope:",
            "            description: scope for frontend_session_timeout (days|hours|minutes)",
            "            type: str",
            "        logout_delegation_urls:",
            "            description: List of logout URLs that logouts are delegated to",
            "            type: list",
            "        logout_mode:",
            "            description: Mode of logout (None|Delegation)",
            "            type: str",
            "        redirect_to_requested_url:",
            "            description: Should a redirect to the requested URL be made",
            "            type: bool",
            "\"\"\"",
            "",
            "from ansible.module_utils.utm_utils import UTM, UTMModule",
            "from ansible.module_utils._text import to_native",
            "",
            "",
            "def main():",
            "    endpoint = \"reverse_proxy/auth_profile\"",
            "    key_to_check_for_changes = [\"aaa\", \"basic_prompt\", \"backend_mode\", \"backend_strip_basic_auth\",",
            "                                \"backend_user_prefix\", \"backend_user_suffix\", \"comment\", \"frontend_cookie\",",
            "                                \"frontend_cookie_secret\", \"frontend_form\", \"frontend_form_template\",",
            "                                \"frontend_login\", \"frontend_logout\", \"frontend_mode\", \"frontend_realm\",",
            "                                \"frontend_session_allow_persistency\", \"frontend_session_lifetime\",",
            "                                \"frontend_session_lifetime_limited\", \"frontend_session_lifetime_scope\",",
            "                                \"frontend_session_timeout\", \"frontend_session_timeout_enabled\",",
            "                                \"frontend_session_timeout_scope\", \"logout_delegation_urls\", \"logout_mode\",",
            "                                \"redirect_to_requested_url\"]",
            "",
            "    module = UTMModule(",
            "        argument_spec=dict(",
            "            name=dict(type='str', required=True),",
            "            aaa=dict(type='list', elements='str', required=True),",
            "            basic_prompt=dict(type='str', required=True),",
            "            backend_mode=dict(type='str', required=False, default=\"None\", choices=['Basic', 'None']),",
            "            backend_strip_basic_auth=dict(type='bool', required=False, default=True, choices=[True, False]),",
            "            backend_user_prefix=dict(type='str', required=False, default=\"\"),",
            "            backend_user_suffix=dict(type='str', required=False, default=\"\"),",
            "            comment=dict(type='str', required=False, default=\"\"),",
            "            frontend_cookie=dict(type='str', required=False),",
            "            frontend_cookie_secret=dict(type='str', required=False),",
            "            frontend_form=dict(type='str', required=False),",
            "            frontend_form_template=dict(type='str', required=False, default=\"\"),",
            "            frontend_login=dict(type='str', required=False),",
            "            frontend_logout=dict(type='str', required=False),",
            "            frontend_mode=dict(type='str', required=False, default=\"Basic\", choices=['Basic', 'Form']),",
            "            frontend_realm=dict(type='str', required=False),",
            "            frontend_session_allow_persistency=dict(type='bool', required=False, default=False, choices=[True, False]),",
            "            frontend_session_lifetime=dict(type='int', required=True),",
            "            frontend_session_lifetime_limited=dict(type='bool', required=False, default=True, choices=[True, False]),",
            "            frontend_session_lifetime_scope=dict(type='str', required=False, default=\"hours\", choices=['days', 'hours', 'minutes']),",
            "            frontend_session_timeout=dict(type='int', required=True),",
            "            frontend_session_timeout_enabled=dict(type='bool', required=False, default=True, choices=[True, False]),",
            "            frontend_session_timeout_scope=dict(type='str', required=False, default=\"minutes\", choices=['days', 'hours', 'minutes']),",
            "            logout_delegation_urls=dict(type='list', elements='str', required=False, default=[]),",
            "            logout_mode=dict(type='str', required=False, default=\"None\", choices=['None', 'Delegation']),",
            "            redirect_to_requested_url=dict(type='bool', required=False, default=False, choices=[True, False])",
            "        )",
            "    )",
            "    try:",
            "        UTM(module, endpoint, key_to_check_for_changes).execute()",
            "    except Exception as e:",
            "        module.fail_json(msg=to_native(e))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "",
            "# Copyright: (c) 2018, Stephan Schwarz <stearz@gmx.de>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {",
            "    'metadata_version': '1.1',",
            "    'status': ['preview'],",
            "    'supported_by': 'community'",
            "}",
            "",
            "DOCUMENTATION = \"\"\"",
            "---",
            "module: utm_proxy_auth_profile",
            "",
            "author:",
            "    - Stephan Schwarz (@stearz)",
            "",
            "short_description: create, update or destroy reverse_proxy auth_profile entry in Sophos UTM",
            "",
            "description:",
            "    - Create, update or destroy a reverse_proxy auth_profile entry in SOPHOS UTM.",
            "    - This module needs to have the REST Ability of the UTM to be activated.",
            "",
            "version_added: \"2.8\"",
            "",
            "options:",
            "    name:",
            "        description:",
            "          - The name of the object. Will be used to identify the entry",
            "        required: true",
            "    aaa:",
            "        description:",
            "          - List of references to utm_aaa objects (allowed users or groups)",
            "        required: true",
            "    basic_prompt:",
            "        description:",
            "          - The message in the basic authentication prompt",
            "        required: true",
            "    backend_mode:",
            "        description:",
            "          - Specifies if the backend server needs authentication ([Basic|None])",
            "        default: None",
            "        choices:",
            "          - Basic",
            "          - None",
            "    backend_strip_basic_auth:",
            "        description:",
            "          - Should the login data be stripped when proxying the request to the backend host",
            "        type: bool",
            "        default: True",
            "        choices:",
            "          - True",
            "          - False",
            "    backend_user_prefix:",
            "        description:",
            "          - Prefix string to prepend to the username for backend authentication",
            "        default: \"\"",
            "    backend_user_suffix:",
            "        description:",
            "          - Suffix string to append to the username for backend authentication",
            "        default: \"\"",
            "    comment:",
            "        description:",
            "          - Optional comment string",
            "        default: \"\"",
            "    frontend_cookie:",
            "        description:",
            "          - Frontend cookie name",
            "    frontend_cookie_secret:",
            "        description:",
            "          - Frontend cookie secret",
            "    frontend_form:",
            "        description:",
            "          - Frontend authentication form name",
            "    frontend_form_template:",
            "        description:",
            "          - Frontend authentication form template",
            "        default: \"\"",
            "    frontend_login:",
            "        description:",
            "          - Frontend login name",
            "    frontend_logout:",
            "        description:",
            "          - Frontend logout name",
            "    frontend_mode:",
            "        description:",
            "          - Frontend authentication mode (Form|Basic)",
            "        default: Basic",
            "        choices:",
            "          - Basic",
            "          - Form",
            "    frontend_realm:",
            "        description:",
            "          - Frontend authentication realm",
            "    frontend_session_allow_persistency:",
            "        description:",
            "          - Allow session persistency",
            "        type: bool",
            "        default: False",
            "        choices:",
            "          - True",
            "          - False",
            "    frontend_session_lifetime:",
            "        description:",
            "          - session lifetime",
            "        required: true",
            "    frontend_session_lifetime_limited:",
            "        description:",
            "          - Specifies if limitation of session lifetime is active",
            "        type: bool",
            "        default: True",
            "        choices:",
            "          - True",
            "          - False",
            "    frontend_session_lifetime_scope:",
            "        description:",
            "          - scope for frontend_session_lifetime (days|hours|minutes)",
            "        default: hours",
            "        choices:",
            "          - days",
            "          - hours",
            "          - minutes",
            "    frontend_session_timeout:",
            "        description:",
            "          - session timeout",
            "        required: true",
            "    frontend_session_timeout_enabled:",
            "        description:",
            "          - Specifies if session timeout is active",
            "        type: bool",
            "        default: True",
            "        choices:",
            "          - True",
            "          - False",
            "    frontend_session_timeout_scope:",
            "        description:",
            "          - scope for frontend_session_timeout (days|hours|minutes)",
            "        default: minutes",
            "        choices:",
            "          - days",
            "          - hours",
            "          - minutes",
            "    logout_delegation_urls:",
            "        description:",
            "          - List of logout URLs that logouts are delegated to",
            "        default: []",
            "    logout_mode:",
            "        description:",
            "          - Mode of logout (None|Delegation)",
            "        default: None",
            "        choices:",
            "          - None",
            "          - Delegation",
            "    redirect_to_requested_url:",
            "        description:",
            "          - Should a redirect to the requested URL be made",
            "        type: bool",
            "        default: False",
            "        choices:",
            "          - True",
            "          - False",
            "",
            "extends_documentation_fragment:",
            "    - utm",
            "\"\"\"",
            "",
            "EXAMPLES = \"\"\"",
            "- name: Create UTM proxy_auth_profile",
            "  utm_proxy_auth_profile:",
            "    utm_host: sophos.host.name",
            "    utm_token: abcdefghijklmno1234",
            "    name: TestAuthProfileEntry",
            "    aaa: [REF_OBJECT_STRING,REF_ANOTHEROBJECT_STRING]",
            "    basic_prompt: \"Authentication required: Please login\"",
            "    frontend_session_lifetime: 1",
            "    frontend_session_timeout: 1",
            "    state: present",
            "",
            "- name: Remove UTM proxy_auth_profile",
            "  utm_proxy_auth_profile:",
            "    utm_host: sophos.host.name",
            "    utm_token: abcdefghijklmno1234",
            "    name: TestAuthProfileEntry",
            "    state: absent",
            "",
            "- name: Read UTM proxy_auth_profile",
            "  utm_proxy_auth_profile:",
            "    utm_host: sophos.host.name",
            "    utm_token: abcdefghijklmno1234",
            "    name: TestAuthProfileEntry",
            "    state: info",
            "",
            "\"\"\"",
            "",
            "RETURN = \"\"\"",
            "result:",
            "    description: The utm object that was created",
            "    returned: success",
            "    type: complex",
            "    contains:",
            "        _ref:",
            "            description: The reference name of the object",
            "            type: str",
            "        _locked:",
            "            description: Whether or not the object is currently locked",
            "            type: bool",
            "        _type:",
            "            description: The type of the object",
            "            type: str",
            "        name:",
            "            description: The name of the object",
            "            type: str",
            "        aaa:",
            "            description: List of references to utm_aaa objects (allowed users or groups)",
            "            type: list",
            "        basic_prompt:",
            "            description: The message in the basic authentication prompt",
            "            type: str",
            "        backend_mode:",
            "            description: Specifies if the backend server needs authentication ([Basic|None])",
            "            type: str",
            "        backend_strip_basic_auth:",
            "            description: Should the login data be stripped when proxying the request to the backend host",
            "            type: bool",
            "        backend_user_prefix:",
            "            description: Prefix string to prepend to the username for backend authentication",
            "            type: str",
            "        backend_user_suffix:",
            "            description: Suffix string to append to the username for backend authentication",
            "            type: str",
            "        comment:",
            "            description: Optional comment string",
            "            type: str",
            "        frontend_cookie:",
            "            description: Frontend cookie name",
            "            type: str",
            "        frontend_cookie_secret:",
            "            description: Frontend cookie secret",
            "            type: str",
            "        frontend_form:",
            "            description: Frontend authentication form name",
            "            type: str",
            "        frontend_form_template:",
            "            description: Frontend authentication form template",
            "            type: str",
            "        frontend_login:",
            "            description: Frontend login name",
            "            type: str",
            "        frontend_logout:",
            "            description: Frontend logout name",
            "            type: str",
            "        frontend_mode:",
            "            description: Frontend authentication mode (Form|Basic)",
            "            type: str",
            "        frontend_realm:",
            "            description: Frontend authentication realm",
            "            type: str",
            "        frontend_session_allow_persistency:",
            "            description: Allow session persistency",
            "            type: bool",
            "        frontend_session_lifetime:",
            "            description: session lifetime",
            "            type: int",
            "        frontend_session_lifetime_limited:",
            "            description: Specifies if limitation of session lifetime is active",
            "            type: bool",
            "        frontend_session_lifetime_scope:",
            "            description: scope for frontend_session_lifetime (days|hours|minutes)",
            "            type: str",
            "        frontend_session_timeout:",
            "            description: session timeout",
            "            type: int",
            "        frontend_session_timeout_enabled:",
            "            description: Specifies if session timeout is active",
            "            type: bool",
            "        frontend_session_timeout_scope:",
            "            description: scope for frontend_session_timeout (days|hours|minutes)",
            "            type: str",
            "        logout_delegation_urls:",
            "            description: List of logout URLs that logouts are delegated to",
            "            type: list",
            "        logout_mode:",
            "            description: Mode of logout (None|Delegation)",
            "            type: str",
            "        redirect_to_requested_url:",
            "            description: Should a redirect to the requested URL be made",
            "            type: bool",
            "\"\"\"",
            "",
            "from ansible.module_utils.utm_utils import UTM, UTMModule",
            "from ansible.module_utils._text import to_native",
            "",
            "",
            "def main():",
            "    endpoint = \"reverse_proxy/auth_profile\"",
            "    key_to_check_for_changes = [\"aaa\", \"basic_prompt\", \"backend_mode\", \"backend_strip_basic_auth\",",
            "                                \"backend_user_prefix\", \"backend_user_suffix\", \"comment\", \"frontend_cookie\",",
            "                                \"frontend_cookie_secret\", \"frontend_form\", \"frontend_form_template\",",
            "                                \"frontend_login\", \"frontend_logout\", \"frontend_mode\", \"frontend_realm\",",
            "                                \"frontend_session_allow_persistency\", \"frontend_session_lifetime\",",
            "                                \"frontend_session_lifetime_limited\", \"frontend_session_lifetime_scope\",",
            "                                \"frontend_session_timeout\", \"frontend_session_timeout_enabled\",",
            "                                \"frontend_session_timeout_scope\", \"logout_delegation_urls\", \"logout_mode\",",
            "                                \"redirect_to_requested_url\"]",
            "",
            "    module = UTMModule(",
            "        argument_spec=dict(",
            "            name=dict(type='str', required=True),",
            "            aaa=dict(type='list', elements='str', required=True),",
            "            basic_prompt=dict(type='str', required=True),",
            "            backend_mode=dict(type='str', required=False, default=\"None\", choices=['Basic', 'None']),",
            "            backend_strip_basic_auth=dict(type='bool', required=False, default=True, choices=[True, False]),",
            "            backend_user_prefix=dict(type='str', required=False, default=\"\"),",
            "            backend_user_suffix=dict(type='str', required=False, default=\"\"),",
            "            comment=dict(type='str', required=False, default=\"\"),",
            "            frontend_cookie=dict(type='str', required=False),",
            "            frontend_cookie_secret=dict(type='str', required=False, no_log=True),",
            "            frontend_form=dict(type='str', required=False),",
            "            frontend_form_template=dict(type='str', required=False, default=\"\"),",
            "            frontend_login=dict(type='str', required=False),",
            "            frontend_logout=dict(type='str', required=False),",
            "            frontend_mode=dict(type='str', required=False, default=\"Basic\", choices=['Basic', 'Form']),",
            "            frontend_realm=dict(type='str', required=False),",
            "            frontend_session_allow_persistency=dict(type='bool', required=False, default=False, choices=[True, False]),",
            "            frontend_session_lifetime=dict(type='int', required=True),",
            "            frontend_session_lifetime_limited=dict(type='bool', required=False, default=True, choices=[True, False]),",
            "            frontend_session_lifetime_scope=dict(type='str', required=False, default=\"hours\", choices=['days', 'hours', 'minutes']),",
            "            frontend_session_timeout=dict(type='int', required=True),",
            "            frontend_session_timeout_enabled=dict(type='bool', required=False, default=True, choices=[True, False]),",
            "            frontend_session_timeout_scope=dict(type='str', required=False, default=\"minutes\", choices=['days', 'hours', 'minutes']),",
            "            logout_delegation_urls=dict(type='list', elements='str', required=False, default=[]),",
            "            logout_mode=dict(type='str', required=False, default=\"None\", choices=['None', 'Delegation']),",
            "            redirect_to_requested_url=dict(type='bool', required=False, default=False, choices=[True, False])",
            "        )",
            "    )",
            "    try:",
            "        UTM(module, endpoint, key_to_check_for_changes).execute()",
            "    except Exception as e:",
            "        module.fail_json(msg=to_native(e))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "322": [
                "main"
            ]
        },
        "addLocation": []
    }
}