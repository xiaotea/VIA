{
    "django/core/serializers/xml_serializer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.utils.xmlutils import SimplerXMLGenerator"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.utils.encoding import smart_unicode"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from xml.dom import pulldom"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from xml.sax import handler"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from xml.sax.expatreader import ExpatParser as _ExpatParser"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " class Serializer(base.Serializer):"
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 151,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "     def __init__(self, stream_or_string, **options):"
            },
            "10": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         super(Deserializer, self).__init__(stream_or_string, **options)"
            },
            "11": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.event_stream = pulldom.parse(self.stream)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        self.event_stream = pulldom.parse(self.stream, self._make_parser())"
            },
            "13": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         self.db = options.pop('using', DEFAULT_DB_ALIAS)"
            },
            "14": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    def _make_parser(self):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        \"\"\"Create a hardened XML parser (no custom/external entities).\"\"\""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        return DefusedExpatParser()"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     def next(self):"
            },
            "20": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         for event, node in self.event_stream:"
            },
            "21": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "             if event == \"START_ELEMENT\" and node.nodeName == \"object\":"
            },
            "22": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "         else:"
            },
            "23": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "            pass"
            },
            "24": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "     return u\"\".join(inner_text)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+# Below code based on Christian Heimes' defusedxml"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+class DefusedExpatParser(_ExpatParser):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+    \"\"\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+    An expat parser hardened against XML bomb attacks."
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+    Forbids DTDs, external entity references"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+    \"\"\""
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+    def __init__(self, *args, **kwargs):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+        _ExpatParser.__init__(self, *args, **kwargs)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+        self.setFeature(handler.feature_external_ges, False)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+        self.setFeature(handler.feature_external_pes, False)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+    def start_doctype_decl(self, name, sysid, pubid, has_internal_subset):"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+        raise DTDForbidden(name, sysid, pubid)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+    def entity_decl(self, name, is_parameter_entity, value, base,"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+                    sysid, pubid, notation_name):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+        raise EntitiesForbidden(name, value, base, sysid, pubid, notation_name)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+    def unparsed_entity_decl(self, name, base, sysid, pubid, notation_name):"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+        # expat 1.2"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+        raise EntitiesForbidden(name, None, base, sysid, pubid, notation_name)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+    def external_entity_ref_handler(self, context, base, sysid, pubid):"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+        raise ExternalReferenceForbidden(context, base, sysid, pubid)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+    def reset(self):"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+        _ExpatParser.reset(self)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+        parser = self._parser"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        parser.StartDoctypeDeclHandler = self.start_doctype_decl"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+        parser.EntityDeclHandler = self.entity_decl"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+        parser.UnparsedEntityDeclHandler = self.unparsed_entity_decl"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+        parser.ExternalEntityRefHandler = self.external_entity_ref_handler"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+class DefusedXmlException(ValueError):"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+    \"\"\"Base exception.\"\"\""
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+    def __repr__(self):"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+        return str(self)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+class DTDForbidden(DefusedXmlException):"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+    \"\"\"Document type definition is forbidden.\"\"\""
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+    def __init__(self, name, sysid, pubid):"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+        super(DTDForbidden, self).__init__()"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+        self.name = name"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+        self.sysid = sysid"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+        self.pubid = pubid"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+    def __str__(self):"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+        tpl = \"DTDForbidden(name='{}', system_id={!r}, public_id={!r})\""
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        return tpl.format(self.name, self.sysid, self.pubid)"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+class EntitiesForbidden(DefusedXmlException):"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+    \"\"\"Entity definition is forbidden.\"\"\""
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+    def __init__(self, name, value, base, sysid, pubid, notation_name):"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+        super(EntitiesForbidden, self).__init__()"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        self.name = name"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+        self.value = value"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+        self.base = base"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+        self.sysid = sysid"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+        self.pubid = pubid"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+        self.notation_name = notation_name"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+    def __str__(self):"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+        tpl = \"EntitiesForbidden(name='{}', system_id={!r}, public_id={!r})\""
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+        return tpl.format(self.name, self.sysid, self.pubid)"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+class ExternalReferenceForbidden(DefusedXmlException):"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+    \"\"\"Resolving an external reference is forbidden.\"\"\""
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+    def __init__(self, context, base, sysid, pubid):"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+        super(ExternalReferenceForbidden, self).__init__()"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+        self.context = context"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+        self.base = base"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+        self.sysid = sysid"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+        self.pubid = pubid"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+    def __str__(self):"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+        tpl = \"ExternalReferenceForbidden(system_id='{}', public_id={})\""
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+        return tpl.format(self.sysid, self.pubid)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "XML serializer.",
            "\"\"\"",
            "",
            "from django.conf import settings",
            "from django.core.serializers import base",
            "from django.db import models, DEFAULT_DB_ALIAS",
            "from django.utils.xmlutils import SimplerXMLGenerator",
            "from django.utils.encoding import smart_unicode",
            "from xml.dom import pulldom",
            "",
            "class Serializer(base.Serializer):",
            "    \"\"\"",
            "    Serializes a QuerySet to XML.",
            "    \"\"\"",
            "",
            "    def indent(self, level):",
            "        if self.options.get('indent', None) is not None:",
            "            self.xml.ignorableWhitespace('\\n' + ' ' * self.options.get('indent', None) * level)",
            "",
            "    def start_serialization(self):",
            "        \"\"\"",
            "        Start serialization -- open the XML document and the root element.",
            "        \"\"\"",
            "        self.xml = SimplerXMLGenerator(self.stream, self.options.get(\"encoding\", settings.DEFAULT_CHARSET))",
            "        self.xml.startDocument()",
            "        self.xml.startElement(\"django-objects\", {\"version\" : \"1.0\"})",
            "",
            "    def end_serialization(self):",
            "        \"\"\"",
            "        End serialization -- end the document.",
            "        \"\"\"",
            "        self.indent(0)",
            "        self.xml.endElement(\"django-objects\")",
            "        self.xml.endDocument()",
            "",
            "    def start_object(self, obj):",
            "        \"\"\"",
            "        Called as each object is handled.",
            "        \"\"\"",
            "        if not hasattr(obj, \"_meta\"):",
            "            raise base.SerializationError(\"Non-model object (%s) encountered during serialization\" % type(obj))",
            "",
            "        self.indent(1)",
            "        obj_pk = obj._get_pk_val()",
            "        if obj_pk is None:",
            "            attrs = {\"model\": smart_unicode(obj._meta),}",
            "        else:",
            "            attrs = {",
            "                \"pk\": smart_unicode(obj._get_pk_val()),",
            "                \"model\": smart_unicode(obj._meta),",
            "            }",
            "",
            "        self.xml.startElement(\"object\", attrs)",
            "",
            "    def end_object(self, obj):",
            "        \"\"\"",
            "        Called after handling all fields for an object.",
            "        \"\"\"",
            "        self.indent(1)",
            "        self.xml.endElement(\"object\")",
            "",
            "    def handle_field(self, obj, field):",
            "        \"\"\"",
            "        Called to handle each field on an object (except for ForeignKeys and",
            "        ManyToManyFields)",
            "        \"\"\"",
            "        self.indent(2)",
            "        self.xml.startElement(\"field\", {",
            "            \"name\" : field.name,",
            "            \"type\" : field.get_internal_type()",
            "        })",
            "",
            "        # Get a \"string version\" of the object's data.",
            "        if getattr(obj, field.name) is not None:",
            "            self.xml.characters(field.value_to_string(obj))",
            "        else:",
            "            self.xml.addQuickElement(\"None\")",
            "",
            "        self.xml.endElement(\"field\")",
            "",
            "    def handle_fk_field(self, obj, field):",
            "        \"\"\"",
            "        Called to handle a ForeignKey (we need to treat them slightly",
            "        differently from regular fields).",
            "        \"\"\"",
            "        self._start_relational_field(field)",
            "        related_att = getattr(obj, field.get_attname())",
            "        if related_att is not None:",
            "            if self.use_natural_keys and hasattr(field.rel.to, 'natural_key'):",
            "                related = getattr(obj, field.name)",
            "                # If related object has a natural key, use it",
            "                related = related.natural_key()",
            "                # Iterable natural keys are rolled out as subelements",
            "                for key_value in related:",
            "                    self.xml.startElement(\"natural\", {})",
            "                    self.xml.characters(smart_unicode(key_value))",
            "                    self.xml.endElement(\"natural\")",
            "            else:",
            "                self.xml.characters(smart_unicode(related_att))",
            "        else:",
            "            self.xml.addQuickElement(\"None\")",
            "        self.xml.endElement(\"field\")",
            "",
            "    def handle_m2m_field(self, obj, field):",
            "        \"\"\"",
            "        Called to handle a ManyToManyField. Related objects are only",
            "        serialized as references to the object's PK (i.e. the related *data*",
            "        is not dumped, just the relation).",
            "        \"\"\"",
            "        if field.rel.through._meta.auto_created:",
            "            self._start_relational_field(field)",
            "            if self.use_natural_keys and hasattr(field.rel.to, 'natural_key'):",
            "                # If the objects in the m2m have a natural key, use it",
            "                def handle_m2m(value):",
            "                    natural = value.natural_key()",
            "                    # Iterable natural keys are rolled out as subelements",
            "                    self.xml.startElement(\"object\", {})",
            "                    for key_value in natural:",
            "                        self.xml.startElement(\"natural\", {})",
            "                        self.xml.characters(smart_unicode(key_value))",
            "                        self.xml.endElement(\"natural\")",
            "                    self.xml.endElement(\"object\")",
            "            else:",
            "                def handle_m2m(value):",
            "                    self.xml.addQuickElement(\"object\", attrs={",
            "                        'pk' : smart_unicode(value._get_pk_val())",
            "                    })",
            "            for relobj in getattr(obj, field.name).iterator():",
            "                handle_m2m(relobj)",
            "",
            "            self.xml.endElement(\"field\")",
            "",
            "    def _start_relational_field(self, field):",
            "        \"\"\"",
            "        Helper to output the <field> element for relational fields",
            "        \"\"\"",
            "        self.indent(2)",
            "        self.xml.startElement(\"field\", {",
            "            \"name\" : field.name,",
            "            \"rel\"  : field.rel.__class__.__name__,",
            "            \"to\"   : smart_unicode(field.rel.to._meta),",
            "        })",
            "",
            "class Deserializer(base.Deserializer):",
            "    \"\"\"",
            "    Deserialize XML.",
            "    \"\"\"",
            "",
            "    def __init__(self, stream_or_string, **options):",
            "        super(Deserializer, self).__init__(stream_or_string, **options)",
            "        self.event_stream = pulldom.parse(self.stream)",
            "        self.db = options.pop('using', DEFAULT_DB_ALIAS)",
            "",
            "    def next(self):",
            "        for event, node in self.event_stream:",
            "            if event == \"START_ELEMENT\" and node.nodeName == \"object\":",
            "                self.event_stream.expandNode(node)",
            "                return self._handle_object(node)",
            "        raise StopIteration",
            "",
            "    def _handle_object(self, node):",
            "        \"\"\"",
            "        Convert an <object> node to a DeserializedObject.",
            "        \"\"\"",
            "        # Look up the model using the model loading mechanism. If this fails,",
            "        # bail.",
            "        Model = self._get_model_from_node(node, \"model\")",
            "",
            "        # Start building a data dictionary from the object.",
            "        # If the node is missing the pk set it to None",
            "        if node.hasAttribute(\"pk\"):",
            "            pk = node.getAttribute(\"pk\")",
            "        else:",
            "            pk = None",
            "",
            "        data = {Model._meta.pk.attname : Model._meta.pk.to_python(pk)}",
            "",
            "        # Also start building a dict of m2m data (this is saved as",
            "        # {m2m_accessor_attribute : [list_of_related_objects]})",
            "        m2m_data = {}",
            "",
            "        # Deseralize each field.",
            "        for field_node in node.getElementsByTagName(\"field\"):",
            "            # If the field is missing the name attribute, bail (are you",
            "            # sensing a pattern here?)",
            "            field_name = field_node.getAttribute(\"name\")",
            "            if not field_name:",
            "                raise base.DeserializationError(\"<field> node is missing the 'name' attribute\")",
            "",
            "            # Get the field from the Model. This will raise a",
            "            # FieldDoesNotExist if, well, the field doesn't exist, which will",
            "            # be propagated correctly.",
            "            field = Model._meta.get_field(field_name)",
            "",
            "            # As is usually the case, relation fields get the special treatment.",
            "            if field.rel and isinstance(field.rel, models.ManyToManyRel):",
            "                m2m_data[field.name] = self._handle_m2m_field_node(field_node, field)",
            "            elif field.rel and isinstance(field.rel, models.ManyToOneRel):",
            "                data[field.attname] = self._handle_fk_field_node(field_node, field)",
            "            else:",
            "                if field_node.getElementsByTagName('None'):",
            "                    value = None",
            "                else:",
            "                    value = field.to_python(getInnerText(field_node).strip())",
            "                data[field.name] = value",
            "",
            "        # Return a DeserializedObject so that the m2m data has a place to live.",
            "        return base.DeserializedObject(Model(**data), m2m_data)",
            "",
            "    def _handle_fk_field_node(self, node, field):",
            "        \"\"\"",
            "        Handle a <field> node for a ForeignKey",
            "        \"\"\"",
            "        # Check if there is a child node named 'None', returning None if so.",
            "        if node.getElementsByTagName('None'):",
            "            return None",
            "        else:",
            "            if hasattr(field.rel.to._default_manager, 'get_by_natural_key'):",
            "                keys = node.getElementsByTagName('natural')",
            "                if keys:",
            "                    # If there are 'natural' subelements, it must be a natural key",
            "                    field_value = [getInnerText(k).strip() for k in keys]",
            "                    obj = field.rel.to._default_manager.db_manager(self.db).get_by_natural_key(*field_value)",
            "                    obj_pk = getattr(obj, field.rel.field_name)",
            "                    # If this is a natural foreign key to an object that",
            "                    # has a FK/O2O as the foreign key, use the FK value",
            "                    if field.rel.to._meta.pk.rel:",
            "                        obj_pk = obj_pk.pk",
            "                else:",
            "                    # Otherwise, treat like a normal PK",
            "                    field_value = getInnerText(node).strip()",
            "                    obj_pk = field.rel.to._meta.get_field(field.rel.field_name).to_python(field_value)",
            "                return obj_pk",
            "            else:",
            "                field_value = getInnerText(node).strip()",
            "                return field.rel.to._meta.get_field(field.rel.field_name).to_python(field_value)",
            "",
            "    def _handle_m2m_field_node(self, node, field):",
            "        \"\"\"",
            "        Handle a <field> node for a ManyToManyField.",
            "        \"\"\"",
            "        if hasattr(field.rel.to._default_manager, 'get_by_natural_key'):",
            "            def m2m_convert(n):",
            "                keys = n.getElementsByTagName('natural')",
            "                if keys:",
            "                    # If there are 'natural' subelements, it must be a natural key",
            "                    field_value = [getInnerText(k).strip() for k in keys]",
            "                    obj_pk = field.rel.to._default_manager.db_manager(self.db).get_by_natural_key(*field_value).pk",
            "                else:",
            "                    # Otherwise, treat like a normal PK value.",
            "                    obj_pk = field.rel.to._meta.pk.to_python(n.getAttribute('pk'))",
            "                return obj_pk",
            "        else:",
            "            m2m_convert = lambda n: field.rel.to._meta.pk.to_python(n.getAttribute('pk'))",
            "        return [m2m_convert(c) for c in node.getElementsByTagName(\"object\")]",
            "",
            "    def _get_model_from_node(self, node, attr):",
            "        \"\"\"",
            "        Helper to look up a model from a <object model=...> or a <field",
            "        rel=... to=...> node.",
            "        \"\"\"",
            "        model_identifier = node.getAttribute(attr)",
            "        if not model_identifier:",
            "            raise base.DeserializationError(",
            "                \"<%s> node is missing the required '%s' attribute\" \\",
            "                    % (node.nodeName, attr))",
            "        try:",
            "            Model = models.get_model(*model_identifier.split(\".\"))",
            "        except TypeError:",
            "            Model = None",
            "        if Model is None:",
            "            raise base.DeserializationError(",
            "                \"<%s> node has invalid model identifier: '%s'\" % \\",
            "                    (node.nodeName, model_identifier))",
            "        return Model",
            "",
            "",
            "def getInnerText(node):",
            "    \"\"\"",
            "    Get all the inner text of a DOM node (recursively).",
            "    \"\"\"",
            "    # inspired by http://mail.python.org/pipermail/xml-sig/2005-March/011022.html",
            "    inner_text = []",
            "    for child in node.childNodes:",
            "        if child.nodeType == child.TEXT_NODE or child.nodeType == child.CDATA_SECTION_NODE:",
            "            inner_text.append(child.data)",
            "        elif child.nodeType == child.ELEMENT_NODE:",
            "            inner_text.extend(getInnerText(child))",
            "        else:",
            "           pass",
            "    return u\"\".join(inner_text)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "XML serializer.",
            "\"\"\"",
            "",
            "from django.conf import settings",
            "from django.core.serializers import base",
            "from django.db import models, DEFAULT_DB_ALIAS",
            "from django.utils.xmlutils import SimplerXMLGenerator",
            "from django.utils.encoding import smart_unicode",
            "from xml.dom import pulldom",
            "from xml.sax import handler",
            "from xml.sax.expatreader import ExpatParser as _ExpatParser",
            "",
            "class Serializer(base.Serializer):",
            "    \"\"\"",
            "    Serializes a QuerySet to XML.",
            "    \"\"\"",
            "",
            "    def indent(self, level):",
            "        if self.options.get('indent', None) is not None:",
            "            self.xml.ignorableWhitespace('\\n' + ' ' * self.options.get('indent', None) * level)",
            "",
            "    def start_serialization(self):",
            "        \"\"\"",
            "        Start serialization -- open the XML document and the root element.",
            "        \"\"\"",
            "        self.xml = SimplerXMLGenerator(self.stream, self.options.get(\"encoding\", settings.DEFAULT_CHARSET))",
            "        self.xml.startDocument()",
            "        self.xml.startElement(\"django-objects\", {\"version\" : \"1.0\"})",
            "",
            "    def end_serialization(self):",
            "        \"\"\"",
            "        End serialization -- end the document.",
            "        \"\"\"",
            "        self.indent(0)",
            "        self.xml.endElement(\"django-objects\")",
            "        self.xml.endDocument()",
            "",
            "    def start_object(self, obj):",
            "        \"\"\"",
            "        Called as each object is handled.",
            "        \"\"\"",
            "        if not hasattr(obj, \"_meta\"):",
            "            raise base.SerializationError(\"Non-model object (%s) encountered during serialization\" % type(obj))",
            "",
            "        self.indent(1)",
            "        obj_pk = obj._get_pk_val()",
            "        if obj_pk is None:",
            "            attrs = {\"model\": smart_unicode(obj._meta),}",
            "        else:",
            "            attrs = {",
            "                \"pk\": smart_unicode(obj._get_pk_val()),",
            "                \"model\": smart_unicode(obj._meta),",
            "            }",
            "",
            "        self.xml.startElement(\"object\", attrs)",
            "",
            "    def end_object(self, obj):",
            "        \"\"\"",
            "        Called after handling all fields for an object.",
            "        \"\"\"",
            "        self.indent(1)",
            "        self.xml.endElement(\"object\")",
            "",
            "    def handle_field(self, obj, field):",
            "        \"\"\"",
            "        Called to handle each field on an object (except for ForeignKeys and",
            "        ManyToManyFields)",
            "        \"\"\"",
            "        self.indent(2)",
            "        self.xml.startElement(\"field\", {",
            "            \"name\" : field.name,",
            "            \"type\" : field.get_internal_type()",
            "        })",
            "",
            "        # Get a \"string version\" of the object's data.",
            "        if getattr(obj, field.name) is not None:",
            "            self.xml.characters(field.value_to_string(obj))",
            "        else:",
            "            self.xml.addQuickElement(\"None\")",
            "",
            "        self.xml.endElement(\"field\")",
            "",
            "    def handle_fk_field(self, obj, field):",
            "        \"\"\"",
            "        Called to handle a ForeignKey (we need to treat them slightly",
            "        differently from regular fields).",
            "        \"\"\"",
            "        self._start_relational_field(field)",
            "        related_att = getattr(obj, field.get_attname())",
            "        if related_att is not None:",
            "            if self.use_natural_keys and hasattr(field.rel.to, 'natural_key'):",
            "                related = getattr(obj, field.name)",
            "                # If related object has a natural key, use it",
            "                related = related.natural_key()",
            "                # Iterable natural keys are rolled out as subelements",
            "                for key_value in related:",
            "                    self.xml.startElement(\"natural\", {})",
            "                    self.xml.characters(smart_unicode(key_value))",
            "                    self.xml.endElement(\"natural\")",
            "            else:",
            "                self.xml.characters(smart_unicode(related_att))",
            "        else:",
            "            self.xml.addQuickElement(\"None\")",
            "        self.xml.endElement(\"field\")",
            "",
            "    def handle_m2m_field(self, obj, field):",
            "        \"\"\"",
            "        Called to handle a ManyToManyField. Related objects are only",
            "        serialized as references to the object's PK (i.e. the related *data*",
            "        is not dumped, just the relation).",
            "        \"\"\"",
            "        if field.rel.through._meta.auto_created:",
            "            self._start_relational_field(field)",
            "            if self.use_natural_keys and hasattr(field.rel.to, 'natural_key'):",
            "                # If the objects in the m2m have a natural key, use it",
            "                def handle_m2m(value):",
            "                    natural = value.natural_key()",
            "                    # Iterable natural keys are rolled out as subelements",
            "                    self.xml.startElement(\"object\", {})",
            "                    for key_value in natural:",
            "                        self.xml.startElement(\"natural\", {})",
            "                        self.xml.characters(smart_unicode(key_value))",
            "                        self.xml.endElement(\"natural\")",
            "                    self.xml.endElement(\"object\")",
            "            else:",
            "                def handle_m2m(value):",
            "                    self.xml.addQuickElement(\"object\", attrs={",
            "                        'pk' : smart_unicode(value._get_pk_val())",
            "                    })",
            "            for relobj in getattr(obj, field.name).iterator():",
            "                handle_m2m(relobj)",
            "",
            "            self.xml.endElement(\"field\")",
            "",
            "    def _start_relational_field(self, field):",
            "        \"\"\"",
            "        Helper to output the <field> element for relational fields",
            "        \"\"\"",
            "        self.indent(2)",
            "        self.xml.startElement(\"field\", {",
            "            \"name\" : field.name,",
            "            \"rel\"  : field.rel.__class__.__name__,",
            "            \"to\"   : smart_unicode(field.rel.to._meta),",
            "        })",
            "",
            "class Deserializer(base.Deserializer):",
            "    \"\"\"",
            "    Deserialize XML.",
            "    \"\"\"",
            "",
            "    def __init__(self, stream_or_string, **options):",
            "        super(Deserializer, self).__init__(stream_or_string, **options)",
            "        self.event_stream = pulldom.parse(self.stream, self._make_parser())",
            "        self.db = options.pop('using', DEFAULT_DB_ALIAS)",
            "",
            "    def _make_parser(self):",
            "        \"\"\"Create a hardened XML parser (no custom/external entities).\"\"\"",
            "        return DefusedExpatParser()",
            "",
            "    def next(self):",
            "        for event, node in self.event_stream:",
            "            if event == \"START_ELEMENT\" and node.nodeName == \"object\":",
            "                self.event_stream.expandNode(node)",
            "                return self._handle_object(node)",
            "        raise StopIteration",
            "",
            "    def _handle_object(self, node):",
            "        \"\"\"",
            "        Convert an <object> node to a DeserializedObject.",
            "        \"\"\"",
            "        # Look up the model using the model loading mechanism. If this fails,",
            "        # bail.",
            "        Model = self._get_model_from_node(node, \"model\")",
            "",
            "        # Start building a data dictionary from the object.",
            "        # If the node is missing the pk set it to None",
            "        if node.hasAttribute(\"pk\"):",
            "            pk = node.getAttribute(\"pk\")",
            "        else:",
            "            pk = None",
            "",
            "        data = {Model._meta.pk.attname : Model._meta.pk.to_python(pk)}",
            "",
            "        # Also start building a dict of m2m data (this is saved as",
            "        # {m2m_accessor_attribute : [list_of_related_objects]})",
            "        m2m_data = {}",
            "",
            "        # Deseralize each field.",
            "        for field_node in node.getElementsByTagName(\"field\"):",
            "            # If the field is missing the name attribute, bail (are you",
            "            # sensing a pattern here?)",
            "            field_name = field_node.getAttribute(\"name\")",
            "            if not field_name:",
            "                raise base.DeserializationError(\"<field> node is missing the 'name' attribute\")",
            "",
            "            # Get the field from the Model. This will raise a",
            "            # FieldDoesNotExist if, well, the field doesn't exist, which will",
            "            # be propagated correctly.",
            "            field = Model._meta.get_field(field_name)",
            "",
            "            # As is usually the case, relation fields get the special treatment.",
            "            if field.rel and isinstance(field.rel, models.ManyToManyRel):",
            "                m2m_data[field.name] = self._handle_m2m_field_node(field_node, field)",
            "            elif field.rel and isinstance(field.rel, models.ManyToOneRel):",
            "                data[field.attname] = self._handle_fk_field_node(field_node, field)",
            "            else:",
            "                if field_node.getElementsByTagName('None'):",
            "                    value = None",
            "                else:",
            "                    value = field.to_python(getInnerText(field_node).strip())",
            "                data[field.name] = value",
            "",
            "        # Return a DeserializedObject so that the m2m data has a place to live.",
            "        return base.DeserializedObject(Model(**data), m2m_data)",
            "",
            "    def _handle_fk_field_node(self, node, field):",
            "        \"\"\"",
            "        Handle a <field> node for a ForeignKey",
            "        \"\"\"",
            "        # Check if there is a child node named 'None', returning None if so.",
            "        if node.getElementsByTagName('None'):",
            "            return None",
            "        else:",
            "            if hasattr(field.rel.to._default_manager, 'get_by_natural_key'):",
            "                keys = node.getElementsByTagName('natural')",
            "                if keys:",
            "                    # If there are 'natural' subelements, it must be a natural key",
            "                    field_value = [getInnerText(k).strip() for k in keys]",
            "                    obj = field.rel.to._default_manager.db_manager(self.db).get_by_natural_key(*field_value)",
            "                    obj_pk = getattr(obj, field.rel.field_name)",
            "                    # If this is a natural foreign key to an object that",
            "                    # has a FK/O2O as the foreign key, use the FK value",
            "                    if field.rel.to._meta.pk.rel:",
            "                        obj_pk = obj_pk.pk",
            "                else:",
            "                    # Otherwise, treat like a normal PK",
            "                    field_value = getInnerText(node).strip()",
            "                    obj_pk = field.rel.to._meta.get_field(field.rel.field_name).to_python(field_value)",
            "                return obj_pk",
            "            else:",
            "                field_value = getInnerText(node).strip()",
            "                return field.rel.to._meta.get_field(field.rel.field_name).to_python(field_value)",
            "",
            "    def _handle_m2m_field_node(self, node, field):",
            "        \"\"\"",
            "        Handle a <field> node for a ManyToManyField.",
            "        \"\"\"",
            "        if hasattr(field.rel.to._default_manager, 'get_by_natural_key'):",
            "            def m2m_convert(n):",
            "                keys = n.getElementsByTagName('natural')",
            "                if keys:",
            "                    # If there are 'natural' subelements, it must be a natural key",
            "                    field_value = [getInnerText(k).strip() for k in keys]",
            "                    obj_pk = field.rel.to._default_manager.db_manager(self.db).get_by_natural_key(*field_value).pk",
            "                else:",
            "                    # Otherwise, treat like a normal PK value.",
            "                    obj_pk = field.rel.to._meta.pk.to_python(n.getAttribute('pk'))",
            "                return obj_pk",
            "        else:",
            "            m2m_convert = lambda n: field.rel.to._meta.pk.to_python(n.getAttribute('pk'))",
            "        return [m2m_convert(c) for c in node.getElementsByTagName(\"object\")]",
            "",
            "    def _get_model_from_node(self, node, attr):",
            "        \"\"\"",
            "        Helper to look up a model from a <object model=...> or a <field",
            "        rel=... to=...> node.",
            "        \"\"\"",
            "        model_identifier = node.getAttribute(attr)",
            "        if not model_identifier:",
            "            raise base.DeserializationError(",
            "                \"<%s> node is missing the required '%s' attribute\" \\",
            "                    % (node.nodeName, attr))",
            "        try:",
            "            Model = models.get_model(*model_identifier.split(\".\"))",
            "        except TypeError:",
            "            Model = None",
            "        if Model is None:",
            "            raise base.DeserializationError(",
            "                \"<%s> node has invalid model identifier: '%s'\" % \\",
            "                    (node.nodeName, model_identifier))",
            "        return Model",
            "",
            "",
            "def getInnerText(node):",
            "    \"\"\"",
            "    Get all the inner text of a DOM node (recursively).",
            "    \"\"\"",
            "    # inspired by http://mail.python.org/pipermail/xml-sig/2005-March/011022.html",
            "    inner_text = []",
            "    for child in node.childNodes:",
            "        if child.nodeType == child.TEXT_NODE or child.nodeType == child.CDATA_SECTION_NODE:",
            "            inner_text.append(child.data)",
            "        elif child.nodeType == child.ELEMENT_NODE:",
            "            inner_text.extend(getInnerText(child))",
            "        else:",
            "           pass",
            "    return u\"\".join(inner_text)",
            "",
            "",
            "# Below code based on Christian Heimes' defusedxml",
            "",
            "",
            "class DefusedExpatParser(_ExpatParser):",
            "    \"\"\"",
            "    An expat parser hardened against XML bomb attacks.",
            "",
            "    Forbids DTDs, external entity references",
            "",
            "    \"\"\"",
            "    def __init__(self, *args, **kwargs):",
            "        _ExpatParser.__init__(self, *args, **kwargs)",
            "        self.setFeature(handler.feature_external_ges, False)",
            "        self.setFeature(handler.feature_external_pes, False)",
            "",
            "    def start_doctype_decl(self, name, sysid, pubid, has_internal_subset):",
            "        raise DTDForbidden(name, sysid, pubid)",
            "",
            "    def entity_decl(self, name, is_parameter_entity, value, base,",
            "                    sysid, pubid, notation_name):",
            "        raise EntitiesForbidden(name, value, base, sysid, pubid, notation_name)",
            "",
            "    def unparsed_entity_decl(self, name, base, sysid, pubid, notation_name):",
            "        # expat 1.2",
            "        raise EntitiesForbidden(name, None, base, sysid, pubid, notation_name)",
            "",
            "    def external_entity_ref_handler(self, context, base, sysid, pubid):",
            "        raise ExternalReferenceForbidden(context, base, sysid, pubid)",
            "",
            "    def reset(self):",
            "        _ExpatParser.reset(self)",
            "        parser = self._parser",
            "        parser.StartDoctypeDeclHandler = self.start_doctype_decl",
            "        parser.EntityDeclHandler = self.entity_decl",
            "        parser.UnparsedEntityDeclHandler = self.unparsed_entity_decl",
            "        parser.ExternalEntityRefHandler = self.external_entity_ref_handler",
            "",
            "",
            "class DefusedXmlException(ValueError):",
            "    \"\"\"Base exception.\"\"\"",
            "    def __repr__(self):",
            "        return str(self)",
            "",
            "",
            "class DTDForbidden(DefusedXmlException):",
            "    \"\"\"Document type definition is forbidden.\"\"\"",
            "    def __init__(self, name, sysid, pubid):",
            "        super(DTDForbidden, self).__init__()",
            "        self.name = name",
            "        self.sysid = sysid",
            "        self.pubid = pubid",
            "",
            "    def __str__(self):",
            "        tpl = \"DTDForbidden(name='{}', system_id={!r}, public_id={!r})\"",
            "        return tpl.format(self.name, self.sysid, self.pubid)",
            "",
            "",
            "class EntitiesForbidden(DefusedXmlException):",
            "    \"\"\"Entity definition is forbidden.\"\"\"",
            "    def __init__(self, name, value, base, sysid, pubid, notation_name):",
            "        super(EntitiesForbidden, self).__init__()",
            "        self.name = name",
            "        self.value = value",
            "        self.base = base",
            "        self.sysid = sysid",
            "        self.pubid = pubid",
            "        self.notation_name = notation_name",
            "",
            "    def __str__(self):",
            "        tpl = \"EntitiesForbidden(name='{}', system_id={!r}, public_id={!r})\"",
            "        return tpl.format(self.name, self.sysid, self.pubid)",
            "",
            "",
            "class ExternalReferenceForbidden(DefusedXmlException):",
            "    \"\"\"Resolving an external reference is forbidden.\"\"\"",
            "    def __init__(self, context, base, sysid, pubid):",
            "        super(ExternalReferenceForbidden, self).__init__()",
            "        self.context = context",
            "        self.base = base",
            "        self.sysid = sysid",
            "        self.pubid = pubid",
            "",
            "    def __str__(self):",
            "        tpl = \"ExternalReferenceForbidden(system_id='{}', public_id={})\"",
            "        return tpl.format(self.sysid, self.pubid)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "152": [
                "Deserializer",
                "__init__"
            ]
        },
        "addLocation": []
    }
}