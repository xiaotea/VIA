{
    "nova/tests/unit/virt/xenapi/test_volume_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from eventlet import greenthread"
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import mock"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+import six"
            },
            "4": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from nova import exception"
            },
            "6": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from nova import test"
            },
            "7": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "                          'target_lun': None,"
            },
            "8": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "                          'auth_method': 'CHAP',"
            },
            "9": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "                          'auth_username': 'username',"
            },
            "10": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                         'auth_password': 'password'}}"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+                         'auth_password': 'verybadpass'}}"
            },
            "12": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     def test_parse_volume_info_parsing_auth_details(self):"
            },
            "14": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         conn_info = self._make_connection_info()"
            },
            "15": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         result = volume_utils._parse_volume_info(conn_info['data'])"
            },
            "16": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         self.assertEqual('username', result['chapuser'])"
            },
            "18": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual('password', result['chappassword'])"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        self.assertEqual('verybadpass', result['chappassword'])"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+    def test_parse_volume_info_missing_details(self):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+        # Tests that a StorageError is raised if volume_id, target_host, or"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        # target_ign is missing from connection_data. Also ensures that the"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        # auth_password value is not present in the StorageError message."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        for data_key_to_null in ('volume_id', 'target_portal', 'target_iqn'):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+            conn_info = self._make_connection_info()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+            conn_info['data'][data_key_to_null] = None"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+            ex = self.assertRaises(exception.StorageError,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+                                   volume_utils._parse_volume_info,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                                   conn_info['data'])"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+            self.assertNotIn('verybadpass', six.text_type(ex))"
            },
            "32": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 192,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "     def test_get_device_number_raise_exception_on_wrong_mountpoint(self):"
            },
            "34": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         self.assertRaises("
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from eventlet import greenthread",
            "import mock",
            "",
            "from nova import exception",
            "from nova import test",
            "from nova.tests.unit.virt.xenapi import stubs",
            "from nova.virt.xenapi import volume_utils",
            "",
            "",
            "class SROps(stubs.XenAPITestBaseNoDB):",
            "    def test_find_sr_valid_uuid(self):",
            "        self.session = mock.Mock()",
            "        self.session.call_xenapi.return_value = 'sr_ref'",
            "        self.assertEqual(volume_utils.find_sr_by_uuid(self.session,",
            "                                                      'sr_uuid'),",
            "                         'sr_ref')",
            "",
            "    def test_find_sr_invalid_uuid(self):",
            "        class UUIDException(Exception):",
            "            details = [\"UUID_INVALID\", \"\", \"\", \"\"]",
            "",
            "        self.session = mock.Mock()",
            "        self.session.XenAPI.Failure = UUIDException",
            "        self.session.call_xenapi.side_effect = UUIDException",
            "        self.assertIsNone(",
            "            volume_utils.find_sr_by_uuid(self.session, 'sr_uuid'))",
            "",
            "    def test_find_sr_from_vdi(self):",
            "        vdi_ref = 'fake-ref'",
            "",
            "        def fake_call_xenapi(method, *args):",
            "            self.assertEqual(method, 'VDI.get_SR')",
            "            self.assertEqual(args[0], vdi_ref)",
            "            return args[0]",
            "",
            "        session = mock.Mock()",
            "        session.call_xenapi.side_effect = fake_call_xenapi",
            "        self.assertEqual(volume_utils.find_sr_from_vdi(session, vdi_ref),",
            "                         vdi_ref)",
            "",
            "    def test_find_sr_from_vdi_exception(self):",
            "        vdi_ref = 'fake-ref'",
            "",
            "        class FakeException(Exception):",
            "            pass",
            "",
            "        def fake_call_xenapi(method, *args):",
            "            self.assertEqual(method, 'VDI.get_SR')",
            "            self.assertEqual(args[0], vdi_ref)",
            "            return args[0]",
            "",
            "        session = mock.Mock()",
            "        session.XenAPI.Failure = FakeException",
            "        session.call_xenapi.side_effect = FakeException",
            "        self.assertRaises(exception.StorageError,",
            "                volume_utils.find_sr_from_vdi, session, vdi_ref)",
            "",
            "",
            "class ISCSIParametersTestCase(stubs.XenAPITestBaseNoDB):",
            "    def test_target_host(self):",
            "        self.assertEqual(volume_utils._get_target_host('host:port'),",
            "                         'host')",
            "",
            "        self.assertEqual(volume_utils._get_target_host('host'),",
            "                         'host')",
            "",
            "        # There is no default value",
            "        self.assertIsNone(volume_utils._get_target_host(':port'))",
            "",
            "        self.assertIsNone(volume_utils._get_target_host(None))",
            "",
            "    def test_target_port(self):",
            "        self.assertEqual(volume_utils._get_target_port('host:port'),",
            "                         'port')",
            "",
            "        self.assertEqual(volume_utils._get_target_port('host'),",
            "                         '3260')",
            "",
            "",
            "class IntroduceTestCase(stubs.XenAPITestBaseNoDB):",
            "",
            "    @mock.patch.object(volume_utils, '_get_vdi_ref')",
            "    @mock.patch.object(greenthread, 'sleep')",
            "    def test_introduce_vdi_retry(self, mock_sleep, mock_get_vdi_ref):",
            "        def fake_get_vdi_ref(session, sr_ref, vdi_uuid, target_lun):",
            "            fake_get_vdi_ref.call_count += 1",
            "            if fake_get_vdi_ref.call_count == 2:",
            "                return 'vdi_ref'",
            "",
            "        def fake_call_xenapi(method, *args):",
            "            if method == 'SR.scan':",
            "                return",
            "            elif method == 'VDI.get_record':",
            "                return {'managed': 'true'}",
            "",
            "        session = mock.Mock()",
            "        session.call_xenapi.side_effect = fake_call_xenapi",
            "",
            "        mock_get_vdi_ref.side_effect = fake_get_vdi_ref",
            "        fake_get_vdi_ref.call_count = 0",
            "",
            "        self.assertEqual(volume_utils.introduce_vdi(session, 'sr_ref'),",
            "                         'vdi_ref')",
            "        mock_sleep.assert_called_once_with(20)",
            "",
            "    @mock.patch.object(volume_utils, '_get_vdi_ref')",
            "    @mock.patch.object(greenthread, 'sleep')",
            "    def test_introduce_vdi_exception(self, mock_sleep, mock_get_vdi_ref):",
            "        def fake_call_xenapi(method, *args):",
            "            if method == 'SR.scan':",
            "                return",
            "            elif method == 'VDI.get_record':",
            "                return {'managed': 'true'}",
            "",
            "        session = mock.Mock()",
            "        session.call_xenapi.side_effect = fake_call_xenapi",
            "        mock_get_vdi_ref.return_value = None",
            "",
            "        self.assertRaises(exception.StorageError,",
            "                          volume_utils.introduce_vdi, session, 'sr_ref')",
            "        mock_sleep.assert_called_once_with(20)",
            "",
            "",
            "class ParseVolumeInfoTestCase(stubs.XenAPITestBaseNoDB):",
            "    def test_mountpoint_to_number(self):",
            "        cases = {",
            "            'sda': 0,",
            "            'sdp': 15,",
            "            'hda': 0,",
            "            'hdp': 15,",
            "            'vda': 0,",
            "            'xvda': 0,",
            "            '0': 0,",
            "            '10': 10,",
            "            'vdq': -1,",
            "            'sdq': -1,",
            "            'hdq': -1,",
            "            'xvdq': -1,",
            "        }",
            "",
            "        for (input, expected) in cases.iteritems():",
            "            actual = volume_utils._mountpoint_to_number(input)",
            "            self.assertEqual(actual, expected,",
            "                    '%s yielded %s, not %s' % (input, actual, expected))",
            "",
            "    @classmethod",
            "    def _make_connection_info(cls):",
            "        target_iqn = 'iqn.2010-10.org.openstack:volume-00000001'",
            "        return {'driver_volume_type': 'iscsi',",
            "                'data': {'volume_id': 1,",
            "                         'target_iqn': target_iqn,",
            "                         'target_portal': '127.0.0.1:3260,fake',",
            "                         'target_lun': None,",
            "                         'auth_method': 'CHAP',",
            "                         'auth_username': 'username',",
            "                         'auth_password': 'password'}}",
            "",
            "    def test_parse_volume_info_parsing_auth_details(self):",
            "        conn_info = self._make_connection_info()",
            "        result = volume_utils._parse_volume_info(conn_info['data'])",
            "",
            "        self.assertEqual('username', result['chapuser'])",
            "        self.assertEqual('password', result['chappassword'])",
            "",
            "    def test_get_device_number_raise_exception_on_wrong_mountpoint(self):",
            "        self.assertRaises(",
            "            exception.StorageError,",
            "            volume_utils.get_device_number,",
            "            'dev/sd')",
            "",
            "",
            "class FindVBDTestCase(stubs.XenAPITestBaseNoDB):",
            "    def test_find_vbd_by_number_works(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = [\"a\", \"b\"]",
            "        session.VBD.get_userdevice.return_value = \"1\"",
            "",
            "        result = volume_utils.find_vbd_by_number(session, \"vm_ref\", 1)",
            "",
            "        self.assertEqual(\"a\", result)",
            "        session.VM.get_VBDs.assert_called_once_with(\"vm_ref\")",
            "        session.VBD.get_userdevice.assert_called_once_with(\"a\")",
            "",
            "    def test_find_vbd_by_number_no_matches(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = [\"a\", \"b\"]",
            "        session.VBD.get_userdevice.return_value = \"3\"",
            "",
            "        result = volume_utils.find_vbd_by_number(session, \"vm_ref\", 1)",
            "",
            "        self.assertIsNone(result)",
            "        session.VM.get_VBDs.assert_called_once_with(\"vm_ref\")",
            "        expected = [mock.call(\"a\"), mock.call(\"b\")]",
            "        self.assertEqual(expected,",
            "                         session.VBD.get_userdevice.call_args_list)",
            "",
            "    def test_find_vbd_by_number_no_vbds(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = []",
            "",
            "        result = volume_utils.find_vbd_by_number(session, \"vm_ref\", 1)",
            "",
            "        self.assertIsNone(result)",
            "        session.VM.get_VBDs.assert_called_once_with(\"vm_ref\")",
            "        self.assertFalse(session.VBD.get_userdevice.called)",
            "",
            "    def test_find_vbd_by_number_ignores_exception(self):",
            "        session = mock.Mock()",
            "        session.XenAPI.Failure = test.TestingException",
            "        session.VM.get_VBDs.return_value = [\"a\"]",
            "        session.VBD.get_userdevice.side_effect = test.TestingException",
            "",
            "        result = volume_utils.find_vbd_by_number(session, \"vm_ref\", 1)",
            "",
            "        self.assertIsNone(result)",
            "        session.VM.get_VBDs.assert_called_once_with(\"vm_ref\")",
            "        session.VBD.get_userdevice.assert_called_once_with(\"a\")",
            "",
            "",
            "class BootedFromVolumeTestCase(stubs.XenAPITestBaseNoDB):",
            "    def test_booted_from_volume(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = ['vbd_ref']",
            "        session.VBD.get_userdevice.return_value = '0'",
            "        session.VBD.get_other_config.return_value = {'osvol': True}",
            "        booted_from_volume = volume_utils.is_booted_from_volume(session,",
            "                'vm_ref')",
            "        self.assertTrue(booted_from_volume)",
            "",
            "    def test_not_booted_from_volume(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = ['vbd_ref']",
            "        session.VBD.get_userdevice.return_value = '0'",
            "        session.VBD.get_other_config.return_value = {}",
            "        booted_from_volume = volume_utils.is_booted_from_volume(session,",
            "                'vm_ref')",
            "        self.assertFalse(booted_from_volume)"
        ],
        "afterPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from eventlet import greenthread",
            "import mock",
            "import six",
            "",
            "from nova import exception",
            "from nova import test",
            "from nova.tests.unit.virt.xenapi import stubs",
            "from nova.virt.xenapi import volume_utils",
            "",
            "",
            "class SROps(stubs.XenAPITestBaseNoDB):",
            "    def test_find_sr_valid_uuid(self):",
            "        self.session = mock.Mock()",
            "        self.session.call_xenapi.return_value = 'sr_ref'",
            "        self.assertEqual(volume_utils.find_sr_by_uuid(self.session,",
            "                                                      'sr_uuid'),",
            "                         'sr_ref')",
            "",
            "    def test_find_sr_invalid_uuid(self):",
            "        class UUIDException(Exception):",
            "            details = [\"UUID_INVALID\", \"\", \"\", \"\"]",
            "",
            "        self.session = mock.Mock()",
            "        self.session.XenAPI.Failure = UUIDException",
            "        self.session.call_xenapi.side_effect = UUIDException",
            "        self.assertIsNone(",
            "            volume_utils.find_sr_by_uuid(self.session, 'sr_uuid'))",
            "",
            "    def test_find_sr_from_vdi(self):",
            "        vdi_ref = 'fake-ref'",
            "",
            "        def fake_call_xenapi(method, *args):",
            "            self.assertEqual(method, 'VDI.get_SR')",
            "            self.assertEqual(args[0], vdi_ref)",
            "            return args[0]",
            "",
            "        session = mock.Mock()",
            "        session.call_xenapi.side_effect = fake_call_xenapi",
            "        self.assertEqual(volume_utils.find_sr_from_vdi(session, vdi_ref),",
            "                         vdi_ref)",
            "",
            "    def test_find_sr_from_vdi_exception(self):",
            "        vdi_ref = 'fake-ref'",
            "",
            "        class FakeException(Exception):",
            "            pass",
            "",
            "        def fake_call_xenapi(method, *args):",
            "            self.assertEqual(method, 'VDI.get_SR')",
            "            self.assertEqual(args[0], vdi_ref)",
            "            return args[0]",
            "",
            "        session = mock.Mock()",
            "        session.XenAPI.Failure = FakeException",
            "        session.call_xenapi.side_effect = FakeException",
            "        self.assertRaises(exception.StorageError,",
            "                volume_utils.find_sr_from_vdi, session, vdi_ref)",
            "",
            "",
            "class ISCSIParametersTestCase(stubs.XenAPITestBaseNoDB):",
            "    def test_target_host(self):",
            "        self.assertEqual(volume_utils._get_target_host('host:port'),",
            "                         'host')",
            "",
            "        self.assertEqual(volume_utils._get_target_host('host'),",
            "                         'host')",
            "",
            "        # There is no default value",
            "        self.assertIsNone(volume_utils._get_target_host(':port'))",
            "",
            "        self.assertIsNone(volume_utils._get_target_host(None))",
            "",
            "    def test_target_port(self):",
            "        self.assertEqual(volume_utils._get_target_port('host:port'),",
            "                         'port')",
            "",
            "        self.assertEqual(volume_utils._get_target_port('host'),",
            "                         '3260')",
            "",
            "",
            "class IntroduceTestCase(stubs.XenAPITestBaseNoDB):",
            "",
            "    @mock.patch.object(volume_utils, '_get_vdi_ref')",
            "    @mock.patch.object(greenthread, 'sleep')",
            "    def test_introduce_vdi_retry(self, mock_sleep, mock_get_vdi_ref):",
            "        def fake_get_vdi_ref(session, sr_ref, vdi_uuid, target_lun):",
            "            fake_get_vdi_ref.call_count += 1",
            "            if fake_get_vdi_ref.call_count == 2:",
            "                return 'vdi_ref'",
            "",
            "        def fake_call_xenapi(method, *args):",
            "            if method == 'SR.scan':",
            "                return",
            "            elif method == 'VDI.get_record':",
            "                return {'managed': 'true'}",
            "",
            "        session = mock.Mock()",
            "        session.call_xenapi.side_effect = fake_call_xenapi",
            "",
            "        mock_get_vdi_ref.side_effect = fake_get_vdi_ref",
            "        fake_get_vdi_ref.call_count = 0",
            "",
            "        self.assertEqual(volume_utils.introduce_vdi(session, 'sr_ref'),",
            "                         'vdi_ref')",
            "        mock_sleep.assert_called_once_with(20)",
            "",
            "    @mock.patch.object(volume_utils, '_get_vdi_ref')",
            "    @mock.patch.object(greenthread, 'sleep')",
            "    def test_introduce_vdi_exception(self, mock_sleep, mock_get_vdi_ref):",
            "        def fake_call_xenapi(method, *args):",
            "            if method == 'SR.scan':",
            "                return",
            "            elif method == 'VDI.get_record':",
            "                return {'managed': 'true'}",
            "",
            "        session = mock.Mock()",
            "        session.call_xenapi.side_effect = fake_call_xenapi",
            "        mock_get_vdi_ref.return_value = None",
            "",
            "        self.assertRaises(exception.StorageError,",
            "                          volume_utils.introduce_vdi, session, 'sr_ref')",
            "        mock_sleep.assert_called_once_with(20)",
            "",
            "",
            "class ParseVolumeInfoTestCase(stubs.XenAPITestBaseNoDB):",
            "    def test_mountpoint_to_number(self):",
            "        cases = {",
            "            'sda': 0,",
            "            'sdp': 15,",
            "            'hda': 0,",
            "            'hdp': 15,",
            "            'vda': 0,",
            "            'xvda': 0,",
            "            '0': 0,",
            "            '10': 10,",
            "            'vdq': -1,",
            "            'sdq': -1,",
            "            'hdq': -1,",
            "            'xvdq': -1,",
            "        }",
            "",
            "        for (input, expected) in cases.iteritems():",
            "            actual = volume_utils._mountpoint_to_number(input)",
            "            self.assertEqual(actual, expected,",
            "                    '%s yielded %s, not %s' % (input, actual, expected))",
            "",
            "    @classmethod",
            "    def _make_connection_info(cls):",
            "        target_iqn = 'iqn.2010-10.org.openstack:volume-00000001'",
            "        return {'driver_volume_type': 'iscsi',",
            "                'data': {'volume_id': 1,",
            "                         'target_iqn': target_iqn,",
            "                         'target_portal': '127.0.0.1:3260,fake',",
            "                         'target_lun': None,",
            "                         'auth_method': 'CHAP',",
            "                         'auth_username': 'username',",
            "                         'auth_password': 'verybadpass'}}",
            "",
            "    def test_parse_volume_info_parsing_auth_details(self):",
            "        conn_info = self._make_connection_info()",
            "        result = volume_utils._parse_volume_info(conn_info['data'])",
            "",
            "        self.assertEqual('username', result['chapuser'])",
            "        self.assertEqual('verybadpass', result['chappassword'])",
            "",
            "    def test_parse_volume_info_missing_details(self):",
            "        # Tests that a StorageError is raised if volume_id, target_host, or",
            "        # target_ign is missing from connection_data. Also ensures that the",
            "        # auth_password value is not present in the StorageError message.",
            "        for data_key_to_null in ('volume_id', 'target_portal', 'target_iqn'):",
            "            conn_info = self._make_connection_info()",
            "            conn_info['data'][data_key_to_null] = None",
            "            ex = self.assertRaises(exception.StorageError,",
            "                                   volume_utils._parse_volume_info,",
            "                                   conn_info['data'])",
            "            self.assertNotIn('verybadpass', six.text_type(ex))",
            "",
            "    def test_get_device_number_raise_exception_on_wrong_mountpoint(self):",
            "        self.assertRaises(",
            "            exception.StorageError,",
            "            volume_utils.get_device_number,",
            "            'dev/sd')",
            "",
            "",
            "class FindVBDTestCase(stubs.XenAPITestBaseNoDB):",
            "    def test_find_vbd_by_number_works(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = [\"a\", \"b\"]",
            "        session.VBD.get_userdevice.return_value = \"1\"",
            "",
            "        result = volume_utils.find_vbd_by_number(session, \"vm_ref\", 1)",
            "",
            "        self.assertEqual(\"a\", result)",
            "        session.VM.get_VBDs.assert_called_once_with(\"vm_ref\")",
            "        session.VBD.get_userdevice.assert_called_once_with(\"a\")",
            "",
            "    def test_find_vbd_by_number_no_matches(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = [\"a\", \"b\"]",
            "        session.VBD.get_userdevice.return_value = \"3\"",
            "",
            "        result = volume_utils.find_vbd_by_number(session, \"vm_ref\", 1)",
            "",
            "        self.assertIsNone(result)",
            "        session.VM.get_VBDs.assert_called_once_with(\"vm_ref\")",
            "        expected = [mock.call(\"a\"), mock.call(\"b\")]",
            "        self.assertEqual(expected,",
            "                         session.VBD.get_userdevice.call_args_list)",
            "",
            "    def test_find_vbd_by_number_no_vbds(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = []",
            "",
            "        result = volume_utils.find_vbd_by_number(session, \"vm_ref\", 1)",
            "",
            "        self.assertIsNone(result)",
            "        session.VM.get_VBDs.assert_called_once_with(\"vm_ref\")",
            "        self.assertFalse(session.VBD.get_userdevice.called)",
            "",
            "    def test_find_vbd_by_number_ignores_exception(self):",
            "        session = mock.Mock()",
            "        session.XenAPI.Failure = test.TestingException",
            "        session.VM.get_VBDs.return_value = [\"a\"]",
            "        session.VBD.get_userdevice.side_effect = test.TestingException",
            "",
            "        result = volume_utils.find_vbd_by_number(session, \"vm_ref\", 1)",
            "",
            "        self.assertIsNone(result)",
            "        session.VM.get_VBDs.assert_called_once_with(\"vm_ref\")",
            "        session.VBD.get_userdevice.assert_called_once_with(\"a\")",
            "",
            "",
            "class BootedFromVolumeTestCase(stubs.XenAPITestBaseNoDB):",
            "    def test_booted_from_volume(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = ['vbd_ref']",
            "        session.VBD.get_userdevice.return_value = '0'",
            "        session.VBD.get_other_config.return_value = {'osvol': True}",
            "        booted_from_volume = volume_utils.is_booted_from_volume(session,",
            "                'vm_ref')",
            "        self.assertTrue(booted_from_volume)",
            "",
            "    def test_not_booted_from_volume(self):",
            "        session = mock.Mock()",
            "        session.VM.get_VBDs.return_value = ['vbd_ref']",
            "        session.VBD.get_userdevice.return_value = '0'",
            "        session.VBD.get_other_config.return_value = {}",
            "        booted_from_volume = volume_utils.is_booted_from_volume(session,",
            "                'vm_ref')",
            "        self.assertFalse(booted_from_volume)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "171": [
                "ParseVolumeInfoTestCase",
                "_make_connection_info"
            ],
            "178": [
                "ParseVolumeInfoTestCase",
                "test_parse_volume_info_parsing_auth_details"
            ]
        },
        "addLocation": []
    },
    "nova/tests/unit/virt/xenapi/test_volumeops.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "         mock_intro.assert_called_once_with(self.session, \"sr\","
            },
            "1": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "                                            target_lun=\"lun\")"
            },
            "2": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 383,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+    @mock.patch.object(volume_utils, \"introduce_vdi\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+    @mock.patch.object(volumeops.LOG, 'debug')"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+    def test_connect_hypervisor_to_volume_mask_password(self, mock_debug,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+                                                        mock_intro):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+        # Tests that the connection_data is scrubbed before logging."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+        data = {'auth_password': 'verybadpass'}"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+        self.ops._connect_hypervisor_to_volume(\"sr\", data)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+        self.assertTrue(mock_debug.called, 'LOG.debug was not called')"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+        password_logged = False"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+        for call in mock_debug.call_args_list:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+            # The call object is a tuple of (args, kwargs)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+            if 'verybadpass' in call[0]:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+                password_logged = True"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+                break"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+        self.assertFalse(password_logged, 'connection_data was not scrubbed')"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "     @mock.patch.object(vm_utils, \"is_vm_shutdown\")"
            },
            "20": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "     @mock.patch.object(vm_utils, \"create_vbd\")"
            },
            "21": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "     def test_attach_volume_to_vm_plug(self, mock_vbd, mock_shutdown):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2012 Citrix Systems, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "",
            "from nova import exception",
            "from nova import test",
            "from nova.tests.unit.virt.xenapi import stubs",
            "from nova.virt.xenapi import vm_utils",
            "from nova.virt.xenapi import volume_utils",
            "from nova.virt.xenapi import volumeops",
            "",
            "",
            "class VolumeOpsTestBase(stubs.XenAPITestBaseNoDB):",
            "    def setUp(self):",
            "        super(VolumeOpsTestBase, self).setUp()",
            "        self._setup_mock_volumeops()",
            "",
            "    def _setup_mock_volumeops(self):",
            "        self.session = stubs.FakeSessionForVolumeTests('fake_uri')",
            "        self.ops = volumeops.VolumeOps(self.session)",
            "",
            "",
            "class VolumeDetachTestCase(VolumeOpsTestBase):",
            "    def test_detach_volume_call(self):",
            "        registered_calls = []",
            "",
            "        def regcall(label):",
            "            def side_effect(*args, **kwargs):",
            "                registered_calls.append(label)",
            "            return side_effect",
            "",
            "        ops = volumeops.VolumeOps('session')",
            "        self.mox.StubOutWithMock(volumeops.vm_utils, 'lookup')",
            "        self.mox.StubOutWithMock(volumeops.volume_utils, 'find_vbd_by_number')",
            "        self.mox.StubOutWithMock(volumeops.vm_utils, 'is_vm_shutdown')",
            "        self.mox.StubOutWithMock(volumeops.vm_utils, 'unplug_vbd')",
            "        self.mox.StubOutWithMock(volumeops.vm_utils, 'destroy_vbd')",
            "        self.mox.StubOutWithMock(volumeops.volume_utils, 'get_device_number')",
            "        self.mox.StubOutWithMock(volumeops.volume_utils, 'find_sr_from_vbd')",
            "        self.mox.StubOutWithMock(volumeops.volume_utils, 'purge_sr')",
            "",
            "        volumeops.vm_utils.lookup('session', 'instance_1').AndReturn(",
            "            'vmref')",
            "",
            "        volumeops.volume_utils.get_device_number('mountpoint').AndReturn(",
            "            'devnumber')",
            "",
            "        volumeops.volume_utils.find_vbd_by_number(",
            "            'session', 'vmref', 'devnumber').AndReturn('vbdref')",
            "",
            "        volumeops.vm_utils.is_vm_shutdown('session', 'vmref').AndReturn(",
            "            False)",
            "",
            "        volumeops.vm_utils.unplug_vbd('session', 'vbdref', 'vmref')",
            "",
            "        volumeops.vm_utils.destroy_vbd('session', 'vbdref').WithSideEffects(",
            "            regcall('destroy_vbd'))",
            "",
            "        volumeops.volume_utils.find_sr_from_vbd(",
            "            'session', 'vbdref').WithSideEffects(",
            "                regcall('find_sr_from_vbd')).AndReturn('srref')",
            "",
            "        volumeops.volume_utils.purge_sr('session', 'srref')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        ops.detach_volume(",
            "            dict(driver_volume_type='iscsi', data='conn_data'),",
            "            'instance_1', 'mountpoint')",
            "",
            "        self.assertEqual(",
            "            ['find_sr_from_vbd', 'destroy_vbd'], registered_calls)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volume_utils, \"find_vbd_by_number\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_detach_volume(self, mock_vm, mock_vbd, mock_detach):",
            "        mock_vm.return_value = \"vm_ref\"",
            "        mock_vbd.return_value = \"vbd_ref\"",
            "",
            "        self.ops.detach_volume({}, \"name\", \"/dev/xvdd\")",
            "",
            "        mock_vm.assert_called_once_with(self.session, \"name\")",
            "        mock_vbd.assert_called_once_with(self.session, \"vm_ref\", 3)",
            "        mock_detach.assert_called_once_with(\"vm_ref\", [\"vbd_ref\"])",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volume_utils, \"find_vbd_by_number\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_detach_volume_skips_error_skip_attach(self, mock_vm, mock_vbd,",
            "                                                   mock_detach):",
            "        mock_vm.return_value = \"vm_ref\"",
            "        mock_vbd.return_value = None",
            "",
            "        self.ops.detach_volume({}, \"name\", \"/dev/xvdd\")",
            "",
            "        self.assertFalse(mock_detach.called)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volume_utils, \"find_vbd_by_number\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_detach_volume_raises(self, mock_vm, mock_vbd,",
            "                                  mock_detach):",
            "        mock_vm.return_value = \"vm_ref\"",
            "        mock_vbd.side_effect = test.TestingException",
            "",
            "        self.assertRaises(test.TestingException,",
            "                          self.ops.detach_volume, {}, \"name\", \"/dev/xvdd\")",
            "        self.assertFalse(mock_detach.called)",
            "",
            "    @mock.patch.object(volume_utils, \"purge_sr\")",
            "    @mock.patch.object(vm_utils, \"destroy_vbd\")",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(vm_utils, \"unplug_vbd\")",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    def test_detach_vbds_and_srs_not_shutdown(self, mock_shutdown, mock_unplug,",
            "            mock_find_sr, mock_destroy, mock_purge):",
            "        mock_shutdown.return_value = False",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        self.ops._detach_vbds_and_srs(\"vm_ref\", [\"vbd_ref\"])",
            "",
            "        mock_shutdown.assert_called_once_with(self.session, \"vm_ref\")",
            "        mock_find_sr.assert_called_once_with(self.session, \"vbd_ref\")",
            "        mock_unplug.assert_called_once_with(self.session, \"vbd_ref\", \"vm_ref\")",
            "        mock_destroy.assert_called_once_with(self.session, \"vbd_ref\")",
            "        mock_purge.assert_called_once_with(self.session, \"sr_ref\")",
            "",
            "    @mock.patch.object(volume_utils, \"purge_sr\")",
            "    @mock.patch.object(vm_utils, \"destroy_vbd\")",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(vm_utils, \"unplug_vbd\")",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    def test_detach_vbds_and_srs_is_shutdown(self, mock_shutdown, mock_unplug,",
            "            mock_find_sr, mock_destroy, mock_purge):",
            "        mock_shutdown.return_value = True",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        self.ops._detach_vbds_and_srs(\"vm_ref\", [\"vbd_ref_1\", \"vbd_ref_2\"])",
            "",
            "        expected = [mock.call(self.session, \"vbd_ref_1\"),",
            "                    mock.call(self.session, \"vbd_ref_2\")]",
            "        self.assertEqual(expected, mock_destroy.call_args_list)",
            "        mock_purge.assert_called_with(self.session, \"sr_ref\")",
            "        self.assertFalse(mock_unplug.called)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_detach_all_no_volumes(self, mock_get_all, mock_detach):",
            "        mock_get_all.return_value = []",
            "",
            "        self.ops.detach_all(\"vm_ref\")",
            "",
            "        mock_get_all.assert_called_once_with(\"vm_ref\")",
            "        self.assertFalse(mock_detach.called)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_detach_all_volumes(self, mock_get_all, mock_detach):",
            "        mock_get_all.return_value = [\"1\"]",
            "",
            "        self.ops.detach_all(\"vm_ref\")",
            "",
            "        mock_get_all.assert_called_once_with(\"vm_ref\")",
            "        mock_detach.assert_called_once_with(\"vm_ref\", [\"1\"])",
            "",
            "    def test_get_all_volume_vbd_refs_no_vbds(self):",
            "        with mock.patch.object(self.session.VM, \"get_VBDs\") as mock_get:",
            "            with mock.patch.object(self.session.VBD,",
            "                                   \"get_other_config\") as mock_conf:",
            "                mock_get.return_value = []",
            "",
            "                result = self.ops._get_all_volume_vbd_refs(\"vm_ref\")",
            "",
            "                self.assertEqual([], list(result))",
            "                mock_get.assert_called_once_with(\"vm_ref\")",
            "                self.assertFalse(mock_conf.called)",
            "",
            "    def test_get_all_volume_vbd_refs_no_volumes(self):",
            "        with mock.patch.object(self.session.VM, \"get_VBDs\") as mock_get:",
            "            with mock.patch.object(self.session.VBD,",
            "                                   \"get_other_config\") as mock_conf:",
            "                mock_get.return_value = [\"1\"]",
            "                mock_conf.return_value = {}",
            "",
            "                result = self.ops._get_all_volume_vbd_refs(\"vm_ref\")",
            "",
            "                self.assertEqual([], list(result))",
            "                mock_get.assert_called_once_with(\"vm_ref\")",
            "                mock_conf.assert_called_once_with(\"1\")",
            "",
            "    def test_get_all_volume_vbd_refs_with_volumes(self):",
            "        with mock.patch.object(self.session.VM, \"get_VBDs\") as mock_get:",
            "            with mock.patch.object(self.session.VBD,",
            "                                   \"get_other_config\") as mock_conf:",
            "                mock_get.return_value = [\"1\", \"2\"]",
            "                mock_conf.return_value = {\"osvol\": True}",
            "",
            "                result = self.ops._get_all_volume_vbd_refs(\"vm_ref\")",
            "",
            "                self.assertEqual([\"1\", \"2\"], list(result))",
            "                mock_get.assert_called_once_with(\"vm_ref\")",
            "",
            "",
            "class AttachVolumeTestCase(VolumeOpsTestBase):",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_attach_volume_default_hotplug(self, mock_get_vm, mock_attach):",
            "        mock_get_vm.return_value = \"vm_ref\"",
            "",
            "        self.ops.attach_volume({}, \"instance_name\", \"/dev/xvda\")",
            "",
            "        mock_attach.assert_called_once_with({}, \"vm_ref\", \"instance_name\", 0,",
            "                                            True)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_attach_volume_hotplug(self, mock_get_vm, mock_attach):",
            "        mock_get_vm.return_value = \"vm_ref\"",
            "",
            "        self.ops.attach_volume({}, \"instance_name\", \"/dev/xvda\", False)",
            "",
            "        mock_attach.assert_called_once_with({}, \"vm_ref\", \"instance_name\", 0,",
            "                                            False)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume\")",
            "    def test_attach_volume_default_hotplug_connect_volume(self, mock_attach):",
            "        self.ops.connect_volume({})",
            "        mock_attach.assert_called_once_with({})",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_check_is_supported_driver_type\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_to_volume_provider\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_hypervisor_to_volume\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume_to_vm\")",
            "    def test_attach_volume_with_defaults(self, mock_attach, mock_hypervisor,",
            "                                         mock_provider, mock_driver):",
            "        connection_info = {\"data\": {}}",
            "        with mock.patch.object(self.session.VDI, \"get_uuid\") as mock_vdi:",
            "            mock_provider.return_value = (\"sr_ref\", \"sr_uuid\")",
            "            mock_vdi.return_value = \"vdi_uuid\"",
            "",
            "            result = self.ops._attach_volume(connection_info)",
            "",
            "            self.assertEqual(result, (\"sr_uuid\", \"vdi_uuid\"))",
            "",
            "        mock_driver.assert_called_once_with(connection_info)",
            "        mock_provider.assert_called_once_with({}, None)",
            "        mock_hypervisor.assert_called_once_with(\"sr_ref\", {})",
            "        self.assertFalse(mock_attach.called)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_check_is_supported_driver_type\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_to_volume_provider\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_hypervisor_to_volume\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume_to_vm\")",
            "    def test_attach_volume_with_hot_attach(self, mock_attach, mock_hypervisor,",
            "                                           mock_provider, mock_driver):",
            "        connection_info = {\"data\": {}}",
            "        with mock.patch.object(self.session.VDI, \"get_uuid\") as mock_vdi:",
            "            mock_provider.return_value = (\"sr_ref\", \"sr_uuid\")",
            "            mock_hypervisor.return_value = \"vdi_ref\"",
            "            mock_vdi.return_value = \"vdi_uuid\"",
            "",
            "            result = self.ops._attach_volume(connection_info, \"vm_ref\",",
            "                        \"name\", 2, True)",
            "",
            "            self.assertEqual(result, (\"sr_uuid\", \"vdi_uuid\"))",
            "",
            "        mock_driver.assert_called_once_with(connection_info)",
            "        mock_provider.assert_called_once_with({}, \"name\")",
            "        mock_hypervisor.assert_called_once_with(\"sr_ref\", {})",
            "        mock_attach.assert_called_once_with(\"vdi_ref\", \"vm_ref\", \"name\", 2,",
            "                                            True)",
            "",
            "    @mock.patch.object(volume_utils, \"forget_sr\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_check_is_supported_driver_type\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_to_volume_provider\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_hypervisor_to_volume\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume_to_vm\")",
            "    def test_attach_volume_cleanup(self, mock_attach, mock_hypervisor,",
            "                                   mock_provider, mock_driver, mock_forget):",
            "        connection_info = {\"data\": {}}",
            "        mock_provider.return_value = (\"sr_ref\", \"sr_uuid\")",
            "        mock_hypervisor.side_effect = test.TestingException",
            "",
            "        self.assertRaises(test.TestingException,",
            "                          self.ops._attach_volume, connection_info)",
            "",
            "        mock_driver.assert_called_once_with(connection_info)",
            "        mock_provider.assert_called_once_with({}, None)",
            "        mock_hypervisor.assert_called_once_with(\"sr_ref\", {})",
            "        mock_forget.assert_called_once_with(self.session, \"sr_ref\")",
            "        self.assertFalse(mock_attach.called)",
            "",
            "    def test_check_is_supported_driver_type_pass_iscsi(self):",
            "        conn_info = {\"driver_volume_type\": \"iscsi\"}",
            "        self.ops._check_is_supported_driver_type(conn_info)",
            "",
            "    def test_check_is_supported_driver_type_pass_xensm(self):",
            "        conn_info = {\"driver_volume_type\": \"xensm\"}",
            "        self.ops._check_is_supported_driver_type(conn_info)",
            "",
            "    def test_check_is_supported_driver_type_pass_bad(self):",
            "        conn_info = {\"driver_volume_type\": \"bad\"}",
            "        self.assertRaises(exception.VolumeDriverNotFound,",
            "                          self.ops._check_is_supported_driver_type, conn_info)",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_sr\")",
            "    @mock.patch.object(volume_utils, \"find_sr_by_uuid\")",
            "    @mock.patch.object(volume_utils, \"parse_sr_info\")",
            "    def test_connect_to_volume_provider_new_sr(self, mock_parse, mock_find_sr,",
            "                                               mock_introduce_sr):",
            "        mock_parse.return_value = (\"uuid\", \"label\", \"params\")",
            "        mock_find_sr.return_value = None",
            "        mock_introduce_sr.return_value = \"sr_ref\"",
            "",
            "        ref, uuid = self.ops._connect_to_volume_provider({}, \"name\")",
            "",
            "        self.assertEqual(\"sr_ref\", ref)",
            "        self.assertEqual(\"uuid\", uuid)",
            "        mock_parse.assert_called_once_with({}, \"Disk-for:name\")",
            "        mock_find_sr.assert_called_once_with(self.session, \"uuid\")",
            "        mock_introduce_sr.assert_called_once_with(self.session, \"uuid\",",
            "                                                  \"label\", \"params\")",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_sr\")",
            "    @mock.patch.object(volume_utils, \"find_sr_by_uuid\")",
            "    @mock.patch.object(volume_utils, \"parse_sr_info\")",
            "    def test_connect_to_volume_provider_old_sr(self, mock_parse, mock_find_sr,",
            "                                               mock_introduce_sr):",
            "        mock_parse.return_value = (\"uuid\", \"label\", \"params\")",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        ref, uuid = self.ops._connect_to_volume_provider({}, \"name\")",
            "",
            "        self.assertEqual(\"sr_ref\", ref)",
            "        self.assertEqual(\"uuid\", uuid)",
            "        mock_parse.assert_called_once_with({}, \"Disk-for:name\")",
            "        mock_find_sr.assert_called_once_with(self.session, \"uuid\")",
            "        self.assertFalse(mock_introduce_sr.called)",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_vdi\")",
            "    def test_connect_hypervisor_to_volume_regular(self, mock_intro):",
            "        mock_intro.return_value = \"vdi\"",
            "",
            "        result = self.ops._connect_hypervisor_to_volume(\"sr\", {})",
            "",
            "        self.assertEqual(\"vdi\", result)",
            "        mock_intro.assert_called_once_with(self.session, \"sr\")",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_vdi\")",
            "    def test_connect_hypervisor_to_volume_vdi(self, mock_intro):",
            "        mock_intro.return_value = \"vdi\"",
            "",
            "        conn = {\"vdi_uuid\": \"id\"}",
            "        result = self.ops._connect_hypervisor_to_volume(\"sr\", conn)",
            "",
            "        self.assertEqual(\"vdi\", result)",
            "        mock_intro.assert_called_once_with(self.session, \"sr\",",
            "                                           vdi_uuid=\"id\")",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_vdi\")",
            "    def test_connect_hypervisor_to_volume_lun(self, mock_intro):",
            "        mock_intro.return_value = \"vdi\"",
            "",
            "        conn = {\"target_lun\": \"lun\"}",
            "        result = self.ops._connect_hypervisor_to_volume(\"sr\", conn)",
            "",
            "        self.assertEqual(\"vdi\", result)",
            "        mock_intro.assert_called_once_with(self.session, \"sr\",",
            "                                           target_lun=\"lun\")",
            "",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    @mock.patch.object(vm_utils, \"create_vbd\")",
            "    def test_attach_volume_to_vm_plug(self, mock_vbd, mock_shutdown):",
            "        mock_vbd.return_value = \"vbd\"",
            "        mock_shutdown.return_value = False",
            "",
            "        with mock.patch.object(self.session.VBD, \"plug\") as mock_plug:",
            "            self.ops._attach_volume_to_vm(\"vdi\", \"vm\", \"name\", 2, True)",
            "            mock_plug.assert_called_once_with(\"vbd\", \"vm\")",
            "",
            "        mock_vbd.assert_called_once_with(self.session, \"vm\", \"vdi\", 2,",
            "                                         bootable=False, osvol=True)",
            "        mock_shutdown.assert_called_once_with(self.session, \"vm\")",
            "",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    @mock.patch.object(vm_utils, \"create_vbd\")",
            "    def test_attach_volume_to_vm_no_plug(self, mock_vbd, mock_shutdown):",
            "        mock_vbd.return_value = \"vbd\"",
            "        mock_shutdown.return_value = True",
            "",
            "        with mock.patch.object(self.session.VBD, \"plug\") as mock_plug:",
            "            self.ops._attach_volume_to_vm(\"vdi\", \"vm\", \"name\", 2, True)",
            "            self.assertFalse(mock_plug.called)",
            "",
            "        mock_vbd.assert_called_once_with(self.session, \"vm\", \"vdi\", 2,",
            "                                         bootable=False, osvol=True)",
            "        mock_shutdown.assert_called_once_with(self.session, \"vm\")",
            "",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    @mock.patch.object(vm_utils, \"create_vbd\")",
            "    def test_attach_volume_to_vm_no_hotplug(self, mock_vbd, mock_shutdown):",
            "        mock_vbd.return_value = \"vbd\"",
            "",
            "        with mock.patch.object(self.session.VBD, \"plug\") as mock_plug:",
            "            self.ops._attach_volume_to_vm(\"vdi\", \"vm\", \"name\", 2, False)",
            "            self.assertFalse(mock_plug.called)",
            "",
            "        mock_vbd.assert_called_once_with(self.session, \"vm\", \"vdi\", 2,",
            "                                         bootable=False, osvol=True)",
            "        self.assertFalse(mock_shutdown.called)",
            "",
            "",
            "class FindBadVolumeTestCase(VolumeOpsTestBase):",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_find_bad_volumes_no_vbds(self, mock_get_all):",
            "        mock_get_all.return_value = []",
            "",
            "        result = self.ops.find_bad_volumes(\"vm_ref\")",
            "",
            "        mock_get_all.assert_called_once_with(\"vm_ref\")",
            "        self.assertEqual([], result)",
            "",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_find_bad_volumes_no_bad_vbds(self, mock_get_all, mock_find_sr):",
            "        mock_get_all.return_value = [\"1\", \"2\"]",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        with mock.patch.object(self.session.SR, \"scan\") as mock_scan:",
            "            result = self.ops.find_bad_volumes(\"vm_ref\")",
            "",
            "            mock_get_all.assert_called_once_with(\"vm_ref\")",
            "            expected_find = [mock.call(self.session, \"1\"),",
            "                             mock.call(self.session, \"2\")]",
            "            self.assertEqual(expected_find, mock_find_sr.call_args_list)",
            "            expected_scan = [mock.call(\"sr_ref\"), mock.call(\"sr_ref\")]",
            "            self.assertEqual(expected_scan, mock_scan.call_args_list)",
            "            self.assertEqual([], result)",
            "",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_find_bad_volumes_bad_vbds(self, mock_get_all, mock_find_sr):",
            "        mock_get_all.return_value = [\"vbd_ref\"]",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        class FakeException(Exception):",
            "            details = ['SR_BACKEND_FAILURE_40', \"\", \"\", \"\"]",
            "",
            "        session = mock.Mock()",
            "        session.XenAPI.Failure = FakeException",
            "        self.ops._session = session",
            "",
            "        with mock.patch.object(session.SR, \"scan\") as mock_scan:",
            "            with mock.patch.object(session.VBD,",
            "                                   \"get_device\") as mock_get:",
            "                mock_scan.side_effect = FakeException",
            "                mock_get.return_value = \"xvdb\"",
            "",
            "                result = self.ops.find_bad_volumes(\"vm_ref\")",
            "",
            "                mock_get_all.assert_called_once_with(\"vm_ref\")",
            "                mock_scan.assert_called_once_with(\"sr_ref\")",
            "                mock_get.assert_called_once_with(\"vbd_ref\")",
            "                self.assertEqual([\"/dev/xvdb\"], result)",
            "",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_find_bad_volumes_raises(self, mock_get_all, mock_find_sr):",
            "        mock_get_all.return_value = [\"vbd_ref\"]",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        class FakeException(Exception):",
            "            details = ['foo', \"\", \"\", \"\"]",
            "",
            "        session = mock.Mock()",
            "        session.XenAPI.Failure = FakeException",
            "        self.ops._session = session",
            "",
            "        with mock.patch.object(session.SR, \"scan\") as mock_scan:",
            "            with mock.patch.object(session.VBD,",
            "                                   \"get_device\") as mock_get:",
            "                mock_scan.side_effect = FakeException",
            "                mock_get.return_value = \"xvdb\"",
            "",
            "                self.assertRaises(FakeException,",
            "                                  self.ops.find_bad_volumes, \"vm_ref\")",
            "                mock_scan.assert_called_once_with(\"sr_ref\")",
            "",
            "",
            "class CleanupFromVDIsTestCase(VolumeOpsTestBase):",
            "    def _check_find_purge_calls(self, find_sr_from_vdi, purge_sr, vdi_refs,",
            "            sr_refs):",
            "        find_sr_calls = [mock.call(self.ops._session, vdi_ref) for vdi_ref",
            "                in vdi_refs]",
            "        find_sr_from_vdi.assert_has_calls(find_sr_calls)",
            "        purge_sr_calls = [mock.call(self.ops._session, sr_ref) for sr_ref",
            "                in sr_refs]",
            "        purge_sr.assert_has_calls(purge_sr_calls)",
            "",
            "    @mock.patch.object(volume_utils, 'find_sr_from_vdi')",
            "    @mock.patch.object(volume_utils, 'purge_sr')",
            "    def test_safe_cleanup_from_vdis(self, purge_sr, find_sr_from_vdi):",
            "        vdi_refs = ['vdi_ref1', 'vdi_ref2']",
            "        sr_refs = ['sr_ref1', 'sr_ref2']",
            "        find_sr_from_vdi.side_effect = sr_refs",
            "        self.ops.safe_cleanup_from_vdis(vdi_refs)",
            "",
            "        self._check_find_purge_calls(find_sr_from_vdi, purge_sr, vdi_refs,",
            "                sr_refs)",
            "",
            "    @mock.patch.object(volume_utils, 'find_sr_from_vdi',",
            "            side_effect=[exception.StorageError(reason=''), 'sr_ref2'])",
            "    @mock.patch.object(volume_utils, 'purge_sr')",
            "    def test_safe_cleanup_from_vdis_handles_find_sr_exception(self, purge_sr,",
            "            find_sr_from_vdi):",
            "        vdi_refs = ['vdi_ref1', 'vdi_ref2']",
            "        sr_refs = ['sr_ref2']",
            "        find_sr_from_vdi.side_effect = [exception.StorageError(reason=''),",
            "                sr_refs[0]]",
            "        self.ops.safe_cleanup_from_vdis(vdi_refs)",
            "",
            "        self._check_find_purge_calls(find_sr_from_vdi, purge_sr, vdi_refs,",
            "                sr_refs)",
            "",
            "    @mock.patch.object(volume_utils, 'find_sr_from_vdi')",
            "    @mock.patch.object(volume_utils, 'purge_sr')",
            "    def test_safe_cleanup_from_vdis_handles_purge_sr_exception(self, purge_sr,",
            "            find_sr_from_vdi):",
            "        vdi_refs = ['vdi_ref1', 'vdi_ref2']",
            "        sr_refs = ['sr_ref1', 'sr_ref2']",
            "        find_sr_from_vdi.side_effect = sr_refs",
            "        purge_sr.side_effects = [test.TestingException, None]",
            "        self.ops.safe_cleanup_from_vdis(vdi_refs)",
            "",
            "        self._check_find_purge_calls(find_sr_from_vdi, purge_sr, vdi_refs,",
            "                sr_refs)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2012 Citrix Systems, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "",
            "from nova import exception",
            "from nova import test",
            "from nova.tests.unit.virt.xenapi import stubs",
            "from nova.virt.xenapi import vm_utils",
            "from nova.virt.xenapi import volume_utils",
            "from nova.virt.xenapi import volumeops",
            "",
            "",
            "class VolumeOpsTestBase(stubs.XenAPITestBaseNoDB):",
            "    def setUp(self):",
            "        super(VolumeOpsTestBase, self).setUp()",
            "        self._setup_mock_volumeops()",
            "",
            "    def _setup_mock_volumeops(self):",
            "        self.session = stubs.FakeSessionForVolumeTests('fake_uri')",
            "        self.ops = volumeops.VolumeOps(self.session)",
            "",
            "",
            "class VolumeDetachTestCase(VolumeOpsTestBase):",
            "    def test_detach_volume_call(self):",
            "        registered_calls = []",
            "",
            "        def regcall(label):",
            "            def side_effect(*args, **kwargs):",
            "                registered_calls.append(label)",
            "            return side_effect",
            "",
            "        ops = volumeops.VolumeOps('session')",
            "        self.mox.StubOutWithMock(volumeops.vm_utils, 'lookup')",
            "        self.mox.StubOutWithMock(volumeops.volume_utils, 'find_vbd_by_number')",
            "        self.mox.StubOutWithMock(volumeops.vm_utils, 'is_vm_shutdown')",
            "        self.mox.StubOutWithMock(volumeops.vm_utils, 'unplug_vbd')",
            "        self.mox.StubOutWithMock(volumeops.vm_utils, 'destroy_vbd')",
            "        self.mox.StubOutWithMock(volumeops.volume_utils, 'get_device_number')",
            "        self.mox.StubOutWithMock(volumeops.volume_utils, 'find_sr_from_vbd')",
            "        self.mox.StubOutWithMock(volumeops.volume_utils, 'purge_sr')",
            "",
            "        volumeops.vm_utils.lookup('session', 'instance_1').AndReturn(",
            "            'vmref')",
            "",
            "        volumeops.volume_utils.get_device_number('mountpoint').AndReturn(",
            "            'devnumber')",
            "",
            "        volumeops.volume_utils.find_vbd_by_number(",
            "            'session', 'vmref', 'devnumber').AndReturn('vbdref')",
            "",
            "        volumeops.vm_utils.is_vm_shutdown('session', 'vmref').AndReturn(",
            "            False)",
            "",
            "        volumeops.vm_utils.unplug_vbd('session', 'vbdref', 'vmref')",
            "",
            "        volumeops.vm_utils.destroy_vbd('session', 'vbdref').WithSideEffects(",
            "            regcall('destroy_vbd'))",
            "",
            "        volumeops.volume_utils.find_sr_from_vbd(",
            "            'session', 'vbdref').WithSideEffects(",
            "                regcall('find_sr_from_vbd')).AndReturn('srref')",
            "",
            "        volumeops.volume_utils.purge_sr('session', 'srref')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        ops.detach_volume(",
            "            dict(driver_volume_type='iscsi', data='conn_data'),",
            "            'instance_1', 'mountpoint')",
            "",
            "        self.assertEqual(",
            "            ['find_sr_from_vbd', 'destroy_vbd'], registered_calls)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volume_utils, \"find_vbd_by_number\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_detach_volume(self, mock_vm, mock_vbd, mock_detach):",
            "        mock_vm.return_value = \"vm_ref\"",
            "        mock_vbd.return_value = \"vbd_ref\"",
            "",
            "        self.ops.detach_volume({}, \"name\", \"/dev/xvdd\")",
            "",
            "        mock_vm.assert_called_once_with(self.session, \"name\")",
            "        mock_vbd.assert_called_once_with(self.session, \"vm_ref\", 3)",
            "        mock_detach.assert_called_once_with(\"vm_ref\", [\"vbd_ref\"])",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volume_utils, \"find_vbd_by_number\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_detach_volume_skips_error_skip_attach(self, mock_vm, mock_vbd,",
            "                                                   mock_detach):",
            "        mock_vm.return_value = \"vm_ref\"",
            "        mock_vbd.return_value = None",
            "",
            "        self.ops.detach_volume({}, \"name\", \"/dev/xvdd\")",
            "",
            "        self.assertFalse(mock_detach.called)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volume_utils, \"find_vbd_by_number\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_detach_volume_raises(self, mock_vm, mock_vbd,",
            "                                  mock_detach):",
            "        mock_vm.return_value = \"vm_ref\"",
            "        mock_vbd.side_effect = test.TestingException",
            "",
            "        self.assertRaises(test.TestingException,",
            "                          self.ops.detach_volume, {}, \"name\", \"/dev/xvdd\")",
            "        self.assertFalse(mock_detach.called)",
            "",
            "    @mock.patch.object(volume_utils, \"purge_sr\")",
            "    @mock.patch.object(vm_utils, \"destroy_vbd\")",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(vm_utils, \"unplug_vbd\")",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    def test_detach_vbds_and_srs_not_shutdown(self, mock_shutdown, mock_unplug,",
            "            mock_find_sr, mock_destroy, mock_purge):",
            "        mock_shutdown.return_value = False",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        self.ops._detach_vbds_and_srs(\"vm_ref\", [\"vbd_ref\"])",
            "",
            "        mock_shutdown.assert_called_once_with(self.session, \"vm_ref\")",
            "        mock_find_sr.assert_called_once_with(self.session, \"vbd_ref\")",
            "        mock_unplug.assert_called_once_with(self.session, \"vbd_ref\", \"vm_ref\")",
            "        mock_destroy.assert_called_once_with(self.session, \"vbd_ref\")",
            "        mock_purge.assert_called_once_with(self.session, \"sr_ref\")",
            "",
            "    @mock.patch.object(volume_utils, \"purge_sr\")",
            "    @mock.patch.object(vm_utils, \"destroy_vbd\")",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(vm_utils, \"unplug_vbd\")",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    def test_detach_vbds_and_srs_is_shutdown(self, mock_shutdown, mock_unplug,",
            "            mock_find_sr, mock_destroy, mock_purge):",
            "        mock_shutdown.return_value = True",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        self.ops._detach_vbds_and_srs(\"vm_ref\", [\"vbd_ref_1\", \"vbd_ref_2\"])",
            "",
            "        expected = [mock.call(self.session, \"vbd_ref_1\"),",
            "                    mock.call(self.session, \"vbd_ref_2\")]",
            "        self.assertEqual(expected, mock_destroy.call_args_list)",
            "        mock_purge.assert_called_with(self.session, \"sr_ref\")",
            "        self.assertFalse(mock_unplug.called)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_detach_all_no_volumes(self, mock_get_all, mock_detach):",
            "        mock_get_all.return_value = []",
            "",
            "        self.ops.detach_all(\"vm_ref\")",
            "",
            "        mock_get_all.assert_called_once_with(\"vm_ref\")",
            "        self.assertFalse(mock_detach.called)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_detach_vbds_and_srs\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_detach_all_volumes(self, mock_get_all, mock_detach):",
            "        mock_get_all.return_value = [\"1\"]",
            "",
            "        self.ops.detach_all(\"vm_ref\")",
            "",
            "        mock_get_all.assert_called_once_with(\"vm_ref\")",
            "        mock_detach.assert_called_once_with(\"vm_ref\", [\"1\"])",
            "",
            "    def test_get_all_volume_vbd_refs_no_vbds(self):",
            "        with mock.patch.object(self.session.VM, \"get_VBDs\") as mock_get:",
            "            with mock.patch.object(self.session.VBD,",
            "                                   \"get_other_config\") as mock_conf:",
            "                mock_get.return_value = []",
            "",
            "                result = self.ops._get_all_volume_vbd_refs(\"vm_ref\")",
            "",
            "                self.assertEqual([], list(result))",
            "                mock_get.assert_called_once_with(\"vm_ref\")",
            "                self.assertFalse(mock_conf.called)",
            "",
            "    def test_get_all_volume_vbd_refs_no_volumes(self):",
            "        with mock.patch.object(self.session.VM, \"get_VBDs\") as mock_get:",
            "            with mock.patch.object(self.session.VBD,",
            "                                   \"get_other_config\") as mock_conf:",
            "                mock_get.return_value = [\"1\"]",
            "                mock_conf.return_value = {}",
            "",
            "                result = self.ops._get_all_volume_vbd_refs(\"vm_ref\")",
            "",
            "                self.assertEqual([], list(result))",
            "                mock_get.assert_called_once_with(\"vm_ref\")",
            "                mock_conf.assert_called_once_with(\"1\")",
            "",
            "    def test_get_all_volume_vbd_refs_with_volumes(self):",
            "        with mock.patch.object(self.session.VM, \"get_VBDs\") as mock_get:",
            "            with mock.patch.object(self.session.VBD,",
            "                                   \"get_other_config\") as mock_conf:",
            "                mock_get.return_value = [\"1\", \"2\"]",
            "                mock_conf.return_value = {\"osvol\": True}",
            "",
            "                result = self.ops._get_all_volume_vbd_refs(\"vm_ref\")",
            "",
            "                self.assertEqual([\"1\", \"2\"], list(result))",
            "                mock_get.assert_called_once_with(\"vm_ref\")",
            "",
            "",
            "class AttachVolumeTestCase(VolumeOpsTestBase):",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_attach_volume_default_hotplug(self, mock_get_vm, mock_attach):",
            "        mock_get_vm.return_value = \"vm_ref\"",
            "",
            "        self.ops.attach_volume({}, \"instance_name\", \"/dev/xvda\")",
            "",
            "        mock_attach.assert_called_once_with({}, \"vm_ref\", \"instance_name\", 0,",
            "                                            True)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume\")",
            "    @mock.patch.object(vm_utils, \"vm_ref_or_raise\")",
            "    def test_attach_volume_hotplug(self, mock_get_vm, mock_attach):",
            "        mock_get_vm.return_value = \"vm_ref\"",
            "",
            "        self.ops.attach_volume({}, \"instance_name\", \"/dev/xvda\", False)",
            "",
            "        mock_attach.assert_called_once_with({}, \"vm_ref\", \"instance_name\", 0,",
            "                                            False)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume\")",
            "    def test_attach_volume_default_hotplug_connect_volume(self, mock_attach):",
            "        self.ops.connect_volume({})",
            "        mock_attach.assert_called_once_with({})",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_check_is_supported_driver_type\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_to_volume_provider\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_hypervisor_to_volume\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume_to_vm\")",
            "    def test_attach_volume_with_defaults(self, mock_attach, mock_hypervisor,",
            "                                         mock_provider, mock_driver):",
            "        connection_info = {\"data\": {}}",
            "        with mock.patch.object(self.session.VDI, \"get_uuid\") as mock_vdi:",
            "            mock_provider.return_value = (\"sr_ref\", \"sr_uuid\")",
            "            mock_vdi.return_value = \"vdi_uuid\"",
            "",
            "            result = self.ops._attach_volume(connection_info)",
            "",
            "            self.assertEqual(result, (\"sr_uuid\", \"vdi_uuid\"))",
            "",
            "        mock_driver.assert_called_once_with(connection_info)",
            "        mock_provider.assert_called_once_with({}, None)",
            "        mock_hypervisor.assert_called_once_with(\"sr_ref\", {})",
            "        self.assertFalse(mock_attach.called)",
            "",
            "    @mock.patch.object(volumeops.VolumeOps, \"_check_is_supported_driver_type\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_to_volume_provider\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_hypervisor_to_volume\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume_to_vm\")",
            "    def test_attach_volume_with_hot_attach(self, mock_attach, mock_hypervisor,",
            "                                           mock_provider, mock_driver):",
            "        connection_info = {\"data\": {}}",
            "        with mock.patch.object(self.session.VDI, \"get_uuid\") as mock_vdi:",
            "            mock_provider.return_value = (\"sr_ref\", \"sr_uuid\")",
            "            mock_hypervisor.return_value = \"vdi_ref\"",
            "            mock_vdi.return_value = \"vdi_uuid\"",
            "",
            "            result = self.ops._attach_volume(connection_info, \"vm_ref\",",
            "                        \"name\", 2, True)",
            "",
            "            self.assertEqual(result, (\"sr_uuid\", \"vdi_uuid\"))",
            "",
            "        mock_driver.assert_called_once_with(connection_info)",
            "        mock_provider.assert_called_once_with({}, \"name\")",
            "        mock_hypervisor.assert_called_once_with(\"sr_ref\", {})",
            "        mock_attach.assert_called_once_with(\"vdi_ref\", \"vm_ref\", \"name\", 2,",
            "                                            True)",
            "",
            "    @mock.patch.object(volume_utils, \"forget_sr\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_check_is_supported_driver_type\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_to_volume_provider\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_connect_hypervisor_to_volume\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_attach_volume_to_vm\")",
            "    def test_attach_volume_cleanup(self, mock_attach, mock_hypervisor,",
            "                                   mock_provider, mock_driver, mock_forget):",
            "        connection_info = {\"data\": {}}",
            "        mock_provider.return_value = (\"sr_ref\", \"sr_uuid\")",
            "        mock_hypervisor.side_effect = test.TestingException",
            "",
            "        self.assertRaises(test.TestingException,",
            "                          self.ops._attach_volume, connection_info)",
            "",
            "        mock_driver.assert_called_once_with(connection_info)",
            "        mock_provider.assert_called_once_with({}, None)",
            "        mock_hypervisor.assert_called_once_with(\"sr_ref\", {})",
            "        mock_forget.assert_called_once_with(self.session, \"sr_ref\")",
            "        self.assertFalse(mock_attach.called)",
            "",
            "    def test_check_is_supported_driver_type_pass_iscsi(self):",
            "        conn_info = {\"driver_volume_type\": \"iscsi\"}",
            "        self.ops._check_is_supported_driver_type(conn_info)",
            "",
            "    def test_check_is_supported_driver_type_pass_xensm(self):",
            "        conn_info = {\"driver_volume_type\": \"xensm\"}",
            "        self.ops._check_is_supported_driver_type(conn_info)",
            "",
            "    def test_check_is_supported_driver_type_pass_bad(self):",
            "        conn_info = {\"driver_volume_type\": \"bad\"}",
            "        self.assertRaises(exception.VolumeDriverNotFound,",
            "                          self.ops._check_is_supported_driver_type, conn_info)",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_sr\")",
            "    @mock.patch.object(volume_utils, \"find_sr_by_uuid\")",
            "    @mock.patch.object(volume_utils, \"parse_sr_info\")",
            "    def test_connect_to_volume_provider_new_sr(self, mock_parse, mock_find_sr,",
            "                                               mock_introduce_sr):",
            "        mock_parse.return_value = (\"uuid\", \"label\", \"params\")",
            "        mock_find_sr.return_value = None",
            "        mock_introduce_sr.return_value = \"sr_ref\"",
            "",
            "        ref, uuid = self.ops._connect_to_volume_provider({}, \"name\")",
            "",
            "        self.assertEqual(\"sr_ref\", ref)",
            "        self.assertEqual(\"uuid\", uuid)",
            "        mock_parse.assert_called_once_with({}, \"Disk-for:name\")",
            "        mock_find_sr.assert_called_once_with(self.session, \"uuid\")",
            "        mock_introduce_sr.assert_called_once_with(self.session, \"uuid\",",
            "                                                  \"label\", \"params\")",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_sr\")",
            "    @mock.patch.object(volume_utils, \"find_sr_by_uuid\")",
            "    @mock.patch.object(volume_utils, \"parse_sr_info\")",
            "    def test_connect_to_volume_provider_old_sr(self, mock_parse, mock_find_sr,",
            "                                               mock_introduce_sr):",
            "        mock_parse.return_value = (\"uuid\", \"label\", \"params\")",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        ref, uuid = self.ops._connect_to_volume_provider({}, \"name\")",
            "",
            "        self.assertEqual(\"sr_ref\", ref)",
            "        self.assertEqual(\"uuid\", uuid)",
            "        mock_parse.assert_called_once_with({}, \"Disk-for:name\")",
            "        mock_find_sr.assert_called_once_with(self.session, \"uuid\")",
            "        self.assertFalse(mock_introduce_sr.called)",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_vdi\")",
            "    def test_connect_hypervisor_to_volume_regular(self, mock_intro):",
            "        mock_intro.return_value = \"vdi\"",
            "",
            "        result = self.ops._connect_hypervisor_to_volume(\"sr\", {})",
            "",
            "        self.assertEqual(\"vdi\", result)",
            "        mock_intro.assert_called_once_with(self.session, \"sr\")",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_vdi\")",
            "    def test_connect_hypervisor_to_volume_vdi(self, mock_intro):",
            "        mock_intro.return_value = \"vdi\"",
            "",
            "        conn = {\"vdi_uuid\": \"id\"}",
            "        result = self.ops._connect_hypervisor_to_volume(\"sr\", conn)",
            "",
            "        self.assertEqual(\"vdi\", result)",
            "        mock_intro.assert_called_once_with(self.session, \"sr\",",
            "                                           vdi_uuid=\"id\")",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_vdi\")",
            "    def test_connect_hypervisor_to_volume_lun(self, mock_intro):",
            "        mock_intro.return_value = \"vdi\"",
            "",
            "        conn = {\"target_lun\": \"lun\"}",
            "        result = self.ops._connect_hypervisor_to_volume(\"sr\", conn)",
            "",
            "        self.assertEqual(\"vdi\", result)",
            "        mock_intro.assert_called_once_with(self.session, \"sr\",",
            "                                           target_lun=\"lun\")",
            "",
            "    @mock.patch.object(volume_utils, \"introduce_vdi\")",
            "    @mock.patch.object(volumeops.LOG, 'debug')",
            "    def test_connect_hypervisor_to_volume_mask_password(self, mock_debug,",
            "                                                        mock_intro):",
            "        # Tests that the connection_data is scrubbed before logging.",
            "        data = {'auth_password': 'verybadpass'}",
            "        self.ops._connect_hypervisor_to_volume(\"sr\", data)",
            "        self.assertTrue(mock_debug.called, 'LOG.debug was not called')",
            "        password_logged = False",
            "        for call in mock_debug.call_args_list:",
            "            # The call object is a tuple of (args, kwargs)",
            "            if 'verybadpass' in call[0]:",
            "                password_logged = True",
            "                break",
            "        self.assertFalse(password_logged, 'connection_data was not scrubbed')",
            "",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    @mock.patch.object(vm_utils, \"create_vbd\")",
            "    def test_attach_volume_to_vm_plug(self, mock_vbd, mock_shutdown):",
            "        mock_vbd.return_value = \"vbd\"",
            "        mock_shutdown.return_value = False",
            "",
            "        with mock.patch.object(self.session.VBD, \"plug\") as mock_plug:",
            "            self.ops._attach_volume_to_vm(\"vdi\", \"vm\", \"name\", 2, True)",
            "            mock_plug.assert_called_once_with(\"vbd\", \"vm\")",
            "",
            "        mock_vbd.assert_called_once_with(self.session, \"vm\", \"vdi\", 2,",
            "                                         bootable=False, osvol=True)",
            "        mock_shutdown.assert_called_once_with(self.session, \"vm\")",
            "",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    @mock.patch.object(vm_utils, \"create_vbd\")",
            "    def test_attach_volume_to_vm_no_plug(self, mock_vbd, mock_shutdown):",
            "        mock_vbd.return_value = \"vbd\"",
            "        mock_shutdown.return_value = True",
            "",
            "        with mock.patch.object(self.session.VBD, \"plug\") as mock_plug:",
            "            self.ops._attach_volume_to_vm(\"vdi\", \"vm\", \"name\", 2, True)",
            "            self.assertFalse(mock_plug.called)",
            "",
            "        mock_vbd.assert_called_once_with(self.session, \"vm\", \"vdi\", 2,",
            "                                         bootable=False, osvol=True)",
            "        mock_shutdown.assert_called_once_with(self.session, \"vm\")",
            "",
            "    @mock.patch.object(vm_utils, \"is_vm_shutdown\")",
            "    @mock.patch.object(vm_utils, \"create_vbd\")",
            "    def test_attach_volume_to_vm_no_hotplug(self, mock_vbd, mock_shutdown):",
            "        mock_vbd.return_value = \"vbd\"",
            "",
            "        with mock.patch.object(self.session.VBD, \"plug\") as mock_plug:",
            "            self.ops._attach_volume_to_vm(\"vdi\", \"vm\", \"name\", 2, False)",
            "            self.assertFalse(mock_plug.called)",
            "",
            "        mock_vbd.assert_called_once_with(self.session, \"vm\", \"vdi\", 2,",
            "                                         bootable=False, osvol=True)",
            "        self.assertFalse(mock_shutdown.called)",
            "",
            "",
            "class FindBadVolumeTestCase(VolumeOpsTestBase):",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_find_bad_volumes_no_vbds(self, mock_get_all):",
            "        mock_get_all.return_value = []",
            "",
            "        result = self.ops.find_bad_volumes(\"vm_ref\")",
            "",
            "        mock_get_all.assert_called_once_with(\"vm_ref\")",
            "        self.assertEqual([], result)",
            "",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_find_bad_volumes_no_bad_vbds(self, mock_get_all, mock_find_sr):",
            "        mock_get_all.return_value = [\"1\", \"2\"]",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        with mock.patch.object(self.session.SR, \"scan\") as mock_scan:",
            "            result = self.ops.find_bad_volumes(\"vm_ref\")",
            "",
            "            mock_get_all.assert_called_once_with(\"vm_ref\")",
            "            expected_find = [mock.call(self.session, \"1\"),",
            "                             mock.call(self.session, \"2\")]",
            "            self.assertEqual(expected_find, mock_find_sr.call_args_list)",
            "            expected_scan = [mock.call(\"sr_ref\"), mock.call(\"sr_ref\")]",
            "            self.assertEqual(expected_scan, mock_scan.call_args_list)",
            "            self.assertEqual([], result)",
            "",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_find_bad_volumes_bad_vbds(self, mock_get_all, mock_find_sr):",
            "        mock_get_all.return_value = [\"vbd_ref\"]",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        class FakeException(Exception):",
            "            details = ['SR_BACKEND_FAILURE_40', \"\", \"\", \"\"]",
            "",
            "        session = mock.Mock()",
            "        session.XenAPI.Failure = FakeException",
            "        self.ops._session = session",
            "",
            "        with mock.patch.object(session.SR, \"scan\") as mock_scan:",
            "            with mock.patch.object(session.VBD,",
            "                                   \"get_device\") as mock_get:",
            "                mock_scan.side_effect = FakeException",
            "                mock_get.return_value = \"xvdb\"",
            "",
            "                result = self.ops.find_bad_volumes(\"vm_ref\")",
            "",
            "                mock_get_all.assert_called_once_with(\"vm_ref\")",
            "                mock_scan.assert_called_once_with(\"sr_ref\")",
            "                mock_get.assert_called_once_with(\"vbd_ref\")",
            "                self.assertEqual([\"/dev/xvdb\"], result)",
            "",
            "    @mock.patch.object(volume_utils, \"find_sr_from_vbd\")",
            "    @mock.patch.object(volumeops.VolumeOps, \"_get_all_volume_vbd_refs\")",
            "    def test_find_bad_volumes_raises(self, mock_get_all, mock_find_sr):",
            "        mock_get_all.return_value = [\"vbd_ref\"]",
            "        mock_find_sr.return_value = \"sr_ref\"",
            "",
            "        class FakeException(Exception):",
            "            details = ['foo', \"\", \"\", \"\"]",
            "",
            "        session = mock.Mock()",
            "        session.XenAPI.Failure = FakeException",
            "        self.ops._session = session",
            "",
            "        with mock.patch.object(session.SR, \"scan\") as mock_scan:",
            "            with mock.patch.object(session.VBD,",
            "                                   \"get_device\") as mock_get:",
            "                mock_scan.side_effect = FakeException",
            "                mock_get.return_value = \"xvdb\"",
            "",
            "                self.assertRaises(FakeException,",
            "                                  self.ops.find_bad_volumes, \"vm_ref\")",
            "                mock_scan.assert_called_once_with(\"sr_ref\")",
            "",
            "",
            "class CleanupFromVDIsTestCase(VolumeOpsTestBase):",
            "    def _check_find_purge_calls(self, find_sr_from_vdi, purge_sr, vdi_refs,",
            "            sr_refs):",
            "        find_sr_calls = [mock.call(self.ops._session, vdi_ref) for vdi_ref",
            "                in vdi_refs]",
            "        find_sr_from_vdi.assert_has_calls(find_sr_calls)",
            "        purge_sr_calls = [mock.call(self.ops._session, sr_ref) for sr_ref",
            "                in sr_refs]",
            "        purge_sr.assert_has_calls(purge_sr_calls)",
            "",
            "    @mock.patch.object(volume_utils, 'find_sr_from_vdi')",
            "    @mock.patch.object(volume_utils, 'purge_sr')",
            "    def test_safe_cleanup_from_vdis(self, purge_sr, find_sr_from_vdi):",
            "        vdi_refs = ['vdi_ref1', 'vdi_ref2']",
            "        sr_refs = ['sr_ref1', 'sr_ref2']",
            "        find_sr_from_vdi.side_effect = sr_refs",
            "        self.ops.safe_cleanup_from_vdis(vdi_refs)",
            "",
            "        self._check_find_purge_calls(find_sr_from_vdi, purge_sr, vdi_refs,",
            "                sr_refs)",
            "",
            "    @mock.patch.object(volume_utils, 'find_sr_from_vdi',",
            "            side_effect=[exception.StorageError(reason=''), 'sr_ref2'])",
            "    @mock.patch.object(volume_utils, 'purge_sr')",
            "    def test_safe_cleanup_from_vdis_handles_find_sr_exception(self, purge_sr,",
            "            find_sr_from_vdi):",
            "        vdi_refs = ['vdi_ref1', 'vdi_ref2']",
            "        sr_refs = ['sr_ref2']",
            "        find_sr_from_vdi.side_effect = [exception.StorageError(reason=''),",
            "                sr_refs[0]]",
            "        self.ops.safe_cleanup_from_vdis(vdi_refs)",
            "",
            "        self._check_find_purge_calls(find_sr_from_vdi, purge_sr, vdi_refs,",
            "                sr_refs)",
            "",
            "    @mock.patch.object(volume_utils, 'find_sr_from_vdi')",
            "    @mock.patch.object(volume_utils, 'purge_sr')",
            "    def test_safe_cleanup_from_vdis_handles_purge_sr_exception(self, purge_sr,",
            "            find_sr_from_vdi):",
            "        vdi_refs = ['vdi_ref1', 'vdi_ref2']",
            "        sr_refs = ['sr_ref1', 'sr_ref2']",
            "        find_sr_from_vdi.side_effect = sr_refs",
            "        purge_sr.side_effects = [test.TestingException, None]",
            "        self.ops.safe_cleanup_from_vdis(vdi_refs)",
            "",
            "        self._check_find_purge_calls(find_sr_from_vdi, purge_sr, vdi_refs,",
            "                sr_refs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.agentscope.studio._app",
            "nova.tests.unit.virt.xenapi.test_volumeops.AttachVolumeTestCase.self"
        ]
    },
    "nova/virt/xenapi/volume_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from eventlet import greenthread"
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from oslo_config import cfg"
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from oslo_log import log as logging"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from oslo_utils import strutils"
            },
            "4": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from nova import exception"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from nova.i18n import _, _LE, _LW"
            },
            "7": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             target_iqn is None):"
            },
            "8": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         raise exception.StorageError("
            },
            "9": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                 reason=_('Unable to obtain target information %s') %"
            },
            "10": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        connection_data)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                        strutils.mask_password(connection_data))"
            },
            "12": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "     volume_info = {}"
            },
            "13": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "     volume_info['id'] = volume_id"
            },
            "14": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     volume_info['target'] = target_host"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "# Copyright (c) 2013 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Helper methods for operations related to the management of volumes,",
            "and storage repositories",
            "\"\"\"",
            "",
            "import re",
            "import string",
            "",
            "from eventlet import greenthread",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "",
            "from nova import exception",
            "from nova.i18n import _, _LE, _LW",
            "",
            "xenapi_volume_utils_opts = [",
            "    cfg.IntOpt('introduce_vdi_retry_wait',",
            "               default=20,",
            "               help='Number of seconds to wait for an SR to settle '",
            "                    'if the VDI does not exist when first introduced'),",
            "    ]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(xenapi_volume_utils_opts, 'xenserver')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def parse_sr_info(connection_data, description=''):",
            "    label = connection_data.pop('name_label',",
            "                                'tempSR-%s' % connection_data.get('volume_id'))",
            "    params = {}",
            "    if 'sr_uuid' not in connection_data:",
            "        params = _parse_volume_info(connection_data)",
            "        # This magic label sounds a lot like 'False Disc' in leet-speak",
            "        uuid = \"FA15E-D15C-\" + str(params['id'])",
            "    else:",
            "        uuid = connection_data['sr_uuid']",
            "        for k in connection_data.get('introduce_sr_keys', {}):",
            "            params[k] = connection_data[k]",
            "    params['name_description'] = connection_data.get('name_description',",
            "                                                     description)",
            "",
            "    return (uuid, label, params)",
            "",
            "",
            "def _parse_volume_info(connection_data):",
            "    \"\"\"Parse device_path and mountpoint as they can be used by XenAPI.",
            "    In particular, the mountpoint (e.g. /dev/sdc) must be translated",
            "    into a numeric literal.",
            "    \"\"\"",
            "    volume_id = connection_data['volume_id']",
            "    target_portal = connection_data['target_portal']",
            "    target_host = _get_target_host(target_portal)",
            "    target_port = _get_target_port(target_portal)",
            "    target_iqn = connection_data['target_iqn']",
            "",
            "    log_params = {",
            "        \"vol_id\": volume_id,",
            "        \"host\": target_host,",
            "        \"port\": target_port,",
            "        \"iqn\": target_iqn",
            "    }",
            "    LOG.debug('(vol_id,host,port,iqn): '",
            "              '(%(vol_id)s,%(host)s,%(port)s,%(iqn)s)', log_params)",
            "",
            "    if (volume_id is None or",
            "        target_host is None or",
            "            target_iqn is None):",
            "        raise exception.StorageError(",
            "                reason=_('Unable to obtain target information %s') %",
            "                        connection_data)",
            "    volume_info = {}",
            "    volume_info['id'] = volume_id",
            "    volume_info['target'] = target_host",
            "    volume_info['port'] = target_port",
            "    volume_info['targetIQN'] = target_iqn",
            "    if ('auth_method' in connection_data and",
            "            connection_data['auth_method'] == 'CHAP'):",
            "        volume_info['chapuser'] = connection_data['auth_username']",
            "        volume_info['chappassword'] = connection_data['auth_password']",
            "",
            "    return volume_info",
            "",
            "",
            "def _get_target_host(iscsi_string):",
            "    \"\"\"Retrieve target host.\"\"\"",
            "    if iscsi_string:",
            "        host = iscsi_string.split(':')[0]",
            "        if len(host) > 0:",
            "            return host",
            "    return CONF.xenserver.target_host",
            "",
            "",
            "def _get_target_port(iscsi_string):",
            "    \"\"\"Retrieve target port.\"\"\"",
            "    if iscsi_string and ':' in iscsi_string:",
            "        return iscsi_string.split(':')[1]",
            "",
            "    return CONF.xenserver.target_port",
            "",
            "",
            "def introduce_sr(session, sr_uuid, label, params):",
            "    LOG.debug('Introducing SR %s', label)",
            "",
            "    sr_type, sr_desc = _handle_sr_params(params)",
            "",
            "    sr_ref = session.call_xenapi('SR.introduce', sr_uuid, label, sr_desc,",
            "            sr_type, '', False, params)",
            "",
            "    LOG.debug('Creating PBD for SR')",
            "    pbd_ref = _create_pbd(session, sr_ref, params)",
            "",
            "    LOG.debug('Plugging SR')",
            "    session.call_xenapi(\"PBD.plug\", pbd_ref)",
            "",
            "    session.call_xenapi(\"SR.scan\", sr_ref)",
            "    return sr_ref",
            "",
            "",
            "def _handle_sr_params(params):",
            "    if 'id' in params:",
            "        del params['id']",
            "",
            "    sr_type = params.pop('sr_type', 'iscsi')",
            "    sr_desc = params.pop('name_description', '')",
            "    return sr_type, sr_desc",
            "",
            "",
            "def _create_pbd(session, sr_ref, params):",
            "    pbd_rec = {}",
            "    pbd_rec['host'] = session.host_ref",
            "    pbd_rec['SR'] = sr_ref",
            "    pbd_rec['device_config'] = params",
            "    pbd_ref = session.call_xenapi(\"PBD.create\", pbd_rec)",
            "    return pbd_ref",
            "",
            "",
            "def introduce_vdi(session, sr_ref, vdi_uuid=None, target_lun=None):",
            "    \"\"\"Introduce VDI in the host.\"\"\"",
            "    try:",
            "        vdi_ref = _get_vdi_ref(session, sr_ref, vdi_uuid, target_lun)",
            "        if vdi_ref is None:",
            "            greenthread.sleep(CONF.xenserver.introduce_vdi_retry_wait)",
            "            session.call_xenapi(\"SR.scan\", sr_ref)",
            "            vdi_ref = _get_vdi_ref(session, sr_ref, vdi_uuid, target_lun)",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to introduce VDI on SR'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to introduce VDI on SR %s') % sr_ref)",
            "",
            "    if not vdi_ref:",
            "        raise exception.StorageError(",
            "                reason=_('VDI not found on SR %(sr)s (vdi_uuid '",
            "                         '%(vdi_uuid)s, target_lun %(target_lun)s)') %",
            "                            {'sr': sr_ref, 'vdi_uuid': vdi_uuid,",
            "                             'target_lun': target_lun})",
            "",
            "    try:",
            "        vdi_rec = session.call_xenapi(\"VDI.get_record\", vdi_ref)",
            "        LOG.debug(vdi_rec)",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to get record of VDI'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to get record of VDI %s on') % vdi_ref)",
            "",
            "    if vdi_rec['managed']:",
            "        # We do not need to introduce the vdi",
            "        return vdi_ref",
            "",
            "    try:",
            "        return session.call_xenapi(\"VDI.introduce\",",
            "                                    vdi_rec['uuid'],",
            "                                    vdi_rec['name_label'],",
            "                                    vdi_rec['name_description'],",
            "                                    vdi_rec['SR'],",
            "                                    vdi_rec['type'],",
            "                                    vdi_rec['sharable'],",
            "                                    vdi_rec['read_only'],",
            "                                    vdi_rec['other_config'],",
            "                                    vdi_rec['location'],",
            "                                    vdi_rec['xenstore_data'],",
            "                                    vdi_rec['sm_config'])",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to introduce VDI for SR'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to introduce VDI for SR %s') % sr_ref)",
            "",
            "",
            "def _get_vdi_ref(session, sr_ref, vdi_uuid, target_lun):",
            "    if vdi_uuid:",
            "        LOG.debug(\"vdi_uuid: %s\" % vdi_uuid)",
            "        return session.call_xenapi(\"VDI.get_by_uuid\", vdi_uuid)",
            "    elif target_lun:",
            "        vdi_refs = session.call_xenapi(\"SR.get_VDIs\", sr_ref)",
            "        for curr_ref in vdi_refs:",
            "            curr_rec = session.call_xenapi(\"VDI.get_record\", curr_ref)",
            "            if ('sm_config' in curr_rec and",
            "                'LUNid' in curr_rec['sm_config'] and",
            "                curr_rec['sm_config']['LUNid'] == str(target_lun)):",
            "                return curr_ref",
            "    else:",
            "        return (session.call_xenapi(\"SR.get_VDIs\", sr_ref))[0]",
            "",
            "    return None",
            "",
            "",
            "def purge_sr(session, sr_ref):",
            "    # Make sure no VBDs are referencing the SR VDIs",
            "    vdi_refs = session.call_xenapi(\"SR.get_VDIs\", sr_ref)",
            "    for vdi_ref in vdi_refs:",
            "        vbd_refs = session.call_xenapi(\"VDI.get_VBDs\", vdi_ref)",
            "        if vbd_refs:",
            "            LOG.warning(_LW('Cannot purge SR with referenced VDIs'))",
            "            return",
            "",
            "    forget_sr(session, sr_ref)",
            "",
            "",
            "def forget_sr(session, sr_ref):",
            "    \"\"\"Forgets the storage repository without destroying the VDIs within.\"\"\"",
            "    LOG.debug('Forgetting SR...')",
            "    _unplug_pbds(session, sr_ref)",
            "    session.call_xenapi(\"SR.forget\", sr_ref)",
            "",
            "",
            "def _unplug_pbds(session, sr_ref):",
            "    try:",
            "        pbds = session.call_xenapi(\"SR.get_PBDs\", sr_ref)",
            "    except session.XenAPI.Failure as exc:",
            "        LOG.warning(_LW('Ignoring exception %(exc)s when getting PBDs'",
            "                        ' for %(sr_ref)s'), {'exc': exc, 'sr_ref': sr_ref})",
            "        return",
            "",
            "    for pbd in pbds:",
            "        try:",
            "            session.call_xenapi(\"PBD.unplug\", pbd)",
            "        except session.XenAPI.Failure as exc:",
            "            LOG.warning(_LW('Ignoring exception %(exc)s when unplugging'",
            "                            ' PBD %(pbd)s'), {'exc': exc, 'pbd': pbd})",
            "",
            "",
            "def get_device_number(mountpoint):",
            "    device_number = _mountpoint_to_number(mountpoint)",
            "    if device_number < 0:",
            "        raise exception.StorageError(",
            "                reason=_('Unable to obtain target information %s') %",
            "                       mountpoint)",
            "    return device_number",
            "",
            "",
            "def _mountpoint_to_number(mountpoint):",
            "    \"\"\"Translate a mountpoint like /dev/sdc into a numeric.\"\"\"",
            "    if mountpoint.startswith('/dev/'):",
            "        mountpoint = mountpoint[5:]",
            "    if re.match('^[hs]d[a-p]$', mountpoint):",
            "        return (ord(mountpoint[2:3]) - ord('a'))",
            "    elif re.match('^x?vd[a-p]$', mountpoint):",
            "        return (ord(mountpoint[-1]) - ord('a'))",
            "    elif re.match('^[0-9]+$', mountpoint):",
            "        return string.atoi(mountpoint, 10)",
            "    else:",
            "        LOG.warning(_LW('Mountpoint cannot be translated: %s'), mountpoint)",
            "        return -1",
            "",
            "",
            "def find_sr_by_uuid(session, sr_uuid):",
            "    \"\"\"Return the storage repository given a uuid.\"\"\"",
            "    try:",
            "        return session.call_xenapi(\"SR.get_by_uuid\", sr_uuid)",
            "    except session.XenAPI.Failure as exc:",
            "        if exc.details[0] == 'UUID_INVALID':",
            "            return None",
            "        raise",
            "",
            "",
            "def find_sr_from_vbd(session, vbd_ref):",
            "    \"\"\"Find the SR reference from the VBD reference.\"\"\"",
            "    try:",
            "        vdi_ref = session.call_xenapi(\"VBD.get_VDI\", vbd_ref)",
            "        sr_ref = session.call_xenapi(\"VDI.get_SR\", vdi_ref)",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to find SR from VBD'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to find SR from VBD %s') % vbd_ref)",
            "    return sr_ref",
            "",
            "",
            "def find_sr_from_vdi(session, vdi_ref):",
            "    \"\"\"Find the SR reference from the VDI reference.\"\"\"",
            "    try:",
            "        sr_ref = session.call_xenapi(\"VDI.get_SR\", vdi_ref)",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to find SR from VDI'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to find SR from VDI %s') % vdi_ref)",
            "    return sr_ref",
            "",
            "",
            "def find_vbd_by_number(session, vm_ref, dev_number):",
            "    \"\"\"Get the VBD reference from the device number.\"\"\"",
            "    vbd_refs = session.VM.get_VBDs(vm_ref)",
            "    requested_device = str(dev_number)",
            "    if vbd_refs:",
            "        for vbd_ref in vbd_refs:",
            "            try:",
            "                user_device = session.VBD.get_userdevice(vbd_ref)",
            "                if user_device == requested_device:",
            "                    return vbd_ref",
            "            except session.XenAPI.Failure:",
            "                msg = \"Error looking up VBD %s for %s\" % (vbd_ref, vm_ref)",
            "                LOG.debug(msg, exc_info=True)",
            "",
            "",
            "def is_booted_from_volume(session, vm_ref):",
            "    \"\"\"Determine if the root device is a volume.\"\"\"",
            "    vbd_ref = find_vbd_by_number(session, vm_ref, 0)",
            "    vbd_other_config = session.VBD.get_other_config(vbd_ref)",
            "    if vbd_other_config.get('osvol', False):",
            "        return True",
            "    return False"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "# Copyright (c) 2013 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Helper methods for operations related to the management of volumes,",
            "and storage repositories",
            "\"\"\"",
            "",
            "import re",
            "import string",
            "",
            "from eventlet import greenthread",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_utils import strutils",
            "",
            "from nova import exception",
            "from nova.i18n import _, _LE, _LW",
            "",
            "xenapi_volume_utils_opts = [",
            "    cfg.IntOpt('introduce_vdi_retry_wait',",
            "               default=20,",
            "               help='Number of seconds to wait for an SR to settle '",
            "                    'if the VDI does not exist when first introduced'),",
            "    ]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(xenapi_volume_utils_opts, 'xenserver')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def parse_sr_info(connection_data, description=''):",
            "    label = connection_data.pop('name_label',",
            "                                'tempSR-%s' % connection_data.get('volume_id'))",
            "    params = {}",
            "    if 'sr_uuid' not in connection_data:",
            "        params = _parse_volume_info(connection_data)",
            "        # This magic label sounds a lot like 'False Disc' in leet-speak",
            "        uuid = \"FA15E-D15C-\" + str(params['id'])",
            "    else:",
            "        uuid = connection_data['sr_uuid']",
            "        for k in connection_data.get('introduce_sr_keys', {}):",
            "            params[k] = connection_data[k]",
            "    params['name_description'] = connection_data.get('name_description',",
            "                                                     description)",
            "",
            "    return (uuid, label, params)",
            "",
            "",
            "def _parse_volume_info(connection_data):",
            "    \"\"\"Parse device_path and mountpoint as they can be used by XenAPI.",
            "    In particular, the mountpoint (e.g. /dev/sdc) must be translated",
            "    into a numeric literal.",
            "    \"\"\"",
            "    volume_id = connection_data['volume_id']",
            "    target_portal = connection_data['target_portal']",
            "    target_host = _get_target_host(target_portal)",
            "    target_port = _get_target_port(target_portal)",
            "    target_iqn = connection_data['target_iqn']",
            "",
            "    log_params = {",
            "        \"vol_id\": volume_id,",
            "        \"host\": target_host,",
            "        \"port\": target_port,",
            "        \"iqn\": target_iqn",
            "    }",
            "    LOG.debug('(vol_id,host,port,iqn): '",
            "              '(%(vol_id)s,%(host)s,%(port)s,%(iqn)s)', log_params)",
            "",
            "    if (volume_id is None or",
            "        target_host is None or",
            "            target_iqn is None):",
            "        raise exception.StorageError(",
            "                reason=_('Unable to obtain target information %s') %",
            "                        strutils.mask_password(connection_data))",
            "    volume_info = {}",
            "    volume_info['id'] = volume_id",
            "    volume_info['target'] = target_host",
            "    volume_info['port'] = target_port",
            "    volume_info['targetIQN'] = target_iqn",
            "    if ('auth_method' in connection_data and",
            "            connection_data['auth_method'] == 'CHAP'):",
            "        volume_info['chapuser'] = connection_data['auth_username']",
            "        volume_info['chappassword'] = connection_data['auth_password']",
            "",
            "    return volume_info",
            "",
            "",
            "def _get_target_host(iscsi_string):",
            "    \"\"\"Retrieve target host.\"\"\"",
            "    if iscsi_string:",
            "        host = iscsi_string.split(':')[0]",
            "        if len(host) > 0:",
            "            return host",
            "    return CONF.xenserver.target_host",
            "",
            "",
            "def _get_target_port(iscsi_string):",
            "    \"\"\"Retrieve target port.\"\"\"",
            "    if iscsi_string and ':' in iscsi_string:",
            "        return iscsi_string.split(':')[1]",
            "",
            "    return CONF.xenserver.target_port",
            "",
            "",
            "def introduce_sr(session, sr_uuid, label, params):",
            "    LOG.debug('Introducing SR %s', label)",
            "",
            "    sr_type, sr_desc = _handle_sr_params(params)",
            "",
            "    sr_ref = session.call_xenapi('SR.introduce', sr_uuid, label, sr_desc,",
            "            sr_type, '', False, params)",
            "",
            "    LOG.debug('Creating PBD for SR')",
            "    pbd_ref = _create_pbd(session, sr_ref, params)",
            "",
            "    LOG.debug('Plugging SR')",
            "    session.call_xenapi(\"PBD.plug\", pbd_ref)",
            "",
            "    session.call_xenapi(\"SR.scan\", sr_ref)",
            "    return sr_ref",
            "",
            "",
            "def _handle_sr_params(params):",
            "    if 'id' in params:",
            "        del params['id']",
            "",
            "    sr_type = params.pop('sr_type', 'iscsi')",
            "    sr_desc = params.pop('name_description', '')",
            "    return sr_type, sr_desc",
            "",
            "",
            "def _create_pbd(session, sr_ref, params):",
            "    pbd_rec = {}",
            "    pbd_rec['host'] = session.host_ref",
            "    pbd_rec['SR'] = sr_ref",
            "    pbd_rec['device_config'] = params",
            "    pbd_ref = session.call_xenapi(\"PBD.create\", pbd_rec)",
            "    return pbd_ref",
            "",
            "",
            "def introduce_vdi(session, sr_ref, vdi_uuid=None, target_lun=None):",
            "    \"\"\"Introduce VDI in the host.\"\"\"",
            "    try:",
            "        vdi_ref = _get_vdi_ref(session, sr_ref, vdi_uuid, target_lun)",
            "        if vdi_ref is None:",
            "            greenthread.sleep(CONF.xenserver.introduce_vdi_retry_wait)",
            "            session.call_xenapi(\"SR.scan\", sr_ref)",
            "            vdi_ref = _get_vdi_ref(session, sr_ref, vdi_uuid, target_lun)",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to introduce VDI on SR'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to introduce VDI on SR %s') % sr_ref)",
            "",
            "    if not vdi_ref:",
            "        raise exception.StorageError(",
            "                reason=_('VDI not found on SR %(sr)s (vdi_uuid '",
            "                         '%(vdi_uuid)s, target_lun %(target_lun)s)') %",
            "                            {'sr': sr_ref, 'vdi_uuid': vdi_uuid,",
            "                             'target_lun': target_lun})",
            "",
            "    try:",
            "        vdi_rec = session.call_xenapi(\"VDI.get_record\", vdi_ref)",
            "        LOG.debug(vdi_rec)",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to get record of VDI'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to get record of VDI %s on') % vdi_ref)",
            "",
            "    if vdi_rec['managed']:",
            "        # We do not need to introduce the vdi",
            "        return vdi_ref",
            "",
            "    try:",
            "        return session.call_xenapi(\"VDI.introduce\",",
            "                                    vdi_rec['uuid'],",
            "                                    vdi_rec['name_label'],",
            "                                    vdi_rec['name_description'],",
            "                                    vdi_rec['SR'],",
            "                                    vdi_rec['type'],",
            "                                    vdi_rec['sharable'],",
            "                                    vdi_rec['read_only'],",
            "                                    vdi_rec['other_config'],",
            "                                    vdi_rec['location'],",
            "                                    vdi_rec['xenstore_data'],",
            "                                    vdi_rec['sm_config'])",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to introduce VDI for SR'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to introduce VDI for SR %s') % sr_ref)",
            "",
            "",
            "def _get_vdi_ref(session, sr_ref, vdi_uuid, target_lun):",
            "    if vdi_uuid:",
            "        LOG.debug(\"vdi_uuid: %s\" % vdi_uuid)",
            "        return session.call_xenapi(\"VDI.get_by_uuid\", vdi_uuid)",
            "    elif target_lun:",
            "        vdi_refs = session.call_xenapi(\"SR.get_VDIs\", sr_ref)",
            "        for curr_ref in vdi_refs:",
            "            curr_rec = session.call_xenapi(\"VDI.get_record\", curr_ref)",
            "            if ('sm_config' in curr_rec and",
            "                'LUNid' in curr_rec['sm_config'] and",
            "                curr_rec['sm_config']['LUNid'] == str(target_lun)):",
            "                return curr_ref",
            "    else:",
            "        return (session.call_xenapi(\"SR.get_VDIs\", sr_ref))[0]",
            "",
            "    return None",
            "",
            "",
            "def purge_sr(session, sr_ref):",
            "    # Make sure no VBDs are referencing the SR VDIs",
            "    vdi_refs = session.call_xenapi(\"SR.get_VDIs\", sr_ref)",
            "    for vdi_ref in vdi_refs:",
            "        vbd_refs = session.call_xenapi(\"VDI.get_VBDs\", vdi_ref)",
            "        if vbd_refs:",
            "            LOG.warning(_LW('Cannot purge SR with referenced VDIs'))",
            "            return",
            "",
            "    forget_sr(session, sr_ref)",
            "",
            "",
            "def forget_sr(session, sr_ref):",
            "    \"\"\"Forgets the storage repository without destroying the VDIs within.\"\"\"",
            "    LOG.debug('Forgetting SR...')",
            "    _unplug_pbds(session, sr_ref)",
            "    session.call_xenapi(\"SR.forget\", sr_ref)",
            "",
            "",
            "def _unplug_pbds(session, sr_ref):",
            "    try:",
            "        pbds = session.call_xenapi(\"SR.get_PBDs\", sr_ref)",
            "    except session.XenAPI.Failure as exc:",
            "        LOG.warning(_LW('Ignoring exception %(exc)s when getting PBDs'",
            "                        ' for %(sr_ref)s'), {'exc': exc, 'sr_ref': sr_ref})",
            "        return",
            "",
            "    for pbd in pbds:",
            "        try:",
            "            session.call_xenapi(\"PBD.unplug\", pbd)",
            "        except session.XenAPI.Failure as exc:",
            "            LOG.warning(_LW('Ignoring exception %(exc)s when unplugging'",
            "                            ' PBD %(pbd)s'), {'exc': exc, 'pbd': pbd})",
            "",
            "",
            "def get_device_number(mountpoint):",
            "    device_number = _mountpoint_to_number(mountpoint)",
            "    if device_number < 0:",
            "        raise exception.StorageError(",
            "                reason=_('Unable to obtain target information %s') %",
            "                       mountpoint)",
            "    return device_number",
            "",
            "",
            "def _mountpoint_to_number(mountpoint):",
            "    \"\"\"Translate a mountpoint like /dev/sdc into a numeric.\"\"\"",
            "    if mountpoint.startswith('/dev/'):",
            "        mountpoint = mountpoint[5:]",
            "    if re.match('^[hs]d[a-p]$', mountpoint):",
            "        return (ord(mountpoint[2:3]) - ord('a'))",
            "    elif re.match('^x?vd[a-p]$', mountpoint):",
            "        return (ord(mountpoint[-1]) - ord('a'))",
            "    elif re.match('^[0-9]+$', mountpoint):",
            "        return string.atoi(mountpoint, 10)",
            "    else:",
            "        LOG.warning(_LW('Mountpoint cannot be translated: %s'), mountpoint)",
            "        return -1",
            "",
            "",
            "def find_sr_by_uuid(session, sr_uuid):",
            "    \"\"\"Return the storage repository given a uuid.\"\"\"",
            "    try:",
            "        return session.call_xenapi(\"SR.get_by_uuid\", sr_uuid)",
            "    except session.XenAPI.Failure as exc:",
            "        if exc.details[0] == 'UUID_INVALID':",
            "            return None",
            "        raise",
            "",
            "",
            "def find_sr_from_vbd(session, vbd_ref):",
            "    \"\"\"Find the SR reference from the VBD reference.\"\"\"",
            "    try:",
            "        vdi_ref = session.call_xenapi(\"VBD.get_VDI\", vbd_ref)",
            "        sr_ref = session.call_xenapi(\"VDI.get_SR\", vdi_ref)",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to find SR from VBD'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to find SR from VBD %s') % vbd_ref)",
            "    return sr_ref",
            "",
            "",
            "def find_sr_from_vdi(session, vdi_ref):",
            "    \"\"\"Find the SR reference from the VDI reference.\"\"\"",
            "    try:",
            "        sr_ref = session.call_xenapi(\"VDI.get_SR\", vdi_ref)",
            "    except session.XenAPI.Failure:",
            "        LOG.exception(_LE('Unable to find SR from VDI'))",
            "        raise exception.StorageError(",
            "                reason=_('Unable to find SR from VDI %s') % vdi_ref)",
            "    return sr_ref",
            "",
            "",
            "def find_vbd_by_number(session, vm_ref, dev_number):",
            "    \"\"\"Get the VBD reference from the device number.\"\"\"",
            "    vbd_refs = session.VM.get_VBDs(vm_ref)",
            "    requested_device = str(dev_number)",
            "    if vbd_refs:",
            "        for vbd_ref in vbd_refs:",
            "            try:",
            "                user_device = session.VBD.get_userdevice(vbd_ref)",
            "                if user_device == requested_device:",
            "                    return vbd_ref",
            "            except session.XenAPI.Failure:",
            "                msg = \"Error looking up VBD %s for %s\" % (vbd_ref, vm_ref)",
            "                LOG.debug(msg, exc_info=True)",
            "",
            "",
            "def is_booted_from_volume(session, vm_ref):",
            "    \"\"\"Determine if the root device is a volume.\"\"\"",
            "    vbd_ref = find_vbd_by_number(session, vm_ref, 0)",
            "    vbd_other_config = session.VBD.get_other_config(vbd_ref)",
            "    if vbd_other_config.get('osvol', False):",
            "        return True",
            "    return False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "87": [
                "_parse_volume_info"
            ]
        },
        "addLocation": []
    },
    "nova/virt/xenapi/volumeops.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from oslo_log import log as logging"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from oslo_utils import excutils"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from oslo_utils import strutils"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from nova import exception"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from nova.i18n import _LI, _LW"
            },
            "7": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         return (sr_ref, sr_uuid)"
            },
            "8": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     def _connect_hypervisor_to_volume(self, sr_ref, connection_data):"
            },
            "10": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        LOG.debug(\"Connect volume to hypervisor: %s\", connection_data)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        # connection_data can have credentials in it so make sure to scrub"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        # those before logging."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        LOG.debug(\"Connect volume to hypervisor: %s\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                  strutils.mask_password(connection_data))"
            },
            "15": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         if 'vdi_uuid' in connection_data:"
            },
            "16": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "             vdi_ref = volume_utils.introduce_vdi("
            },
            "17": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "                     self._session, sr_ref,"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "# Copyright (c) 2013 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Management class for Storage-related functions (attach, detach, etc).",
            "\"\"\"",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "",
            "from nova import exception",
            "from nova.i18n import _LI, _LW",
            "from nova.virt.xenapi import vm_utils",
            "from nova.virt.xenapi import volume_utils",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class VolumeOps(object):",
            "    \"\"\"Management class for Volume-related tasks.\"\"\"",
            "",
            "    def __init__(self, session):",
            "        self._session = session",
            "",
            "    def attach_volume(self, connection_info, instance_name, mountpoint,",
            "                      hotplug=True):",
            "        \"\"\"Attach volume to VM instance.\"\"\"",
            "        # TODO(johngarbutt) move this into _attach_volume_to_vm",
            "        dev_number = volume_utils.get_device_number(mountpoint)",
            "",
            "        vm_ref = vm_utils.vm_ref_or_raise(self._session, instance_name)",
            "        return self._attach_volume(connection_info, vm_ref,",
            "                                   instance_name, dev_number, hotplug)",
            "",
            "    def connect_volume(self, connection_info):",
            "        \"\"\"Attach volume to hypervisor, but not the VM.\"\"\"",
            "        return self._attach_volume(connection_info)",
            "",
            "    def _attach_volume(self, connection_info, vm_ref=None, instance_name=None,",
            "                       dev_number=None, hotplug=False):",
            "",
            "        self._check_is_supported_driver_type(connection_info)",
            "",
            "        connection_data = connection_info['data']",
            "        sr_ref, sr_uuid = self._connect_to_volume_provider(connection_data,",
            "                                                           instance_name)",
            "        try:",
            "            vdi_ref = self._connect_hypervisor_to_volume(sr_ref,",
            "                                                         connection_data)",
            "            vdi_uuid = self._session.VDI.get_uuid(vdi_ref)",
            "            LOG.info(_LI('Connected volume (vdi_uuid): %s'), vdi_uuid)",
            "",
            "            if vm_ref:",
            "                self._attach_volume_to_vm(vdi_ref, vm_ref, instance_name,",
            "                                          dev_number, hotplug)",
            "",
            "            return (sr_uuid, vdi_uuid)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                # NOTE(sirp): Forgetting the SR will have the effect of",
            "                # cleaning up the VDI and VBD records, so no need to handle",
            "                # that explicitly.",
            "                volume_utils.forget_sr(self._session, sr_ref)",
            "",
            "    def _check_is_supported_driver_type(self, connection_info):",
            "        driver_type = connection_info['driver_volume_type']",
            "        if driver_type not in ['iscsi', 'xensm']:",
            "            raise exception.VolumeDriverNotFound(driver_type=driver_type)",
            "",
            "    def _connect_to_volume_provider(self, connection_data, instance_name):",
            "        sr_uuid, sr_label, sr_params = volume_utils.parse_sr_info(",
            "                connection_data, 'Disk-for:%s' % instance_name)",
            "        sr_ref = volume_utils.find_sr_by_uuid(self._session, sr_uuid)",
            "        if not sr_ref:",
            "            # introduce SR because not already present",
            "            sr_ref = volume_utils.introduce_sr(",
            "                    self._session, sr_uuid, sr_label, sr_params)",
            "        return (sr_ref, sr_uuid)",
            "",
            "    def _connect_hypervisor_to_volume(self, sr_ref, connection_data):",
            "        LOG.debug(\"Connect volume to hypervisor: %s\", connection_data)",
            "        if 'vdi_uuid' in connection_data:",
            "            vdi_ref = volume_utils.introduce_vdi(",
            "                    self._session, sr_ref,",
            "                    vdi_uuid=connection_data['vdi_uuid'])",
            "",
            "        elif 'target_lun' in connection_data:",
            "            vdi_ref = volume_utils.introduce_vdi(",
            "                    self._session, sr_ref,",
            "                    target_lun=connection_data['target_lun'])",
            "",
            "        else:",
            "            # NOTE(sirp): This will introduce the first VDI in the SR",
            "            vdi_ref = volume_utils.introduce_vdi(self._session, sr_ref)",
            "",
            "        return vdi_ref",
            "",
            "    def _attach_volume_to_vm(self, vdi_ref, vm_ref, instance_name, dev_number,",
            "                             hotplug):",
            "        LOG.debug('Attach_volume vdi: %(vdi_ref)s vm: %(vm_ref)s',",
            "                  {'vdi_ref': vdi_ref, 'vm_ref': vm_ref})",
            "",
            "        # osvol is added to the vbd so we can spot which vbds are volumes",
            "        vbd_ref = vm_utils.create_vbd(self._session, vm_ref, vdi_ref,",
            "                                      dev_number, bootable=False,",
            "                                      osvol=True)",
            "        if hotplug:",
            "            # NOTE(johngarbutt) can only call VBD.plug on a running vm",
            "            running = not vm_utils.is_vm_shutdown(self._session, vm_ref)",
            "            if running:",
            "                LOG.debug(\"Plugging VBD: %s\", vbd_ref)",
            "                self._session.VBD.plug(vbd_ref, vm_ref)",
            "",
            "        LOG.info(_LI('Dev %(dev_number)s attached to'",
            "                     ' instance %(instance_name)s'),",
            "                 {'instance_name': instance_name, 'dev_number': dev_number})",
            "",
            "    def detach_volume(self, connection_info, instance_name, mountpoint):",
            "        \"\"\"Detach volume storage to VM instance.\"\"\"",
            "        LOG.debug(\"Detach_volume: %(instance_name)s, %(mountpoint)s\",",
            "                  {'instance_name': instance_name, 'mountpoint': mountpoint})",
            "",
            "        vm_ref = vm_utils.vm_ref_or_raise(self._session, instance_name)",
            "",
            "        device_number = volume_utils.get_device_number(mountpoint)",
            "        vbd_ref = volume_utils.find_vbd_by_number(self._session, vm_ref,",
            "                                                  device_number)",
            "",
            "        if vbd_ref is None:",
            "            # NOTE(sirp): If we don't find the VBD then it must have been",
            "            # detached previously.",
            "            LOG.warning(_LW('Skipping detach because VBD for %s was '",
            "                            'not found'), instance_name)",
            "        else:",
            "            self._detach_vbds_and_srs(vm_ref, [vbd_ref])",
            "            LOG.info(_LI('Mountpoint %(mountpoint)s detached from instance'",
            "                         ' %(instance_name)s'),",
            "                     {'instance_name': instance_name,",
            "                      'mountpoint': mountpoint})",
            "",
            "    def _detach_vbds_and_srs(self, vm_ref, vbd_refs):",
            "        is_vm_shutdown = vm_utils.is_vm_shutdown(self._session, vm_ref)",
            "",
            "        for vbd_ref in vbd_refs:",
            "            # find sr before we destroy the vbd",
            "            sr_ref = volume_utils.find_sr_from_vbd(self._session, vbd_ref)",
            "",
            "            if not is_vm_shutdown:",
            "                vm_utils.unplug_vbd(self._session, vbd_ref, vm_ref)",
            "",
            "            vm_utils.destroy_vbd(self._session, vbd_ref)",
            "            # Forget (i.e. disconnect) SR only if not in use",
            "            volume_utils.purge_sr(self._session, sr_ref)",
            "",
            "    def detach_all(self, vm_ref):",
            "        \"\"\"Detach all cinder volumes.\"\"\"",
            "        vbd_refs = self._get_all_volume_vbd_refs(vm_ref)",
            "        if vbd_refs:",
            "            self._detach_vbds_and_srs(vm_ref, vbd_refs)",
            "",
            "    def _get_all_volume_vbd_refs(self, vm_ref):",
            "        \"\"\"Return VBD refs for all Nova/Cinder volumes.\"\"\"",
            "        vbd_refs = self._session.VM.get_VBDs(vm_ref)",
            "        for vbd_ref in vbd_refs:",
            "            other_config = self._session.VBD.get_other_config(vbd_ref)",
            "            if other_config.get('osvol'):",
            "                yield vbd_ref",
            "",
            "    def find_bad_volumes(self, vm_ref):",
            "        \"\"\"Find any volumes with their connection severed.",
            "",
            "        Certain VM operations (e.g. `VM.start`, `VM.reboot`, etc.) will not",
            "        work when a VBD is present that points to a non-working volume. To work",
            "        around this, we scan for non-working volumes and detach them before",
            "        retrying a failed operation.",
            "        \"\"\"",
            "        bad_devices = []",
            "        vbd_refs = self._get_all_volume_vbd_refs(vm_ref)",
            "        for vbd_ref in vbd_refs:",
            "            sr_ref = volume_utils.find_sr_from_vbd(self._session, vbd_ref)",
            "",
            "            try:",
            "                # TODO(sirp): bug1152401 This relies on a 120 sec timeout",
            "                # within XenServer, update this to fail-fast when this is fixed",
            "                # upstream",
            "                self._session.SR.scan(sr_ref)",
            "            except self._session.XenAPI.Failure as exc:",
            "                if exc.details[0] == 'SR_BACKEND_FAILURE_40':",
            "                    device = self._session.VBD.get_device(vbd_ref)",
            "                    bad_devices.append('/dev/%s' % device)",
            "                else:",
            "                    raise",
            "",
            "        return bad_devices",
            "",
            "    def safe_cleanup_from_vdis(self, vdi_refs):",
            "        # A helper method to detach volumes that are not associated with an",
            "        # instance",
            "",
            "        for vdi_ref in vdi_refs:",
            "            try:",
            "                sr_ref = volume_utils.find_sr_from_vdi(self._session, vdi_ref)",
            "            except exception.StorageError as exc:",
            "                LOG.debug(exc.format_message())",
            "                continue",
            "            try:",
            "                # Forget (i.e. disconnect) SR only if not in use",
            "                volume_utils.purge_sr(self._session, sr_ref)",
            "            except Exception:",
            "                LOG.debug('Ignoring error while purging sr: %s' % sr_ref,",
            "                        exc_info=True)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "# Copyright (c) 2013 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Management class for Storage-related functions (attach, detach, etc).",
            "\"\"\"",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "from oslo_utils import strutils",
            "",
            "from nova import exception",
            "from nova.i18n import _LI, _LW",
            "from nova.virt.xenapi import vm_utils",
            "from nova.virt.xenapi import volume_utils",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class VolumeOps(object):",
            "    \"\"\"Management class for Volume-related tasks.\"\"\"",
            "",
            "    def __init__(self, session):",
            "        self._session = session",
            "",
            "    def attach_volume(self, connection_info, instance_name, mountpoint,",
            "                      hotplug=True):",
            "        \"\"\"Attach volume to VM instance.\"\"\"",
            "        # TODO(johngarbutt) move this into _attach_volume_to_vm",
            "        dev_number = volume_utils.get_device_number(mountpoint)",
            "",
            "        vm_ref = vm_utils.vm_ref_or_raise(self._session, instance_name)",
            "        return self._attach_volume(connection_info, vm_ref,",
            "                                   instance_name, dev_number, hotplug)",
            "",
            "    def connect_volume(self, connection_info):",
            "        \"\"\"Attach volume to hypervisor, but not the VM.\"\"\"",
            "        return self._attach_volume(connection_info)",
            "",
            "    def _attach_volume(self, connection_info, vm_ref=None, instance_name=None,",
            "                       dev_number=None, hotplug=False):",
            "",
            "        self._check_is_supported_driver_type(connection_info)",
            "",
            "        connection_data = connection_info['data']",
            "        sr_ref, sr_uuid = self._connect_to_volume_provider(connection_data,",
            "                                                           instance_name)",
            "        try:",
            "            vdi_ref = self._connect_hypervisor_to_volume(sr_ref,",
            "                                                         connection_data)",
            "            vdi_uuid = self._session.VDI.get_uuid(vdi_ref)",
            "            LOG.info(_LI('Connected volume (vdi_uuid): %s'), vdi_uuid)",
            "",
            "            if vm_ref:",
            "                self._attach_volume_to_vm(vdi_ref, vm_ref, instance_name,",
            "                                          dev_number, hotplug)",
            "",
            "            return (sr_uuid, vdi_uuid)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                # NOTE(sirp): Forgetting the SR will have the effect of",
            "                # cleaning up the VDI and VBD records, so no need to handle",
            "                # that explicitly.",
            "                volume_utils.forget_sr(self._session, sr_ref)",
            "",
            "    def _check_is_supported_driver_type(self, connection_info):",
            "        driver_type = connection_info['driver_volume_type']",
            "        if driver_type not in ['iscsi', 'xensm']:",
            "            raise exception.VolumeDriverNotFound(driver_type=driver_type)",
            "",
            "    def _connect_to_volume_provider(self, connection_data, instance_name):",
            "        sr_uuid, sr_label, sr_params = volume_utils.parse_sr_info(",
            "                connection_data, 'Disk-for:%s' % instance_name)",
            "        sr_ref = volume_utils.find_sr_by_uuid(self._session, sr_uuid)",
            "        if not sr_ref:",
            "            # introduce SR because not already present",
            "            sr_ref = volume_utils.introduce_sr(",
            "                    self._session, sr_uuid, sr_label, sr_params)",
            "        return (sr_ref, sr_uuid)",
            "",
            "    def _connect_hypervisor_to_volume(self, sr_ref, connection_data):",
            "        # connection_data can have credentials in it so make sure to scrub",
            "        # those before logging.",
            "        LOG.debug(\"Connect volume to hypervisor: %s\",",
            "                  strutils.mask_password(connection_data))",
            "        if 'vdi_uuid' in connection_data:",
            "            vdi_ref = volume_utils.introduce_vdi(",
            "                    self._session, sr_ref,",
            "                    vdi_uuid=connection_data['vdi_uuid'])",
            "",
            "        elif 'target_lun' in connection_data:",
            "            vdi_ref = volume_utils.introduce_vdi(",
            "                    self._session, sr_ref,",
            "                    target_lun=connection_data['target_lun'])",
            "",
            "        else:",
            "            # NOTE(sirp): This will introduce the first VDI in the SR",
            "            vdi_ref = volume_utils.introduce_vdi(self._session, sr_ref)",
            "",
            "        return vdi_ref",
            "",
            "    def _attach_volume_to_vm(self, vdi_ref, vm_ref, instance_name, dev_number,",
            "                             hotplug):",
            "        LOG.debug('Attach_volume vdi: %(vdi_ref)s vm: %(vm_ref)s',",
            "                  {'vdi_ref': vdi_ref, 'vm_ref': vm_ref})",
            "",
            "        # osvol is added to the vbd so we can spot which vbds are volumes",
            "        vbd_ref = vm_utils.create_vbd(self._session, vm_ref, vdi_ref,",
            "                                      dev_number, bootable=False,",
            "                                      osvol=True)",
            "        if hotplug:",
            "            # NOTE(johngarbutt) can only call VBD.plug on a running vm",
            "            running = not vm_utils.is_vm_shutdown(self._session, vm_ref)",
            "            if running:",
            "                LOG.debug(\"Plugging VBD: %s\", vbd_ref)",
            "                self._session.VBD.plug(vbd_ref, vm_ref)",
            "",
            "        LOG.info(_LI('Dev %(dev_number)s attached to'",
            "                     ' instance %(instance_name)s'),",
            "                 {'instance_name': instance_name, 'dev_number': dev_number})",
            "",
            "    def detach_volume(self, connection_info, instance_name, mountpoint):",
            "        \"\"\"Detach volume storage to VM instance.\"\"\"",
            "        LOG.debug(\"Detach_volume: %(instance_name)s, %(mountpoint)s\",",
            "                  {'instance_name': instance_name, 'mountpoint': mountpoint})",
            "",
            "        vm_ref = vm_utils.vm_ref_or_raise(self._session, instance_name)",
            "",
            "        device_number = volume_utils.get_device_number(mountpoint)",
            "        vbd_ref = volume_utils.find_vbd_by_number(self._session, vm_ref,",
            "                                                  device_number)",
            "",
            "        if vbd_ref is None:",
            "            # NOTE(sirp): If we don't find the VBD then it must have been",
            "            # detached previously.",
            "            LOG.warning(_LW('Skipping detach because VBD for %s was '",
            "                            'not found'), instance_name)",
            "        else:",
            "            self._detach_vbds_and_srs(vm_ref, [vbd_ref])",
            "            LOG.info(_LI('Mountpoint %(mountpoint)s detached from instance'",
            "                         ' %(instance_name)s'),",
            "                     {'instance_name': instance_name,",
            "                      'mountpoint': mountpoint})",
            "",
            "    def _detach_vbds_and_srs(self, vm_ref, vbd_refs):",
            "        is_vm_shutdown = vm_utils.is_vm_shutdown(self._session, vm_ref)",
            "",
            "        for vbd_ref in vbd_refs:",
            "            # find sr before we destroy the vbd",
            "            sr_ref = volume_utils.find_sr_from_vbd(self._session, vbd_ref)",
            "",
            "            if not is_vm_shutdown:",
            "                vm_utils.unplug_vbd(self._session, vbd_ref, vm_ref)",
            "",
            "            vm_utils.destroy_vbd(self._session, vbd_ref)",
            "            # Forget (i.e. disconnect) SR only if not in use",
            "            volume_utils.purge_sr(self._session, sr_ref)",
            "",
            "    def detach_all(self, vm_ref):",
            "        \"\"\"Detach all cinder volumes.\"\"\"",
            "        vbd_refs = self._get_all_volume_vbd_refs(vm_ref)",
            "        if vbd_refs:",
            "            self._detach_vbds_and_srs(vm_ref, vbd_refs)",
            "",
            "    def _get_all_volume_vbd_refs(self, vm_ref):",
            "        \"\"\"Return VBD refs for all Nova/Cinder volumes.\"\"\"",
            "        vbd_refs = self._session.VM.get_VBDs(vm_ref)",
            "        for vbd_ref in vbd_refs:",
            "            other_config = self._session.VBD.get_other_config(vbd_ref)",
            "            if other_config.get('osvol'):",
            "                yield vbd_ref",
            "",
            "    def find_bad_volumes(self, vm_ref):",
            "        \"\"\"Find any volumes with their connection severed.",
            "",
            "        Certain VM operations (e.g. `VM.start`, `VM.reboot`, etc.) will not",
            "        work when a VBD is present that points to a non-working volume. To work",
            "        around this, we scan for non-working volumes and detach them before",
            "        retrying a failed operation.",
            "        \"\"\"",
            "        bad_devices = []",
            "        vbd_refs = self._get_all_volume_vbd_refs(vm_ref)",
            "        for vbd_ref in vbd_refs:",
            "            sr_ref = volume_utils.find_sr_from_vbd(self._session, vbd_ref)",
            "",
            "            try:",
            "                # TODO(sirp): bug1152401 This relies on a 120 sec timeout",
            "                # within XenServer, update this to fail-fast when this is fixed",
            "                # upstream",
            "                self._session.SR.scan(sr_ref)",
            "            except self._session.XenAPI.Failure as exc:",
            "                if exc.details[0] == 'SR_BACKEND_FAILURE_40':",
            "                    device = self._session.VBD.get_device(vbd_ref)",
            "                    bad_devices.append('/dev/%s' % device)",
            "                else:",
            "                    raise",
            "",
            "        return bad_devices",
            "",
            "    def safe_cleanup_from_vdis(self, vdi_refs):",
            "        # A helper method to detach volumes that are not associated with an",
            "        # instance",
            "",
            "        for vdi_ref in vdi_refs:",
            "            try:",
            "                sr_ref = volume_utils.find_sr_from_vdi(self._session, vdi_ref)",
            "            except exception.StorageError as exc:",
            "                LOG.debug(exc.format_message())",
            "                continue",
            "            try:",
            "                # Forget (i.e. disconnect) SR only if not in use",
            "                volume_utils.purge_sr(self._session, sr_ref)",
            "            except Exception:",
            "                LOG.debug('Ignoring error while purging sr: %s' % sr_ref,",
            "                        exc_info=True)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "94": [
                "VolumeOps",
                "_connect_hypervisor_to_volume"
            ]
        },
        "addLocation": []
    }
}