{
    "jupyter_server/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import sys"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import warnings"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from contextlib import contextmanager"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from pathlib import Path"
            },
            "4": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from typing import Any, Generator, NewType, Sequence"
            },
            "5": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from urllib.parse import ("
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     SplitResult,"
            },
            "7": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "     return isinstance(spec.submodule_search_locations, _NamespacePath)"
            },
            "8": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 340,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 341,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def filefind(filename: str, path_dirs: Sequence[str] | str | None = None) -> str:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+def filefind(filename: str, path_dirs: Sequence[str]) -> str:"
            },
            "12": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "     \"\"\"Find a file by looking through a sequence of paths."
            },
            "13": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    This iterates through a sequence of paths looking for a file and returns"
            },
            "14": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    the full, absolute path of the first occurrence of the file.  If no set of"
            },
            "15": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    path dirs is given, the filename is tested as is, after running through"
            },
            "16": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :func:`expandvars` and :func:`expanduser`.  Thus a simple call::"
            },
            "17": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 344,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        filefind(\"myfile.txt\")"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+    For use in FileFindHandler."
            },
            "20": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 346,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    will find the file in the current working dir, but::"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+    Iterates through a sequence of paths looking for a file and returns"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+    the full, absolute path of the first occurrence of the file."
            },
            "24": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 349,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        filefind(\"~/myfile.txt\")"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+    Absolute paths are not accepted for inputs."
            },
            "27": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 351,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Will find the file in the users home directory.  This function does not"
            },
            "29": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    automatically try any paths, such as the cwd or the user's home directory."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+    This function does not automatically try any paths,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+    such as the cwd or the user's home directory."
            },
            "32": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 354,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "     Parameters"
            },
            "34": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "     ----------"
            },
            "35": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "     filename : str"
            },
            "36": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        The filename to look for."
            },
            "37": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    path_dirs : str, None or sequence of str"
            },
            "38": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        The sequence of paths to look for the file in.  If None, the filename"
            },
            "39": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        need to be absolute or be in the cwd.  If a string, the string is"
            },
            "40": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        put into a sequence and the searched.  If a sequence, walk through"
            },
            "41": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        each element and join with ``filename``, calling :func:`expandvars`"
            },
            "42": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        and :func:`expanduser` before testing for existence."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        The filename to look for. Must be a relative path."
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+    path_dirs : sequence of str"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+        The sequence of paths to look in for the file."
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+        Walk through each element and join with ``filename``."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        Only after ensuring the path resolves within the directory is it checked for existence."
            },
            "48": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 363,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "     Returns"
            },
            "50": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "     -------"
            },
            "51": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Raises :exc:`IOError` or returns absolute path to file."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+    Raises :exc:`OSError` or returns absolute path to file."
            },
            "53": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "     \"\"\""
            },
            "54": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "55": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # If paths are quoted, abspath gets confused, strip them..."
            },
            "56": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    filename = filename.strip('\"').strip(\"'\")"
            },
            "57": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # If the input is an absolute path, just check it exists"
            },
            "58": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if os.path.isabs(filename) and os.path.isfile(filename):"
            },
            "59": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return filename"
            },
            "60": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "61": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if path_dirs is None:"
            },
            "62": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path_dirs = (\"\",)"
            },
            "63": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif isinstance(path_dirs, str):"
            },
            "64": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path_dirs = (path_dirs,)"
            },
            "65": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "66": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    for path in path_dirs:"
            },
            "67": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if path == \".\":"
            },
            "68": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path = os.getcwd()  # noqa: PLW2901"
            },
            "69": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        testname = expand_path(os.path.join(path, filename))"
            },
            "70": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if os.path.isfile(testname):"
            },
            "71": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return os.path.abspath(testname)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+    file_path = Path(filename)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+    # If the input is an absolute path, reject it"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+    if file_path.is_absolute():"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+        msg = f\"{filename} is absolute, filefind only accepts relative paths.\""
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+        raise OSError(msg)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+    for path_str in path_dirs:"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+        path = Path(path_str).absolute()"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+        test_path = path / file_path"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+        # os.path.abspath resolves '..', but Path.absolute() doesn't"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+        # Path.resolve() does, but traverses symlinks, which we don't want"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+        test_path = Path(os.path.abspath(test_path))"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+        if sys.version_info >= (3, 9):"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+            if not test_path.is_relative_to(path):"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+                # points outside root, e.g. via `filename='../foo'`"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+                continue"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+        else:"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+            # is_relative_to is new in 3.9"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+            try:"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+                test_path.relative_to(path)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+            except ValueError:"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+                # points outside root, e.g. via `filename='../foo'`"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+                continue"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+        # make sure we don't call is_file before we know it's a file within a prefix"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+        # GHSA-hrw6-wg82-cm62 - can leak password hash on windows."
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+        if test_path.is_file():"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+            return os.path.abspath(test_path)"
            },
            "100": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 396,
                "PatchRowcode": " "
            },
            "101": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "     msg = f\"File {filename!r} does not exist in any of the search paths: {path_dirs!r}\""
            },
            "102": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "     raise OSError(msg)"
            },
            "103": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 399,
                "PatchRowcode": " "
            },
            "104": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 400,
                "PatchRowcode": " "
            },
            "105": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def expand_path(s: str) -> str:"
            },
            "106": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\"Expand $VARS and ~names in a string, like a shell"
            },
            "107": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "108": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :Examples:"
            },
            "109": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-       In [2]: os.environ['FOO']='test'"
            },
            "110": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-       In [3]: expand_path('variable FOO is $FOO')"
            },
            "111": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-       Out[3]: 'variable FOO is test'"
            },
            "112": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "113": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # This is a pretty subtle hack. When expand user is given a UNC path"
            },
            "114": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # on Windows (\\\\server\\share$\\%username%), os.path.expandvars, removes"
            },
            "115": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # the $ to get (\\\\server\\share\\%username%). I think it considered $"
            },
            "116": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # alone an empty var. But, we need the $ to remains there (it indicates"
            },
            "117": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # a hidden share)."
            },
            "118": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if os.name == \"nt\":"
            },
            "119": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        s = s.replace(\"$\\\\\", \"IPYTHON_TEMP\")"
            },
            "120": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    s = os.path.expandvars(os.path.expanduser(s))"
            },
            "121": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if os.name == \"nt\":"
            },
            "122": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        s = s.replace(\"IPYTHON_TEMP\", \"$\\\\\")"
            },
            "123": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return s"
            },
            "124": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "125": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "126": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 401,
                "PatchRowcode": " def import_item(name: str) -> Any:"
            },
            "127": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "     \"\"\"Import and return ``bar`` given the string ``foo.bar``."
            },
            "128": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "     Calling ``bar = import_item(\"foo.bar\")`` is the functional equivalent of"
            }
        },
        "frontPatchFile": [
            "\"\"\"Notebook related utilities\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "from __future__ import annotations",
            "",
            "import errno",
            "import importlib.util",
            "import os",
            "import socket",
            "import sys",
            "import warnings",
            "from contextlib import contextmanager",
            "from typing import Any, Generator, NewType, Sequence",
            "from urllib.parse import (",
            "    SplitResult,",
            "    quote,",
            "    unquote,",
            "    urlparse,",
            "    urlsplit,",
            "    urlunsplit,",
            ")",
            "from urllib.parse import (",
            "    urljoin as _urljoin,",
            ")",
            "from urllib.request import pathname2url as _pathname2url",
            "",
            "from _frozen_importlib_external import _NamespacePath",
            "from jupyter_core.utils import ensure_async as _ensure_async",
            "from packaging.version import Version",
            "from tornado.httpclient import AsyncHTTPClient, HTTPClient, HTTPRequest, HTTPResponse",
            "from tornado.netutil import Resolver",
            "",
            "ApiPath = NewType(\"ApiPath\", str)",
            "",
            "# Re-export",
            "urljoin = _urljoin",
            "pathname2url = _pathname2url",
            "ensure_async = _ensure_async",
            "",
            "",
            "def url_path_join(*pieces: str) -> str:",
            "    \"\"\"Join components of url into a relative url",
            "",
            "    Use to prevent double slash when joining subpath. This will leave the",
            "    initial and final / in place",
            "    \"\"\"",
            "    initial = pieces[0].startswith(\"/\")",
            "    final = pieces[-1].endswith(\"/\")",
            "    stripped = [s.strip(\"/\") for s in pieces]",
            "    result = \"/\".join(s for s in stripped if s)",
            "    if initial:",
            "        result = \"/\" + result",
            "    if final:",
            "        result = result + \"/\"",
            "    if result == \"//\":",
            "        result = \"/\"",
            "    return result",
            "",
            "",
            "def url_is_absolute(url: str) -> bool:",
            "    \"\"\"Determine whether a given URL is absolute\"\"\"",
            "    return urlparse(url).path.startswith(\"/\")",
            "",
            "",
            "def path2url(path: str) -> str:",
            "    \"\"\"Convert a local file path to a URL\"\"\"",
            "    pieces = [quote(p) for p in path.split(os.sep)]",
            "    # preserve trailing /",
            "    if pieces[-1] == \"\":",
            "        pieces[-1] = \"/\"",
            "    url = url_path_join(*pieces)",
            "    return url",
            "",
            "",
            "def url2path(url: str) -> str:",
            "    \"\"\"Convert a URL to a local file path\"\"\"",
            "    pieces = [unquote(p) for p in url.split(\"/\")]",
            "    path = os.path.join(*pieces)",
            "    return path",
            "",
            "",
            "def url_escape(path: str) -> str:",
            "    \"\"\"Escape special characters in a URL path",
            "",
            "    Turns '/foo bar/' into '/foo%20bar/'",
            "    \"\"\"",
            "    parts = path.split(\"/\")",
            "    return \"/\".join([quote(p) for p in parts])",
            "",
            "",
            "def url_unescape(path: str) -> str:",
            "    \"\"\"Unescape special characters in a URL path",
            "",
            "    Turns '/foo%20bar/' into '/foo bar/'",
            "    \"\"\"",
            "    return \"/\".join([unquote(p) for p in path.split(\"/\")])",
            "",
            "",
            "def samefile_simple(path: str, other_path: str) -> bool:",
            "    \"\"\"",
            "    Fill in for os.path.samefile when it is unavailable (Windows+py2).",
            "",
            "    Do a case-insensitive string comparison in this case",
            "    plus comparing the full stat result (including times)",
            "    because Windows + py2 doesn't support the stat fields",
            "    needed for identifying if it's the same file (st_ino, st_dev).",
            "",
            "    Only to be used if os.path.samefile is not available.",
            "",
            "    Parameters",
            "    ----------",
            "    path : str",
            "        representing a path to a file",
            "    other_path : str",
            "        representing a path to another file",
            "",
            "    Returns",
            "    -------",
            "    same:   Boolean that is True if both path and other path are the same",
            "    \"\"\"",
            "    path_stat = os.stat(path)",
            "    other_path_stat = os.stat(other_path)",
            "    return path.lower() == other_path.lower() and path_stat == other_path_stat",
            "",
            "",
            "def to_os_path(path: ApiPath, root: str = \"\") -> str:",
            "    \"\"\"Convert an API path to a filesystem path",
            "",
            "    If given, root will be prepended to the path.",
            "    root must be a filesystem path already.",
            "    \"\"\"",
            "    parts = str(path).strip(\"/\").split(\"/\")",
            "    parts = [p for p in parts if p != \"\"]  #  remove duplicate splits",
            "    path_ = os.path.join(root, *parts)",
            "    return os.path.normpath(path_)",
            "",
            "",
            "def to_api_path(os_path: str, root: str = \"\") -> ApiPath:",
            "    \"\"\"Convert a filesystem path to an API path",
            "",
            "    If given, root will be removed from the path.",
            "    root must be a filesystem path already.",
            "    \"\"\"",
            "    if os_path.startswith(root):",
            "        os_path = os_path[len(root) :]",
            "    parts = os_path.strip(os.path.sep).split(os.path.sep)",
            "    parts = [p for p in parts if p != \"\"]  # remove duplicate splits",
            "    path = \"/\".join(parts)",
            "    return ApiPath(path)",
            "",
            "",
            "def check_version(v: str, check: str) -> bool:",
            "    \"\"\"check version string v >= check",
            "",
            "    If dev/prerelease tags result in TypeError for string-number comparison,",
            "    it is assumed that the dependency is satisfied.",
            "    Users on dev branches are responsible for keeping their own packages up to date.",
            "    \"\"\"",
            "    try:",
            "        return bool(Version(v) >= Version(check))",
            "    except TypeError:",
            "        return True",
            "",
            "",
            "# Copy of IPython.utils.process.check_pid:",
            "",
            "",
            "def _check_pid_win32(pid: int) -> bool:",
            "    import ctypes",
            "",
            "    # OpenProcess returns 0 if no such process (of ours) exists",
            "    # positive int otherwise",
            "    return bool(ctypes.windll.kernel32.OpenProcess(1, 0, pid))  # type:ignore[attr-defined]",
            "",
            "",
            "def _check_pid_posix(pid: int) -> bool:",
            "    \"\"\"Copy of IPython.utils.process.check_pid\"\"\"",
            "    try:",
            "        os.kill(pid, 0)",
            "    except OSError as err:",
            "        if err.errno == errno.ESRCH:",
            "            return False",
            "        elif err.errno == errno.EPERM:",
            "            # Don't have permission to signal the process - probably means it exists",
            "            return True",
            "        raise",
            "    else:",
            "        return True",
            "",
            "",
            "if sys.platform == \"win32\":",
            "    check_pid = _check_pid_win32",
            "else:",
            "    check_pid = _check_pid_posix",
            "",
            "",
            "async def run_sync_in_loop(maybe_async):",
            "    \"\"\"**DEPRECATED**: Use ``ensure_async`` from jupyter_core instead.\"\"\"",
            "    warnings.warn(",
            "        \"run_sync_in_loop is deprecated since Jupyter Server 2.0, use 'ensure_async' from jupyter_core instead\",",
            "        DeprecationWarning,",
            "        stacklevel=2,",
            "    )",
            "    return ensure_async(maybe_async)",
            "",
            "",
            "def urlencode_unix_socket_path(socket_path: str) -> str:",
            "    \"\"\"Encodes a UNIX socket path string from a socket path for the `http+unix` URI form.\"\"\"",
            "    return socket_path.replace(\"/\", \"%2F\")",
            "",
            "",
            "def urldecode_unix_socket_path(socket_path: str) -> str:",
            "    \"\"\"Decodes a UNIX sock path string from an encoded sock path for the `http+unix` URI form.\"\"\"",
            "    return socket_path.replace(\"%2F\", \"/\")",
            "",
            "",
            "def urlencode_unix_socket(socket_path: str) -> str:",
            "    \"\"\"Encodes a UNIX socket URL from a socket path for the `http+unix` URI form.\"\"\"",
            "    return \"http+unix://%s\" % urlencode_unix_socket_path(socket_path)",
            "",
            "",
            "def unix_socket_in_use(socket_path: str) -> bool:",
            "    \"\"\"Checks whether a UNIX socket path on disk is in use by attempting to connect to it.\"\"\"",
            "    if not os.path.exists(socket_path):",
            "        return False",
            "",
            "    try:",
            "        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)",
            "        sock.connect(socket_path)",
            "    except OSError:",
            "        return False",
            "    else:",
            "        return True",
            "    finally:",
            "        sock.close()",
            "",
            "",
            "@contextmanager",
            "def _request_for_tornado_client(",
            "    urlstring: str, method: str = \"GET\", body: Any = None, headers: Any = None",
            ") -> Generator[HTTPRequest, None, None]:",
            "    \"\"\"A utility that provides a context that handles",
            "    HTTP, HTTPS, and HTTP+UNIX request.",
            "    Creates a tornado HTTPRequest object with a URL",
            "    that tornado's HTTPClients can accept.",
            "    If the request is made to a unix socket, temporarily",
            "    configure the AsyncHTTPClient to resolve the URL",
            "    and connect to the proper socket.",
            "    \"\"\"",
            "    parts = urlsplit(urlstring)",
            "    if parts.scheme in [\"http\", \"https\"]:",
            "        pass",
            "    elif parts.scheme == \"http+unix\":",
            "        # If unix socket, mimic HTTP.",
            "        parts = SplitResult(",
            "            scheme=\"http\",",
            "            netloc=parts.netloc,",
            "            path=parts.path,",
            "            query=parts.query,",
            "            fragment=parts.fragment,",
            "        )",
            "",
            "        class UnixSocketResolver(Resolver):",
            "            \"\"\"A resolver that routes HTTP requests to unix sockets",
            "            in tornado HTTP clients.",
            "            Due to constraints in Tornados' API, the scheme of the",
            "            must be `http` (not `http+unix`). Applications should replace",
            "            the scheme in URLS before making a request to the HTTP client.",
            "            \"\"\"",
            "",
            "            def initialize(self, resolver):",
            "                self.resolver = resolver",
            "",
            "            def close(self):",
            "                self.resolver.close()",
            "",
            "            async def resolve(self, host, port, *args, **kwargs):",
            "                return [(socket.AF_UNIX, urldecode_unix_socket_path(host))]",
            "",
            "        resolver = UnixSocketResolver(resolver=Resolver())",
            "        AsyncHTTPClient.configure(None, resolver=resolver)",
            "    else:",
            "        msg = \"Unknown URL scheme.\"",
            "        raise Exception(msg)",
            "",
            "    # Yield the request for the given client.",
            "    url = urlunsplit(parts)",
            "    request = HTTPRequest(url, method=method, body=body, headers=headers, validate_cert=False)",
            "    yield request",
            "",
            "",
            "def fetch(",
            "    urlstring: str, method: str = \"GET\", body: Any = None, headers: Any = None",
            ") -> HTTPResponse:",
            "    \"\"\"",
            "    Send a HTTP, HTTPS, or HTTP+UNIX request",
            "    to a Tornado Web Server. Returns a tornado HTTPResponse.",
            "    \"\"\"",
            "    with _request_for_tornado_client(",
            "        urlstring, method=method, body=body, headers=headers",
            "    ) as request:",
            "        response = HTTPClient(AsyncHTTPClient).fetch(request)",
            "    return response",
            "",
            "",
            "async def async_fetch(",
            "    urlstring: str, method: str = \"GET\", body: Any = None, headers: Any = None, io_loop: Any = None",
            ") -> HTTPResponse:",
            "    \"\"\"",
            "    Send an asynchronous HTTP, HTTPS, or HTTP+UNIX request",
            "    to a Tornado Web Server. Returns a tornado HTTPResponse.",
            "    \"\"\"",
            "    with _request_for_tornado_client(",
            "        urlstring, method=method, body=body, headers=headers",
            "    ) as request:",
            "        response = await AsyncHTTPClient(io_loop).fetch(request)",
            "    return response",
            "",
            "",
            "def is_namespace_package(namespace: str) -> bool | None:",
            "    \"\"\"Is the provided namespace a Python Namespace Package (PEP420).",
            "",
            "    https://www.python.org/dev/peps/pep-0420/#specification",
            "",
            "    Returns `None` if module is not importable.",
            "",
            "    \"\"\"",
            "    # NOTE: using submodule_search_locations because the loader can be None",
            "    try:",
            "        spec = importlib.util.find_spec(namespace)",
            "    except ValueError:  # spec is not set - see https://docs.python.org/3/library/importlib.html#importlib.util.find_spec",
            "        return None",
            "",
            "    if not spec:",
            "        # e.g. module not installed",
            "        return None",
            "    return isinstance(spec.submodule_search_locations, _NamespacePath)",
            "",
            "",
            "def filefind(filename: str, path_dirs: Sequence[str] | str | None = None) -> str:",
            "    \"\"\"Find a file by looking through a sequence of paths.",
            "    This iterates through a sequence of paths looking for a file and returns",
            "    the full, absolute path of the first occurrence of the file.  If no set of",
            "    path dirs is given, the filename is tested as is, after running through",
            "    :func:`expandvars` and :func:`expanduser`.  Thus a simple call::",
            "",
            "        filefind(\"myfile.txt\")",
            "",
            "    will find the file in the current working dir, but::",
            "",
            "        filefind(\"~/myfile.txt\")",
            "",
            "    Will find the file in the users home directory.  This function does not",
            "    automatically try any paths, such as the cwd or the user's home directory.",
            "",
            "    Parameters",
            "    ----------",
            "    filename : str",
            "        The filename to look for.",
            "    path_dirs : str, None or sequence of str",
            "        The sequence of paths to look for the file in.  If None, the filename",
            "        need to be absolute or be in the cwd.  If a string, the string is",
            "        put into a sequence and the searched.  If a sequence, walk through",
            "        each element and join with ``filename``, calling :func:`expandvars`",
            "        and :func:`expanduser` before testing for existence.",
            "",
            "    Returns",
            "    -------",
            "    Raises :exc:`IOError` or returns absolute path to file.",
            "    \"\"\"",
            "",
            "    # If paths are quoted, abspath gets confused, strip them...",
            "    filename = filename.strip('\"').strip(\"'\")",
            "    # If the input is an absolute path, just check it exists",
            "    if os.path.isabs(filename) and os.path.isfile(filename):",
            "        return filename",
            "",
            "    if path_dirs is None:",
            "        path_dirs = (\"\",)",
            "    elif isinstance(path_dirs, str):",
            "        path_dirs = (path_dirs,)",
            "",
            "    for path in path_dirs:",
            "        if path == \".\":",
            "            path = os.getcwd()  # noqa: PLW2901",
            "        testname = expand_path(os.path.join(path, filename))",
            "        if os.path.isfile(testname):",
            "            return os.path.abspath(testname)",
            "",
            "    msg = f\"File {filename!r} does not exist in any of the search paths: {path_dirs!r}\"",
            "    raise OSError(msg)",
            "",
            "",
            "def expand_path(s: str) -> str:",
            "    \"\"\"Expand $VARS and ~names in a string, like a shell",
            "",
            "    :Examples:",
            "       In [2]: os.environ['FOO']='test'",
            "       In [3]: expand_path('variable FOO is $FOO')",
            "       Out[3]: 'variable FOO is test'",
            "    \"\"\"",
            "    # This is a pretty subtle hack. When expand user is given a UNC path",
            "    # on Windows (\\\\server\\share$\\%username%), os.path.expandvars, removes",
            "    # the $ to get (\\\\server\\share\\%username%). I think it considered $",
            "    # alone an empty var. But, we need the $ to remains there (it indicates",
            "    # a hidden share).",
            "    if os.name == \"nt\":",
            "        s = s.replace(\"$\\\\\", \"IPYTHON_TEMP\")",
            "    s = os.path.expandvars(os.path.expanduser(s))",
            "    if os.name == \"nt\":",
            "        s = s.replace(\"IPYTHON_TEMP\", \"$\\\\\")",
            "    return s",
            "",
            "",
            "def import_item(name: str) -> Any:",
            "    \"\"\"Import and return ``bar`` given the string ``foo.bar``.",
            "    Calling ``bar = import_item(\"foo.bar\")`` is the functional equivalent of",
            "    executing the code ``from foo import bar``.",
            "    Parameters",
            "    ----------",
            "    name : str",
            "      The fully qualified name of the module/package being imported.",
            "    Returns",
            "    -------",
            "    mod : module object",
            "       The module that was imported.",
            "    \"\"\"",
            "",
            "    parts = name.rsplit(\".\", 1)",
            "    if len(parts) == 2:",
            "        # called with 'foo.bar....'",
            "        package, obj = parts",
            "        module = __import__(package, fromlist=[obj])",
            "        try:",
            "            pak = getattr(module, obj)",
            "        except AttributeError as e:",
            "            raise ImportError(\"No module named %s\" % obj) from e",
            "        return pak",
            "    else:",
            "        # called with un-dotted string",
            "        return __import__(parts[0])",
            "",
            "",
            "class JupyterServerAuthWarning(RuntimeWarning):",
            "    \"\"\"Emitted when authentication configuration issue is detected.",
            "",
            "    Intended for filtering out expected warnings in tests, including",
            "    downstream tests, rather than for users to silence this warning.",
            "    \"\"\""
        ],
        "afterPatchFile": [
            "\"\"\"Notebook related utilities\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "from __future__ import annotations",
            "",
            "import errno",
            "import importlib.util",
            "import os",
            "import socket",
            "import sys",
            "import warnings",
            "from contextlib import contextmanager",
            "from pathlib import Path",
            "from typing import Any, Generator, NewType, Sequence",
            "from urllib.parse import (",
            "    SplitResult,",
            "    quote,",
            "    unquote,",
            "    urlparse,",
            "    urlsplit,",
            "    urlunsplit,",
            ")",
            "from urllib.parse import (",
            "    urljoin as _urljoin,",
            ")",
            "from urllib.request import pathname2url as _pathname2url",
            "",
            "from _frozen_importlib_external import _NamespacePath",
            "from jupyter_core.utils import ensure_async as _ensure_async",
            "from packaging.version import Version",
            "from tornado.httpclient import AsyncHTTPClient, HTTPClient, HTTPRequest, HTTPResponse",
            "from tornado.netutil import Resolver",
            "",
            "ApiPath = NewType(\"ApiPath\", str)",
            "",
            "# Re-export",
            "urljoin = _urljoin",
            "pathname2url = _pathname2url",
            "ensure_async = _ensure_async",
            "",
            "",
            "def url_path_join(*pieces: str) -> str:",
            "    \"\"\"Join components of url into a relative url",
            "",
            "    Use to prevent double slash when joining subpath. This will leave the",
            "    initial and final / in place",
            "    \"\"\"",
            "    initial = pieces[0].startswith(\"/\")",
            "    final = pieces[-1].endswith(\"/\")",
            "    stripped = [s.strip(\"/\") for s in pieces]",
            "    result = \"/\".join(s for s in stripped if s)",
            "    if initial:",
            "        result = \"/\" + result",
            "    if final:",
            "        result = result + \"/\"",
            "    if result == \"//\":",
            "        result = \"/\"",
            "    return result",
            "",
            "",
            "def url_is_absolute(url: str) -> bool:",
            "    \"\"\"Determine whether a given URL is absolute\"\"\"",
            "    return urlparse(url).path.startswith(\"/\")",
            "",
            "",
            "def path2url(path: str) -> str:",
            "    \"\"\"Convert a local file path to a URL\"\"\"",
            "    pieces = [quote(p) for p in path.split(os.sep)]",
            "    # preserve trailing /",
            "    if pieces[-1] == \"\":",
            "        pieces[-1] = \"/\"",
            "    url = url_path_join(*pieces)",
            "    return url",
            "",
            "",
            "def url2path(url: str) -> str:",
            "    \"\"\"Convert a URL to a local file path\"\"\"",
            "    pieces = [unquote(p) for p in url.split(\"/\")]",
            "    path = os.path.join(*pieces)",
            "    return path",
            "",
            "",
            "def url_escape(path: str) -> str:",
            "    \"\"\"Escape special characters in a URL path",
            "",
            "    Turns '/foo bar/' into '/foo%20bar/'",
            "    \"\"\"",
            "    parts = path.split(\"/\")",
            "    return \"/\".join([quote(p) for p in parts])",
            "",
            "",
            "def url_unescape(path: str) -> str:",
            "    \"\"\"Unescape special characters in a URL path",
            "",
            "    Turns '/foo%20bar/' into '/foo bar/'",
            "    \"\"\"",
            "    return \"/\".join([unquote(p) for p in path.split(\"/\")])",
            "",
            "",
            "def samefile_simple(path: str, other_path: str) -> bool:",
            "    \"\"\"",
            "    Fill in for os.path.samefile when it is unavailable (Windows+py2).",
            "",
            "    Do a case-insensitive string comparison in this case",
            "    plus comparing the full stat result (including times)",
            "    because Windows + py2 doesn't support the stat fields",
            "    needed for identifying if it's the same file (st_ino, st_dev).",
            "",
            "    Only to be used if os.path.samefile is not available.",
            "",
            "    Parameters",
            "    ----------",
            "    path : str",
            "        representing a path to a file",
            "    other_path : str",
            "        representing a path to another file",
            "",
            "    Returns",
            "    -------",
            "    same:   Boolean that is True if both path and other path are the same",
            "    \"\"\"",
            "    path_stat = os.stat(path)",
            "    other_path_stat = os.stat(other_path)",
            "    return path.lower() == other_path.lower() and path_stat == other_path_stat",
            "",
            "",
            "def to_os_path(path: ApiPath, root: str = \"\") -> str:",
            "    \"\"\"Convert an API path to a filesystem path",
            "",
            "    If given, root will be prepended to the path.",
            "    root must be a filesystem path already.",
            "    \"\"\"",
            "    parts = str(path).strip(\"/\").split(\"/\")",
            "    parts = [p for p in parts if p != \"\"]  #  remove duplicate splits",
            "    path_ = os.path.join(root, *parts)",
            "    return os.path.normpath(path_)",
            "",
            "",
            "def to_api_path(os_path: str, root: str = \"\") -> ApiPath:",
            "    \"\"\"Convert a filesystem path to an API path",
            "",
            "    If given, root will be removed from the path.",
            "    root must be a filesystem path already.",
            "    \"\"\"",
            "    if os_path.startswith(root):",
            "        os_path = os_path[len(root) :]",
            "    parts = os_path.strip(os.path.sep).split(os.path.sep)",
            "    parts = [p for p in parts if p != \"\"]  # remove duplicate splits",
            "    path = \"/\".join(parts)",
            "    return ApiPath(path)",
            "",
            "",
            "def check_version(v: str, check: str) -> bool:",
            "    \"\"\"check version string v >= check",
            "",
            "    If dev/prerelease tags result in TypeError for string-number comparison,",
            "    it is assumed that the dependency is satisfied.",
            "    Users on dev branches are responsible for keeping their own packages up to date.",
            "    \"\"\"",
            "    try:",
            "        return bool(Version(v) >= Version(check))",
            "    except TypeError:",
            "        return True",
            "",
            "",
            "# Copy of IPython.utils.process.check_pid:",
            "",
            "",
            "def _check_pid_win32(pid: int) -> bool:",
            "    import ctypes",
            "",
            "    # OpenProcess returns 0 if no such process (of ours) exists",
            "    # positive int otherwise",
            "    return bool(ctypes.windll.kernel32.OpenProcess(1, 0, pid))  # type:ignore[attr-defined]",
            "",
            "",
            "def _check_pid_posix(pid: int) -> bool:",
            "    \"\"\"Copy of IPython.utils.process.check_pid\"\"\"",
            "    try:",
            "        os.kill(pid, 0)",
            "    except OSError as err:",
            "        if err.errno == errno.ESRCH:",
            "            return False",
            "        elif err.errno == errno.EPERM:",
            "            # Don't have permission to signal the process - probably means it exists",
            "            return True",
            "        raise",
            "    else:",
            "        return True",
            "",
            "",
            "if sys.platform == \"win32\":",
            "    check_pid = _check_pid_win32",
            "else:",
            "    check_pid = _check_pid_posix",
            "",
            "",
            "async def run_sync_in_loop(maybe_async):",
            "    \"\"\"**DEPRECATED**: Use ``ensure_async`` from jupyter_core instead.\"\"\"",
            "    warnings.warn(",
            "        \"run_sync_in_loop is deprecated since Jupyter Server 2.0, use 'ensure_async' from jupyter_core instead\",",
            "        DeprecationWarning,",
            "        stacklevel=2,",
            "    )",
            "    return ensure_async(maybe_async)",
            "",
            "",
            "def urlencode_unix_socket_path(socket_path: str) -> str:",
            "    \"\"\"Encodes a UNIX socket path string from a socket path for the `http+unix` URI form.\"\"\"",
            "    return socket_path.replace(\"/\", \"%2F\")",
            "",
            "",
            "def urldecode_unix_socket_path(socket_path: str) -> str:",
            "    \"\"\"Decodes a UNIX sock path string from an encoded sock path for the `http+unix` URI form.\"\"\"",
            "    return socket_path.replace(\"%2F\", \"/\")",
            "",
            "",
            "def urlencode_unix_socket(socket_path: str) -> str:",
            "    \"\"\"Encodes a UNIX socket URL from a socket path for the `http+unix` URI form.\"\"\"",
            "    return \"http+unix://%s\" % urlencode_unix_socket_path(socket_path)",
            "",
            "",
            "def unix_socket_in_use(socket_path: str) -> bool:",
            "    \"\"\"Checks whether a UNIX socket path on disk is in use by attempting to connect to it.\"\"\"",
            "    if not os.path.exists(socket_path):",
            "        return False",
            "",
            "    try:",
            "        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)",
            "        sock.connect(socket_path)",
            "    except OSError:",
            "        return False",
            "    else:",
            "        return True",
            "    finally:",
            "        sock.close()",
            "",
            "",
            "@contextmanager",
            "def _request_for_tornado_client(",
            "    urlstring: str, method: str = \"GET\", body: Any = None, headers: Any = None",
            ") -> Generator[HTTPRequest, None, None]:",
            "    \"\"\"A utility that provides a context that handles",
            "    HTTP, HTTPS, and HTTP+UNIX request.",
            "    Creates a tornado HTTPRequest object with a URL",
            "    that tornado's HTTPClients can accept.",
            "    If the request is made to a unix socket, temporarily",
            "    configure the AsyncHTTPClient to resolve the URL",
            "    and connect to the proper socket.",
            "    \"\"\"",
            "    parts = urlsplit(urlstring)",
            "    if parts.scheme in [\"http\", \"https\"]:",
            "        pass",
            "    elif parts.scheme == \"http+unix\":",
            "        # If unix socket, mimic HTTP.",
            "        parts = SplitResult(",
            "            scheme=\"http\",",
            "            netloc=parts.netloc,",
            "            path=parts.path,",
            "            query=parts.query,",
            "            fragment=parts.fragment,",
            "        )",
            "",
            "        class UnixSocketResolver(Resolver):",
            "            \"\"\"A resolver that routes HTTP requests to unix sockets",
            "            in tornado HTTP clients.",
            "            Due to constraints in Tornados' API, the scheme of the",
            "            must be `http` (not `http+unix`). Applications should replace",
            "            the scheme in URLS before making a request to the HTTP client.",
            "            \"\"\"",
            "",
            "            def initialize(self, resolver):",
            "                self.resolver = resolver",
            "",
            "            def close(self):",
            "                self.resolver.close()",
            "",
            "            async def resolve(self, host, port, *args, **kwargs):",
            "                return [(socket.AF_UNIX, urldecode_unix_socket_path(host))]",
            "",
            "        resolver = UnixSocketResolver(resolver=Resolver())",
            "        AsyncHTTPClient.configure(None, resolver=resolver)",
            "    else:",
            "        msg = \"Unknown URL scheme.\"",
            "        raise Exception(msg)",
            "",
            "    # Yield the request for the given client.",
            "    url = urlunsplit(parts)",
            "    request = HTTPRequest(url, method=method, body=body, headers=headers, validate_cert=False)",
            "    yield request",
            "",
            "",
            "def fetch(",
            "    urlstring: str, method: str = \"GET\", body: Any = None, headers: Any = None",
            ") -> HTTPResponse:",
            "    \"\"\"",
            "    Send a HTTP, HTTPS, or HTTP+UNIX request",
            "    to a Tornado Web Server. Returns a tornado HTTPResponse.",
            "    \"\"\"",
            "    with _request_for_tornado_client(",
            "        urlstring, method=method, body=body, headers=headers",
            "    ) as request:",
            "        response = HTTPClient(AsyncHTTPClient).fetch(request)",
            "    return response",
            "",
            "",
            "async def async_fetch(",
            "    urlstring: str, method: str = \"GET\", body: Any = None, headers: Any = None, io_loop: Any = None",
            ") -> HTTPResponse:",
            "    \"\"\"",
            "    Send an asynchronous HTTP, HTTPS, or HTTP+UNIX request",
            "    to a Tornado Web Server. Returns a tornado HTTPResponse.",
            "    \"\"\"",
            "    with _request_for_tornado_client(",
            "        urlstring, method=method, body=body, headers=headers",
            "    ) as request:",
            "        response = await AsyncHTTPClient(io_loop).fetch(request)",
            "    return response",
            "",
            "",
            "def is_namespace_package(namespace: str) -> bool | None:",
            "    \"\"\"Is the provided namespace a Python Namespace Package (PEP420).",
            "",
            "    https://www.python.org/dev/peps/pep-0420/#specification",
            "",
            "    Returns `None` if module is not importable.",
            "",
            "    \"\"\"",
            "    # NOTE: using submodule_search_locations because the loader can be None",
            "    try:",
            "        spec = importlib.util.find_spec(namespace)",
            "    except ValueError:  # spec is not set - see https://docs.python.org/3/library/importlib.html#importlib.util.find_spec",
            "        return None",
            "",
            "    if not spec:",
            "        # e.g. module not installed",
            "        return None",
            "    return isinstance(spec.submodule_search_locations, _NamespacePath)",
            "",
            "",
            "def filefind(filename: str, path_dirs: Sequence[str]) -> str:",
            "    \"\"\"Find a file by looking through a sequence of paths.",
            "",
            "    For use in FileFindHandler.",
            "",
            "    Iterates through a sequence of paths looking for a file and returns",
            "    the full, absolute path of the first occurrence of the file.",
            "",
            "    Absolute paths are not accepted for inputs.",
            "",
            "    This function does not automatically try any paths,",
            "    such as the cwd or the user's home directory.",
            "",
            "    Parameters",
            "    ----------",
            "    filename : str",
            "        The filename to look for. Must be a relative path.",
            "    path_dirs : sequence of str",
            "        The sequence of paths to look in for the file.",
            "        Walk through each element and join with ``filename``.",
            "        Only after ensuring the path resolves within the directory is it checked for existence.",
            "",
            "    Returns",
            "    -------",
            "    Raises :exc:`OSError` or returns absolute path to file.",
            "    \"\"\"",
            "    file_path = Path(filename)",
            "",
            "    # If the input is an absolute path, reject it",
            "    if file_path.is_absolute():",
            "        msg = f\"{filename} is absolute, filefind only accepts relative paths.\"",
            "        raise OSError(msg)",
            "",
            "    for path_str in path_dirs:",
            "        path = Path(path_str).absolute()",
            "        test_path = path / file_path",
            "        # os.path.abspath resolves '..', but Path.absolute() doesn't",
            "        # Path.resolve() does, but traverses symlinks, which we don't want",
            "        test_path = Path(os.path.abspath(test_path))",
            "        if sys.version_info >= (3, 9):",
            "            if not test_path.is_relative_to(path):",
            "                # points outside root, e.g. via `filename='../foo'`",
            "                continue",
            "        else:",
            "            # is_relative_to is new in 3.9",
            "            try:",
            "                test_path.relative_to(path)",
            "            except ValueError:",
            "                # points outside root, e.g. via `filename='../foo'`",
            "                continue",
            "        # make sure we don't call is_file before we know it's a file within a prefix",
            "        # GHSA-hrw6-wg82-cm62 - can leak password hash on windows.",
            "        if test_path.is_file():",
            "            return os.path.abspath(test_path)",
            "",
            "    msg = f\"File {filename!r} does not exist in any of the search paths: {path_dirs!r}\"",
            "    raise OSError(msg)",
            "",
            "",
            "def import_item(name: str) -> Any:",
            "    \"\"\"Import and return ``bar`` given the string ``foo.bar``.",
            "    Calling ``bar = import_item(\"foo.bar\")`` is the functional equivalent of",
            "    executing the code ``from foo import bar``.",
            "    Parameters",
            "    ----------",
            "    name : str",
            "      The fully qualified name of the module/package being imported.",
            "    Returns",
            "    -------",
            "    mod : module object",
            "       The module that was imported.",
            "    \"\"\"",
            "",
            "    parts = name.rsplit(\".\", 1)",
            "    if len(parts) == 2:",
            "        # called with 'foo.bar....'",
            "        package, obj = parts",
            "        module = __import__(package, fromlist=[obj])",
            "        try:",
            "            pak = getattr(module, obj)",
            "        except AttributeError as e:",
            "            raise ImportError(\"No module named %s\" % obj) from e",
            "        return pak",
            "    else:",
            "        # called with un-dotted string",
            "        return __import__(parts[0])",
            "",
            "",
            "class JupyterServerAuthWarning(RuntimeWarning):",
            "    \"\"\"Emitted when authentication configuration issue is detected.",
            "",
            "    Intended for filtering out expected warnings in tests, including",
            "    downstream tests, rather than for users to silence this warning.",
            "    \"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "341": [
                "filefind"
            ],
            "343": [
                "filefind"
            ],
            "344": [
                "filefind"
            ],
            "345": [
                "filefind"
            ],
            "346": [
                "filefind"
            ],
            "348": [
                "filefind"
            ],
            "350": [
                "filefind"
            ],
            "352": [
                "filefind"
            ],
            "354": [
                "filefind"
            ],
            "355": [
                "filefind"
            ],
            "360": [
                "filefind"
            ],
            "361": [
                "filefind"
            ],
            "362": [
                "filefind"
            ],
            "363": [
                "filefind"
            ],
            "364": [
                "filefind"
            ],
            "365": [
                "filefind"
            ],
            "366": [
                "filefind"
            ],
            "370": [
                "filefind"
            ],
            "372": [
                "filefind"
            ],
            "373": [
                "filefind"
            ],
            "374": [
                "filefind"
            ],
            "375": [
                "filefind"
            ],
            "376": [
                "filefind"
            ],
            "377": [
                "filefind"
            ],
            "378": [
                "filefind"
            ],
            "379": [
                "filefind"
            ],
            "380": [
                "filefind"
            ],
            "381": [
                "filefind"
            ],
            "382": [
                "filefind"
            ],
            "383": [
                "filefind"
            ],
            "384": [
                "filefind"
            ],
            "385": [
                "filefind"
            ],
            "386": [
                "filefind"
            ],
            "387": [
                "filefind"
            ],
            "388": [
                "filefind"
            ],
            "389": [
                "filefind"
            ],
            "395": [
                "expand_path"
            ],
            "396": [
                "expand_path"
            ],
            "397": [
                "expand_path"
            ],
            "398": [
                "expand_path"
            ],
            "399": [
                "expand_path"
            ],
            "400": [
                "expand_path"
            ],
            "401": [
                "expand_path"
            ],
            "402": [
                "expand_path"
            ],
            "403": [
                "expand_path"
            ],
            "404": [
                "expand_path"
            ],
            "405": [
                "expand_path"
            ],
            "406": [
                "expand_path"
            ],
            "407": [
                "expand_path"
            ],
            "408": [
                "expand_path"
            ],
            "409": [
                "expand_path"
            ],
            "410": [
                "expand_path"
            ],
            "411": [
                "expand_path"
            ],
            "412": [
                "expand_path"
            ],
            "413": [
                "expand_path"
            ],
            "414": [],
            "415": []
        },
        "addLocation": []
    }
}