{
    "jupyterhub/apihandlers/users.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "             data = user_list"
            },
            "1": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 223,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "         self.write(json.dumps(data))"
            },
            "3": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # if testing with raiselaod above, need expire_all to avoid affecting other operations"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+        # if testing with raiseload above, need expire_all to avoid affecting other operations"
            },
            "5": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         # self.db.expire_all()"
            },
            "6": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "     @needs_scope('admin:users')"
            },
            "8": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         # admin is set for all users"
            },
            "9": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         # to create admin and non-admin users requires at least two API requests"
            },
            "10": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         admin = data.get('admin', False)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+        if admin and not self.current_user.admin:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+            raise web.HTTPError(403, \"Only admins can grant admin permissions\")"
            },
            "13": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 241,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         to_create = []"
            },
            "15": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "         invalid_names = []"
            },
            "16": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "         if user is not None:"
            },
            "17": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "             raise web.HTTPError(409, f\"User {user_name} already exists\")"
            },
            "18": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 313,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user = self.user_from_username(user_name)"
            },
            "20": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "         if data:"
            },
            "21": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "             self._check_user_model(data)"
            },
            "22": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if 'admin' in data:"
            },
            "23": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                user.admin = data['admin']"
            },
            "24": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                assign_default_roles(self.db, entity=user)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+            if data.get('admin', False) and not self.current_user.admin:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+                raise web.HTTPError(403, \"Only admins can grant admin permissions\")"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+        # create the user"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+        user = self.user_from_username(user_name)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+        if data and data.get('admin', False):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+            user.admin = data['admin']"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+            assign_default_roles(self.db, entity=user)"
            },
            "33": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "         self.db.commit()"
            },
            "34": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 325,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "         try:"
            },
            "36": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "                         data['name']"
            },
            "37": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "                     ),"
            },
            "38": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "                 )"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+        if not self.current_user.admin:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+            if user.admin:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+                raise web.HTTPError(403, \"Only admins can modify other admins\")"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+            if 'admin' in data and data['admin']:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+                raise web.HTTPError(403, \"Only admins can grant admin permissions\")"
            },
            "45": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "         for key, value in data.items():"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+            value_s = \"...\" if key == \"auth_state\" else repr(value)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+            self.log.info("
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+                f\"{self.current_user.name} setting {key}={value_s} for {user.name}\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+            )"
            },
            "50": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "             if key == 'auth_state':"
            },
            "51": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "                 await user.save_auth_state(value)"
            },
            "52": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "             else:"
            }
        },
        "frontPatchFile": [
            "\"\"\"User handlers\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import asyncio",
            "import inspect",
            "import json",
            "import sys",
            "from datetime import timedelta, timezone",
            "",
            "if sys.version_info >= (3, 10):",
            "    from contextlib import aclosing",
            "else:",
            "    from async_generator import aclosing",
            "",
            "from dateutil.parser import parse as parse_date",
            "from sqlalchemy import func, or_",
            "from sqlalchemy.orm import joinedload, raiseload, selectinload  # noqa",
            "from tornado import web",
            "from tornado.iostream import StreamClosedError",
            "",
            "from .. import orm, scopes",
            "from ..roles import assign_default_roles",
            "from ..scopes import needs_scope",
            "from ..user import User",
            "from ..utils import (",
            "    isoformat,",
            "    iterate_until,",
            "    maybe_future,",
            "    url_escape_path,",
            "    url_path_join,",
            "    utcnow,",
            ")",
            "from .base import APIHandler",
            "",
            "",
            "class SelfAPIHandler(APIHandler):",
            "    \"\"\"Return the authenticated user's model",
            "",
            "    Based on the authentication info. Acts as a 'whoami' for auth tokens.",
            "    \"\"\"",
            "",
            "    async def get(self):",
            "        user = self.current_user",
            "        if user is None:",
            "            raise web.HTTPError(403)",
            "",
            "        _added_scopes = set()",
            "        if isinstance(user, orm.Service):",
            "            # ensure we have the minimal 'identify' scopes for the token owner",
            "            identify_scopes = scopes.identify_scopes(user)",
            "            get_model = self.service_model",
            "        else:",
            "            identify_scopes = scopes.identify_scopes(user.orm_user)",
            "            get_model = self.user_model",
            "",
            "        # ensure we have permission to identify ourselves",
            "        # all tokens can do this on this endpoint",
            "        for scope in identify_scopes:",
            "            if scope not in self.expanded_scopes:",
            "                _added_scopes.add(scope)",
            "                self.expanded_scopes |= {scope}",
            "        if _added_scopes:",
            "            # re-parse with new scopes",
            "            self.parsed_scopes = scopes.parse_scopes(self.expanded_scopes)",
            "",
            "        model = get_model(user)",
            "",
            "        # add session_id associated with token",
            "        # added in 2.0",
            "        # token_id added in 5.0",
            "        token = self.get_token()",
            "        if token:",
            "            model[\"token_id\"] = token.api_id",
            "            model[\"session_id\"] = token.session_id",
            "        else:",
            "            model[\"token_id\"] = None",
            "            model[\"session_id\"] = None",
            "",
            "        # add scopes to identify model,",
            "        # but not the scopes we added to ensure we could read our own model",
            "        model[\"scopes\"] = sorted(self.expanded_scopes.difference(_added_scopes))",
            "        self.write(json.dumps(model))",
            "",
            "",
            "class UserListAPIHandler(APIHandler):",
            "    def _user_has_ready_spawner(self, orm_user):",
            "        \"\"\"Return True if a user has *any* ready spawners",
            "",
            "        Used for filtering from active -> ready",
            "        \"\"\"",
            "        user = self.users[orm_user]",
            "        return any(spawner.ready for spawner in user.spawners.values())",
            "",
            "    @needs_scope('list:users')",
            "    def get(self):",
            "        state_filter = self.get_argument(\"state\", None)",
            "        name_filter = self.get_argument(\"name_filter\", None)",
            "        sort = sort_by_param = self.get_argument(\"sort\", \"id\")",
            "        sort_direction = \"asc\"",
            "        if sort[:1] == '-':",
            "            sort_direction = \"desc\"",
            "            sort = sort[1:]",
            "",
            "        offset, limit = self.get_api_pagination()",
            "",
            "        if sort in {\"id\", \"name\", \"last_activity\"}:",
            "            sort_column = getattr(orm.User, sort)",
            "        else:",
            "            raise web.HTTPError(",
            "                400,",
            "                f\"sort must be 'id', 'name', or 'last_activity', not '{sort_by_param}'\",",
            "            )",
            "",
            "        # NULL is sorted inconsistently, so make it explicit",
            "        if sort_direction == \"asc\":",
            "            sort_order = (sort_column.is_not(None), sort_column.asc())",
            "        elif sort_direction == \"desc\":",
            "            sort_order = (sort_column.is_(None), sort_column.desc())",
            "        else:",
            "            # this can't happen, users don't specify direction",
            "            raise ValueError(",
            "                f\"sort_direction must be 'asc' or 'desc', got '{sort_direction}'\"",
            "            )",
            "",
            "        # post_filter",
            "        post_filter = None",
            "",
            "        # starting query",
            "        query = self.db.query(orm.User)",
            "",
            "        if state_filter in {\"active\", \"ready\"}:",
            "            # only get users with active servers",
            "            # an 'active' Spawner has a server record in the database",
            "            # which means Spawner.server != None",
            "            # it may still be in a pending start/stop state.",
            "            # join filters out users with no Spawners",
            "            query = (",
            "                query",
            "                # join filters out any Users with no Spawners",
            "                .join(orm.Spawner, orm.User._orm_spawners)",
            "                # this implicitly gets Users with *any* active server",
            "                .filter(orm.Spawner.server != None)",
            "                # group-by ensures the count is correct",
            "                .group_by(orm.User.id)",
            "            )",
            "            if state_filter == \"ready\":",
            "                # have to post-process query results because active vs ready",
            "                # can only be distinguished with in-memory Spawner properties",
            "                post_filter = self._user_has_ready_spawner",
            "",
            "        elif state_filter == \"inactive\":",
            "            # only get users with *no* active servers",
            "            # as opposed to users with *any inactive servers*",
            "            # this is the complement to the above query.",
            "            # how expensive is this with lots of servers?",
            "            query = (",
            "                query.outerjoin(orm.Spawner, orm.User._orm_spawners)",
            "                .outerjoin(orm.Server, orm.Spawner.server)",
            "                .group_by(orm.User.id)",
            "                .having(func.count(orm.Server.id) == 0)",
            "            )",
            "        elif state_filter:",
            "            raise web.HTTPError(400, f\"Unrecognized state filter: {state_filter!r}\")",
            "",
            "        # apply eager load options",
            "        query = query.options(",
            "            selectinload(orm.User.roles),",
            "            selectinload(orm.User.groups),",
            "            joinedload(orm.User._orm_spawners).joinedload(orm.Spawner.user),",
            "            # raiseload here helps us make sure we've loaded everything in one query",
            "            # but since we share a single db session, we can't do this for real",
            "            # but it's useful in testing",
            "            # raiseload(\"*\"),",
            "        )",
            "",
            "        sub_scope = self.parsed_scopes['list:users']",
            "        if sub_scope != scopes.Scope.ALL:",
            "            if not set(sub_scope).issubset({'group', 'user'}):",
            "                # don't expand invalid !server=x filter to all users!",
            "                self.log.warning(",
            "                    f\"Invalid filter on list:user for {self.current_user}: {sub_scope}\"",
            "                )",
            "                raise web.HTTPError(403)",
            "            filters = []",
            "            if 'user' in sub_scope:",
            "                filters.append(orm.User.name.in_(sub_scope['user']))",
            "            if 'group' in sub_scope:",
            "                filters.append(",
            "                    orm.User.groups.any(",
            "                        orm.Group.name.in_(sub_scope['group']),",
            "                    )",
            "                )",
            "",
            "            if len(filters) == 1:",
            "                query = query.filter(filters[0])",
            "            else:",
            "                query = query.filter(or_(*filters))",
            "",
            "        if name_filter:",
            "            query = query.filter(orm.User.name.ilike(f'%{name_filter}%'))",
            "",
            "        full_query = query",
            "        query = query.order_by(*sort_order).offset(offset).limit(limit)",
            "",
            "        user_list = []",
            "        for u in query:",
            "            if post_filter is None or post_filter(u):",
            "                user_model = self.user_model(u)",
            "                if user_model:",
            "                    user_list.append(user_model)",
            "",
            "        total_count = full_query.count()",
            "        if self.accepts_pagination:",
            "            data = self.paginated_model(user_list, offset, limit, total_count)",
            "        else:",
            "            query_count = query.count()",
            "            if offset == 0 and total_count > query_count:",
            "                self.log.warning(",
            "                    f\"Truncated user list in request that does not expect pagination. Processing {query_count} of {total_count} total users.\"",
            "                )",
            "            data = user_list",
            "",
            "        self.write(json.dumps(data))",
            "        # if testing with raiselaod above, need expire_all to avoid affecting other operations",
            "        # self.db.expire_all()",
            "",
            "    @needs_scope('admin:users')",
            "    async def post(self):",
            "        data = self.get_json_body()",
            "        if not data or not isinstance(data, dict) or not data.get('usernames'):",
            "            raise web.HTTPError(400, \"Must specify at least one user to create\")",
            "",
            "        usernames = data.pop('usernames')",
            "        self._check_user_model(data)",
            "        # admin is set for all users",
            "        # to create admin and non-admin users requires at least two API requests",
            "        admin = data.get('admin', False)",
            "",
            "        to_create = []",
            "        invalid_names = []",
            "        for name in usernames:",
            "            name = self.authenticator.normalize_username(name)",
            "            if not self.authenticator.validate_username(name):",
            "                invalid_names.append(name)",
            "                continue",
            "            user = self.find_user(name)",
            "            if user is not None:",
            "                self.log.warning(f\"User {name} already exists\")",
            "            else:",
            "                to_create.append(name)",
            "",
            "        if invalid_names:",
            "            if len(invalid_names) == 1:",
            "                msg = f\"Invalid username: {invalid_names[0]}\"",
            "            else:",
            "                msg = \"Invalid usernames: {}\".format(', '.join(invalid_names))",
            "            raise web.HTTPError(400, msg)",
            "",
            "        if not to_create:",
            "            raise web.HTTPError(409, \"All %i users already exist\" % len(usernames))",
            "",
            "        created = []",
            "        for name in to_create:",
            "            user = self.user_from_username(name)",
            "            if admin:",
            "                user.admin = True",
            "            assign_default_roles(self.db, entity=user)",
            "            self.db.commit()",
            "            try:",
            "                await maybe_future(self.authenticator.add_user(user))",
            "            except Exception as e:",
            "                self.log.error(f\"Failed to create user: {name}\", exc_info=True)",
            "                self.users.delete(user)",
            "                raise web.HTTPError(400, f\"Failed to create user {name}: {e}\")",
            "            else:",
            "                created.append(user)",
            "",
            "        self.write(json.dumps([self.user_model(u) for u in created]))",
            "        self.set_status(201)",
            "",
            "",
            "class UserAPIHandler(APIHandler):",
            "    @needs_scope(",
            "        'read:users',",
            "        'read:users:name',",
            "        'read:servers',",
            "        'read:users:groups',",
            "        'read:users:activity',",
            "        'read:roles:users',",
            "    )",
            "    async def get(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        model = self.user_model(user)",
            "        # auth state will only be shown if the requester is an admin",
            "        # this means users can't see their own auth state unless they",
            "        # are admins, Hub admins often are also marked as admins so they",
            "        # will see their auth state but normal users won't",
            "        if 'auth_state' in model:",
            "            model['auth_state'] = await user.get_auth_state()",
            "        self.write(json.dumps(model))",
            "",
            "    @needs_scope('admin:users')",
            "    async def post(self, user_name):",
            "        data = self.get_json_body()",
            "        user = self.find_user(user_name)",
            "        if user is not None:",
            "            raise web.HTTPError(409, f\"User {user_name} already exists\")",
            "",
            "        user = self.user_from_username(user_name)",
            "        if data:",
            "            self._check_user_model(data)",
            "            if 'admin' in data:",
            "                user.admin = data['admin']",
            "                assign_default_roles(self.db, entity=user)",
            "        self.db.commit()",
            "",
            "        try:",
            "            await maybe_future(self.authenticator.add_user(user))",
            "        except Exception:",
            "            self.log.error(f\"Failed to create user: {user_name}\", exc_info=True)",
            "            # remove from registry",
            "            self.users.delete(user)",
            "            raise web.HTTPError(400, f\"Failed to create user: {user_name}\")",
            "",
            "        self.write(json.dumps(self.user_model(user)))",
            "        self.set_status(201)",
            "",
            "    @needs_scope('delete:users')",
            "    async def delete(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        if user.name == self.current_user.name:",
            "            raise web.HTTPError(400, \"Cannot delete yourself!\")",
            "        if user.spawner._stop_pending:",
            "            raise web.HTTPError(",
            "                400,",
            "                f\"{user_name}'s server is in the process of stopping, please wait.\",",
            "            )",
            "        if user.running:",
            "            await self.stop_single_user(user)",
            "            if user.spawner._stop_pending:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"{user_name}'s server is in the process of stopping, please wait.\",",
            "                )",
            "",
            "        await maybe_future(self.authenticator.delete_user(user))",
            "",
            "        await user.delete_spawners()",
            "",
            "        # remove from registry",
            "        self.users.delete(user)",
            "",
            "        self.set_status(204)",
            "",
            "    @needs_scope('admin:users')",
            "    async def patch(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        data = self.get_json_body()",
            "        self._check_user_model(data)",
            "        if 'name' in data and data['name'] != user_name:",
            "            # check if the new name is already taken inside db",
            "            if self.find_user(data['name']):",
            "                raise web.HTTPError(",
            "                    400,",
            "                    \"User {} already exists, username must be unique\".format(",
            "                        data['name']",
            "                    ),",
            "                )",
            "        for key, value in data.items():",
            "            if key == 'auth_state':",
            "                await user.save_auth_state(value)",
            "            else:",
            "                setattr(user, key, value)",
            "                if key == 'admin':",
            "                    assign_default_roles(self.db, entity=user)",
            "        self.db.commit()",
            "        user_ = self.user_model(user)",
            "        user_['auth_state'] = await user.get_auth_state()",
            "        self.write(json.dumps(user_))",
            "",
            "",
            "class UserTokenListAPIHandler(APIHandler):",
            "    \"\"\"API endpoint for listing/creating tokens\"\"\"",
            "",
            "    # defer check_xsrf_cookie so we can accept auth",
            "    # in the `auth` request field, which shouldn't require xsrf cookies",
            "    _skip_post_check_xsrf = True",
            "",
            "    def check_xsrf_cookie(self):",
            "        if self.request.method == 'POST' and self._skip_post_check_xsrf:",
            "            return",
            "        return super().check_xsrf_cookie()",
            "",
            "    @needs_scope('read:tokens')",
            "    def get(self, user_name):",
            "        \"\"\"Get tokens for a given user\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, f\"No such user: {user_name}\")",
            "",
            "        now = utcnow(with_tz=False)",
            "        api_tokens = []",
            "",
            "        def sort_key(token):",
            "            return token.last_activity or token.created",
            "",
            "        for token in sorted(user.api_tokens, key=sort_key):",
            "            if token.expires_at and token.expires_at < now:",
            "                # exclude expired tokens",
            "                self.db.delete(token)",
            "                self.db.commit()",
            "                continue",
            "            api_tokens.append(self.token_model(token))",
            "",
            "        self.write(json.dumps({'api_tokens': api_tokens}))",
            "",
            "    async def post(self, user_name):",
            "        body = self.get_json_body() or {}",
            "        if not isinstance(body, dict):",
            "            raise web.HTTPError(400, \"Body must be a JSON dict or empty\")",
            "",
            "        requester = self.current_user",
            "        if requester is None:",
            "            # defer to Authenticator for identifying the user",
            "            # can be username+password or an upstream auth token",
            "            try:",
            "                name = await self.authenticate(body.get('auth'))",
            "                if isinstance(name, dict):",
            "                    # not a simple string so it has to be a dict",
            "                    name = name.get('name')",
            "                # don't check xsrf if we've authenticated via the request body",
            "            except web.HTTPError as e:",
            "                # turn any authentication error into 403",
            "                raise web.HTTPError(403)",
            "            except Exception as e:",
            "                # suppress and log error here in case Authenticator",
            "                # isn't prepared to handle auth via this data",
            "                self.log.error(",
            "                    \"Error authenticating request for %s: %s\", self.request.uri, e",
            "                )",
            "                raise web.HTTPError(403)",
            "            if name is None:",
            "                raise web.HTTPError(403)",
            "            requester = self.find_user(name)",
            "        else:",
            "            # perform delayed xsrf check",
            "            # if we aren't authenticating via the request body",
            "            self._skip_post_check_xsrf = False",
            "            self.check_xsrf_cookie()",
            "        if requester is None:",
            "            # couldn't identify requester",
            "            raise web.HTTPError(403)",
            "        self._jupyterhub_user = requester",
            "        self._resolve_roles_and_scopes()",
            "        user = self.find_user(user_name)",
            "        kind = 'user' if isinstance(requester, User) else 'service'",
            "        scope_filter = self.get_scope_filter('tokens')",
            "        if user is None or not scope_filter(user, kind):",
            "            raise web.HTTPError(",
            "                403,",
            "                f\"{kind.title()} {user_name} not found or no permissions to generate tokens\",",
            "            )",
            "",
            "        note = body.get('note')",
            "        if not note:",
            "            note = \"Requested via api\"",
            "            if requester is not user:",
            "                note += f\" by {kind} {requester.name}\"",
            "",
            "        token_roles = body.get(\"roles\")",
            "        token_scopes = body.get(\"scopes\")",
            "",
            "        # check type of permissions",
            "        for key in (\"roles\", \"scopes\"):",
            "            value = body.get(key)",
            "            if value is None:",
            "                continue",
            "            if not isinstance(value, list) or not all(",
            "                isinstance(item, str) for item in value",
            "            ):",
            "                raise web.HTTPError(",
            "                    400, f\"token {key} must be null or a list of strings, not {value!r}\"",
            "                )",
            "",
            "        expires_in = body.get('expires_in', None)",
            "        if not (expires_in is None or isinstance(expires_in, int)):",
            "            raise web.HTTPError(",
            "                400,",
            "                f\"token expires_in must be null or integer, not {expires_in!r}\",",
            "            )",
            "        expires_in_max = self.settings[\"token_expires_in_max_seconds\"]",
            "        if expires_in_max:",
            "            # validate expires_in against limit",
            "            if expires_in is None:",
            "                # expiration unspecified, use max value",
            "                # (default before max limit was introduced was 'never', this is closest equivalent)",
            "                expires_in = expires_in_max",
            "            elif expires_in > expires_in_max:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"token expires_in: {expires_in} must not exceed {expires_in_max}\",",
            "                )",
            "",
            "        try:",
            "            api_token = user.new_api_token(",
            "                note=note,",
            "                expires_in=expires_in,",
            "                roles=token_roles,",
            "                scopes=token_scopes,",
            "            )",
            "        except (ValueError, KeyError) as e:",
            "            raise web.HTTPError(400, str(e))",
            "        if requester is not user:",
            "            self.log.info(",
            "                \"%s %s requested API token for %s\",",
            "                kind.title(),",
            "                requester.name,",
            "                user.name,",
            "            )",
            "        else:",
            "            user_kind = 'user' if isinstance(user, User) else 'service'",
            "            self.log.info(\"%s %s requested new API token\", user_kind.title(), user.name)",
            "        # retrieve the model",
            "        orm_token = orm.APIToken.find(self.db, api_token)",
            "        if orm_token is None:",
            "            self.log.error(",
            "                \"Failed to find token after creating it: %r. Maybe it expired already?\",",
            "                body,",
            "            )",
            "            raise web.HTTPError(500, \"Failed to create token\")",
            "        token_model = self.token_model(orm_token)",
            "        token_model['token'] = api_token",
            "        self.write(json.dumps(token_model))",
            "        self.set_status(201)",
            "",
            "",
            "class UserTokenAPIHandler(APIHandler):",
            "    \"\"\"API endpoint for retrieving/deleting individual tokens\"\"\"",
            "",
            "    def find_token_by_id(self, user, token_id):",
            "        \"\"\"Find a token object by token-id key",
            "",
            "        Raises 404 if not found for any reason",
            "        (e.g. wrong owner, invalid key format, etc.)",
            "        \"\"\"",
            "        not_found = f\"No such token {token_id} for user {user.name}\"",
            "        prefix, id_ = token_id[:1], token_id[1:]",
            "        if prefix != 'a':",
            "            raise web.HTTPError(404, not_found)",
            "        try:",
            "            id_ = int(id_)",
            "        except ValueError:",
            "            raise web.HTTPError(404, not_found)",
            "",
            "        orm_token = self.db.query(orm.APIToken).filter_by(id=id_).first()",
            "        if orm_token is None or orm_token.user is not user.orm_user:",
            "            raise web.HTTPError(404, not_found)",
            "        return orm_token",
            "",
            "    @needs_scope('read:tokens')",
            "    def get(self, user_name, token_id):",
            "        \"\"\"\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, f\"No such user: {user_name}\")",
            "        token = self.find_token_by_id(user, token_id)",
            "        self.write(json.dumps(self.token_model(token)))",
            "",
            "    @needs_scope('tokens')",
            "    def delete(self, user_name, token_id):",
            "        \"\"\"Delete a token\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, f\"No such user: {user_name}\")",
            "        token = self.find_token_by_id(user, token_id)",
            "        # deleting an oauth token deletes *all* oauth tokens for that client",
            "        client_id = token.client_id",
            "        if token.client_id != \"jupyterhub\":",
            "            tokens = [",
            "                token for token in user.api_tokens if token.client_id == client_id",
            "            ]",
            "            self.log.info(",
            "                f\"Deleting {len(tokens)} tokens for {user_name} issued by {token.client_id}\"",
            "            )",
            "        else:",
            "            self.log.info(f\"Deleting token {token_id} for {user_name}\")",
            "            tokens = [token]",
            "        for token in tokens:",
            "            self.db.delete(token)",
            "        self.db.commit()",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(204)",
            "",
            "",
            "class UserServerAPIHandler(APIHandler):",
            "    \"\"\"Start and stop single-user servers\"\"\"",
            "",
            "    @needs_scope('servers')",
            "    async def post(self, user_name, server_name=''):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # this can be reached if a token has `servers`",
            "            # permission on *all* users",
            "            raise web.HTTPError(404)",
            "",
            "        if server_name:",
            "            if not self.allow_named_servers:",
            "                raise web.HTTPError(400, \"Named servers are not enabled.\")",
            "",
            "            named_server_limit_per_user = (",
            "                await self.get_current_user_named_server_limit()",
            "            )",
            "",
            "            if named_server_limit_per_user > 0 and server_name not in user.orm_spawners:",
            "                named_spawners = list(user.all_spawners(include_default=False))",
            "                if named_server_limit_per_user <= len(named_spawners):",
            "                    raise web.HTTPError(",
            "                        400,",
            "                        f\"User {user_name} already has the maximum of {named_server_limit_per_user} named servers.\"",
            "                        \"  One must be deleted before a new server can be created\",",
            "                    )",
            "        spawner = user.get_spawner(server_name, replace_failed=True)",
            "        pending = spawner.pending",
            "        if pending == 'spawn':",
            "            self.set_header('Content-Type', 'text/plain')",
            "            self.set_status(202)",
            "            return",
            "        elif pending:",
            "            raise web.HTTPError(400, f\"{spawner._log_name} is pending {pending}\")",
            "",
            "        if spawner.ready:",
            "            # include notify, so that a server that died is noticed immediately",
            "            # set _spawn_pending flag to prevent races while we wait",
            "            spawner._spawn_pending = True",
            "            try:",
            "                state = await spawner.poll_and_notify()",
            "            finally:",
            "                spawner._spawn_pending = False",
            "            if state is None:",
            "                raise web.HTTPError(400, f\"{spawner._log_name} is already running\")",
            "",
            "        options = self.get_json_body()",
            "        await self.spawn_single_user(user, server_name, options=options)",
            "        status = 202 if spawner.pending == 'spawn' else 201",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(status)",
            "",
            "    @needs_scope('delete:servers')",
            "    async def delete(self, user_name, server_name=''):",
            "        user = self.find_user(user_name)",
            "        options = self.get_json_body()",
            "        remove = (options or {}).get('remove', False)",
            "",
            "        async def _remove_spawner(f=None):",
            "            \"\"\"Remove the spawner object",
            "",
            "            only called after it stops successfully",
            "            \"\"\"",
            "            if f:",
            "                # await f, stop on error,",
            "                # leaving resources in the db in case of failure to stop",
            "                await f",
            "            self.log.info(\"Deleting spawner %s\", spawner._log_name)",
            "            await maybe_future(user._delete_spawner(spawner))",
            "",
            "            self.db.delete(spawner.orm_spawner)",
            "            user.spawners.pop(server_name, None)",
            "            self.db.commit()",
            "",
            "        if server_name:",
            "            if not self.allow_named_servers:",
            "                raise web.HTTPError(400, \"Named servers are not enabled.\")",
            "            if server_name not in user.orm_spawners:",
            "                raise web.HTTPError(",
            "                    404, f\"{user_name} has no server named '{server_name}'\"",
            "                )",
            "        elif remove:",
            "            raise web.HTTPError(400, \"Cannot delete the default server\")",
            "",
            "        spawner = user.spawners[server_name]",
            "        if spawner.pending == 'stop':",
            "            self.log.debug(\"%s already stopping\", spawner._log_name)",
            "            self.set_header('Content-Type', 'text/plain')",
            "            self.set_status(202)",
            "            if remove:",
            "                # schedule remove when stop completes",
            "                asyncio.ensure_future(_remove_spawner(spawner._stop_future))",
            "            return",
            "",
            "        stop_future = None",
            "        if spawner.pending:",
            "            # we are interrupting a pending start",
            "            # hopefully nothing gets leftover",
            "            self.log.warning(",
            "                f\"Interrupting spawner {spawner._log_name}, pending {spawner.pending}\"",
            "            )",
            "            spawn_future = spawner._spawn_future",
            "            if spawn_future:",
            "                spawn_future.cancel()",
            "            # Give cancel a chance to resolve?",
            "            # not sure what we would wait for here,",
            "            await asyncio.sleep(1)",
            "            stop_future = await self.stop_single_user(user, server_name)",
            "",
            "        elif spawner.ready:",
            "            # include notify, so that a server that died is noticed immediately",
            "            status = await spawner.poll_and_notify()",
            "            if status is None:",
            "                stop_future = await self.stop_single_user(user, server_name)",
            "",
            "        if remove:",
            "            if stop_future:",
            "                # schedule remove when stop completes",
            "                asyncio.ensure_future(_remove_spawner(spawner._stop_future))",
            "            else:",
            "                await _remove_spawner()",
            "",
            "        status = 202 if spawner._stop_pending else 204",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(status)",
            "",
            "",
            "class UserAdminAccessAPIHandler(APIHandler):",
            "    \"\"\"Grant admins access to single-user servers",
            "",
            "    This handler sets the necessary cookie for an admin to login to a single-user server.",
            "    \"\"\"",
            "",
            "    @needs_scope('servers')",
            "    def post(self, user_name):",
            "        self.log.warning(",
            "            \"Deprecated in JupyterHub 0.8.\"",
            "            \" Admin access API is not needed now that we use OAuth.\"",
            "        )",
            "        current = self.current_user",
            "        self.log.warning(",
            "            \"Admin user %s has requested access to %s's server\", current.name, user_name",
            "        )",
            "        if not self.settings.get('admin_access', False):",
            "            raise web.HTTPError(403, \"admin access to user servers disabled\")",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "",
            "",
            "class SpawnProgressAPIHandler(APIHandler):",
            "    \"\"\"EventStream handler for pending spawns\"\"\"",
            "",
            "    keepalive_interval = 8",
            "",
            "    def get_content_type(self):",
            "        return 'text/event-stream'",
            "",
            "    async def send_event(self, event):",
            "        try:",
            "            self.write(f'data: {json.dumps(event)}\\n\\n')",
            "            await self.flush()",
            "        except StreamClosedError:",
            "            self.log.warning(\"Stream closed while handling %s\", self.request.uri)",
            "            # raise Finish to halt the handler",
            "            raise web.Finish()",
            "",
            "    def initialize(self):",
            "        super().initialize()",
            "        self._finish_future = asyncio.Future()",
            "",
            "    def on_finish(self):",
            "        self._finish_future.set_result(None)",
            "",
            "    async def keepalive(self):",
            "        \"\"\"Write empty lines periodically",
            "",
            "        to avoid being closed by intermediate proxies",
            "        when there's a large gap between events.",
            "        \"\"\"",
            "        while not self._finish_future.done():",
            "            try:",
            "                self.write(\"\\n\\n\")",
            "                await self.flush()",
            "            except (StreamClosedError, RuntimeError):",
            "                return",
            "",
            "            await asyncio.wait([self._finish_future], timeout=self.keepalive_interval)",
            "",
            "    @needs_scope('read:servers')",
            "    async def get(self, user_name, server_name=''):",
            "        self.set_header('Cache-Control', 'no-cache')",
            "        if server_name is None:",
            "            server_name = ''",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # no such user",
            "            raise web.HTTPError(404)",
            "        if server_name not in user.spawners:",
            "            # user has no such server",
            "            raise web.HTTPError(404)",
            "        spawner = user.spawners[server_name]",
            "",
            "        # start sending keepalive to avoid proxies closing the connection",
            "        asyncio.ensure_future(self.keepalive())",
            "        # cases:",
            "        # - spawner already started and ready",
            "        # - spawner not running at all",
            "        # - spawner failed",
            "        # - spawner pending start (what we expect)",
            "        failed_event = {'progress': 100, 'failed': True, 'message': \"Spawn failed\"}",
            "",
            "        async def get_ready_event():",
            "            url = url_path_join(user.url, url_escape_path(server_name), '/')",
            "            ready_event = {",
            "                'progress': 100,",
            "                'ready': True,",
            "                'message': f\"Server ready at {url}\",",
            "                'html_message': f'Server ready at <a href=\"{url}\">{url}</a>',",
            "                'url': url,",
            "            }",
            "            original_ready_event = ready_event.copy()",
            "            if spawner.progress_ready_hook:",
            "                try:",
            "                    ready_event = spawner.progress_ready_hook(spawner, ready_event)",
            "                    if inspect.isawaitable(ready_event):",
            "                        ready_event = await ready_event",
            "                except Exception as e:",
            "                    self.log.exception(f\"Error in ready_event hook: {e}\")",
            "                    ready_event = original_ready_event",
            "            return ready_event",
            "",
            "        if spawner.ready:",
            "            # spawner already ready. Trigger progress-completion immediately",
            "            self.log.info(\"Server %s is already started\", spawner._log_name)",
            "            ready_event = await get_ready_event()",
            "            await self.send_event(ready_event)",
            "            return",
            "",
            "        spawn_future = spawner._spawn_future",
            "",
            "        if not spawner._spawn_pending:",
            "            # not pending, no progress to fetch",
            "            # check if spawner has just failed",
            "            f = spawn_future",
            "            if f and f.cancelled():",
            "                failed_event['message'] = \"Spawn cancelled\"",
            "            elif f and f.done() and f.exception():",
            "                exc = f.exception()",
            "                message = getattr(exc, \"jupyterhub_message\", str(exc))",
            "                failed_event['message'] = f\"Spawn failed: {message}\"",
            "                html_message = getattr(exc, \"jupyterhub_html_message\", \"\")",
            "                if html_message:",
            "                    failed_event['html_message'] = html_message",
            "                await self.send_event(failed_event)",
            "                return",
            "            else:",
            "                raise web.HTTPError(400, \"%s is not starting...\", spawner._log_name)",
            "",
            "        # retrieve progress events from the Spawner",
            "        async with aclosing(",
            "            iterate_until(spawn_future, spawner._generate_progress())",
            "        ) as events:",
            "            try:",
            "                async for event in events:",
            "                    # don't allow events to sneakily set the 'ready' flag",
            "                    if 'ready' in event:",
            "                        event.pop('ready', None)",
            "                    await self.send_event(event)",
            "            except asyncio.CancelledError:",
            "                pass",
            "",
            "        # progress finished, wait for spawn to actually resolve,",
            "        # in case progress finished early",
            "        # (ignore errors, which will be logged elsewhere)",
            "        await asyncio.wait([spawn_future])",
            "",
            "        # progress and spawn finished, check if spawn succeeded",
            "        if spawner.ready:",
            "            # spawner is ready, signal completion and redirect",
            "            self.log.info(\"Server %s is ready\", spawner._log_name)",
            "            ready_event = await get_ready_event()",
            "            await self.send_event(ready_event)",
            "        else:",
            "            # what happened? Maybe spawn failed?",
            "            f = spawn_future",
            "            if f and f.cancelled():",
            "                failed_event['message'] = \"Spawn cancelled\"",
            "            elif f and f.done() and f.exception():",
            "                exc = f.exception()",
            "                message = getattr(exc, \"jupyterhub_message\", str(exc))",
            "                failed_event['message'] = f\"Spawn failed: {message}\"",
            "                html_message = getattr(exc, \"jupyterhub_html_message\", \"\")",
            "                if html_message:",
            "                    failed_event['html_message'] = html_message",
            "            else:",
            "                self.log.warning(",
            "                    \"Server %s didn't start for unknown reason\", spawner._log_name",
            "                )",
            "            await self.send_event(failed_event)",
            "",
            "",
            "def _parse_timestamp(timestamp):",
            "    \"\"\"Parse and return a utc timestamp",
            "",
            "    - raise HTTPError(400) on parse error",
            "    - handle and strip tz info for internal consistency",
            "      (we use naive utc timestamps everywhere)",
            "    \"\"\"",
            "    try:",
            "        dt = parse_date(timestamp)",
            "    except Exception:",
            "        raise web.HTTPError(400, \"Not a valid timestamp: %r\", timestamp)",
            "    if dt.tzinfo:",
            "        # strip timezone info to naive UTC datetime",
            "        dt = dt.astimezone(timezone.utc).replace(tzinfo=None)",
            "",
            "    now = utcnow(with_tz=False)",
            "    if (dt - now) > timedelta(minutes=59):",
            "        raise web.HTTPError(",
            "            400,",
            "            f\"Rejecting activity from more than an hour in the future: {isoformat(dt)}\",",
            "        )",
            "    return dt",
            "",
            "",
            "class ActivityAPIHandler(APIHandler):",
            "    def _validate_servers(self, user, servers):",
            "        \"\"\"Validate servers dict argument",
            "",
            "        - types are correct",
            "        - each server exists",
            "        - last_activity fields are parsed into datetime objects",
            "        \"\"\"",
            "        msg = \"servers must be a dict of the form {server_name: {last_activity: timestamp}}\"",
            "        if not isinstance(servers, dict):",
            "            raise web.HTTPError(400, msg)",
            "",
            "        spawners = user.orm_spawners",
            "        for server_name, server_info in servers.items():",
            "            if server_name not in spawners:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"No such server '{server_name}' for user {user.name}\",",
            "                )",
            "            # check that each per-server field is a dict",
            "            if not isinstance(server_info, dict):",
            "                raise web.HTTPError(400, msg)",
            "            # check that last_activity is defined for each per-server dict",
            "            if 'last_activity' not in server_info:",
            "                raise web.HTTPError(400, msg)",
            "            # parse last_activity timestamps",
            "            # _parse_timestamp above is responsible for raising errors",
            "            server_info['last_activity'] = _parse_timestamp(",
            "                server_info['last_activity']",
            "            )",
            "        return servers",
            "",
            "    @needs_scope('users:activity')",
            "    def post(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # no such user",
            "            raise web.HTTPError(404, \"No such user: %r\", user_name)",
            "",
            "        body = self.get_json_body()",
            "        if not isinstance(body, dict):",
            "            raise web.HTTPError(400, \"body must be a json dict\")",
            "",
            "        last_activity_timestamp = body.get('last_activity')",
            "        servers = body.get('servers')",
            "        if not last_activity_timestamp and not servers:",
            "            raise web.HTTPError(",
            "                400, \"body must contain at least one of `last_activity` or `servers`\"",
            "            )",
            "",
            "        if servers:",
            "            # validate server args",
            "            servers = self._validate_servers(user, servers)",
            "            # at this point we know that the servers dict",
            "            # is valid and contains only servers that exist",
            "            # and last_activity is defined and a valid datetime object",
            "",
            "        # update user.last_activity if specified",
            "        if last_activity_timestamp:",
            "            last_activity = _parse_timestamp(last_activity_timestamp)",
            "            if (not user.last_activity) or last_activity > user.last_activity:",
            "                self.log.debug(",
            "                    \"Activity for user %s: %s\", user.name, isoformat(last_activity)",
            "                )",
            "                user.last_activity = last_activity",
            "            else:",
            "                self.log.debug(",
            "                    \"Not updating activity for %s: %s < %s\",",
            "                    user,",
            "                    isoformat(last_activity),",
            "                    isoformat(user.last_activity),",
            "                )",
            "",
            "        if servers:",
            "            for server_name, server_info in servers.items():",
            "                last_activity = server_info['last_activity']",
            "                spawner = user.orm_spawners[server_name]",
            "",
            "                if (not spawner.last_activity) or last_activity > spawner.last_activity:",
            "                    self.log.debug(",
            "                        \"Activity on server %s/%s: %s\",",
            "                        user.name,",
            "                        server_name,",
            "                        isoformat(last_activity),",
            "                    )",
            "                    spawner.last_activity = last_activity",
            "                else:",
            "                    self.log.debug(",
            "                        \"Not updating server activity on %s/%s: %s < %s\",",
            "                        user.name,",
            "                        server_name,",
            "                        isoformat(last_activity),",
            "                        isoformat(user.last_activity),",
            "                    )",
            "",
            "        self.db.commit()",
            "",
            "",
            "default_handlers = [",
            "    (r\"/api/user\", SelfAPIHandler),",
            "    (r\"/api/users\", UserListAPIHandler),",
            "    (r\"/api/users/([^/]+)\", UserAPIHandler),",
            "    (r\"/api/users/([^/]+)/server\", UserServerAPIHandler),",
            "    (r\"/api/users/([^/]+)/server/progress\", SpawnProgressAPIHandler),",
            "    (r\"/api/users/([^/]+)/tokens\", UserTokenListAPIHandler),",
            "    (r\"/api/users/([^/]+)/tokens/([^/]*)\", UserTokenAPIHandler),",
            "    (r\"/api/users/([^/]+)/servers/([^/]*)\", UserServerAPIHandler),",
            "    (r\"/api/users/([^/]+)/servers/([^/]*)/progress\", SpawnProgressAPIHandler),",
            "    (r\"/api/users/([^/]+)/activity\", ActivityAPIHandler),",
            "    (r\"/api/users/([^/]+)/admin-access\", UserAdminAccessAPIHandler),",
            "]"
        ],
        "afterPatchFile": [
            "\"\"\"User handlers\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import asyncio",
            "import inspect",
            "import json",
            "import sys",
            "from datetime import timedelta, timezone",
            "",
            "if sys.version_info >= (3, 10):",
            "    from contextlib import aclosing",
            "else:",
            "    from async_generator import aclosing",
            "",
            "from dateutil.parser import parse as parse_date",
            "from sqlalchemy import func, or_",
            "from sqlalchemy.orm import joinedload, raiseload, selectinload  # noqa",
            "from tornado import web",
            "from tornado.iostream import StreamClosedError",
            "",
            "from .. import orm, scopes",
            "from ..roles import assign_default_roles",
            "from ..scopes import needs_scope",
            "from ..user import User",
            "from ..utils import (",
            "    isoformat,",
            "    iterate_until,",
            "    maybe_future,",
            "    url_escape_path,",
            "    url_path_join,",
            "    utcnow,",
            ")",
            "from .base import APIHandler",
            "",
            "",
            "class SelfAPIHandler(APIHandler):",
            "    \"\"\"Return the authenticated user's model",
            "",
            "    Based on the authentication info. Acts as a 'whoami' for auth tokens.",
            "    \"\"\"",
            "",
            "    async def get(self):",
            "        user = self.current_user",
            "        if user is None:",
            "            raise web.HTTPError(403)",
            "",
            "        _added_scopes = set()",
            "        if isinstance(user, orm.Service):",
            "            # ensure we have the minimal 'identify' scopes for the token owner",
            "            identify_scopes = scopes.identify_scopes(user)",
            "            get_model = self.service_model",
            "        else:",
            "            identify_scopes = scopes.identify_scopes(user.orm_user)",
            "            get_model = self.user_model",
            "",
            "        # ensure we have permission to identify ourselves",
            "        # all tokens can do this on this endpoint",
            "        for scope in identify_scopes:",
            "            if scope not in self.expanded_scopes:",
            "                _added_scopes.add(scope)",
            "                self.expanded_scopes |= {scope}",
            "        if _added_scopes:",
            "            # re-parse with new scopes",
            "            self.parsed_scopes = scopes.parse_scopes(self.expanded_scopes)",
            "",
            "        model = get_model(user)",
            "",
            "        # add session_id associated with token",
            "        # added in 2.0",
            "        # token_id added in 5.0",
            "        token = self.get_token()",
            "        if token:",
            "            model[\"token_id\"] = token.api_id",
            "            model[\"session_id\"] = token.session_id",
            "        else:",
            "            model[\"token_id\"] = None",
            "            model[\"session_id\"] = None",
            "",
            "        # add scopes to identify model,",
            "        # but not the scopes we added to ensure we could read our own model",
            "        model[\"scopes\"] = sorted(self.expanded_scopes.difference(_added_scopes))",
            "        self.write(json.dumps(model))",
            "",
            "",
            "class UserListAPIHandler(APIHandler):",
            "    def _user_has_ready_spawner(self, orm_user):",
            "        \"\"\"Return True if a user has *any* ready spawners",
            "",
            "        Used for filtering from active -> ready",
            "        \"\"\"",
            "        user = self.users[orm_user]",
            "        return any(spawner.ready for spawner in user.spawners.values())",
            "",
            "    @needs_scope('list:users')",
            "    def get(self):",
            "        state_filter = self.get_argument(\"state\", None)",
            "        name_filter = self.get_argument(\"name_filter\", None)",
            "        sort = sort_by_param = self.get_argument(\"sort\", \"id\")",
            "        sort_direction = \"asc\"",
            "        if sort[:1] == '-':",
            "            sort_direction = \"desc\"",
            "            sort = sort[1:]",
            "",
            "        offset, limit = self.get_api_pagination()",
            "",
            "        if sort in {\"id\", \"name\", \"last_activity\"}:",
            "            sort_column = getattr(orm.User, sort)",
            "        else:",
            "            raise web.HTTPError(",
            "                400,",
            "                f\"sort must be 'id', 'name', or 'last_activity', not '{sort_by_param}'\",",
            "            )",
            "",
            "        # NULL is sorted inconsistently, so make it explicit",
            "        if sort_direction == \"asc\":",
            "            sort_order = (sort_column.is_not(None), sort_column.asc())",
            "        elif sort_direction == \"desc\":",
            "            sort_order = (sort_column.is_(None), sort_column.desc())",
            "        else:",
            "            # this can't happen, users don't specify direction",
            "            raise ValueError(",
            "                f\"sort_direction must be 'asc' or 'desc', got '{sort_direction}'\"",
            "            )",
            "",
            "        # post_filter",
            "        post_filter = None",
            "",
            "        # starting query",
            "        query = self.db.query(orm.User)",
            "",
            "        if state_filter in {\"active\", \"ready\"}:",
            "            # only get users with active servers",
            "            # an 'active' Spawner has a server record in the database",
            "            # which means Spawner.server != None",
            "            # it may still be in a pending start/stop state.",
            "            # join filters out users with no Spawners",
            "            query = (",
            "                query",
            "                # join filters out any Users with no Spawners",
            "                .join(orm.Spawner, orm.User._orm_spawners)",
            "                # this implicitly gets Users with *any* active server",
            "                .filter(orm.Spawner.server != None)",
            "                # group-by ensures the count is correct",
            "                .group_by(orm.User.id)",
            "            )",
            "            if state_filter == \"ready\":",
            "                # have to post-process query results because active vs ready",
            "                # can only be distinguished with in-memory Spawner properties",
            "                post_filter = self._user_has_ready_spawner",
            "",
            "        elif state_filter == \"inactive\":",
            "            # only get users with *no* active servers",
            "            # as opposed to users with *any inactive servers*",
            "            # this is the complement to the above query.",
            "            # how expensive is this with lots of servers?",
            "            query = (",
            "                query.outerjoin(orm.Spawner, orm.User._orm_spawners)",
            "                .outerjoin(orm.Server, orm.Spawner.server)",
            "                .group_by(orm.User.id)",
            "                .having(func.count(orm.Server.id) == 0)",
            "            )",
            "        elif state_filter:",
            "            raise web.HTTPError(400, f\"Unrecognized state filter: {state_filter!r}\")",
            "",
            "        # apply eager load options",
            "        query = query.options(",
            "            selectinload(orm.User.roles),",
            "            selectinload(orm.User.groups),",
            "            joinedload(orm.User._orm_spawners).joinedload(orm.Spawner.user),",
            "            # raiseload here helps us make sure we've loaded everything in one query",
            "            # but since we share a single db session, we can't do this for real",
            "            # but it's useful in testing",
            "            # raiseload(\"*\"),",
            "        )",
            "",
            "        sub_scope = self.parsed_scopes['list:users']",
            "        if sub_scope != scopes.Scope.ALL:",
            "            if not set(sub_scope).issubset({'group', 'user'}):",
            "                # don't expand invalid !server=x filter to all users!",
            "                self.log.warning(",
            "                    f\"Invalid filter on list:user for {self.current_user}: {sub_scope}\"",
            "                )",
            "                raise web.HTTPError(403)",
            "            filters = []",
            "            if 'user' in sub_scope:",
            "                filters.append(orm.User.name.in_(sub_scope['user']))",
            "            if 'group' in sub_scope:",
            "                filters.append(",
            "                    orm.User.groups.any(",
            "                        orm.Group.name.in_(sub_scope['group']),",
            "                    )",
            "                )",
            "",
            "            if len(filters) == 1:",
            "                query = query.filter(filters[0])",
            "            else:",
            "                query = query.filter(or_(*filters))",
            "",
            "        if name_filter:",
            "            query = query.filter(orm.User.name.ilike(f'%{name_filter}%'))",
            "",
            "        full_query = query",
            "        query = query.order_by(*sort_order).offset(offset).limit(limit)",
            "",
            "        user_list = []",
            "        for u in query:",
            "            if post_filter is None or post_filter(u):",
            "                user_model = self.user_model(u)",
            "                if user_model:",
            "                    user_list.append(user_model)",
            "",
            "        total_count = full_query.count()",
            "        if self.accepts_pagination:",
            "            data = self.paginated_model(user_list, offset, limit, total_count)",
            "        else:",
            "            query_count = query.count()",
            "            if offset == 0 and total_count > query_count:",
            "                self.log.warning(",
            "                    f\"Truncated user list in request that does not expect pagination. Processing {query_count} of {total_count} total users.\"",
            "                )",
            "            data = user_list",
            "",
            "        self.write(json.dumps(data))",
            "        # if testing with raiseload above, need expire_all to avoid affecting other operations",
            "        # self.db.expire_all()",
            "",
            "    @needs_scope('admin:users')",
            "    async def post(self):",
            "        data = self.get_json_body()",
            "        if not data or not isinstance(data, dict) or not data.get('usernames'):",
            "            raise web.HTTPError(400, \"Must specify at least one user to create\")",
            "",
            "        usernames = data.pop('usernames')",
            "        self._check_user_model(data)",
            "        # admin is set for all users",
            "        # to create admin and non-admin users requires at least two API requests",
            "        admin = data.get('admin', False)",
            "        if admin and not self.current_user.admin:",
            "            raise web.HTTPError(403, \"Only admins can grant admin permissions\")",
            "",
            "        to_create = []",
            "        invalid_names = []",
            "        for name in usernames:",
            "            name = self.authenticator.normalize_username(name)",
            "            if not self.authenticator.validate_username(name):",
            "                invalid_names.append(name)",
            "                continue",
            "            user = self.find_user(name)",
            "            if user is not None:",
            "                self.log.warning(f\"User {name} already exists\")",
            "            else:",
            "                to_create.append(name)",
            "",
            "        if invalid_names:",
            "            if len(invalid_names) == 1:",
            "                msg = f\"Invalid username: {invalid_names[0]}\"",
            "            else:",
            "                msg = \"Invalid usernames: {}\".format(', '.join(invalid_names))",
            "            raise web.HTTPError(400, msg)",
            "",
            "        if not to_create:",
            "            raise web.HTTPError(409, \"All %i users already exist\" % len(usernames))",
            "",
            "        created = []",
            "        for name in to_create:",
            "            user = self.user_from_username(name)",
            "            if admin:",
            "                user.admin = True",
            "            assign_default_roles(self.db, entity=user)",
            "            self.db.commit()",
            "            try:",
            "                await maybe_future(self.authenticator.add_user(user))",
            "            except Exception as e:",
            "                self.log.error(f\"Failed to create user: {name}\", exc_info=True)",
            "                self.users.delete(user)",
            "                raise web.HTTPError(400, f\"Failed to create user {name}: {e}\")",
            "            else:",
            "                created.append(user)",
            "",
            "        self.write(json.dumps([self.user_model(u) for u in created]))",
            "        self.set_status(201)",
            "",
            "",
            "class UserAPIHandler(APIHandler):",
            "    @needs_scope(",
            "        'read:users',",
            "        'read:users:name',",
            "        'read:servers',",
            "        'read:users:groups',",
            "        'read:users:activity',",
            "        'read:roles:users',",
            "    )",
            "    async def get(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        model = self.user_model(user)",
            "        # auth state will only be shown if the requester is an admin",
            "        # this means users can't see their own auth state unless they",
            "        # are admins, Hub admins often are also marked as admins so they",
            "        # will see their auth state but normal users won't",
            "        if 'auth_state' in model:",
            "            model['auth_state'] = await user.get_auth_state()",
            "        self.write(json.dumps(model))",
            "",
            "    @needs_scope('admin:users')",
            "    async def post(self, user_name):",
            "        data = self.get_json_body()",
            "        user = self.find_user(user_name)",
            "        if user is not None:",
            "            raise web.HTTPError(409, f\"User {user_name} already exists\")",
            "",
            "        if data:",
            "            self._check_user_model(data)",
            "            if data.get('admin', False) and not self.current_user.admin:",
            "                raise web.HTTPError(403, \"Only admins can grant admin permissions\")",
            "",
            "        # create the user",
            "        user = self.user_from_username(user_name)",
            "        if data and data.get('admin', False):",
            "            user.admin = data['admin']",
            "            assign_default_roles(self.db, entity=user)",
            "        self.db.commit()",
            "",
            "        try:",
            "            await maybe_future(self.authenticator.add_user(user))",
            "        except Exception:",
            "            self.log.error(f\"Failed to create user: {user_name}\", exc_info=True)",
            "            # remove from registry",
            "            self.users.delete(user)",
            "            raise web.HTTPError(400, f\"Failed to create user: {user_name}\")",
            "",
            "        self.write(json.dumps(self.user_model(user)))",
            "        self.set_status(201)",
            "",
            "    @needs_scope('delete:users')",
            "    async def delete(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        if user.name == self.current_user.name:",
            "            raise web.HTTPError(400, \"Cannot delete yourself!\")",
            "        if user.spawner._stop_pending:",
            "            raise web.HTTPError(",
            "                400,",
            "                f\"{user_name}'s server is in the process of stopping, please wait.\",",
            "            )",
            "        if user.running:",
            "            await self.stop_single_user(user)",
            "            if user.spawner._stop_pending:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"{user_name}'s server is in the process of stopping, please wait.\",",
            "                )",
            "",
            "        await maybe_future(self.authenticator.delete_user(user))",
            "",
            "        await user.delete_spawners()",
            "",
            "        # remove from registry",
            "        self.users.delete(user)",
            "",
            "        self.set_status(204)",
            "",
            "    @needs_scope('admin:users')",
            "    async def patch(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "        data = self.get_json_body()",
            "        self._check_user_model(data)",
            "        if 'name' in data and data['name'] != user_name:",
            "            # check if the new name is already taken inside db",
            "            if self.find_user(data['name']):",
            "                raise web.HTTPError(",
            "                    400,",
            "                    \"User {} already exists, username must be unique\".format(",
            "                        data['name']",
            "                    ),",
            "                )",
            "",
            "        if not self.current_user.admin:",
            "            if user.admin:",
            "                raise web.HTTPError(403, \"Only admins can modify other admins\")",
            "            if 'admin' in data and data['admin']:",
            "                raise web.HTTPError(403, \"Only admins can grant admin permissions\")",
            "        for key, value in data.items():",
            "            value_s = \"...\" if key == \"auth_state\" else repr(value)",
            "            self.log.info(",
            "                f\"{self.current_user.name} setting {key}={value_s} for {user.name}\"",
            "            )",
            "            if key == 'auth_state':",
            "                await user.save_auth_state(value)",
            "            else:",
            "                setattr(user, key, value)",
            "                if key == 'admin':",
            "                    assign_default_roles(self.db, entity=user)",
            "        self.db.commit()",
            "        user_ = self.user_model(user)",
            "        user_['auth_state'] = await user.get_auth_state()",
            "        self.write(json.dumps(user_))",
            "",
            "",
            "class UserTokenListAPIHandler(APIHandler):",
            "    \"\"\"API endpoint for listing/creating tokens\"\"\"",
            "",
            "    # defer check_xsrf_cookie so we can accept auth",
            "    # in the `auth` request field, which shouldn't require xsrf cookies",
            "    _skip_post_check_xsrf = True",
            "",
            "    def check_xsrf_cookie(self):",
            "        if self.request.method == 'POST' and self._skip_post_check_xsrf:",
            "            return",
            "        return super().check_xsrf_cookie()",
            "",
            "    @needs_scope('read:tokens')",
            "    def get(self, user_name):",
            "        \"\"\"Get tokens for a given user\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, f\"No such user: {user_name}\")",
            "",
            "        now = utcnow(with_tz=False)",
            "        api_tokens = []",
            "",
            "        def sort_key(token):",
            "            return token.last_activity or token.created",
            "",
            "        for token in sorted(user.api_tokens, key=sort_key):",
            "            if token.expires_at and token.expires_at < now:",
            "                # exclude expired tokens",
            "                self.db.delete(token)",
            "                self.db.commit()",
            "                continue",
            "            api_tokens.append(self.token_model(token))",
            "",
            "        self.write(json.dumps({'api_tokens': api_tokens}))",
            "",
            "    async def post(self, user_name):",
            "        body = self.get_json_body() or {}",
            "        if not isinstance(body, dict):",
            "            raise web.HTTPError(400, \"Body must be a JSON dict or empty\")",
            "",
            "        requester = self.current_user",
            "        if requester is None:",
            "            # defer to Authenticator for identifying the user",
            "            # can be username+password or an upstream auth token",
            "            try:",
            "                name = await self.authenticate(body.get('auth'))",
            "                if isinstance(name, dict):",
            "                    # not a simple string so it has to be a dict",
            "                    name = name.get('name')",
            "                # don't check xsrf if we've authenticated via the request body",
            "            except web.HTTPError as e:",
            "                # turn any authentication error into 403",
            "                raise web.HTTPError(403)",
            "            except Exception as e:",
            "                # suppress and log error here in case Authenticator",
            "                # isn't prepared to handle auth via this data",
            "                self.log.error(",
            "                    \"Error authenticating request for %s: %s\", self.request.uri, e",
            "                )",
            "                raise web.HTTPError(403)",
            "            if name is None:",
            "                raise web.HTTPError(403)",
            "            requester = self.find_user(name)",
            "        else:",
            "            # perform delayed xsrf check",
            "            # if we aren't authenticating via the request body",
            "            self._skip_post_check_xsrf = False",
            "            self.check_xsrf_cookie()",
            "        if requester is None:",
            "            # couldn't identify requester",
            "            raise web.HTTPError(403)",
            "        self._jupyterhub_user = requester",
            "        self._resolve_roles_and_scopes()",
            "        user = self.find_user(user_name)",
            "        kind = 'user' if isinstance(requester, User) else 'service'",
            "        scope_filter = self.get_scope_filter('tokens')",
            "        if user is None or not scope_filter(user, kind):",
            "            raise web.HTTPError(",
            "                403,",
            "                f\"{kind.title()} {user_name} not found or no permissions to generate tokens\",",
            "            )",
            "",
            "        note = body.get('note')",
            "        if not note:",
            "            note = \"Requested via api\"",
            "            if requester is not user:",
            "                note += f\" by {kind} {requester.name}\"",
            "",
            "        token_roles = body.get(\"roles\")",
            "        token_scopes = body.get(\"scopes\")",
            "",
            "        # check type of permissions",
            "        for key in (\"roles\", \"scopes\"):",
            "            value = body.get(key)",
            "            if value is None:",
            "                continue",
            "            if not isinstance(value, list) or not all(",
            "                isinstance(item, str) for item in value",
            "            ):",
            "                raise web.HTTPError(",
            "                    400, f\"token {key} must be null or a list of strings, not {value!r}\"",
            "                )",
            "",
            "        expires_in = body.get('expires_in', None)",
            "        if not (expires_in is None or isinstance(expires_in, int)):",
            "            raise web.HTTPError(",
            "                400,",
            "                f\"token expires_in must be null or integer, not {expires_in!r}\",",
            "            )",
            "        expires_in_max = self.settings[\"token_expires_in_max_seconds\"]",
            "        if expires_in_max:",
            "            # validate expires_in against limit",
            "            if expires_in is None:",
            "                # expiration unspecified, use max value",
            "                # (default before max limit was introduced was 'never', this is closest equivalent)",
            "                expires_in = expires_in_max",
            "            elif expires_in > expires_in_max:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"token expires_in: {expires_in} must not exceed {expires_in_max}\",",
            "                )",
            "",
            "        try:",
            "            api_token = user.new_api_token(",
            "                note=note,",
            "                expires_in=expires_in,",
            "                roles=token_roles,",
            "                scopes=token_scopes,",
            "            )",
            "        except (ValueError, KeyError) as e:",
            "            raise web.HTTPError(400, str(e))",
            "        if requester is not user:",
            "            self.log.info(",
            "                \"%s %s requested API token for %s\",",
            "                kind.title(),",
            "                requester.name,",
            "                user.name,",
            "            )",
            "        else:",
            "            user_kind = 'user' if isinstance(user, User) else 'service'",
            "            self.log.info(\"%s %s requested new API token\", user_kind.title(), user.name)",
            "        # retrieve the model",
            "        orm_token = orm.APIToken.find(self.db, api_token)",
            "        if orm_token is None:",
            "            self.log.error(",
            "                \"Failed to find token after creating it: %r. Maybe it expired already?\",",
            "                body,",
            "            )",
            "            raise web.HTTPError(500, \"Failed to create token\")",
            "        token_model = self.token_model(orm_token)",
            "        token_model['token'] = api_token",
            "        self.write(json.dumps(token_model))",
            "        self.set_status(201)",
            "",
            "",
            "class UserTokenAPIHandler(APIHandler):",
            "    \"\"\"API endpoint for retrieving/deleting individual tokens\"\"\"",
            "",
            "    def find_token_by_id(self, user, token_id):",
            "        \"\"\"Find a token object by token-id key",
            "",
            "        Raises 404 if not found for any reason",
            "        (e.g. wrong owner, invalid key format, etc.)",
            "        \"\"\"",
            "        not_found = f\"No such token {token_id} for user {user.name}\"",
            "        prefix, id_ = token_id[:1], token_id[1:]",
            "        if prefix != 'a':",
            "            raise web.HTTPError(404, not_found)",
            "        try:",
            "            id_ = int(id_)",
            "        except ValueError:",
            "            raise web.HTTPError(404, not_found)",
            "",
            "        orm_token = self.db.query(orm.APIToken).filter_by(id=id_).first()",
            "        if orm_token is None or orm_token.user is not user.orm_user:",
            "            raise web.HTTPError(404, not_found)",
            "        return orm_token",
            "",
            "    @needs_scope('read:tokens')",
            "    def get(self, user_name, token_id):",
            "        \"\"\"\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, f\"No such user: {user_name}\")",
            "        token = self.find_token_by_id(user, token_id)",
            "        self.write(json.dumps(self.token_model(token)))",
            "",
            "    @needs_scope('tokens')",
            "    def delete(self, user_name, token_id):",
            "        \"\"\"Delete a token\"\"\"",
            "        user = self.find_user(user_name)",
            "        if not user:",
            "            raise web.HTTPError(404, f\"No such user: {user_name}\")",
            "        token = self.find_token_by_id(user, token_id)",
            "        # deleting an oauth token deletes *all* oauth tokens for that client",
            "        client_id = token.client_id",
            "        if token.client_id != \"jupyterhub\":",
            "            tokens = [",
            "                token for token in user.api_tokens if token.client_id == client_id",
            "            ]",
            "            self.log.info(",
            "                f\"Deleting {len(tokens)} tokens for {user_name} issued by {token.client_id}\"",
            "            )",
            "        else:",
            "            self.log.info(f\"Deleting token {token_id} for {user_name}\")",
            "            tokens = [token]",
            "        for token in tokens:",
            "            self.db.delete(token)",
            "        self.db.commit()",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(204)",
            "",
            "",
            "class UserServerAPIHandler(APIHandler):",
            "    \"\"\"Start and stop single-user servers\"\"\"",
            "",
            "    @needs_scope('servers')",
            "    async def post(self, user_name, server_name=''):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # this can be reached if a token has `servers`",
            "            # permission on *all* users",
            "            raise web.HTTPError(404)",
            "",
            "        if server_name:",
            "            if not self.allow_named_servers:",
            "                raise web.HTTPError(400, \"Named servers are not enabled.\")",
            "",
            "            named_server_limit_per_user = (",
            "                await self.get_current_user_named_server_limit()",
            "            )",
            "",
            "            if named_server_limit_per_user > 0 and server_name not in user.orm_spawners:",
            "                named_spawners = list(user.all_spawners(include_default=False))",
            "                if named_server_limit_per_user <= len(named_spawners):",
            "                    raise web.HTTPError(",
            "                        400,",
            "                        f\"User {user_name} already has the maximum of {named_server_limit_per_user} named servers.\"",
            "                        \"  One must be deleted before a new server can be created\",",
            "                    )",
            "        spawner = user.get_spawner(server_name, replace_failed=True)",
            "        pending = spawner.pending",
            "        if pending == 'spawn':",
            "            self.set_header('Content-Type', 'text/plain')",
            "            self.set_status(202)",
            "            return",
            "        elif pending:",
            "            raise web.HTTPError(400, f\"{spawner._log_name} is pending {pending}\")",
            "",
            "        if spawner.ready:",
            "            # include notify, so that a server that died is noticed immediately",
            "            # set _spawn_pending flag to prevent races while we wait",
            "            spawner._spawn_pending = True",
            "            try:",
            "                state = await spawner.poll_and_notify()",
            "            finally:",
            "                spawner._spawn_pending = False",
            "            if state is None:",
            "                raise web.HTTPError(400, f\"{spawner._log_name} is already running\")",
            "",
            "        options = self.get_json_body()",
            "        await self.spawn_single_user(user, server_name, options=options)",
            "        status = 202 if spawner.pending == 'spawn' else 201",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(status)",
            "",
            "    @needs_scope('delete:servers')",
            "    async def delete(self, user_name, server_name=''):",
            "        user = self.find_user(user_name)",
            "        options = self.get_json_body()",
            "        remove = (options or {}).get('remove', False)",
            "",
            "        async def _remove_spawner(f=None):",
            "            \"\"\"Remove the spawner object",
            "",
            "            only called after it stops successfully",
            "            \"\"\"",
            "            if f:",
            "                # await f, stop on error,",
            "                # leaving resources in the db in case of failure to stop",
            "                await f",
            "            self.log.info(\"Deleting spawner %s\", spawner._log_name)",
            "            await maybe_future(user._delete_spawner(spawner))",
            "",
            "            self.db.delete(spawner.orm_spawner)",
            "            user.spawners.pop(server_name, None)",
            "            self.db.commit()",
            "",
            "        if server_name:",
            "            if not self.allow_named_servers:",
            "                raise web.HTTPError(400, \"Named servers are not enabled.\")",
            "            if server_name not in user.orm_spawners:",
            "                raise web.HTTPError(",
            "                    404, f\"{user_name} has no server named '{server_name}'\"",
            "                )",
            "        elif remove:",
            "            raise web.HTTPError(400, \"Cannot delete the default server\")",
            "",
            "        spawner = user.spawners[server_name]",
            "        if spawner.pending == 'stop':",
            "            self.log.debug(\"%s already stopping\", spawner._log_name)",
            "            self.set_header('Content-Type', 'text/plain')",
            "            self.set_status(202)",
            "            if remove:",
            "                # schedule remove when stop completes",
            "                asyncio.ensure_future(_remove_spawner(spawner._stop_future))",
            "            return",
            "",
            "        stop_future = None",
            "        if spawner.pending:",
            "            # we are interrupting a pending start",
            "            # hopefully nothing gets leftover",
            "            self.log.warning(",
            "                f\"Interrupting spawner {spawner._log_name}, pending {spawner.pending}\"",
            "            )",
            "            spawn_future = spawner._spawn_future",
            "            if spawn_future:",
            "                spawn_future.cancel()",
            "            # Give cancel a chance to resolve?",
            "            # not sure what we would wait for here,",
            "            await asyncio.sleep(1)",
            "            stop_future = await self.stop_single_user(user, server_name)",
            "",
            "        elif spawner.ready:",
            "            # include notify, so that a server that died is noticed immediately",
            "            status = await spawner.poll_and_notify()",
            "            if status is None:",
            "                stop_future = await self.stop_single_user(user, server_name)",
            "",
            "        if remove:",
            "            if stop_future:",
            "                # schedule remove when stop completes",
            "                asyncio.ensure_future(_remove_spawner(spawner._stop_future))",
            "            else:",
            "                await _remove_spawner()",
            "",
            "        status = 202 if spawner._stop_pending else 204",
            "        self.set_header('Content-Type', 'text/plain')",
            "        self.set_status(status)",
            "",
            "",
            "class UserAdminAccessAPIHandler(APIHandler):",
            "    \"\"\"Grant admins access to single-user servers",
            "",
            "    This handler sets the necessary cookie for an admin to login to a single-user server.",
            "    \"\"\"",
            "",
            "    @needs_scope('servers')",
            "    def post(self, user_name):",
            "        self.log.warning(",
            "            \"Deprecated in JupyterHub 0.8.\"",
            "            \" Admin access API is not needed now that we use OAuth.\"",
            "        )",
            "        current = self.current_user",
            "        self.log.warning(",
            "            \"Admin user %s has requested access to %s's server\", current.name, user_name",
            "        )",
            "        if not self.settings.get('admin_access', False):",
            "            raise web.HTTPError(403, \"admin access to user servers disabled\")",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            raise web.HTTPError(404)",
            "",
            "",
            "class SpawnProgressAPIHandler(APIHandler):",
            "    \"\"\"EventStream handler for pending spawns\"\"\"",
            "",
            "    keepalive_interval = 8",
            "",
            "    def get_content_type(self):",
            "        return 'text/event-stream'",
            "",
            "    async def send_event(self, event):",
            "        try:",
            "            self.write(f'data: {json.dumps(event)}\\n\\n')",
            "            await self.flush()",
            "        except StreamClosedError:",
            "            self.log.warning(\"Stream closed while handling %s\", self.request.uri)",
            "            # raise Finish to halt the handler",
            "            raise web.Finish()",
            "",
            "    def initialize(self):",
            "        super().initialize()",
            "        self._finish_future = asyncio.Future()",
            "",
            "    def on_finish(self):",
            "        self._finish_future.set_result(None)",
            "",
            "    async def keepalive(self):",
            "        \"\"\"Write empty lines periodically",
            "",
            "        to avoid being closed by intermediate proxies",
            "        when there's a large gap between events.",
            "        \"\"\"",
            "        while not self._finish_future.done():",
            "            try:",
            "                self.write(\"\\n\\n\")",
            "                await self.flush()",
            "            except (StreamClosedError, RuntimeError):",
            "                return",
            "",
            "            await asyncio.wait([self._finish_future], timeout=self.keepalive_interval)",
            "",
            "    @needs_scope('read:servers')",
            "    async def get(self, user_name, server_name=''):",
            "        self.set_header('Cache-Control', 'no-cache')",
            "        if server_name is None:",
            "            server_name = ''",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # no such user",
            "            raise web.HTTPError(404)",
            "        if server_name not in user.spawners:",
            "            # user has no such server",
            "            raise web.HTTPError(404)",
            "        spawner = user.spawners[server_name]",
            "",
            "        # start sending keepalive to avoid proxies closing the connection",
            "        asyncio.ensure_future(self.keepalive())",
            "        # cases:",
            "        # - spawner already started and ready",
            "        # - spawner not running at all",
            "        # - spawner failed",
            "        # - spawner pending start (what we expect)",
            "        failed_event = {'progress': 100, 'failed': True, 'message': \"Spawn failed\"}",
            "",
            "        async def get_ready_event():",
            "            url = url_path_join(user.url, url_escape_path(server_name), '/')",
            "            ready_event = {",
            "                'progress': 100,",
            "                'ready': True,",
            "                'message': f\"Server ready at {url}\",",
            "                'html_message': f'Server ready at <a href=\"{url}\">{url}</a>',",
            "                'url': url,",
            "            }",
            "            original_ready_event = ready_event.copy()",
            "            if spawner.progress_ready_hook:",
            "                try:",
            "                    ready_event = spawner.progress_ready_hook(spawner, ready_event)",
            "                    if inspect.isawaitable(ready_event):",
            "                        ready_event = await ready_event",
            "                except Exception as e:",
            "                    self.log.exception(f\"Error in ready_event hook: {e}\")",
            "                    ready_event = original_ready_event",
            "            return ready_event",
            "",
            "        if spawner.ready:",
            "            # spawner already ready. Trigger progress-completion immediately",
            "            self.log.info(\"Server %s is already started\", spawner._log_name)",
            "            ready_event = await get_ready_event()",
            "            await self.send_event(ready_event)",
            "            return",
            "",
            "        spawn_future = spawner._spawn_future",
            "",
            "        if not spawner._spawn_pending:",
            "            # not pending, no progress to fetch",
            "            # check if spawner has just failed",
            "            f = spawn_future",
            "            if f and f.cancelled():",
            "                failed_event['message'] = \"Spawn cancelled\"",
            "            elif f and f.done() and f.exception():",
            "                exc = f.exception()",
            "                message = getattr(exc, \"jupyterhub_message\", str(exc))",
            "                failed_event['message'] = f\"Spawn failed: {message}\"",
            "                html_message = getattr(exc, \"jupyterhub_html_message\", \"\")",
            "                if html_message:",
            "                    failed_event['html_message'] = html_message",
            "                await self.send_event(failed_event)",
            "                return",
            "            else:",
            "                raise web.HTTPError(400, \"%s is not starting...\", spawner._log_name)",
            "",
            "        # retrieve progress events from the Spawner",
            "        async with aclosing(",
            "            iterate_until(spawn_future, spawner._generate_progress())",
            "        ) as events:",
            "            try:",
            "                async for event in events:",
            "                    # don't allow events to sneakily set the 'ready' flag",
            "                    if 'ready' in event:",
            "                        event.pop('ready', None)",
            "                    await self.send_event(event)",
            "            except asyncio.CancelledError:",
            "                pass",
            "",
            "        # progress finished, wait for spawn to actually resolve,",
            "        # in case progress finished early",
            "        # (ignore errors, which will be logged elsewhere)",
            "        await asyncio.wait([spawn_future])",
            "",
            "        # progress and spawn finished, check if spawn succeeded",
            "        if spawner.ready:",
            "            # spawner is ready, signal completion and redirect",
            "            self.log.info(\"Server %s is ready\", spawner._log_name)",
            "            ready_event = await get_ready_event()",
            "            await self.send_event(ready_event)",
            "        else:",
            "            # what happened? Maybe spawn failed?",
            "            f = spawn_future",
            "            if f and f.cancelled():",
            "                failed_event['message'] = \"Spawn cancelled\"",
            "            elif f and f.done() and f.exception():",
            "                exc = f.exception()",
            "                message = getattr(exc, \"jupyterhub_message\", str(exc))",
            "                failed_event['message'] = f\"Spawn failed: {message}\"",
            "                html_message = getattr(exc, \"jupyterhub_html_message\", \"\")",
            "                if html_message:",
            "                    failed_event['html_message'] = html_message",
            "            else:",
            "                self.log.warning(",
            "                    \"Server %s didn't start for unknown reason\", spawner._log_name",
            "                )",
            "            await self.send_event(failed_event)",
            "",
            "",
            "def _parse_timestamp(timestamp):",
            "    \"\"\"Parse and return a utc timestamp",
            "",
            "    - raise HTTPError(400) on parse error",
            "    - handle and strip tz info for internal consistency",
            "      (we use naive utc timestamps everywhere)",
            "    \"\"\"",
            "    try:",
            "        dt = parse_date(timestamp)",
            "    except Exception:",
            "        raise web.HTTPError(400, \"Not a valid timestamp: %r\", timestamp)",
            "    if dt.tzinfo:",
            "        # strip timezone info to naive UTC datetime",
            "        dt = dt.astimezone(timezone.utc).replace(tzinfo=None)",
            "",
            "    now = utcnow(with_tz=False)",
            "    if (dt - now) > timedelta(minutes=59):",
            "        raise web.HTTPError(",
            "            400,",
            "            f\"Rejecting activity from more than an hour in the future: {isoformat(dt)}\",",
            "        )",
            "    return dt",
            "",
            "",
            "class ActivityAPIHandler(APIHandler):",
            "    def _validate_servers(self, user, servers):",
            "        \"\"\"Validate servers dict argument",
            "",
            "        - types are correct",
            "        - each server exists",
            "        - last_activity fields are parsed into datetime objects",
            "        \"\"\"",
            "        msg = \"servers must be a dict of the form {server_name: {last_activity: timestamp}}\"",
            "        if not isinstance(servers, dict):",
            "            raise web.HTTPError(400, msg)",
            "",
            "        spawners = user.orm_spawners",
            "        for server_name, server_info in servers.items():",
            "            if server_name not in spawners:",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"No such server '{server_name}' for user {user.name}\",",
            "                )",
            "            # check that each per-server field is a dict",
            "            if not isinstance(server_info, dict):",
            "                raise web.HTTPError(400, msg)",
            "            # check that last_activity is defined for each per-server dict",
            "            if 'last_activity' not in server_info:",
            "                raise web.HTTPError(400, msg)",
            "            # parse last_activity timestamps",
            "            # _parse_timestamp above is responsible for raising errors",
            "            server_info['last_activity'] = _parse_timestamp(",
            "                server_info['last_activity']",
            "            )",
            "        return servers",
            "",
            "    @needs_scope('users:activity')",
            "    def post(self, user_name):",
            "        user = self.find_user(user_name)",
            "        if user is None:",
            "            # no such user",
            "            raise web.HTTPError(404, \"No such user: %r\", user_name)",
            "",
            "        body = self.get_json_body()",
            "        if not isinstance(body, dict):",
            "            raise web.HTTPError(400, \"body must be a json dict\")",
            "",
            "        last_activity_timestamp = body.get('last_activity')",
            "        servers = body.get('servers')",
            "        if not last_activity_timestamp and not servers:",
            "            raise web.HTTPError(",
            "                400, \"body must contain at least one of `last_activity` or `servers`\"",
            "            )",
            "",
            "        if servers:",
            "            # validate server args",
            "            servers = self._validate_servers(user, servers)",
            "            # at this point we know that the servers dict",
            "            # is valid and contains only servers that exist",
            "            # and last_activity is defined and a valid datetime object",
            "",
            "        # update user.last_activity if specified",
            "        if last_activity_timestamp:",
            "            last_activity = _parse_timestamp(last_activity_timestamp)",
            "            if (not user.last_activity) or last_activity > user.last_activity:",
            "                self.log.debug(",
            "                    \"Activity for user %s: %s\", user.name, isoformat(last_activity)",
            "                )",
            "                user.last_activity = last_activity",
            "            else:",
            "                self.log.debug(",
            "                    \"Not updating activity for %s: %s < %s\",",
            "                    user,",
            "                    isoformat(last_activity),",
            "                    isoformat(user.last_activity),",
            "                )",
            "",
            "        if servers:",
            "            for server_name, server_info in servers.items():",
            "                last_activity = server_info['last_activity']",
            "                spawner = user.orm_spawners[server_name]",
            "",
            "                if (not spawner.last_activity) or last_activity > spawner.last_activity:",
            "                    self.log.debug(",
            "                        \"Activity on server %s/%s: %s\",",
            "                        user.name,",
            "                        server_name,",
            "                        isoformat(last_activity),",
            "                    )",
            "                    spawner.last_activity = last_activity",
            "                else:",
            "                    self.log.debug(",
            "                        \"Not updating server activity on %s/%s: %s < %s\",",
            "                        user.name,",
            "                        server_name,",
            "                        isoformat(last_activity),",
            "                        isoformat(user.last_activity),",
            "                    )",
            "",
            "        self.db.commit()",
            "",
            "",
            "default_handlers = [",
            "    (r\"/api/user\", SelfAPIHandler),",
            "    (r\"/api/users\", UserListAPIHandler),",
            "    (r\"/api/users/([^/]+)\", UserAPIHandler),",
            "    (r\"/api/users/([^/]+)/server\", UserServerAPIHandler),",
            "    (r\"/api/users/([^/]+)/server/progress\", SpawnProgressAPIHandler),",
            "    (r\"/api/users/([^/]+)/tokens\", UserTokenListAPIHandler),",
            "    (r\"/api/users/([^/]+)/tokens/([^/]*)\", UserTokenAPIHandler),",
            "    (r\"/api/users/([^/]+)/servers/([^/]*)\", UserServerAPIHandler),",
            "    (r\"/api/users/([^/]+)/servers/([^/]*)/progress\", SpawnProgressAPIHandler),",
            "    (r\"/api/users/([^/]+)/activity\", ActivityAPIHandler),",
            "    (r\"/api/users/([^/]+)/admin-access\", UserAdminAccessAPIHandler),",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "225": [
                "UserListAPIHandler"
            ],
            "312": [
                "UserAPIHandler"
            ],
            "315": [
                "UserAPIHandler"
            ],
            "316": [
                "UserAPIHandler"
            ],
            "317": [
                "UserAPIHandler"
            ]
        },
        "addLocation": []
    },
    "jupyterhub/scopes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         'doc_description': 'Access the admin page. Permission to take actions via the admin page granted separately.',"
            },
            "1": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     },"
            },
            "2": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     'admin:users': {"
            },
            "3": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'description': 'Read, write, create and delete users and their authentication state, not including their servers or tokens.',"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        'description': 'Read, modify, create, and delete users and their authentication state, not including their servers or tokens. This is an extremely privileged scope and should be considered tantamount to superuser.',"
            },
            "5": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         'subscopes': ['admin:auth_state', 'users', 'read:roles:users', 'delete:users'],"
            },
            "6": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     },"
            },
            "7": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     'admin:auth_state': {'description': 'Read a user\u2019s authentication state.'},"
            },
            "8": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         'subscopes': ['groups', 'read:roles:groups', 'delete:groups'],"
            },
            "9": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "     },"
            },
            "10": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "     'groups': {"
            },
            "11": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'description': 'Read and write group information, including adding/removing users to/from groups.',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        'description': 'Read and write group information, including adding/removing users to/from groups. Note: adding users to groups is a way of granting permissions to users of the group,and may grant _access_ to users of other groups.',"
            },
            "13": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         'subscopes': ['read:groups', 'list:groups'],"
            },
            "14": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "     },"
            },
            "15": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "     'list:groups': {"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "General scope definitions and utilities",
            "",
            "Scope functions generally return _immutable_ collections,",
            "such as `frozenset` to avoid mutating cached values.",
            "If needed, mutable copies can be made, e.g. `set(frozen_scopes)`",
            "",
            "Scope variable nomenclature",
            "---------------------------",
            "scopes or 'raw' scopes: collection of scopes that may contain abbreviations (e.g., in role definition)",
            "expanded scopes: set of expanded scopes without abbreviations (i.e., resolved metascopes, filters, and subscopes)",
            "parsed scopes: dictionary format of expanded scopes (`read:users!user=name` -> `{'read:users': {user: [name]}`)",
            "intersection : set of expanded scopes as intersection of 2 expanded scope sets",
            "identify scopes: set of expanded scopes needed for identify (whoami) endpoints",
            "reduced scopes: expanded scopes that have been reduced",
            "\"\"\"",
            "",
            "import functools",
            "import inspect",
            "import re",
            "import warnings",
            "from enum import Enum",
            "from functools import lru_cache",
            "from itertools import chain",
            "from textwrap import indent",
            "",
            "import sqlalchemy as sa",
            "from tornado import web",
            "from tornado.log import app_log",
            "",
            "from . import orm, roles",
            "from ._memoize import DoNotCache, FrozenDict, lru_cache_key",
            "",
            "\"\"\"when modifying the scope definitions, make sure that `docs/source/rbac/generate-scope-table.py` is run",
            "   so that changes are reflected in the documentation and REST API description.\"\"\"",
            "scope_definitions = {",
            "    '(no_scope)': {'description': 'Identify the owner of the requesting entity.'},",
            "    'self': {",
            "        'description': 'Your own resources',",
            "        'doc_description': 'The user\u2019s own resources _(metascope for users, resolves to (no_scope) for services)_',",
            "    },",
            "    'inherit': {",
            "        'description': 'Anything you have access to',",
            "        'doc_description': 'Everything that the token-owning entity can access _(metascope for tokens)_',",
            "    },",
            "    'admin-ui': {",
            "        'description': 'Access the admin page.',",
            "        'doc_description': 'Access the admin page. Permission to take actions via the admin page granted separately.',",
            "    },",
            "    'admin:users': {",
            "        'description': 'Read, write, create and delete users and their authentication state, not including their servers or tokens.',",
            "        'subscopes': ['admin:auth_state', 'users', 'read:roles:users', 'delete:users'],",
            "    },",
            "    'admin:auth_state': {'description': 'Read a user\u2019s authentication state.'},",
            "    'users': {",
            "        'description': 'Read and write permissions to user models (excluding servers, tokens and authentication state).',",
            "        'subscopes': ['read:users', 'list:users', 'users:activity'],",
            "    },",
            "    'delete:users': {",
            "        'description': \"Delete users.\",",
            "    },",
            "    'list:users': {",
            "        'description': 'List users, including at least their names.',",
            "        'subscopes': ['read:users:name'],",
            "    },",
            "    'read:users': {",
            "        'description': 'Read user models (including servers, tokens and authentication state).',",
            "        'subscopes': [",
            "            'read:users:name',",
            "            'read:users:groups',",
            "            'read:users:activity',",
            "        ],",
            "    },",
            "    'read:users:name': {'description': 'Read names of users.'},",
            "    'read:users:groups': {'description': 'Read users\u2019 group membership.'},",
            "    'read:users:activity': {'description': 'Read time of last user activity.'},",
            "    'read:roles': {",
            "        'description': 'Read role assignments.',",
            "        'subscopes': ['read:roles:users', 'read:roles:services', 'read:roles:groups'],",
            "    },",
            "    'read:roles:users': {'description': 'Read user role assignments.'},",
            "    'read:roles:services': {'description': 'Read service role assignments.'},",
            "    'read:roles:groups': {'description': 'Read group role assignments.'},",
            "    'users:activity': {",
            "        'description': 'Update time of last user activity.',",
            "        'subscopes': ['read:users:activity'],",
            "    },",
            "    'admin:servers': {",
            "        'description': 'Read, start, stop, create and delete user servers and their state.',",
            "        'subscopes': ['admin:server_state', 'servers'],",
            "    },",
            "    'admin:server_state': {'description': 'Read and write users\u2019 server state.'},",
            "    'servers': {",
            "        'description': 'Start and stop user servers.',",
            "        'subscopes': ['read:servers', 'delete:servers'],",
            "    },",
            "    'read:servers': {",
            "        'description': 'Read users\u2019 names and their server models (excluding the server state).',",
            "        'subscopes': ['read:users:name'],",
            "    },",
            "    'delete:servers': {'description': \"Stop and delete users' servers.\"},",
            "    'tokens': {",
            "        'description': 'Read, write, create and delete user tokens.',",
            "        'subscopes': ['read:tokens'],",
            "    },",
            "    'read:tokens': {'description': 'Read user tokens.'},",
            "    'admin:groups': {",
            "        'description': 'Read and write group information, create and delete groups.',",
            "        'subscopes': ['groups', 'read:roles:groups', 'delete:groups'],",
            "    },",
            "    'groups': {",
            "        'description': 'Read and write group information, including adding/removing users to/from groups.',",
            "        'subscopes': ['read:groups', 'list:groups'],",
            "    },",
            "    'list:groups': {",
            "        'description': 'List groups, including at least their names.',",
            "        'subscopes': ['read:groups:name'],",
            "    },",
            "    'read:groups': {",
            "        'description': 'Read group models.',",
            "        'subscopes': ['read:groups:name'],",
            "    },",
            "    'read:groups:name': {'description': 'Read group names.'},",
            "    'delete:groups': {",
            "        'description': \"Delete groups.\",",
            "    },",
            "    'admin:services': {",
            "        'description': 'Create, read, update, delete services, not including services defined from config files.',",
            "        'subscopes': ['list:services', 'read:services', 'read:roles:services'],",
            "    },",
            "    'list:services': {",
            "        'description': 'List services, including at least their names.',",
            "        'subscopes': ['read:services:name'],",
            "    },",
            "    'read:services': {",
            "        'description': 'Read service models.',",
            "        'subscopes': ['read:services:name'],",
            "    },",
            "    'read:services:name': {'description': 'Read service names.'},",
            "    'read:hub': {'description': 'Read detailed information about the Hub.'},",
            "    'access:servers': {",
            "        'description': 'Access user servers via API or browser.',",
            "    },",
            "    'access:services': {",
            "        'description': 'Access services via API or browser.',",
            "    },",
            "    'users:shares': {",
            "        'description': \"Read and revoke a user's access to shared servers.\",",
            "        'subscopes': [",
            "            'read:users:shares',",
            "        ],",
            "    },",
            "    'read:users:shares': {",
            "        'description': \"Read servers shared with a user.\",",
            "    },",
            "    'groups:shares': {",
            "        'description': \"Read and revoke a group's access to shared servers.\",",
            "        'subscopes': [",
            "            'read:groups:shares',",
            "        ],",
            "    },",
            "    'read:groups:shares': {",
            "        'description': \"Read servers shared with a group.\",",
            "    },",
            "    'read:shares': {",
            "        'description': \"Read information about shared access to servers.\",",
            "    },",
            "    'shares': {",
            "        'description': \"Manage access to shared servers.\",",
            "        'subscopes': [",
            "            'access:servers',",
            "            'read:shares',",
            "            'users:shares',",
            "            'groups:shares',",
            "        ],",
            "    },",
            "    'proxy': {",
            "        'description': 'Read information about the proxy\u2019s routing table, sync the Hub with the proxy and notify the Hub about a new proxy.'",
            "    },",
            "    'shutdown': {'description': 'Shutdown the hub.'},",
            "    'read:metrics': {",
            "        'description': \"Read prometheus metrics.\",",
            "    },",
            "}",
            "",
            "",
            "class Scope(Enum):",
            "    ALL = True",
            "",
            "",
            "def _intersection_cache_key(scopes_a, scopes_b, db=None):",
            "    \"\"\"Cache key function for scope intersections\"\"\"",
            "    return (frozenset(scopes_a), frozenset(scopes_b))",
            "",
            "",
            "@lru_cache_key(_intersection_cache_key)",
            "def _intersect_expanded_scopes(scopes_a, scopes_b, db=None):",
            "    \"\"\"Intersect two sets of scopes by comparing their permissions",
            "",
            "    Arguments:",
            "      scopes_a, scopes_b: sets of expanded scopes",
            "      db (optional): db connection for resolving group membership",
            "",
            "    Returns:",
            "      intersection: set of expanded scopes as intersection of the arguments",
            "",
            "    If db is given, group membership will be accounted for in intersections,",
            "    Otherwise, it can result in lower than intended permissions,",
            "          (i.e. users!group=x & users!user=y will be empty, even if user y is in group x.)",
            "    \"\"\"",
            "    scopes_a = frozenset(scopes_a)",
            "    scopes_b = frozenset(scopes_b)",
            "",
            "    # cached lookups for group membership of users and servers",
            "    @lru_cache",
            "    def groups_for_user(username):",
            "        \"\"\"Get set of group names for a given username\"\"\"",
            "        # if we need a group lookup, the result is not cacheable",
            "        nonlocal needs_db",
            "        needs_db = True",
            "        group_query = (",
            "            db.query(orm.Group.name)",
            "            .join(orm.User.groups)",
            "            .filter(orm.User.name == username)",
            "        )",
            "        return {row[0] for row in group_query}",
            "",
            "    @lru_cache",
            "    def groups_for_server(server):",
            "        \"\"\"Get set of group names for a given server\"\"\"",
            "        username, _, servername = server.partition(\"/\")",
            "        return groups_for_user(username)",
            "",
            "    parsed_scopes_a = parse_scopes(scopes_a)",
            "    parsed_scopes_b = parse_scopes(scopes_b)",
            "",
            "    # track whether we need a db lookup (for groups)",
            "    # because we can't cache the intersection if we do",
            "    # if there are no group filters, this is cacheable",
            "    needs_db = False",
            "",
            "    common_bases = parsed_scopes_a.keys() & parsed_scopes_b.keys()",
            "",
            "    common_filters = {}",
            "    warned = False",
            "    for base in common_bases:",
            "        filters_a = parsed_scopes_a[base]",
            "        filters_b = parsed_scopes_b[base]",
            "        if filters_a == Scope.ALL:",
            "            common_filters[base] = filters_b",
            "        elif filters_b == Scope.ALL:",
            "            common_filters[base] = filters_a",
            "        else:",
            "            common_entities = filters_a.keys() & filters_b.keys()",
            "            all_entities = filters_a.keys() | filters_b.keys()",
            "",
            "            # if we don't have a db session, we can't check group membership",
            "            # warn *if* there are non-overlapping user= and group= filters that we can't check",
            "            if (",
            "                db is None",
            "                and not warned",
            "                and 'group' in all_entities",
            "                and ('user' in all_entities or 'server' in all_entities)",
            "            ):",
            "                # this could resolve wrong if there's a user or server only on one side and a group only on the other",
            "                # check both directions: A has group X not in B group list AND B has user Y not in A user list",
            "                for a, b in [(filters_a, filters_b), (filters_b, filters_a)]:",
            "                    for b_key in ('user', 'server'):",
            "                        if (",
            "                            not warned",
            "                            and \"group\" in a",
            "                            and b_key in b",
            "                            and a[\"group\"].difference(b.get(\"group\", []))",
            "                            and b[b_key].difference(a.get(b_key, []))",
            "                        ):",
            "                            warnings.warn(",
            "                                f\"{base}[!{b_key}={b[b_key]}, !group={a['group']}] combinations of filters present,\"",
            "                                \" without db access. Intersection between not considered.\"",
            "                                \" May result in lower than intended permissions.\",",
            "                                UserWarning,",
            "                            )",
            "                            warned = True",
            "                            needs_db = True",
            "",
            "            common_filters[base] = {",
            "                entity: filters_a[entity] & filters_b[entity]",
            "                for entity in common_entities",
            "            }",
            "",
            "            # resolve hierarchies (group/user/server) in both directions",
            "            common_servers = initial_common_servers = common_filters[base].get(",
            "                \"server\", frozenset()",
            "            )",
            "            common_users = initial_common_users = common_filters[base].get(",
            "                \"user\", frozenset()",
            "            )",
            "",
            "            for a, b in [(filters_a, filters_b), (filters_b, filters_a)]:",
            "                if 'server' in a and b.get('server') != a['server']:",
            "                    # skip already-added servers (includes overlapping servers)",
            "                    servers = a['server'].difference(common_servers)",
            "",
            "                    # resolve user/server hierarchy",
            "                    if servers and 'user' in b:",
            "                        for server in servers:",
            "                            username, _, servername = server.partition(\"/\")",
            "                            if username in b['user']:",
            "                                common_servers = common_servers | {server}",
            "",
            "                    # resolve group/server hierarchy if db available",
            "                    servers = servers.difference(common_servers)",
            "                    if db is not None and servers and 'group' in b:",
            "                        needs_db = True",
            "                        for server in servers:",
            "                            server_groups = groups_for_server(server)",
            "                            if server_groups & b['group']:",
            "                                common_servers = common_servers | {server}",
            "",
            "                # resolve group/user hierarchy if db available and user sets aren't identical",
            "                if (",
            "                    db is not None",
            "                    and 'user' in a",
            "                    and 'group' in b",
            "                    and b.get('user') != a['user']",
            "                ):",
            "                    # skip already-added users (includes overlapping users)",
            "                    users = a['user'].difference(common_users)",
            "                    for username in users:",
            "                        groups = groups_for_user(username)",
            "                        if groups & b[\"group\"]:",
            "                            common_users = common_users | {username}",
            "",
            "            # add server filter if it's non-empty",
            "            # and it changed",
            "            if common_servers and common_servers != initial_common_servers:",
            "                common_filters[base][\"server\"] = common_servers",
            "",
            "            # add user filter if it's non-empty",
            "            # and it changed",
            "            if common_users and common_users != initial_common_users:",
            "                common_filters[base][\"user\"] = common_users",
            "",
            "    intersection = unparse_scopes(common_filters)",
            "    if needs_db:",
            "        # return intersection, but don't cache it if it needed db lookups",
            "        return DoNotCache(intersection)",
            "",
            "    return intersection",
            "",
            "",
            "def get_scopes_for(orm_object):",
            "    \"\"\"Find scopes for a given user or token from their roles and resolve permissions",
            "",
            "    Arguments:",
            "      orm_object: orm object or User wrapper",
            "",
            "    Returns:",
            "      expanded scopes (set) for the orm object",
            "      or",
            "      intersection (set) if orm_object == orm.APIToken",
            "    \"\"\"",
            "    expanded_scopes = set()",
            "    if orm_object is None:",
            "        return expanded_scopes",
            "",
            "    if not isinstance(orm_object, orm.Base):",
            "        from .user import User",
            "",
            "        if isinstance(orm_object, User):",
            "            orm_object = orm_object.orm_user",
            "        else:",
            "            raise TypeError(",
            "                f\"Only allow orm objects or User wrappers, got {orm_object}\"",
            "            )",
            "",
            "    owner = None",
            "    if isinstance(orm_object, orm.APIToken):",
            "        owner = orm_object.user or orm_object.service",
            "        owner_roles = roles.get_roles_for(owner)",
            "        owner_scopes = roles.roles_to_expanded_scopes(owner_roles, owner)",
            "        if owner is orm_object.user:",
            "            for share in owner.shared_with_me:",
            "                owner_scopes |= frozenset(share.scopes)",
            "",
            "        token_scopes = set(orm_object.scopes)",
            "        if 'inherit' in token_scopes:",
            "            # token_scopes includes 'inherit',",
            "            # so we know the intersection is exactly the owner's scopes",
            "            # only thing we miss by short-circuiting here: warning about excluded extra scopes",
            "            return owner_scopes",
            "",
            "        token_scopes = set(",
            "            expand_scopes(",
            "                token_scopes,",
            "                owner=owner,",
            "                oauth_client=orm_object.oauth_client,",
            "            )",
            "        )",
            "",
            "        if orm_object.client_id != \"jupyterhub\":",
            "            # oauth tokens can be used to access the service issuing the token,",
            "            # assuming the owner itself still has permission to do so",
            "            token_scopes.update(access_scopes(orm_object.oauth_client))",
            "",
            "        # reduce to collapse multiple filters on the same scope",
            "        # to avoid spurious logs about discarded scopes",
            "        token_scopes.update(identify_scopes(owner))",
            "        token_scopes = reduce_scopes(token_scopes)",
            "",
            "        intersection = _intersect_expanded_scopes(",
            "            token_scopes,",
            "            owner_scopes,",
            "            db=sa.inspect(orm_object).session,",
            "        )",
            "        discarded_token_scopes = token_scopes - intersection",
            "",
            "        # Not taking symmetric difference here because token owner can naturally have more scopes than token",
            "        if discarded_token_scopes:",
            "            app_log.warning(",
            "                f\"discarding scopes [{discarded_token_scopes}],\"",
            "                f\" not present in roles of owner {owner}\"",
            "            )",
            "            app_log.debug(",
            "                \"Owner %s has scopes: %s\\nToken has scopes: %s\",",
            "                owner,",
            "                owner_scopes,",
            "                token_scopes,",
            "            )",
            "        expanded_scopes = intersection",
            "        # always include identify scopes",
            "        expanded_scopes",
            "    else:",
            "        expanded_scopes = roles.roles_to_expanded_scopes(",
            "            roles.get_roles_for(orm_object),",
            "            owner=orm_object,",
            "        )",
            "",
            "        # add permissions granted from 'shares'",
            "        if hasattr(orm_object, \"shared_with_me\"):",
            "            for share in orm_object.shared_with_me:",
            "                expanded_scopes |= expand_share_scopes(share)",
            "        if isinstance(orm_object, orm.User):",
            "            for group in orm_object.groups:",
            "                for share in group.shared_with_me:",
            "                    expanded_scopes |= expand_share_scopes(share)",
            "",
            "    return expanded_scopes",
            "",
            "",
            "def expand_share_scopes(share):",
            "    \"\"\"Get expanded scopes for a Share\"\"\"",
            "    return expand_scopes(",
            "        share.scopes,",
            "        owner=share.user or share.group,",
            "        oauth_client=share.spawner.oauth_client,",
            "    )",
            "",
            "",
            "@lru_cache",
            "def _expand_self_scope(username):",
            "    \"\"\"",
            "    Users have a metascope 'self' that should be expanded to standard user privileges.",
            "    At the moment that is a user-filtered version (optional read) access to",
            "    users",
            "    users:name",
            "    users:groups",
            "    users:activity",
            "    tokens",
            "    servers",
            "    access:servers",
            "",
            "",
            "    Arguments:",
            "      username (str): user name",
            "",
            "    Returns:",
            "      expanded scopes (set): set of expanded scopes covering standard user privileges",
            "    \"\"\"",
            "    scope_list = [",
            "        'read:users',",
            "        'read:users:name',",
            "        'read:users:groups',",
            "        'users:shares',",
            "        'read:users:shares',",
            "        'read:shares',",
            "        'users:activity',",
            "        'read:users:activity',",
            "        'servers',",
            "        'delete:servers',",
            "        'read:servers',",
            "        'tokens',",
            "        'read:tokens',",
            "        'access:servers',",
            "    ]",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(f\"{scope}!user={username}\" for scope in scope_list)",
            "",
            "",
            "@lru_cache(maxsize=65535)",
            "def _expand_scope(scope):",
            "    \"\"\"Returns a scope and all subscopes",
            "",
            "    Arguments:",
            "      scope (str): the scope to expand",
            "",
            "    Returns:",
            "      expanded scope (set): set of all scope's subscopes including the scope itself",
            "    \"\"\"",
            "",
            "    # remove filter, save for later",
            "    scope_name, sep, filter_ = scope.partition('!')",
            "",
            "    # expand scope and subscopes",
            "    expanded_scope_names = set()",
            "",
            "    def _add_subscopes(scope_name):",
            "        expanded_scope_names.add(scope_name)",
            "        if scope_definitions[scope_name].get('subscopes'):",
            "            for subscope in scope_definitions[scope_name].get('subscopes'):",
            "                _add_subscopes(subscope)",
            "",
            "    _add_subscopes(scope_name)",
            "",
            "    # reapply !filter",
            "    if filter_:",
            "        expanded_scopes = {",
            "            f\"{scope_name}!{filter_}\"",
            "            for scope_name in expanded_scope_names",
            "            # server scopes have some cross-resource subscopes",
            "            # where the !server filter doesn't make sense,",
            "            # e.g. read:servers -> read:users:name",
            "            if not (filter_.startswith(\"server\") and scope_name.startswith(\"read:user\"))",
            "        }",
            "    else:",
            "        expanded_scopes = expanded_scope_names",
            "",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(expanded_scopes)",
            "",
            "",
            "def _expand_scopes_key(scopes, owner=None, oauth_client=None):",
            "    \"\"\"Cache key function for expand_scopes",
            "",
            "    scopes is usually a mutable list or set,",
            "    which can be hashed as a frozenset",
            "",
            "    For the owner, we only care about what kind they are,",
            "    and their name.",
            "    \"\"\"",
            "    # freeze scopes for hash",
            "    frozen_scopes = frozenset(scopes)",
            "    if owner is None:",
            "        owner_key = None",
            "    else:",
            "        # owner key is the type and name",
            "        owner_key = (type(owner).__name__, owner.name)",
            "    if oauth_client is None:",
            "        oauth_client_key = None",
            "    else:",
            "        oauth_client_key = oauth_client.identifier",
            "    return (frozen_scopes, owner_key, oauth_client_key)",
            "",
            "",
            "@lru_cache_key(_expand_scopes_key)",
            "def expand_scopes(scopes, owner=None, oauth_client=None):",
            "    \"\"\"Returns a set of fully expanded scopes for a collection of raw scopes",
            "",
            "    Arguments:",
            "      scopes (collection(str)): collection of raw scopes",
            "      owner (obj, optional): orm.User or orm.Service as owner of orm.APIToken",
            "          Used for expansion of metascopes such as `self`",
            "          and owner-based filters such as `!user`",
            "      oauth_client (obj, optional): orm.OAuthClient",
            "          The issuing OAuth client of an API token.",
            "",
            "    Returns:",
            "      expanded scopes (set): set of all expanded scopes, with filters applied for the owner",
            "    \"\"\"",
            "    expanded_scopes = set(chain.from_iterable(map(_expand_scope, scopes)))",
            "",
            "    filter_replacements = {",
            "        \"user\": None,",
            "        \"service\": None,",
            "        \"server\": None,",
            "    }",
            "    user_name = None",
            "    if isinstance(owner, orm.User):",
            "        user_name = owner.name",
            "        filter_replacements[\"user\"] = f\"user={user_name}\"",
            "    elif isinstance(owner, orm.Service):",
            "        filter_replacements[\"service\"] = f\"service={owner.name}\"",
            "",
            "    if oauth_client is not None:",
            "        if oauth_client.service is not None:",
            "            filter_replacements[\"service\"] = f\"service={oauth_client.service.name}\"",
            "        elif oauth_client.spawner is not None:",
            "            spawner = oauth_client.spawner",
            "            filter_replacements[\"server\"] = f\"server={spawner.user.name}/{spawner.name}\"",
            "",
            "    for scope in expanded_scopes.copy():",
            "        base_scope, _, filter = scope.partition('!')",
            "        if filter in filter_replacements:",
            "            # translate !user into !user={username}",
            "            # and !service into !service={servicename}",
            "            # and !server into !server={username}/{servername}",
            "            expanded_scopes.remove(scope)",
            "            expanded_filter = filter_replacements[filter]",
            "            if expanded_filter:",
            "                # translate",
            "                expanded_scopes.add(f'{base_scope}!{expanded_filter}')",
            "            else:",
            "                warnings.warn(",
            "                    f\"Not expanding !{filter} filter without target {filter} in {scope}\",",
            "                    stacklevel=3,",
            "                )",
            "",
            "    if 'self' in expanded_scopes:",
            "        expanded_scopes.remove('self')",
            "        if user_name:",
            "            expanded_scopes |= _expand_self_scope(user_name)",
            "        else:",
            "            warnings.warn(",
            "                f\"Not expanding 'self' scope for owner {owner} which is not a User\",",
            "                stacklevel=3,",
            "            )",
            "",
            "    # reduce to discard overlapping scopes",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(reduce_scopes(expanded_scopes))",
            "",
            "",
            "def _resolve_requested_scopes(requested_scopes, have_scopes, user, client, db):",
            "    \"\"\"Resolve requested scopes for an OAuth token",
            "",
            "    Intersects requested scopes with user scopes.",
            "",
            "    First, at the raw scope level,",
            "    then if some scopes remain, intersect expanded scopes.",
            "",
            "    Args:",
            "        requested_scopes (set):",
            "            raw scopes being requested.",
            "        have_scopes (set):",
            "            raw scopes currently held, against which requested_scopes will be checked.",
            "        user (orm.User):",
            "            user for whom the scopes will be issued",
            "        client (orm.OAuthClient):",
            "            oauth client which will own the token",
            "        db:",
            "            database session, required to resolve user|group intersections",
            "",
            "    Returns:",
            "        (allowed_scopes, disallowed_scopes):",
            "            sets of allowed and disallowed scopes from the request",
            "    \"\"\"",
            "",
            "    allowed_scopes = requested_scopes.intersection(have_scopes)",
            "    disallowed_scopes = requested_scopes.difference(have_scopes)",
            "",
            "    if not disallowed_scopes:",
            "        # simple intersection worked, all scopes granted",
            "        return (allowed_scopes, disallowed_scopes)",
            "",
            "    # if we got here, some scopes were disallowed.",
            "    # resolve fully expanded scopes to make sure scope intersections are properly allowed.",
            "    expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "    expanded_have = expand_scopes(have_scopes, user, client)",
            "    # compute one at a time so we can keep the abbreviated scopes",
            "    # if they are a subset of user scopes (e.g. requested !server, have !user)",
            "    for scope in list(disallowed_scopes):",
            "        expanded_disallowed = expand_scopes({scope}, user, client)",
            "        # don't check already-allowed scopes",
            "        expanded_disallowed -= expanded_allowed",
            "        if expanded_disallowed:",
            "            allowed_intersection = _intersect_expanded_scopes(",
            "                expanded_disallowed, expanded_have, db=db",
            "            )",
            "        else:",
            "            allowed_intersection = set()",
            "",
            "        if allowed_intersection == expanded_disallowed:",
            "            # full scope allowed (requested scope is subset of user scopes)",
            "            allowed_scopes.add(scope)",
            "            disallowed_scopes.remove(scope)",
            "            expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "",
            "        elif allowed_intersection:",
            "            # some scopes get through, but not all,",
            "            # allow the subset",
            "            allowed_scopes |= allowed_intersection",
            "            expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "            # choice: report that the requested scope wasn't _fully_ granted (current behavior)",
            "            # or report the exact (likely too detailed) set of not granted scopes (below)",
            "            # disallowed_scopes.remove(scope)",
            "            # disallowed_scopes |= expanded_disallowed.difference(allowed_intersection)",
            "        else:",
            "            # no new scopes granted, original check was right",
            "            pass",
            "    return (allowed_scopes, disallowed_scopes)",
            "",
            "",
            "def _needs_group_expansion(filter_, filter_value, sub_scope):",
            "    \"\"\"",
            "    Check if there is a requirements to expand the `group` scope to individual `user` scopes.",
            "    Assumptions:",
            "    filter_ != Scope.ALL",
            "    \"\"\"",
            "    if not (filter_ in {'user', 'server'} and 'group' in sub_scope):",
            "        return False",
            "    if filter_ in sub_scope:",
            "        return filter_value not in sub_scope[filter_]",
            "    else:",
            "        return True",
            "",
            "",
            "def _has_scope_key(scope, have_scopes, *, post_filter=False, db=None):",
            "    \"\"\"Cache key for has_scope\"\"\"",
            "    if isinstance(have_scopes, dict):",
            "        have_scopes = FrozenDict(have_scopes)",
            "    else:",
            "        have_scopes = frozenset(have_scopes)",
            "    return (scope, have_scopes, post_filter)",
            "",
            "",
            "@lru_cache_key(_has_scope_key)",
            "def has_scope(scope, have_scopes, *, post_filter=False, db=None):",
            "    \"\"\"Boolean function for whether we have a given scope",
            "",
            "    Args:",
            "        scope (str): a single scope",
            "        have_scopes: parsed_scopes dict or expanded_scopes set",
            "        post_filter (bool):",
            "            Allows returning true if _some_ access is granted,",
            "            if not full access.",
            "            Only allowed if scope has no filter",
            "        db (optional): the db session",
            "            Required to check group membership,",
            "            unused otherwise",
            "    Returns:",
            "        True if access is allowed, False otherwise.",
            "        If post_filer is True and have_scopes contains _filtered_ access,",
            "        will return True, assuming filtered-access will be handled later",
            "        (e.g. in the listing-users handler)",
            "    \"\"\"",
            "    req_scope, _, full_filter = scope.partition(\"!\")",
            "    filter_, _, filter_value = full_filter.partition(\"=\")",
            "    if filter_ and not filter_value:",
            "        raise ValueError(",
            "            f\"Unexpanded scope filter {scope} not allowed. Use expanded scopes.\"",
            "        )",
            "",
            "    if isinstance(have_scopes, dict):",
            "        parsed_scopes = have_scopes",
            "    else:",
            "        parsed_scopes = parse_scopes(have_scopes)",
            "",
            "    if req_scope not in parsed_scopes:",
            "        return False",
            "    have_scope_filters = parsed_scopes[req_scope]",
            "    if have_scope_filters == Scope.ALL:",
            "        # access to all resources",
            "        return True",
            "",
            "    if not filter_:",
            "        if post_filter:",
            "            # allow filtering after the fact",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    if post_filter:",
            "        raise ValueError(\"post_filter=True only allowed for unfiltered scopes\")",
            "    _db_used = False",
            "",
            "    if filter_ in have_scope_filters and filter_value in have_scope_filters[filter_]:",
            "        return True",
            "",
            "    # server->user",
            "    if filter_ == \"server\" and \"user\" in have_scope_filters:",
            "        user_name = filter_value.partition(\"/\")[0]",
            "        if user_name in have_scope_filters[\"user\"]:",
            "            return True",
            "",
            "    if db and _needs_group_expansion(filter_, filter_value, have_scope_filters):",
            "        _db_used = True",
            "        if filter_ == \"user\":",
            "            user_name = filter_value",
            "        elif filter_ == \"server\":",
            "            user_name = filter_value.partition(\"/\")[0]",
            "        else:",
            "            raise ValueError(",
            "                f\"filter_ should be 'user' or 'server' here, not {filter_!r}\"",
            "            )",
            "        group_names = have_scope_filters['group']",
            "        have_group_query = (",
            "            db.query(orm.Group.name)",
            "            .join(orm.User.groups)",
            "            .filter(orm.User.name == user_name)",
            "            .filter(orm.Group.name.in_(group_names))",
            "        )",
            "        if have_group_query.count() > 0:",
            "            return DoNotCache(True)",
            "",
            "    if _db_used:",
            "        return DoNotCache(False)",
            "    else:",
            "        return False",
            "",
            "",
            "class ScopeNotFound(KeyError):",
            "    pass",
            "",
            "",
            "def _check_scopes_exist(scopes, who_for=None):",
            "    \"\"\"Check if provided scopes exist",
            "",
            "    Arguments:",
            "      scopes (list): list of scopes to check",
            "",
            "    Raises ScopeNotFound if scope does not exist",
            "    \"\"\"",
            "",
            "    allowed_scopes = set(scope_definitions.keys())",
            "    filter_prefixes = ('!user=', '!service=', '!group=', '!server=')",
            "    exact_filters = {\"!user\", \"!service\", \"!server\"}",
            "",
            "    if who_for:",
            "        log_for = f\"for {who_for}\"",
            "    else:",
            "        log_for = \"\"",
            "",
            "    for scope in scopes:",
            "        scopename, _, filter_ = scope.partition('!')",
            "        if scopename not in allowed_scopes:",
            "            if scopename == \"all\":",
            "                raise ScopeNotFound(\"Draft scope 'all' is now called 'inherit'\")",
            "            raise ScopeNotFound(f\"Scope '{scope}' {log_for} does not exist\")",
            "        if filter_:",
            "            full_filter = f\"!{filter_}\"",
            "            if full_filter not in exact_filters and not full_filter.startswith(",
            "                filter_prefixes",
            "            ):",
            "                raise ScopeNotFound(",
            "                    f\"Scope filter {filter_} '{full_filter}' in scope '{scope}' {log_for} does not exist\"",
            "                )",
            "",
            "",
            "def _check_token_scopes(scopes, owner, oauth_client):",
            "    \"\"\"Check that scopes to be assigned to a token",
            "    are in fact",
            "",
            "    Arguments:",
            "      scopes: raw or expanded scopes",
            "      owner: orm.User or orm.Service",
            "",
            "    raises:",
            "        ValueError: if requested scopes exceed owner's assigned scopes",
            "    \"\"\"",
            "    scopes = set(scopes)",
            "    if scopes.issubset({\"inherit\"}):",
            "        # nothing to check for simple 'inherit' scopes",
            "        return",
            "    scopes.discard(\"inherit\")",
            "    # common short circuit",
            "    token_scopes = expand_scopes(scopes, owner=owner, oauth_client=oauth_client)",
            "",
            "    if not token_scopes:",
            "        return",
            "",
            "    owner_scopes = get_scopes_for(owner)",
            "    intersection = _intersect_expanded_scopes(",
            "        token_scopes,",
            "        owner_scopes,",
            "        db=sa.inspect(owner).session,",
            "    )",
            "    excess_scopes = token_scopes - intersection",
            "",
            "    if excess_scopes:",
            "        raise ValueError(",
            "            f\"Not assigning requested scopes {','.join(excess_scopes)} not held by {owner.__class__.__name__} {owner.name}\"",
            "        )",
            "",
            "",
            "@lru_cache_key(frozenset)",
            "def parse_scopes(scope_list):",
            "    \"\"\"",
            "    Parses scopes and filters in something akin to JSON style",
            "",
            "    For instance, scope list [\"users\", \"groups!group=foo\", \"servers!server=user/bar\", \"servers!server=user/baz\"]",
            "    would lead to scope model",
            "    {",
            "       \"users\":scope.ALL,",
            "       \"admin:users\":{",
            "          \"user\":[",
            "             \"alice\"",
            "          ]",
            "       },",
            "       \"servers\":{",
            "          \"server\":[",
            "             \"user/bar\",",
            "             \"user/baz\"",
            "          ]",
            "       }",
            "    }",
            "    \"\"\"",
            "    parsed_scopes = {}",
            "    for scope in scope_list:",
            "        base_scope, _, filter_ = scope.partition('!')",
            "        if not filter_:",
            "            parsed_scopes[base_scope] = Scope.ALL",
            "        elif base_scope not in parsed_scopes:",
            "            parsed_scopes[base_scope] = {}",
            "",
            "        if parsed_scopes[base_scope] != Scope.ALL:",
            "            key, _, value = filter_.partition('=')",
            "            if not value:",
            "                raise ValueError(f\"Empty string is not a valid filter: {scope}\")",
            "            if key not in parsed_scopes[base_scope]:",
            "                parsed_scopes[base_scope][key] = {value}",
            "            else:",
            "                parsed_scopes[base_scope][key].add(value)",
            "    # return immutable FrozenDict because the result is cached",
            "    return FrozenDict(parsed_scopes)",
            "",
            "",
            "@lru_cache_key(FrozenDict)",
            "def unparse_scopes(parsed_scopes):",
            "    \"\"\"Turn a parsed_scopes dictionary back into an expanded scopes set\"\"\"",
            "    expanded_scopes = set()",
            "    for base, filters in parsed_scopes.items():",
            "        if filters == Scope.ALL:",
            "            expanded_scopes.add(base)",
            "        else:",
            "            for entity, names_list in filters.items():",
            "                for name in names_list:",
            "                    expanded_scopes.add(f'{base}!{entity}={name}')",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(expanded_scopes)",
            "",
            "",
            "@lru_cache_key(frozenset)",
            "def reduce_scopes(expanded_scopes):",
            "    \"\"\"Reduce expanded scopes to minimal set",
            "",
            "    Eliminates overlapping scopes, such as access:services and access:services!service=x",
            "    \"\"\"",
            "    # unparse_scopes already returns a frozenset",
            "    return unparse_scopes(parse_scopes(expanded_scopes))",
            "",
            "",
            "def needs_scope(*scopes):",
            "    \"\"\"Decorator to restrict access to users or services with the required scope\"\"\"",
            "",
            "    for scope in scopes:",
            "        if scope not in scope_definitions:",
            "            raise ValueError(f\"Scope {scope} is not a valid scope\")",
            "",
            "    def scope_decorator(func):",
            "        @functools.wraps(func)",
            "        def _auth_func(self, *args, **kwargs):",
            "            if not self.current_user:",
            "                # not authenticated at all, fail with more generic message",
            "                # this is the most likely permission error - missing or mis-specified credentials,",
            "                # don't indicate that they have insufficient permissions.",
            "                raise web.HTTPError(",
            "                    403,",
            "                    \"Missing or invalid credentials.\",",
            "                )",
            "",
            "            sig = inspect.signature(func)",
            "            bound_sig = sig.bind(self, *args, **kwargs)",
            "            bound_sig.apply_defaults()",
            "            # Load scopes in case they haven't been loaded yet",
            "            if not hasattr(self, 'expanded_scopes'):",
            "                self.expanded_scopes = {}",
            "                self.parsed_scopes = {}",
            "",
            "            try:",
            "                end_point = self.request.path",
            "            except AttributeError:",
            "                end_point = self.__name__",
            "",
            "            s_kwargs = {}",
            "            for resource in {'user', 'server', 'group', 'service'}:",
            "                resource_name = resource + '_name'",
            "                if resource_name in bound_sig.arguments:",
            "                    resource_value = bound_sig.arguments[resource_name]",
            "                    s_kwargs[resource] = resource_value",
            "",
            "            if \"server\" in s_kwargs:",
            "                # merge user_name, server_name into server=user/server",
            "                if \"user\" not in s_kwargs:",
            "                    raise ValueError(",
            "                        \"Cannot filter on 'server_name' without 'user_name'\"",
            "                    )",
            "                s_kwargs[\"server\"] = f\"{s_kwargs['user']}/{s_kwargs['server']}\"",
            "                s_kwargs.pop(\"user\")",
            "            if len(s_kwargs) > 1:",
            "                raise ValueError(",
            "                    f\"Cannot filter on more than one field, got {s_kwargs}\"",
            "                )",
            "            elif s_kwargs:",
            "                filter_, filter_value = next(iter(s_kwargs.items()))",
            "            else:",
            "                filter_ = filter_value = None",
            "",
            "            for scope in scopes:",
            "                if filter_ is not None:",
            "                    scope = f\"{scope}!{filter_}={filter_value}\"",
            "                app_log.debug(\"Checking access to %s via scope %s\", end_point, scope)",
            "                has_access = has_scope(",
            "                    scope,",
            "                    self.parsed_scopes,",
            "                    post_filter=filter_ is None,",
            "                    db=self.db,",
            "                )",
            "                if has_access:",
            "                    return func(self, *args, **kwargs)",
            "            app_log.warning(",
            "                \"Not authorizing access to %s. Requires any of [%s] on %s, not derived from scopes [%s]\",",
            "                end_point,",
            "                \", \".join(scopes),",
            "                \"*\" if filter_ is None else f\"{filter_}={filter_value}\",",
            "                \", \".join(self.expanded_scopes),",
            "            )",
            "            if filter_ and any(scope in self.parsed_scopes for scope in scopes):",
            "                # not allowed due do filtered access,",
            "                # same error for nonexistence as missing permission",
            "                raise web.HTTPError(",
            "                    404, \"No access to resources or resources not found\"",
            "                )",
            "            raise web.HTTPError(",
            "                403,",
            "                \"Action is not authorized with current scopes;\"",
            "                f\" requires any of [{', '.join(scopes)}]\",",
            "            )",
            "",
            "        return _auth_func",
            "",
            "    return scope_decorator",
            "",
            "",
            "def _identify_key(obj=None):",
            "    if obj is None:",
            "        return None",
            "    else:",
            "        return (type(obj).__name__, obj.name)",
            "",
            "",
            "@lru_cache_key(_identify_key)",
            "def identify_scopes(obj=None):",
            "    \"\"\"Return 'identify' scopes for an orm object",
            "",
            "    Arguments:",
            "      obj (optional): orm.User or orm.Service",
            "          If not specified, 'raw' scopes for identifying the current user are returned,",
            "          which may need to be expanded, later.",
            "",
            "    Returns:",
            "      identify scopes (set): set of scopes needed for 'identify' endpoints",
            "    \"\"\"",
            "    if obj is None:",
            "        return frozenset(f\"read:users:{field}!user\" for field in {\"name\", \"groups\"})",
            "    elif isinstance(obj, orm.User):",
            "        return frozenset(",
            "            f\"read:users:{field}!user={obj.name}\" for field in {\"name\", \"groups\"}",
            "        )",
            "    elif isinstance(obj, orm.Service):",
            "        return frozenset(",
            "            f\"read:services:{field}!service={obj.name}\" for field in {\"name\"}",
            "        )",
            "    else:",
            "        raise TypeError(f\"Expected orm.User or orm.Service, got {obj!r}\")",
            "",
            "",
            "def _access_cache_key(oauth_client=None, *, spawner=None, service=None):",
            "    if oauth_client:",
            "        return (\"oauth\", oauth_client.identifier)",
            "    elif spawner:",
            "        return (\"spawner\", spawner.user.name, spawner.name)",
            "    elif service:",
            "        return (\"service\", service.name)",
            "",
            "",
            "@lru_cache_key(_access_cache_key)",
            "def access_scopes(oauth_client=None, *, spawner=None, service=None):",
            "    \"\"\"Return scope(s) required to access an oauth client\"\"\"",
            "    scopes = set()",
            "    if oauth_client and oauth_client.identifier == \"jupyterhub\":",
            "        return frozenset()",
            "    if spawner is None and oauth_client:",
            "        spawner = oauth_client.spawner",
            "    if spawner:",
            "        scopes.add(f\"access:servers!server={spawner.user.name}/{spawner.name}\")",
            "    else:",
            "        if service is None:",
            "            service = oauth_client.service",
            "        if service:",
            "            scopes.add(f\"access:services!service={service.name}\")",
            "        else:",
            "            app_log.warning(",
            "                f\"OAuth client {oauth_client} has no associated service or spawner!\"",
            "            )",
            "    return frozenset(scopes)",
            "",
            "",
            "def _check_scope_key(sub_scope, orm_resource, kind):",
            "    \"\"\"Cache key function for check_scope_filter\"\"\"",
            "    if kind == 'server':",
            "        resource_key = (orm_resource.user.name, orm_resource.name)",
            "    else:",
            "        resource_key = orm_resource.name",
            "    return (sub_scope, resource_key, kind)",
            "",
            "",
            "@lru_cache_key(_check_scope_key)",
            "def check_scope_filter(sub_scope, orm_resource, kind):",
            "    \"\"\"Return whether a sub_scope filter applies to a given resource.",
            "",
            "    param sub_scope: parsed_scopes filter (i.e. dict or Scope.ALL)",
            "    param orm_resource: User or Service or Group or Spawner",
            "    param kind: 'user' or 'service' or 'group' or 'server'.",
            "",
            "    Returns True or False",
            "    \"\"\"",
            "    if sub_scope is Scope.ALL:",
            "        return True",
            "    elif kind in sub_scope and orm_resource.name in sub_scope[kind]:",
            "        return True",
            "",
            "    if kind == 'server':",
            "        server_format = f\"{orm_resource.user.name}/{orm_resource.name}\"",
            "        if server_format in sub_scope.get(kind, []):",
            "            return True",
            "        # Fall back on checking if we have user access",
            "        if 'user' in sub_scope and orm_resource.user.name in sub_scope['user']:",
            "            return True",
            "        # Fall back on checking if we have group access for this user",
            "        orm_resource = orm_resource.user",
            "        kind = 'user'",
            "",
            "    if kind == 'user' and 'group' in sub_scope:",
            "        group_names = {group.name for group in orm_resource.groups}",
            "        user_in_group = bool(group_names & set(sub_scope['group']))",
            "        # cannot cache if we needed to lookup groups in db",
            "        return DoNotCache(user_in_group)",
            "    return False",
            "",
            "",
            "def describe_parsed_scopes(parsed_scopes, username=None):",
            "    \"\"\"Return list of descriptions of parsed scopes",
            "",
            "    Highly detailed, often redundant descriptions",
            "    \"\"\"",
            "    descriptions = []",
            "    for scope, filters in parsed_scopes.items():",
            "        if filters == Scope.ALL:",
            "            # no filter",
            "            filter_text = \"\"",
            "        else:",
            "            filter_chunks = []",
            "            for kind, names in filters.items():",
            "                if kind == 'user' and names == {username}:",
            "                    filter_chunks.append(\"only you\")",
            "                else:",
            "                    if len(names) == 1:",
            "                        filter_chunks.append(f\"{kind}: {list(names)[0]}\")",
            "                    else:",
            "                        filter_chunks.append(f\"{kind}s: {', '.join(names)}\")",
            "            filter_text = \"; or \".join(filter_chunks)",
            "        descriptions.append(",
            "            {",
            "                \"scope\": scope,",
            "                \"description\": scope_definitions[scope][\"description\"],",
            "                \"filter\": filter_text,",
            "            }",
            "        )",
            "    return descriptions",
            "",
            "",
            "@lru_cache_key(lambda raw_scopes, username=None: (frozenset(raw_scopes), username))",
            "def describe_raw_scopes(raw_scopes, username=None):",
            "    \"\"\"Return list of descriptions of raw scopes",
            "",
            "    A much shorter list than describe_parsed_scopes",
            "    \"\"\"",
            "    descriptions = []",
            "    for raw_scope in raw_scopes:",
            "        scope, _, filter_ = raw_scope.partition(\"!\")",
            "        if not filter_:",
            "            # no filter",
            "            filter_text = \"\"",
            "        elif filter_ == \"user\":",
            "            filter_text = \"only you\"",
            "        else:",
            "            kind, _, name = filter_.partition(\"=\")",
            "            if kind == \"user\" and name == username:",
            "                filter_text = \"only you\"",
            "            else:",
            "                kind_text = kind",
            "                if kind == 'group':",
            "                    kind_text = \"users in group\"",
            "                filter_text = f\"{kind_text} {name}\"",
            "        descriptions.append(",
            "            {",
            "                \"scope\": scope,",
            "                \"description\": scope_definitions[scope][\"description\"],",
            "                \"filter\": filter_text,",
            "            }",
            "        )",
            "    # make sure we return immutable from a cached function",
            "    return tuple(descriptions)",
            "",
            "",
            "# regex for custom scope",
            "# for-humans description below",
            "# note: scope description duplicated in docs/source/rbac/scopes.md",
            "# update docs when making changes here",
            "_custom_scope_pattern = re.compile(r\"^custom:[a-z0-9][a-z0-9_\\-\\*:]+[a-z0-9_\\*]$\")",
            "",
            "# custom scope pattern description",
            "# used in docstring below and error message when scopes don't match _custom_scope_pattern",
            "_custom_scope_description = \"\"\"",
            "Custom scopes must start with `custom:`",
            "and contain only lowercase ascii letters, numbers, hyphen, underscore, colon, and asterisk (-_:*).",
            "The part after `custom:` must start with a letter or number.",
            "Scopes may not end with a hyphen or colon.",
            "\"\"\"",
            "",
            "",
            "def define_custom_scopes(scopes):",
            "    \"\"\"Define custom scopes",
            "",
            "    Adds custom scopes to the scope_definitions dict.",
            "",
            "    Scopes must start with `custom:`.",
            "    It is recommended to name custom scopes with a pattern like::",
            "",
            "        custom:$your-project:$action:$resource",
            "",
            "    e.g.::",
            "",
            "        custom:jupyter_server:read:contents",
            "",
            "    That makes them easy to parse and avoids collisions across projects.",
            "",
            "    `scopes` must have at least one scope definition,",
            "    and each scope definition must have a `description`,",
            "    which will be displayed on the oauth authorization page,",
            "    and _may_ have a `subscopes` list of other scopes if having one scope",
            "    should imply having other, more specific scopes.",
            "",
            "    Args:",
            "",
            "    scopes: dict",
            "        A dictionary of scope definitions.",
            "        The keys are the scopes,",
            "        while the values are dictionaries with at least a `description` field,",
            "        and optional `subscopes` field.",
            "        CUSTOM_SCOPE_DESCRIPTION",
            "    Examples::",
            "",
            "        define_custom_scopes(",
            "            {",
            "                \"custom:jupyter_server:read:contents\": {",
            "                    \"description\": \"read-only access to files in a Jupyter server\",",
            "                },",
            "                \"custom:jupyter_server:read\": {",
            "                    \"description\": \"read-only access to a Jupyter server\",",
            "                    \"subscopes\": [",
            "                        \"custom:jupyter_server:read:contents\",",
            "                        \"custom:jupyter_server:read:kernels\",",
            "                        \"...\",",
            "                },",
            "            }",
            "        )",
            "    \"\"\".replace(\"CUSTOM_SCOPE_DESCRIPTION\", indent(_custom_scope_description, \" \" * 8))",
            "    for scope, scope_definition in scopes.items():",
            "        if scope in scope_definitions and scope_definitions[scope] != scope_definition:",
            "            raise ValueError(",
            "                f\"Cannot redefine scope {scope}={scope_definition}. Already have {scope}={scope_definitions[scope]}\"",
            "            )",
            "        if not _custom_scope_pattern.match(scope):",
            "            # note: keep this description in sync with docstring above",
            "            raise ValueError(",
            "                f\"Invalid scope name: {scope!r}.\\n{_custom_scope_description}\"",
            "                \" and contain only lowercase ascii letters, numbers, hyphen, underscore, colon, and asterisk.\"",
            "                \" The part after `custom:` must start with a letter or number.\"",
            "                \" Scopes may not end with a hyphen or colon.\"",
            "            )",
            "        if \"description\" not in scope_definition:",
            "            raise ValueError(",
            "                f\"scope {scope}={scope_definition} missing key 'description'\"",
            "            )",
            "        if \"subscopes\" in scope_definition:",
            "            subscopes = scope_definition[\"subscopes\"]",
            "            if not isinstance(subscopes, list) or not all(",
            "                isinstance(s, str) for s in subscopes",
            "            ):",
            "                raise ValueError(",
            "                    f\"subscopes must be a list of scope strings, got {subscopes!r}\"",
            "                )",
            "            for subscope in subscopes:",
            "                if subscope not in scopes:",
            "                    if subscope in scope_definitions:",
            "                        raise ValueError(",
            "                            f\"non-custom subscope {subscope} in {scope}={scope_definition} is not allowed.\"",
            "                            f\" Custom scopes may only have custom subscopes.\"",
            "                            f\" Roles should be used to assign multiple scopes together.\"",
            "                        )",
            "                    raise ValueError(",
            "                        f\"subscope {subscope} in {scope}={scope_definition} not found. All scopes must be defined.\"",
            "                    )",
            "",
            "        extra_keys = set(scope_definition.keys()).difference(",
            "            [\"description\", \"subscopes\"]",
            "        )",
            "        if extra_keys:",
            "            warnings.warn(",
            "                f\"Ignoring unrecognized key(s) {', '.join(extra_keys)!r} in {scope}={scope_definition}\",",
            "                UserWarning,",
            "                stacklevel=2,",
            "            )",
            "        app_log.info(f\"Defining custom scope {scope}\")",
            "        # deferred evaluation for debug-logging",
            "        app_log.debug(\"Defining custom scope %s=%s\", scope, scope_definition)",
            "        scope_definitions[scope] = scope_definition"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "General scope definitions and utilities",
            "",
            "Scope functions generally return _immutable_ collections,",
            "such as `frozenset` to avoid mutating cached values.",
            "If needed, mutable copies can be made, e.g. `set(frozen_scopes)`",
            "",
            "Scope variable nomenclature",
            "---------------------------",
            "scopes or 'raw' scopes: collection of scopes that may contain abbreviations (e.g., in role definition)",
            "expanded scopes: set of expanded scopes without abbreviations (i.e., resolved metascopes, filters, and subscopes)",
            "parsed scopes: dictionary format of expanded scopes (`read:users!user=name` -> `{'read:users': {user: [name]}`)",
            "intersection : set of expanded scopes as intersection of 2 expanded scope sets",
            "identify scopes: set of expanded scopes needed for identify (whoami) endpoints",
            "reduced scopes: expanded scopes that have been reduced",
            "\"\"\"",
            "",
            "import functools",
            "import inspect",
            "import re",
            "import warnings",
            "from enum import Enum",
            "from functools import lru_cache",
            "from itertools import chain",
            "from textwrap import indent",
            "",
            "import sqlalchemy as sa",
            "from tornado import web",
            "from tornado.log import app_log",
            "",
            "from . import orm, roles",
            "from ._memoize import DoNotCache, FrozenDict, lru_cache_key",
            "",
            "\"\"\"when modifying the scope definitions, make sure that `docs/source/rbac/generate-scope-table.py` is run",
            "   so that changes are reflected in the documentation and REST API description.\"\"\"",
            "scope_definitions = {",
            "    '(no_scope)': {'description': 'Identify the owner of the requesting entity.'},",
            "    'self': {",
            "        'description': 'Your own resources',",
            "        'doc_description': 'The user\u2019s own resources _(metascope for users, resolves to (no_scope) for services)_',",
            "    },",
            "    'inherit': {",
            "        'description': 'Anything you have access to',",
            "        'doc_description': 'Everything that the token-owning entity can access _(metascope for tokens)_',",
            "    },",
            "    'admin-ui': {",
            "        'description': 'Access the admin page.',",
            "        'doc_description': 'Access the admin page. Permission to take actions via the admin page granted separately.',",
            "    },",
            "    'admin:users': {",
            "        'description': 'Read, modify, create, and delete users and their authentication state, not including their servers or tokens. This is an extremely privileged scope and should be considered tantamount to superuser.',",
            "        'subscopes': ['admin:auth_state', 'users', 'read:roles:users', 'delete:users'],",
            "    },",
            "    'admin:auth_state': {'description': 'Read a user\u2019s authentication state.'},",
            "    'users': {",
            "        'description': 'Read and write permissions to user models (excluding servers, tokens and authentication state).',",
            "        'subscopes': ['read:users', 'list:users', 'users:activity'],",
            "    },",
            "    'delete:users': {",
            "        'description': \"Delete users.\",",
            "    },",
            "    'list:users': {",
            "        'description': 'List users, including at least their names.',",
            "        'subscopes': ['read:users:name'],",
            "    },",
            "    'read:users': {",
            "        'description': 'Read user models (including servers, tokens and authentication state).',",
            "        'subscopes': [",
            "            'read:users:name',",
            "            'read:users:groups',",
            "            'read:users:activity',",
            "        ],",
            "    },",
            "    'read:users:name': {'description': 'Read names of users.'},",
            "    'read:users:groups': {'description': 'Read users\u2019 group membership.'},",
            "    'read:users:activity': {'description': 'Read time of last user activity.'},",
            "    'read:roles': {",
            "        'description': 'Read role assignments.',",
            "        'subscopes': ['read:roles:users', 'read:roles:services', 'read:roles:groups'],",
            "    },",
            "    'read:roles:users': {'description': 'Read user role assignments.'},",
            "    'read:roles:services': {'description': 'Read service role assignments.'},",
            "    'read:roles:groups': {'description': 'Read group role assignments.'},",
            "    'users:activity': {",
            "        'description': 'Update time of last user activity.',",
            "        'subscopes': ['read:users:activity'],",
            "    },",
            "    'admin:servers': {",
            "        'description': 'Read, start, stop, create and delete user servers and their state.',",
            "        'subscopes': ['admin:server_state', 'servers'],",
            "    },",
            "    'admin:server_state': {'description': 'Read and write users\u2019 server state.'},",
            "    'servers': {",
            "        'description': 'Start and stop user servers.',",
            "        'subscopes': ['read:servers', 'delete:servers'],",
            "    },",
            "    'read:servers': {",
            "        'description': 'Read users\u2019 names and their server models (excluding the server state).',",
            "        'subscopes': ['read:users:name'],",
            "    },",
            "    'delete:servers': {'description': \"Stop and delete users' servers.\"},",
            "    'tokens': {",
            "        'description': 'Read, write, create and delete user tokens.',",
            "        'subscopes': ['read:tokens'],",
            "    },",
            "    'read:tokens': {'description': 'Read user tokens.'},",
            "    'admin:groups': {",
            "        'description': 'Read and write group information, create and delete groups.',",
            "        'subscopes': ['groups', 'read:roles:groups', 'delete:groups'],",
            "    },",
            "    'groups': {",
            "        'description': 'Read and write group information, including adding/removing users to/from groups. Note: adding users to groups is a way of granting permissions to users of the group,and may grant _access_ to users of other groups.',",
            "        'subscopes': ['read:groups', 'list:groups'],",
            "    },",
            "    'list:groups': {",
            "        'description': 'List groups, including at least their names.',",
            "        'subscopes': ['read:groups:name'],",
            "    },",
            "    'read:groups': {",
            "        'description': 'Read group models.',",
            "        'subscopes': ['read:groups:name'],",
            "    },",
            "    'read:groups:name': {'description': 'Read group names.'},",
            "    'delete:groups': {",
            "        'description': \"Delete groups.\",",
            "    },",
            "    'admin:services': {",
            "        'description': 'Create, read, update, delete services, not including services defined from config files.',",
            "        'subscopes': ['list:services', 'read:services', 'read:roles:services'],",
            "    },",
            "    'list:services': {",
            "        'description': 'List services, including at least their names.',",
            "        'subscopes': ['read:services:name'],",
            "    },",
            "    'read:services': {",
            "        'description': 'Read service models.',",
            "        'subscopes': ['read:services:name'],",
            "    },",
            "    'read:services:name': {'description': 'Read service names.'},",
            "    'read:hub': {'description': 'Read detailed information about the Hub.'},",
            "    'access:servers': {",
            "        'description': 'Access user servers via API or browser.',",
            "    },",
            "    'access:services': {",
            "        'description': 'Access services via API or browser.',",
            "    },",
            "    'users:shares': {",
            "        'description': \"Read and revoke a user's access to shared servers.\",",
            "        'subscopes': [",
            "            'read:users:shares',",
            "        ],",
            "    },",
            "    'read:users:shares': {",
            "        'description': \"Read servers shared with a user.\",",
            "    },",
            "    'groups:shares': {",
            "        'description': \"Read and revoke a group's access to shared servers.\",",
            "        'subscopes': [",
            "            'read:groups:shares',",
            "        ],",
            "    },",
            "    'read:groups:shares': {",
            "        'description': \"Read servers shared with a group.\",",
            "    },",
            "    'read:shares': {",
            "        'description': \"Read information about shared access to servers.\",",
            "    },",
            "    'shares': {",
            "        'description': \"Manage access to shared servers.\",",
            "        'subscopes': [",
            "            'access:servers',",
            "            'read:shares',",
            "            'users:shares',",
            "            'groups:shares',",
            "        ],",
            "    },",
            "    'proxy': {",
            "        'description': 'Read information about the proxy\u2019s routing table, sync the Hub with the proxy and notify the Hub about a new proxy.'",
            "    },",
            "    'shutdown': {'description': 'Shutdown the hub.'},",
            "    'read:metrics': {",
            "        'description': \"Read prometheus metrics.\",",
            "    },",
            "}",
            "",
            "",
            "class Scope(Enum):",
            "    ALL = True",
            "",
            "",
            "def _intersection_cache_key(scopes_a, scopes_b, db=None):",
            "    \"\"\"Cache key function for scope intersections\"\"\"",
            "    return (frozenset(scopes_a), frozenset(scopes_b))",
            "",
            "",
            "@lru_cache_key(_intersection_cache_key)",
            "def _intersect_expanded_scopes(scopes_a, scopes_b, db=None):",
            "    \"\"\"Intersect two sets of scopes by comparing their permissions",
            "",
            "    Arguments:",
            "      scopes_a, scopes_b: sets of expanded scopes",
            "      db (optional): db connection for resolving group membership",
            "",
            "    Returns:",
            "      intersection: set of expanded scopes as intersection of the arguments",
            "",
            "    If db is given, group membership will be accounted for in intersections,",
            "    Otherwise, it can result in lower than intended permissions,",
            "          (i.e. users!group=x & users!user=y will be empty, even if user y is in group x.)",
            "    \"\"\"",
            "    scopes_a = frozenset(scopes_a)",
            "    scopes_b = frozenset(scopes_b)",
            "",
            "    # cached lookups for group membership of users and servers",
            "    @lru_cache",
            "    def groups_for_user(username):",
            "        \"\"\"Get set of group names for a given username\"\"\"",
            "        # if we need a group lookup, the result is not cacheable",
            "        nonlocal needs_db",
            "        needs_db = True",
            "        group_query = (",
            "            db.query(orm.Group.name)",
            "            .join(orm.User.groups)",
            "            .filter(orm.User.name == username)",
            "        )",
            "        return {row[0] for row in group_query}",
            "",
            "    @lru_cache",
            "    def groups_for_server(server):",
            "        \"\"\"Get set of group names for a given server\"\"\"",
            "        username, _, servername = server.partition(\"/\")",
            "        return groups_for_user(username)",
            "",
            "    parsed_scopes_a = parse_scopes(scopes_a)",
            "    parsed_scopes_b = parse_scopes(scopes_b)",
            "",
            "    # track whether we need a db lookup (for groups)",
            "    # because we can't cache the intersection if we do",
            "    # if there are no group filters, this is cacheable",
            "    needs_db = False",
            "",
            "    common_bases = parsed_scopes_a.keys() & parsed_scopes_b.keys()",
            "",
            "    common_filters = {}",
            "    warned = False",
            "    for base in common_bases:",
            "        filters_a = parsed_scopes_a[base]",
            "        filters_b = parsed_scopes_b[base]",
            "        if filters_a == Scope.ALL:",
            "            common_filters[base] = filters_b",
            "        elif filters_b == Scope.ALL:",
            "            common_filters[base] = filters_a",
            "        else:",
            "            common_entities = filters_a.keys() & filters_b.keys()",
            "            all_entities = filters_a.keys() | filters_b.keys()",
            "",
            "            # if we don't have a db session, we can't check group membership",
            "            # warn *if* there are non-overlapping user= and group= filters that we can't check",
            "            if (",
            "                db is None",
            "                and not warned",
            "                and 'group' in all_entities",
            "                and ('user' in all_entities or 'server' in all_entities)",
            "            ):",
            "                # this could resolve wrong if there's a user or server only on one side and a group only on the other",
            "                # check both directions: A has group X not in B group list AND B has user Y not in A user list",
            "                for a, b in [(filters_a, filters_b), (filters_b, filters_a)]:",
            "                    for b_key in ('user', 'server'):",
            "                        if (",
            "                            not warned",
            "                            and \"group\" in a",
            "                            and b_key in b",
            "                            and a[\"group\"].difference(b.get(\"group\", []))",
            "                            and b[b_key].difference(a.get(b_key, []))",
            "                        ):",
            "                            warnings.warn(",
            "                                f\"{base}[!{b_key}={b[b_key]}, !group={a['group']}] combinations of filters present,\"",
            "                                \" without db access. Intersection between not considered.\"",
            "                                \" May result in lower than intended permissions.\",",
            "                                UserWarning,",
            "                            )",
            "                            warned = True",
            "                            needs_db = True",
            "",
            "            common_filters[base] = {",
            "                entity: filters_a[entity] & filters_b[entity]",
            "                for entity in common_entities",
            "            }",
            "",
            "            # resolve hierarchies (group/user/server) in both directions",
            "            common_servers = initial_common_servers = common_filters[base].get(",
            "                \"server\", frozenset()",
            "            )",
            "            common_users = initial_common_users = common_filters[base].get(",
            "                \"user\", frozenset()",
            "            )",
            "",
            "            for a, b in [(filters_a, filters_b), (filters_b, filters_a)]:",
            "                if 'server' in a and b.get('server') != a['server']:",
            "                    # skip already-added servers (includes overlapping servers)",
            "                    servers = a['server'].difference(common_servers)",
            "",
            "                    # resolve user/server hierarchy",
            "                    if servers and 'user' in b:",
            "                        for server in servers:",
            "                            username, _, servername = server.partition(\"/\")",
            "                            if username in b['user']:",
            "                                common_servers = common_servers | {server}",
            "",
            "                    # resolve group/server hierarchy if db available",
            "                    servers = servers.difference(common_servers)",
            "                    if db is not None and servers and 'group' in b:",
            "                        needs_db = True",
            "                        for server in servers:",
            "                            server_groups = groups_for_server(server)",
            "                            if server_groups & b['group']:",
            "                                common_servers = common_servers | {server}",
            "",
            "                # resolve group/user hierarchy if db available and user sets aren't identical",
            "                if (",
            "                    db is not None",
            "                    and 'user' in a",
            "                    and 'group' in b",
            "                    and b.get('user') != a['user']",
            "                ):",
            "                    # skip already-added users (includes overlapping users)",
            "                    users = a['user'].difference(common_users)",
            "                    for username in users:",
            "                        groups = groups_for_user(username)",
            "                        if groups & b[\"group\"]:",
            "                            common_users = common_users | {username}",
            "",
            "            # add server filter if it's non-empty",
            "            # and it changed",
            "            if common_servers and common_servers != initial_common_servers:",
            "                common_filters[base][\"server\"] = common_servers",
            "",
            "            # add user filter if it's non-empty",
            "            # and it changed",
            "            if common_users and common_users != initial_common_users:",
            "                common_filters[base][\"user\"] = common_users",
            "",
            "    intersection = unparse_scopes(common_filters)",
            "    if needs_db:",
            "        # return intersection, but don't cache it if it needed db lookups",
            "        return DoNotCache(intersection)",
            "",
            "    return intersection",
            "",
            "",
            "def get_scopes_for(orm_object):",
            "    \"\"\"Find scopes for a given user or token from their roles and resolve permissions",
            "",
            "    Arguments:",
            "      orm_object: orm object or User wrapper",
            "",
            "    Returns:",
            "      expanded scopes (set) for the orm object",
            "      or",
            "      intersection (set) if orm_object == orm.APIToken",
            "    \"\"\"",
            "    expanded_scopes = set()",
            "    if orm_object is None:",
            "        return expanded_scopes",
            "",
            "    if not isinstance(orm_object, orm.Base):",
            "        from .user import User",
            "",
            "        if isinstance(orm_object, User):",
            "            orm_object = orm_object.orm_user",
            "        else:",
            "            raise TypeError(",
            "                f\"Only allow orm objects or User wrappers, got {orm_object}\"",
            "            )",
            "",
            "    owner = None",
            "    if isinstance(orm_object, orm.APIToken):",
            "        owner = orm_object.user or orm_object.service",
            "        owner_roles = roles.get_roles_for(owner)",
            "        owner_scopes = roles.roles_to_expanded_scopes(owner_roles, owner)",
            "        if owner is orm_object.user:",
            "            for share in owner.shared_with_me:",
            "                owner_scopes |= frozenset(share.scopes)",
            "",
            "        token_scopes = set(orm_object.scopes)",
            "        if 'inherit' in token_scopes:",
            "            # token_scopes includes 'inherit',",
            "            # so we know the intersection is exactly the owner's scopes",
            "            # only thing we miss by short-circuiting here: warning about excluded extra scopes",
            "            return owner_scopes",
            "",
            "        token_scopes = set(",
            "            expand_scopes(",
            "                token_scopes,",
            "                owner=owner,",
            "                oauth_client=orm_object.oauth_client,",
            "            )",
            "        )",
            "",
            "        if orm_object.client_id != \"jupyterhub\":",
            "            # oauth tokens can be used to access the service issuing the token,",
            "            # assuming the owner itself still has permission to do so",
            "            token_scopes.update(access_scopes(orm_object.oauth_client))",
            "",
            "        # reduce to collapse multiple filters on the same scope",
            "        # to avoid spurious logs about discarded scopes",
            "        token_scopes.update(identify_scopes(owner))",
            "        token_scopes = reduce_scopes(token_scopes)",
            "",
            "        intersection = _intersect_expanded_scopes(",
            "            token_scopes,",
            "            owner_scopes,",
            "            db=sa.inspect(orm_object).session,",
            "        )",
            "        discarded_token_scopes = token_scopes - intersection",
            "",
            "        # Not taking symmetric difference here because token owner can naturally have more scopes than token",
            "        if discarded_token_scopes:",
            "            app_log.warning(",
            "                f\"discarding scopes [{discarded_token_scopes}],\"",
            "                f\" not present in roles of owner {owner}\"",
            "            )",
            "            app_log.debug(",
            "                \"Owner %s has scopes: %s\\nToken has scopes: %s\",",
            "                owner,",
            "                owner_scopes,",
            "                token_scopes,",
            "            )",
            "        expanded_scopes = intersection",
            "        # always include identify scopes",
            "        expanded_scopes",
            "    else:",
            "        expanded_scopes = roles.roles_to_expanded_scopes(",
            "            roles.get_roles_for(orm_object),",
            "            owner=orm_object,",
            "        )",
            "",
            "        # add permissions granted from 'shares'",
            "        if hasattr(orm_object, \"shared_with_me\"):",
            "            for share in orm_object.shared_with_me:",
            "                expanded_scopes |= expand_share_scopes(share)",
            "        if isinstance(orm_object, orm.User):",
            "            for group in orm_object.groups:",
            "                for share in group.shared_with_me:",
            "                    expanded_scopes |= expand_share_scopes(share)",
            "",
            "    return expanded_scopes",
            "",
            "",
            "def expand_share_scopes(share):",
            "    \"\"\"Get expanded scopes for a Share\"\"\"",
            "    return expand_scopes(",
            "        share.scopes,",
            "        owner=share.user or share.group,",
            "        oauth_client=share.spawner.oauth_client,",
            "    )",
            "",
            "",
            "@lru_cache",
            "def _expand_self_scope(username):",
            "    \"\"\"",
            "    Users have a metascope 'self' that should be expanded to standard user privileges.",
            "    At the moment that is a user-filtered version (optional read) access to",
            "    users",
            "    users:name",
            "    users:groups",
            "    users:activity",
            "    tokens",
            "    servers",
            "    access:servers",
            "",
            "",
            "    Arguments:",
            "      username (str): user name",
            "",
            "    Returns:",
            "      expanded scopes (set): set of expanded scopes covering standard user privileges",
            "    \"\"\"",
            "    scope_list = [",
            "        'read:users',",
            "        'read:users:name',",
            "        'read:users:groups',",
            "        'users:shares',",
            "        'read:users:shares',",
            "        'read:shares',",
            "        'users:activity',",
            "        'read:users:activity',",
            "        'servers',",
            "        'delete:servers',",
            "        'read:servers',",
            "        'tokens',",
            "        'read:tokens',",
            "        'access:servers',",
            "    ]",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(f\"{scope}!user={username}\" for scope in scope_list)",
            "",
            "",
            "@lru_cache(maxsize=65535)",
            "def _expand_scope(scope):",
            "    \"\"\"Returns a scope and all subscopes",
            "",
            "    Arguments:",
            "      scope (str): the scope to expand",
            "",
            "    Returns:",
            "      expanded scope (set): set of all scope's subscopes including the scope itself",
            "    \"\"\"",
            "",
            "    # remove filter, save for later",
            "    scope_name, sep, filter_ = scope.partition('!')",
            "",
            "    # expand scope and subscopes",
            "    expanded_scope_names = set()",
            "",
            "    def _add_subscopes(scope_name):",
            "        expanded_scope_names.add(scope_name)",
            "        if scope_definitions[scope_name].get('subscopes'):",
            "            for subscope in scope_definitions[scope_name].get('subscopes'):",
            "                _add_subscopes(subscope)",
            "",
            "    _add_subscopes(scope_name)",
            "",
            "    # reapply !filter",
            "    if filter_:",
            "        expanded_scopes = {",
            "            f\"{scope_name}!{filter_}\"",
            "            for scope_name in expanded_scope_names",
            "            # server scopes have some cross-resource subscopes",
            "            # where the !server filter doesn't make sense,",
            "            # e.g. read:servers -> read:users:name",
            "            if not (filter_.startswith(\"server\") and scope_name.startswith(\"read:user\"))",
            "        }",
            "    else:",
            "        expanded_scopes = expanded_scope_names",
            "",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(expanded_scopes)",
            "",
            "",
            "def _expand_scopes_key(scopes, owner=None, oauth_client=None):",
            "    \"\"\"Cache key function for expand_scopes",
            "",
            "    scopes is usually a mutable list or set,",
            "    which can be hashed as a frozenset",
            "",
            "    For the owner, we only care about what kind they are,",
            "    and their name.",
            "    \"\"\"",
            "    # freeze scopes for hash",
            "    frozen_scopes = frozenset(scopes)",
            "    if owner is None:",
            "        owner_key = None",
            "    else:",
            "        # owner key is the type and name",
            "        owner_key = (type(owner).__name__, owner.name)",
            "    if oauth_client is None:",
            "        oauth_client_key = None",
            "    else:",
            "        oauth_client_key = oauth_client.identifier",
            "    return (frozen_scopes, owner_key, oauth_client_key)",
            "",
            "",
            "@lru_cache_key(_expand_scopes_key)",
            "def expand_scopes(scopes, owner=None, oauth_client=None):",
            "    \"\"\"Returns a set of fully expanded scopes for a collection of raw scopes",
            "",
            "    Arguments:",
            "      scopes (collection(str)): collection of raw scopes",
            "      owner (obj, optional): orm.User or orm.Service as owner of orm.APIToken",
            "          Used for expansion of metascopes such as `self`",
            "          and owner-based filters such as `!user`",
            "      oauth_client (obj, optional): orm.OAuthClient",
            "          The issuing OAuth client of an API token.",
            "",
            "    Returns:",
            "      expanded scopes (set): set of all expanded scopes, with filters applied for the owner",
            "    \"\"\"",
            "    expanded_scopes = set(chain.from_iterable(map(_expand_scope, scopes)))",
            "",
            "    filter_replacements = {",
            "        \"user\": None,",
            "        \"service\": None,",
            "        \"server\": None,",
            "    }",
            "    user_name = None",
            "    if isinstance(owner, orm.User):",
            "        user_name = owner.name",
            "        filter_replacements[\"user\"] = f\"user={user_name}\"",
            "    elif isinstance(owner, orm.Service):",
            "        filter_replacements[\"service\"] = f\"service={owner.name}\"",
            "",
            "    if oauth_client is not None:",
            "        if oauth_client.service is not None:",
            "            filter_replacements[\"service\"] = f\"service={oauth_client.service.name}\"",
            "        elif oauth_client.spawner is not None:",
            "            spawner = oauth_client.spawner",
            "            filter_replacements[\"server\"] = f\"server={spawner.user.name}/{spawner.name}\"",
            "",
            "    for scope in expanded_scopes.copy():",
            "        base_scope, _, filter = scope.partition('!')",
            "        if filter in filter_replacements:",
            "            # translate !user into !user={username}",
            "            # and !service into !service={servicename}",
            "            # and !server into !server={username}/{servername}",
            "            expanded_scopes.remove(scope)",
            "            expanded_filter = filter_replacements[filter]",
            "            if expanded_filter:",
            "                # translate",
            "                expanded_scopes.add(f'{base_scope}!{expanded_filter}')",
            "            else:",
            "                warnings.warn(",
            "                    f\"Not expanding !{filter} filter without target {filter} in {scope}\",",
            "                    stacklevel=3,",
            "                )",
            "",
            "    if 'self' in expanded_scopes:",
            "        expanded_scopes.remove('self')",
            "        if user_name:",
            "            expanded_scopes |= _expand_self_scope(user_name)",
            "        else:",
            "            warnings.warn(",
            "                f\"Not expanding 'self' scope for owner {owner} which is not a User\",",
            "                stacklevel=3,",
            "            )",
            "",
            "    # reduce to discard overlapping scopes",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(reduce_scopes(expanded_scopes))",
            "",
            "",
            "def _resolve_requested_scopes(requested_scopes, have_scopes, user, client, db):",
            "    \"\"\"Resolve requested scopes for an OAuth token",
            "",
            "    Intersects requested scopes with user scopes.",
            "",
            "    First, at the raw scope level,",
            "    then if some scopes remain, intersect expanded scopes.",
            "",
            "    Args:",
            "        requested_scopes (set):",
            "            raw scopes being requested.",
            "        have_scopes (set):",
            "            raw scopes currently held, against which requested_scopes will be checked.",
            "        user (orm.User):",
            "            user for whom the scopes will be issued",
            "        client (orm.OAuthClient):",
            "            oauth client which will own the token",
            "        db:",
            "            database session, required to resolve user|group intersections",
            "",
            "    Returns:",
            "        (allowed_scopes, disallowed_scopes):",
            "            sets of allowed and disallowed scopes from the request",
            "    \"\"\"",
            "",
            "    allowed_scopes = requested_scopes.intersection(have_scopes)",
            "    disallowed_scopes = requested_scopes.difference(have_scopes)",
            "",
            "    if not disallowed_scopes:",
            "        # simple intersection worked, all scopes granted",
            "        return (allowed_scopes, disallowed_scopes)",
            "",
            "    # if we got here, some scopes were disallowed.",
            "    # resolve fully expanded scopes to make sure scope intersections are properly allowed.",
            "    expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "    expanded_have = expand_scopes(have_scopes, user, client)",
            "    # compute one at a time so we can keep the abbreviated scopes",
            "    # if they are a subset of user scopes (e.g. requested !server, have !user)",
            "    for scope in list(disallowed_scopes):",
            "        expanded_disallowed = expand_scopes({scope}, user, client)",
            "        # don't check already-allowed scopes",
            "        expanded_disallowed -= expanded_allowed",
            "        if expanded_disallowed:",
            "            allowed_intersection = _intersect_expanded_scopes(",
            "                expanded_disallowed, expanded_have, db=db",
            "            )",
            "        else:",
            "            allowed_intersection = set()",
            "",
            "        if allowed_intersection == expanded_disallowed:",
            "            # full scope allowed (requested scope is subset of user scopes)",
            "            allowed_scopes.add(scope)",
            "            disallowed_scopes.remove(scope)",
            "            expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "",
            "        elif allowed_intersection:",
            "            # some scopes get through, but not all,",
            "            # allow the subset",
            "            allowed_scopes |= allowed_intersection",
            "            expanded_allowed = expand_scopes(allowed_scopes, user, client)",
            "            # choice: report that the requested scope wasn't _fully_ granted (current behavior)",
            "            # or report the exact (likely too detailed) set of not granted scopes (below)",
            "            # disallowed_scopes.remove(scope)",
            "            # disallowed_scopes |= expanded_disallowed.difference(allowed_intersection)",
            "        else:",
            "            # no new scopes granted, original check was right",
            "            pass",
            "    return (allowed_scopes, disallowed_scopes)",
            "",
            "",
            "def _needs_group_expansion(filter_, filter_value, sub_scope):",
            "    \"\"\"",
            "    Check if there is a requirements to expand the `group` scope to individual `user` scopes.",
            "    Assumptions:",
            "    filter_ != Scope.ALL",
            "    \"\"\"",
            "    if not (filter_ in {'user', 'server'} and 'group' in sub_scope):",
            "        return False",
            "    if filter_ in sub_scope:",
            "        return filter_value not in sub_scope[filter_]",
            "    else:",
            "        return True",
            "",
            "",
            "def _has_scope_key(scope, have_scopes, *, post_filter=False, db=None):",
            "    \"\"\"Cache key for has_scope\"\"\"",
            "    if isinstance(have_scopes, dict):",
            "        have_scopes = FrozenDict(have_scopes)",
            "    else:",
            "        have_scopes = frozenset(have_scopes)",
            "    return (scope, have_scopes, post_filter)",
            "",
            "",
            "@lru_cache_key(_has_scope_key)",
            "def has_scope(scope, have_scopes, *, post_filter=False, db=None):",
            "    \"\"\"Boolean function for whether we have a given scope",
            "",
            "    Args:",
            "        scope (str): a single scope",
            "        have_scopes: parsed_scopes dict or expanded_scopes set",
            "        post_filter (bool):",
            "            Allows returning true if _some_ access is granted,",
            "            if not full access.",
            "            Only allowed if scope has no filter",
            "        db (optional): the db session",
            "            Required to check group membership,",
            "            unused otherwise",
            "    Returns:",
            "        True if access is allowed, False otherwise.",
            "        If post_filer is True and have_scopes contains _filtered_ access,",
            "        will return True, assuming filtered-access will be handled later",
            "        (e.g. in the listing-users handler)",
            "    \"\"\"",
            "    req_scope, _, full_filter = scope.partition(\"!\")",
            "    filter_, _, filter_value = full_filter.partition(\"=\")",
            "    if filter_ and not filter_value:",
            "        raise ValueError(",
            "            f\"Unexpanded scope filter {scope} not allowed. Use expanded scopes.\"",
            "        )",
            "",
            "    if isinstance(have_scopes, dict):",
            "        parsed_scopes = have_scopes",
            "    else:",
            "        parsed_scopes = parse_scopes(have_scopes)",
            "",
            "    if req_scope not in parsed_scopes:",
            "        return False",
            "    have_scope_filters = parsed_scopes[req_scope]",
            "    if have_scope_filters == Scope.ALL:",
            "        # access to all resources",
            "        return True",
            "",
            "    if not filter_:",
            "        if post_filter:",
            "            # allow filtering after the fact",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    if post_filter:",
            "        raise ValueError(\"post_filter=True only allowed for unfiltered scopes\")",
            "    _db_used = False",
            "",
            "    if filter_ in have_scope_filters and filter_value in have_scope_filters[filter_]:",
            "        return True",
            "",
            "    # server->user",
            "    if filter_ == \"server\" and \"user\" in have_scope_filters:",
            "        user_name = filter_value.partition(\"/\")[0]",
            "        if user_name in have_scope_filters[\"user\"]:",
            "            return True",
            "",
            "    if db and _needs_group_expansion(filter_, filter_value, have_scope_filters):",
            "        _db_used = True",
            "        if filter_ == \"user\":",
            "            user_name = filter_value",
            "        elif filter_ == \"server\":",
            "            user_name = filter_value.partition(\"/\")[0]",
            "        else:",
            "            raise ValueError(",
            "                f\"filter_ should be 'user' or 'server' here, not {filter_!r}\"",
            "            )",
            "        group_names = have_scope_filters['group']",
            "        have_group_query = (",
            "            db.query(orm.Group.name)",
            "            .join(orm.User.groups)",
            "            .filter(orm.User.name == user_name)",
            "            .filter(orm.Group.name.in_(group_names))",
            "        )",
            "        if have_group_query.count() > 0:",
            "            return DoNotCache(True)",
            "",
            "    if _db_used:",
            "        return DoNotCache(False)",
            "    else:",
            "        return False",
            "",
            "",
            "class ScopeNotFound(KeyError):",
            "    pass",
            "",
            "",
            "def _check_scopes_exist(scopes, who_for=None):",
            "    \"\"\"Check if provided scopes exist",
            "",
            "    Arguments:",
            "      scopes (list): list of scopes to check",
            "",
            "    Raises ScopeNotFound if scope does not exist",
            "    \"\"\"",
            "",
            "    allowed_scopes = set(scope_definitions.keys())",
            "    filter_prefixes = ('!user=', '!service=', '!group=', '!server=')",
            "    exact_filters = {\"!user\", \"!service\", \"!server\"}",
            "",
            "    if who_for:",
            "        log_for = f\"for {who_for}\"",
            "    else:",
            "        log_for = \"\"",
            "",
            "    for scope in scopes:",
            "        scopename, _, filter_ = scope.partition('!')",
            "        if scopename not in allowed_scopes:",
            "            if scopename == \"all\":",
            "                raise ScopeNotFound(\"Draft scope 'all' is now called 'inherit'\")",
            "            raise ScopeNotFound(f\"Scope '{scope}' {log_for} does not exist\")",
            "        if filter_:",
            "            full_filter = f\"!{filter_}\"",
            "            if full_filter not in exact_filters and not full_filter.startswith(",
            "                filter_prefixes",
            "            ):",
            "                raise ScopeNotFound(",
            "                    f\"Scope filter {filter_} '{full_filter}' in scope '{scope}' {log_for} does not exist\"",
            "                )",
            "",
            "",
            "def _check_token_scopes(scopes, owner, oauth_client):",
            "    \"\"\"Check that scopes to be assigned to a token",
            "    are in fact",
            "",
            "    Arguments:",
            "      scopes: raw or expanded scopes",
            "      owner: orm.User or orm.Service",
            "",
            "    raises:",
            "        ValueError: if requested scopes exceed owner's assigned scopes",
            "    \"\"\"",
            "    scopes = set(scopes)",
            "    if scopes.issubset({\"inherit\"}):",
            "        # nothing to check for simple 'inherit' scopes",
            "        return",
            "    scopes.discard(\"inherit\")",
            "    # common short circuit",
            "    token_scopes = expand_scopes(scopes, owner=owner, oauth_client=oauth_client)",
            "",
            "    if not token_scopes:",
            "        return",
            "",
            "    owner_scopes = get_scopes_for(owner)",
            "    intersection = _intersect_expanded_scopes(",
            "        token_scopes,",
            "        owner_scopes,",
            "        db=sa.inspect(owner).session,",
            "    )",
            "    excess_scopes = token_scopes - intersection",
            "",
            "    if excess_scopes:",
            "        raise ValueError(",
            "            f\"Not assigning requested scopes {','.join(excess_scopes)} not held by {owner.__class__.__name__} {owner.name}\"",
            "        )",
            "",
            "",
            "@lru_cache_key(frozenset)",
            "def parse_scopes(scope_list):",
            "    \"\"\"",
            "    Parses scopes and filters in something akin to JSON style",
            "",
            "    For instance, scope list [\"users\", \"groups!group=foo\", \"servers!server=user/bar\", \"servers!server=user/baz\"]",
            "    would lead to scope model",
            "    {",
            "       \"users\":scope.ALL,",
            "       \"admin:users\":{",
            "          \"user\":[",
            "             \"alice\"",
            "          ]",
            "       },",
            "       \"servers\":{",
            "          \"server\":[",
            "             \"user/bar\",",
            "             \"user/baz\"",
            "          ]",
            "       }",
            "    }",
            "    \"\"\"",
            "    parsed_scopes = {}",
            "    for scope in scope_list:",
            "        base_scope, _, filter_ = scope.partition('!')",
            "        if not filter_:",
            "            parsed_scopes[base_scope] = Scope.ALL",
            "        elif base_scope not in parsed_scopes:",
            "            parsed_scopes[base_scope] = {}",
            "",
            "        if parsed_scopes[base_scope] != Scope.ALL:",
            "            key, _, value = filter_.partition('=')",
            "            if not value:",
            "                raise ValueError(f\"Empty string is not a valid filter: {scope}\")",
            "            if key not in parsed_scopes[base_scope]:",
            "                parsed_scopes[base_scope][key] = {value}",
            "            else:",
            "                parsed_scopes[base_scope][key].add(value)",
            "    # return immutable FrozenDict because the result is cached",
            "    return FrozenDict(parsed_scopes)",
            "",
            "",
            "@lru_cache_key(FrozenDict)",
            "def unparse_scopes(parsed_scopes):",
            "    \"\"\"Turn a parsed_scopes dictionary back into an expanded scopes set\"\"\"",
            "    expanded_scopes = set()",
            "    for base, filters in parsed_scopes.items():",
            "        if filters == Scope.ALL:",
            "            expanded_scopes.add(base)",
            "        else:",
            "            for entity, names_list in filters.items():",
            "                for name in names_list:",
            "                    expanded_scopes.add(f'{base}!{entity}={name}')",
            "    # return immutable frozenset because the result is cached",
            "    return frozenset(expanded_scopes)",
            "",
            "",
            "@lru_cache_key(frozenset)",
            "def reduce_scopes(expanded_scopes):",
            "    \"\"\"Reduce expanded scopes to minimal set",
            "",
            "    Eliminates overlapping scopes, such as access:services and access:services!service=x",
            "    \"\"\"",
            "    # unparse_scopes already returns a frozenset",
            "    return unparse_scopes(parse_scopes(expanded_scopes))",
            "",
            "",
            "def needs_scope(*scopes):",
            "    \"\"\"Decorator to restrict access to users or services with the required scope\"\"\"",
            "",
            "    for scope in scopes:",
            "        if scope not in scope_definitions:",
            "            raise ValueError(f\"Scope {scope} is not a valid scope\")",
            "",
            "    def scope_decorator(func):",
            "        @functools.wraps(func)",
            "        def _auth_func(self, *args, **kwargs):",
            "            if not self.current_user:",
            "                # not authenticated at all, fail with more generic message",
            "                # this is the most likely permission error - missing or mis-specified credentials,",
            "                # don't indicate that they have insufficient permissions.",
            "                raise web.HTTPError(",
            "                    403,",
            "                    \"Missing or invalid credentials.\",",
            "                )",
            "",
            "            sig = inspect.signature(func)",
            "            bound_sig = sig.bind(self, *args, **kwargs)",
            "            bound_sig.apply_defaults()",
            "            # Load scopes in case they haven't been loaded yet",
            "            if not hasattr(self, 'expanded_scopes'):",
            "                self.expanded_scopes = {}",
            "                self.parsed_scopes = {}",
            "",
            "            try:",
            "                end_point = self.request.path",
            "            except AttributeError:",
            "                end_point = self.__name__",
            "",
            "            s_kwargs = {}",
            "            for resource in {'user', 'server', 'group', 'service'}:",
            "                resource_name = resource + '_name'",
            "                if resource_name in bound_sig.arguments:",
            "                    resource_value = bound_sig.arguments[resource_name]",
            "                    s_kwargs[resource] = resource_value",
            "",
            "            if \"server\" in s_kwargs:",
            "                # merge user_name, server_name into server=user/server",
            "                if \"user\" not in s_kwargs:",
            "                    raise ValueError(",
            "                        \"Cannot filter on 'server_name' without 'user_name'\"",
            "                    )",
            "                s_kwargs[\"server\"] = f\"{s_kwargs['user']}/{s_kwargs['server']}\"",
            "                s_kwargs.pop(\"user\")",
            "            if len(s_kwargs) > 1:",
            "                raise ValueError(",
            "                    f\"Cannot filter on more than one field, got {s_kwargs}\"",
            "                )",
            "            elif s_kwargs:",
            "                filter_, filter_value = next(iter(s_kwargs.items()))",
            "            else:",
            "                filter_ = filter_value = None",
            "",
            "            for scope in scopes:",
            "                if filter_ is not None:",
            "                    scope = f\"{scope}!{filter_}={filter_value}\"",
            "                app_log.debug(\"Checking access to %s via scope %s\", end_point, scope)",
            "                has_access = has_scope(",
            "                    scope,",
            "                    self.parsed_scopes,",
            "                    post_filter=filter_ is None,",
            "                    db=self.db,",
            "                )",
            "                if has_access:",
            "                    return func(self, *args, **kwargs)",
            "            app_log.warning(",
            "                \"Not authorizing access to %s. Requires any of [%s] on %s, not derived from scopes [%s]\",",
            "                end_point,",
            "                \", \".join(scopes),",
            "                \"*\" if filter_ is None else f\"{filter_}={filter_value}\",",
            "                \", \".join(self.expanded_scopes),",
            "            )",
            "            if filter_ and any(scope in self.parsed_scopes for scope in scopes):",
            "                # not allowed due do filtered access,",
            "                # same error for nonexistence as missing permission",
            "                raise web.HTTPError(",
            "                    404, \"No access to resources or resources not found\"",
            "                )",
            "            raise web.HTTPError(",
            "                403,",
            "                \"Action is not authorized with current scopes;\"",
            "                f\" requires any of [{', '.join(scopes)}]\",",
            "            )",
            "",
            "        return _auth_func",
            "",
            "    return scope_decorator",
            "",
            "",
            "def _identify_key(obj=None):",
            "    if obj is None:",
            "        return None",
            "    else:",
            "        return (type(obj).__name__, obj.name)",
            "",
            "",
            "@lru_cache_key(_identify_key)",
            "def identify_scopes(obj=None):",
            "    \"\"\"Return 'identify' scopes for an orm object",
            "",
            "    Arguments:",
            "      obj (optional): orm.User or orm.Service",
            "          If not specified, 'raw' scopes for identifying the current user are returned,",
            "          which may need to be expanded, later.",
            "",
            "    Returns:",
            "      identify scopes (set): set of scopes needed for 'identify' endpoints",
            "    \"\"\"",
            "    if obj is None:",
            "        return frozenset(f\"read:users:{field}!user\" for field in {\"name\", \"groups\"})",
            "    elif isinstance(obj, orm.User):",
            "        return frozenset(",
            "            f\"read:users:{field}!user={obj.name}\" for field in {\"name\", \"groups\"}",
            "        )",
            "    elif isinstance(obj, orm.Service):",
            "        return frozenset(",
            "            f\"read:services:{field}!service={obj.name}\" for field in {\"name\"}",
            "        )",
            "    else:",
            "        raise TypeError(f\"Expected orm.User or orm.Service, got {obj!r}\")",
            "",
            "",
            "def _access_cache_key(oauth_client=None, *, spawner=None, service=None):",
            "    if oauth_client:",
            "        return (\"oauth\", oauth_client.identifier)",
            "    elif spawner:",
            "        return (\"spawner\", spawner.user.name, spawner.name)",
            "    elif service:",
            "        return (\"service\", service.name)",
            "",
            "",
            "@lru_cache_key(_access_cache_key)",
            "def access_scopes(oauth_client=None, *, spawner=None, service=None):",
            "    \"\"\"Return scope(s) required to access an oauth client\"\"\"",
            "    scopes = set()",
            "    if oauth_client and oauth_client.identifier == \"jupyterhub\":",
            "        return frozenset()",
            "    if spawner is None and oauth_client:",
            "        spawner = oauth_client.spawner",
            "    if spawner:",
            "        scopes.add(f\"access:servers!server={spawner.user.name}/{spawner.name}\")",
            "    else:",
            "        if service is None:",
            "            service = oauth_client.service",
            "        if service:",
            "            scopes.add(f\"access:services!service={service.name}\")",
            "        else:",
            "            app_log.warning(",
            "                f\"OAuth client {oauth_client} has no associated service or spawner!\"",
            "            )",
            "    return frozenset(scopes)",
            "",
            "",
            "def _check_scope_key(sub_scope, orm_resource, kind):",
            "    \"\"\"Cache key function for check_scope_filter\"\"\"",
            "    if kind == 'server':",
            "        resource_key = (orm_resource.user.name, orm_resource.name)",
            "    else:",
            "        resource_key = orm_resource.name",
            "    return (sub_scope, resource_key, kind)",
            "",
            "",
            "@lru_cache_key(_check_scope_key)",
            "def check_scope_filter(sub_scope, orm_resource, kind):",
            "    \"\"\"Return whether a sub_scope filter applies to a given resource.",
            "",
            "    param sub_scope: parsed_scopes filter (i.e. dict or Scope.ALL)",
            "    param orm_resource: User or Service or Group or Spawner",
            "    param kind: 'user' or 'service' or 'group' or 'server'.",
            "",
            "    Returns True or False",
            "    \"\"\"",
            "    if sub_scope is Scope.ALL:",
            "        return True",
            "    elif kind in sub_scope and orm_resource.name in sub_scope[kind]:",
            "        return True",
            "",
            "    if kind == 'server':",
            "        server_format = f\"{orm_resource.user.name}/{orm_resource.name}\"",
            "        if server_format in sub_scope.get(kind, []):",
            "            return True",
            "        # Fall back on checking if we have user access",
            "        if 'user' in sub_scope and orm_resource.user.name in sub_scope['user']:",
            "            return True",
            "        # Fall back on checking if we have group access for this user",
            "        orm_resource = orm_resource.user",
            "        kind = 'user'",
            "",
            "    if kind == 'user' and 'group' in sub_scope:",
            "        group_names = {group.name for group in orm_resource.groups}",
            "        user_in_group = bool(group_names & set(sub_scope['group']))",
            "        # cannot cache if we needed to lookup groups in db",
            "        return DoNotCache(user_in_group)",
            "    return False",
            "",
            "",
            "def describe_parsed_scopes(parsed_scopes, username=None):",
            "    \"\"\"Return list of descriptions of parsed scopes",
            "",
            "    Highly detailed, often redundant descriptions",
            "    \"\"\"",
            "    descriptions = []",
            "    for scope, filters in parsed_scopes.items():",
            "        if filters == Scope.ALL:",
            "            # no filter",
            "            filter_text = \"\"",
            "        else:",
            "            filter_chunks = []",
            "            for kind, names in filters.items():",
            "                if kind == 'user' and names == {username}:",
            "                    filter_chunks.append(\"only you\")",
            "                else:",
            "                    if len(names) == 1:",
            "                        filter_chunks.append(f\"{kind}: {list(names)[0]}\")",
            "                    else:",
            "                        filter_chunks.append(f\"{kind}s: {', '.join(names)}\")",
            "            filter_text = \"; or \".join(filter_chunks)",
            "        descriptions.append(",
            "            {",
            "                \"scope\": scope,",
            "                \"description\": scope_definitions[scope][\"description\"],",
            "                \"filter\": filter_text,",
            "            }",
            "        )",
            "    return descriptions",
            "",
            "",
            "@lru_cache_key(lambda raw_scopes, username=None: (frozenset(raw_scopes), username))",
            "def describe_raw_scopes(raw_scopes, username=None):",
            "    \"\"\"Return list of descriptions of raw scopes",
            "",
            "    A much shorter list than describe_parsed_scopes",
            "    \"\"\"",
            "    descriptions = []",
            "    for raw_scope in raw_scopes:",
            "        scope, _, filter_ = raw_scope.partition(\"!\")",
            "        if not filter_:",
            "            # no filter",
            "            filter_text = \"\"",
            "        elif filter_ == \"user\":",
            "            filter_text = \"only you\"",
            "        else:",
            "            kind, _, name = filter_.partition(\"=\")",
            "            if kind == \"user\" and name == username:",
            "                filter_text = \"only you\"",
            "            else:",
            "                kind_text = kind",
            "                if kind == 'group':",
            "                    kind_text = \"users in group\"",
            "                filter_text = f\"{kind_text} {name}\"",
            "        descriptions.append(",
            "            {",
            "                \"scope\": scope,",
            "                \"description\": scope_definitions[scope][\"description\"],",
            "                \"filter\": filter_text,",
            "            }",
            "        )",
            "    # make sure we return immutable from a cached function",
            "    return tuple(descriptions)",
            "",
            "",
            "# regex for custom scope",
            "# for-humans description below",
            "# note: scope description duplicated in docs/source/rbac/scopes.md",
            "# update docs when making changes here",
            "_custom_scope_pattern = re.compile(r\"^custom:[a-z0-9][a-z0-9_\\-\\*:]+[a-z0-9_\\*]$\")",
            "",
            "# custom scope pattern description",
            "# used in docstring below and error message when scopes don't match _custom_scope_pattern",
            "_custom_scope_description = \"\"\"",
            "Custom scopes must start with `custom:`",
            "and contain only lowercase ascii letters, numbers, hyphen, underscore, colon, and asterisk (-_:*).",
            "The part after `custom:` must start with a letter or number.",
            "Scopes may not end with a hyphen or colon.",
            "\"\"\"",
            "",
            "",
            "def define_custom_scopes(scopes):",
            "    \"\"\"Define custom scopes",
            "",
            "    Adds custom scopes to the scope_definitions dict.",
            "",
            "    Scopes must start with `custom:`.",
            "    It is recommended to name custom scopes with a pattern like::",
            "",
            "        custom:$your-project:$action:$resource",
            "",
            "    e.g.::",
            "",
            "        custom:jupyter_server:read:contents",
            "",
            "    That makes them easy to parse and avoids collisions across projects.",
            "",
            "    `scopes` must have at least one scope definition,",
            "    and each scope definition must have a `description`,",
            "    which will be displayed on the oauth authorization page,",
            "    and _may_ have a `subscopes` list of other scopes if having one scope",
            "    should imply having other, more specific scopes.",
            "",
            "    Args:",
            "",
            "    scopes: dict",
            "        A dictionary of scope definitions.",
            "        The keys are the scopes,",
            "        while the values are dictionaries with at least a `description` field,",
            "        and optional `subscopes` field.",
            "        CUSTOM_SCOPE_DESCRIPTION",
            "    Examples::",
            "",
            "        define_custom_scopes(",
            "            {",
            "                \"custom:jupyter_server:read:contents\": {",
            "                    \"description\": \"read-only access to files in a Jupyter server\",",
            "                },",
            "                \"custom:jupyter_server:read\": {",
            "                    \"description\": \"read-only access to a Jupyter server\",",
            "                    \"subscopes\": [",
            "                        \"custom:jupyter_server:read:contents\",",
            "                        \"custom:jupyter_server:read:kernels\",",
            "                        \"...\",",
            "                },",
            "            }",
            "        )",
            "    \"\"\".replace(\"CUSTOM_SCOPE_DESCRIPTION\", indent(_custom_scope_description, \" \" * 8))",
            "    for scope, scope_definition in scopes.items():",
            "        if scope in scope_definitions and scope_definitions[scope] != scope_definition:",
            "            raise ValueError(",
            "                f\"Cannot redefine scope {scope}={scope_definition}. Already have {scope}={scope_definitions[scope]}\"",
            "            )",
            "        if not _custom_scope_pattern.match(scope):",
            "            # note: keep this description in sync with docstring above",
            "            raise ValueError(",
            "                f\"Invalid scope name: {scope!r}.\\n{_custom_scope_description}\"",
            "                \" and contain only lowercase ascii letters, numbers, hyphen, underscore, colon, and asterisk.\"",
            "                \" The part after `custom:` must start with a letter or number.\"",
            "                \" Scopes may not end with a hyphen or colon.\"",
            "            )",
            "        if \"description\" not in scope_definition:",
            "            raise ValueError(",
            "                f\"scope {scope}={scope_definition} missing key 'description'\"",
            "            )",
            "        if \"subscopes\" in scope_definition:",
            "            subscopes = scope_definition[\"subscopes\"]",
            "            if not isinstance(subscopes, list) or not all(",
            "                isinstance(s, str) for s in subscopes",
            "            ):",
            "                raise ValueError(",
            "                    f\"subscopes must be a list of scope strings, got {subscopes!r}\"",
            "                )",
            "            for subscope in subscopes:",
            "                if subscope not in scopes:",
            "                    if subscope in scope_definitions:",
            "                        raise ValueError(",
            "                            f\"non-custom subscope {subscope} in {scope}={scope_definition} is not allowed.\"",
            "                            f\" Custom scopes may only have custom subscopes.\"",
            "                            f\" Roles should be used to assign multiple scopes together.\"",
            "                        )",
            "                    raise ValueError(",
            "                        f\"subscope {subscope} in {scope}={scope_definition} not found. All scopes must be defined.\"",
            "                    )",
            "",
            "        extra_keys = set(scope_definition.keys()).difference(",
            "            [\"description\", \"subscopes\"]",
            "        )",
            "        if extra_keys:",
            "            warnings.warn(",
            "                f\"Ignoring unrecognized key(s) {', '.join(extra_keys)!r} in {scope}={scope_definition}\",",
            "                UserWarning,",
            "                stacklevel=2,",
            "            )",
            "        app_log.info(f\"Defining custom scope {scope}\")",
            "        # deferred evaluation for debug-logging",
            "        app_log.debug(\"Defining custom scope %s=%s\", scope, scope_definition)",
            "        scope_definitions[scope] = scope_definition"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "51": [],
            "112": []
        },
        "addLocation": []
    },
    "jupyterhub/tests/test_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 775,
                "afterPatchRowNumber": 775,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 776,
                "afterPatchRowNumber": 776,
                "PatchRowcode": " @mark.user"
            },
            "2": {
                "beforePatchRowNumber": 777,
                "afterPatchRowNumber": 777,
                "PatchRowcode": " @mark.role"
            },
            "3": {
                "beforePatchRowNumber": 778,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-async def test_add_multi_user_admin(app):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 778,
                "PatchRowcode": "+@mark.parametrize(\"is_admin\", [True, False])"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 779,
                "PatchRowcode": "+async def test_add_multi_user_admin(app, create_user_with_scopes, is_admin):"
            },
            "6": {
                "beforePatchRowNumber": 779,
                "afterPatchRowNumber": 780,
                "PatchRowcode": "     db = app.db"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 781,
                "PatchRowcode": "+    requester = create_user_with_scopes(\"admin:users\")"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 782,
                "PatchRowcode": "+    requester.admin = is_admin"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 783,
                "PatchRowcode": "+    db.commit()"
            },
            "10": {
                "beforePatchRowNumber": 780,
                "afterPatchRowNumber": 784,
                "PatchRowcode": "     names = ['c', 'd']"
            },
            "11": {
                "beforePatchRowNumber": 781,
                "afterPatchRowNumber": 785,
                "PatchRowcode": "     r = await api_request("
            },
            "12": {
                "beforePatchRowNumber": 782,
                "afterPatchRowNumber": 786,
                "PatchRowcode": "         app,"
            },
            "13": {
                "beforePatchRowNumber": 783,
                "afterPatchRowNumber": 787,
                "PatchRowcode": "         'users',"
            },
            "14": {
                "beforePatchRowNumber": 784,
                "afterPatchRowNumber": 788,
                "PatchRowcode": "         method='post',"
            },
            "15": {
                "beforePatchRowNumber": 785,
                "afterPatchRowNumber": 789,
                "PatchRowcode": "         data=json.dumps({'usernames': names, 'admin': True}),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 790,
                "PatchRowcode": "+        name=requester.name,"
            },
            "17": {
                "beforePatchRowNumber": 786,
                "afterPatchRowNumber": 791,
                "PatchRowcode": "     )"
            },
            "18": {
                "beforePatchRowNumber": 787,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert r.status_code == 201"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 792,
                "PatchRowcode": "+    if is_admin:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 793,
                "PatchRowcode": "+        assert r.status_code == 201"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 794,
                "PatchRowcode": "+    else:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 795,
                "PatchRowcode": "+        assert r.status_code == 403"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 796,
                "PatchRowcode": "+        return"
            },
            "24": {
                "beforePatchRowNumber": 788,
                "afterPatchRowNumber": 797,
                "PatchRowcode": "     reply = r.json()"
            },
            "25": {
                "beforePatchRowNumber": 789,
                "afterPatchRowNumber": 798,
                "PatchRowcode": "     r_names = [user['name'] for user in reply]"
            },
            "26": {
                "beforePatchRowNumber": 790,
                "afterPatchRowNumber": 799,
                "PatchRowcode": "     assert names == r_names"
            },
            "27": {
                "beforePatchRowNumber": 822,
                "afterPatchRowNumber": 831,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 823,
                "afterPatchRowNumber": 832,
                "PatchRowcode": " @mark.user"
            },
            "29": {
                "beforePatchRowNumber": 824,
                "afterPatchRowNumber": 833,
                "PatchRowcode": " @mark.role"
            },
            "30": {
                "beforePatchRowNumber": 825,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-async def test_add_admin(app):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 834,
                "PatchRowcode": "+@mark.parametrize(\"is_admin\", [True, False])"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 835,
                "PatchRowcode": "+async def test_add_admin(app, create_user_with_scopes, is_admin):"
            },
            "33": {
                "beforePatchRowNumber": 826,
                "afterPatchRowNumber": 836,
                "PatchRowcode": "     db = app.db"
            },
            "34": {
                "beforePatchRowNumber": 827,
                "afterPatchRowNumber": 837,
                "PatchRowcode": "     name = 'newadmin'"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 838,
                "PatchRowcode": "+    user = create_user_with_scopes(\"admin:users\")"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 839,
                "PatchRowcode": "+    user.admin = is_admin"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 840,
                "PatchRowcode": "+    db.commit()"
            },
            "38": {
                "beforePatchRowNumber": 828,
                "afterPatchRowNumber": 841,
                "PatchRowcode": "     r = await api_request("
            },
            "39": {
                "beforePatchRowNumber": 829,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        app, 'users', name, method='post', data=json.dumps({'admin': True})"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 842,
                "PatchRowcode": "+        app,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 843,
                "PatchRowcode": "+        'users',"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 844,
                "PatchRowcode": "+        name,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 845,
                "PatchRowcode": "+        method='post',"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 846,
                "PatchRowcode": "+        data=json.dumps({'admin': True}),"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 847,
                "PatchRowcode": "+        name=user.name,"
            },
            "46": {
                "beforePatchRowNumber": 830,
                "afterPatchRowNumber": 848,
                "PatchRowcode": "     )"
            },
            "47": {
                "beforePatchRowNumber": 831,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert r.status_code == 201"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 849,
                "PatchRowcode": "+    if is_admin:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 850,
                "PatchRowcode": "+        assert r.status_code == 201"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 851,
                "PatchRowcode": "+    else:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 852,
                "PatchRowcode": "+        assert r.status_code == 403"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 853,
                "PatchRowcode": "+        return"
            },
            "53": {
                "beforePatchRowNumber": 832,
                "afterPatchRowNumber": 854,
                "PatchRowcode": "     user = find_user(db, name)"
            },
            "54": {
                "beforePatchRowNumber": 833,
                "afterPatchRowNumber": 855,
                "PatchRowcode": "     assert user is not None"
            },
            "55": {
                "beforePatchRowNumber": 834,
                "afterPatchRowNumber": 856,
                "PatchRowcode": "     assert user.name == name"
            },
            "56": {
                "beforePatchRowNumber": 848,
                "afterPatchRowNumber": 870,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 849,
                "afterPatchRowNumber": 871,
                "PatchRowcode": " @mark.user"
            },
            "58": {
                "beforePatchRowNumber": 850,
                "afterPatchRowNumber": 872,
                "PatchRowcode": " @mark.role"
            },
            "59": {
                "beforePatchRowNumber": 851,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-async def test_make_admin(app):"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 873,
                "PatchRowcode": "+@mark.parametrize(\"is_admin\", [True, False])"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 874,
                "PatchRowcode": "+async def test_user_make_admin(app, create_user_with_scopes, is_admin):"
            },
            "62": {
                "beforePatchRowNumber": 852,
                "afterPatchRowNumber": 875,
                "PatchRowcode": "     db = app.db"
            },
            "63": {
                "beforePatchRowNumber": 853,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    name = 'admin2'"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 876,
                "PatchRowcode": "+    requester = create_user_with_scopes('admin:users')"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 877,
                "PatchRowcode": "+    requester.admin = is_admin"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 878,
                "PatchRowcode": "+    db.commit()"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 879,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 880,
                "PatchRowcode": "+    name = new_username(\"make_admin\")"
            },
            "69": {
                "beforePatchRowNumber": 854,
                "afterPatchRowNumber": 881,
                "PatchRowcode": "     r = await api_request(app, 'users', name, method='post')"
            },
            "70": {
                "beforePatchRowNumber": 855,
                "afterPatchRowNumber": 882,
                "PatchRowcode": "     assert r.status_code == 201"
            },
            "71": {
                "beforePatchRowNumber": 856,
                "afterPatchRowNumber": 883,
                "PatchRowcode": "     user = find_user(db, name)"
            },
            "72": {
                "beforePatchRowNumber": 861,
                "afterPatchRowNumber": 888,
                "PatchRowcode": "     assert orm.Role.find(db, 'admin') not in user.roles"
            },
            "73": {
                "beforePatchRowNumber": 862,
                "afterPatchRowNumber": 889,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 863,
                "afterPatchRowNumber": 890,
                "PatchRowcode": "     r = await api_request("
            },
            "75": {
                "beforePatchRowNumber": 864,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        app, 'users', name, method='patch', data=json.dumps({'admin': True})"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 891,
                "PatchRowcode": "+        app,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 892,
                "PatchRowcode": "+        'users',"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 893,
                "PatchRowcode": "+        name,"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 894,
                "PatchRowcode": "+        method='patch',"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 895,
                "PatchRowcode": "+        data=json.dumps({'admin': True}),"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 896,
                "PatchRowcode": "+        name=requester.name,"
            },
            "82": {
                "beforePatchRowNumber": 865,
                "afterPatchRowNumber": 897,
                "PatchRowcode": "     )"
            },
            "83": {
                "beforePatchRowNumber": 866,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "84": {
                "beforePatchRowNumber": 867,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert r.status_code == 200"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 898,
                "PatchRowcode": "+    if is_admin:"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 899,
                "PatchRowcode": "+        assert r.status_code == 200"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 900,
                "PatchRowcode": "+    else:"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 901,
                "PatchRowcode": "+        assert r.status_code == 403"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 902,
                "PatchRowcode": "+        return"
            },
            "90": {
                "beforePatchRowNumber": 868,
                "afterPatchRowNumber": 903,
                "PatchRowcode": "     user = find_user(db, name)"
            },
            "91": {
                "beforePatchRowNumber": 869,
                "afterPatchRowNumber": 904,
                "PatchRowcode": "     assert user is not None"
            },
            "92": {
                "beforePatchRowNumber": 870,
                "afterPatchRowNumber": 905,
                "PatchRowcode": "     assert user.name == name"
            },
            "93": {
                "beforePatchRowNumber": 873,
                "afterPatchRowNumber": 908,
                "PatchRowcode": "     assert orm.Role.find(db, 'admin') in user.roles"
            },
            "94": {
                "beforePatchRowNumber": 874,
                "afterPatchRowNumber": 909,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": 875,
                "afterPatchRowNumber": 910,
                "PatchRowcode": " "
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 911,
                "PatchRowcode": "+@mark.user"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 912,
                "PatchRowcode": "+@mark.parametrize(\"requester_is_admin\", [True, False])"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 913,
                "PatchRowcode": "+@mark.parametrize(\"user_is_admin\", [True, False])"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 914,
                "PatchRowcode": "+async def test_user_set_name("
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 915,
                "PatchRowcode": "+    app, user, create_user_with_scopes, requester_is_admin, user_is_admin"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 916,
                "PatchRowcode": "+):"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 917,
                "PatchRowcode": "+    db = app.db"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 918,
                "PatchRowcode": "+    requester = create_user_with_scopes('admin:users')"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 919,
                "PatchRowcode": "+    requester.admin = requester_is_admin"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 920,
                "PatchRowcode": "+    user.admin = user_is_admin"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 921,
                "PatchRowcode": "+    db.commit()"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 922,
                "PatchRowcode": "+    new_name = new_username()"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 923,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 924,
                "PatchRowcode": "+    r = await api_request("
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 925,
                "PatchRowcode": "+        app,"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 926,
                "PatchRowcode": "+        'users',"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 927,
                "PatchRowcode": "+        user.name,"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 928,
                "PatchRowcode": "+        method='patch',"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 929,
                "PatchRowcode": "+        data=json.dumps({'name': new_name}),"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 930,
                "PatchRowcode": "+        name=requester.name,"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 931,
                "PatchRowcode": "+    )"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 932,
                "PatchRowcode": "+    if requester_is_admin or not user_is_admin:"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 933,
                "PatchRowcode": "+        assert r.status_code == 200"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 934,
                "PatchRowcode": "+    else:"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 935,
                "PatchRowcode": "+        assert r.status_code == 403"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 936,
                "PatchRowcode": "+        return"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 937,
                "PatchRowcode": "+    renamed = find_user(db, new_name)"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 938,
                "PatchRowcode": "+    assert renamed is not None"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 939,
                "PatchRowcode": "+    assert renamed.name == new_name"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 940,
                "PatchRowcode": "+    assert renamed.id == user.id"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 941,
                "PatchRowcode": "+"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 942,
                "PatchRowcode": "+"
            },
            "128": {
                "beforePatchRowNumber": 876,
                "afterPatchRowNumber": 943,
                "PatchRowcode": " @mark.user"
            },
            "129": {
                "beforePatchRowNumber": 877,
                "afterPatchRowNumber": 944,
                "PatchRowcode": " async def test_set_auth_state(app, auth_state_enabled):"
            },
            "130": {
                "beforePatchRowNumber": 878,
                "afterPatchRowNumber": 945,
                "PatchRowcode": "     auth_state = {'secret': 'hello'}"
            }
        },
        "frontPatchFile": [
            "\"\"\"Tests for the REST API.\"\"\"",
            "",
            "import asyncio",
            "import json",
            "import re",
            "import sys",
            "import uuid",
            "from copy import deepcopy",
            "from dataclasses import dataclass",
            "from datetime import datetime, timedelta",
            "from unittest import mock",
            "from urllib.parse import parse_qs, quote, urlparse",
            "",
            "import pytest",
            "from dateutil.parser import parse as parse_date",
            "from pytest import fixture, mark",
            "from tornado.httputil import url_concat",
            "",
            "import jupyterhub",
            "",
            "from .. import orm",
            "from ..apihandlers.base import PAGINATION_MEDIA_TYPE",
            "from ..objects import Server",
            "from ..utils import url_path_join as ujoin",
            "from ..utils import utcnow",
            "from .conftest import new_username",
            "from .utils import (",
            "    add_user,",
            "    api_request,",
            "    async_requests,",
            "    auth_header,",
            "    find_user,",
            "    public_host,",
            "    public_url,",
            ")",
            "",
            "# --------------------",
            "# Authentication tests",
            "# --------------------",
            "",
            "",
            "async def test_auth_api(app):",
            "    db = app.db",
            "    r = await api_request(app, 'authorizations', 'gobbledygook')",
            "    assert r.status_code == 404",
            "",
            "    # make a new cookie token",
            "    user = find_user(db, 'admin')",
            "    api_token = user.new_api_token()",
            "",
            "    # check success:",
            "    r = await api_request(app, 'authorizations/token', api_token)",
            "    assert r.status_code == 200",
            "    reply = r.json()",
            "    assert reply['name'] == user.name",
            "",
            "    # check fail",
            "    r = await api_request(",
            "        app, 'authorizations/token', api_token, headers={'Authorization': 'no sir'}",
            "    )",
            "    assert r.status_code == 403",
            "",
            "    r = await api_request(",
            "        app,",
            "        'authorizations/token',",
            "        api_token,",
            "        headers={'Authorization': f'token: {user.cookie_id}'},",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.parametrize(",
            "    \"content_type, status\",",
            "    [",
            "        (\"text/plain\", 403),",
            "        # accepted, but invalid",
            "        (\"application/json; charset=UTF-8\", 400),",
            "    ],",
            ")",
            "async def test_post_content_type(app, content_type, status):",
            "    url = ujoin(public_host(app), app.hub.base_url)",
            "    host = urlparse(url).netloc",
            "    # add admin user",
            "    user = find_user(app.db, 'admin')",
            "    if user is None:",
            "        user = add_user(app.db, name='admin', admin=True)",
            "    cookies = await app.login_user('admin')",
            "",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data='{}',",
            "        headers={",
            "            \"Authorization\": \"\",",
            "            \"Content-Type\": content_type,",
            "        },",
            "        cookies=cookies,",
            "    )",
            "    assert r.status_code == status",
            "",
            "",
            "@mark.parametrize(\"xsrf_in_url\", [True, False, \"invalid\"])",
            "@mark.parametrize(",
            "    \"method, path\",",
            "    [",
            "        (\"GET\", \"user\"),",
            "        (\"POST\", \"users/{username}/tokens\"),",
            "    ],",
            ")",
            "async def test_xsrf_check(app, username, method, path, xsrf_in_url):",
            "    cookies = await app.login_user(username)",
            "    xsrf = cookies['_xsrf']",
            "    if xsrf_in_url == \"invalid\":",
            "        cookies.pop(\"_xsrf\")",
            "        # a valid old-style tornado xsrf token is no longer valid",
            "        xsrf = cookies['_xsrf'] = (",
            "            \"2|7329b149|d837ced983e8aac7468bc7a61ce3d51a|1708610065\"",
            "        )",
            "",
            "    url = path.format(username=username)",
            "    if xsrf_in_url:",
            "        url = f\"{url}?_xsrf={xsrf}\"",
            "",
            "    r = await api_request(",
            "        app,",
            "        url,",
            "        noauth=True,",
            "        cookies=cookies,",
            "    )",
            "    if xsrf_in_url is True:",
            "        assert r.status_code == 200",
            "    else:",
            "        assert r.status_code == 403",
            "",
            "",
            "@mark.parametrize(",
            "    \"auth, expected_message\",",
            "    [",
            "        (\"\", \"Missing or invalid credentials\"),",
            "        (\"cookie_no_xsrf\", \"'_xsrf' argument missing from GET\"),",
            "        (\"cookie_xsrf_mismatch\", \"XSRF cookie does not match GET argument\"),",
            "        (\"token_no_scope\", \"requires any of [list:users]\"),",
            "        (\"cookie_no_scope\", \"requires any of [list:users]\"),",
            "    ],",
            ")",
            "async def test_permission_error_messages(app, user, auth, expected_message):",
            "    # 1. no credentials, should be 403 and not mention xsrf",
            "",
            "    url = public_url(app, path=\"hub/api/users\")",
            "",
            "    kwargs = {}",
            "    kwargs[\"headers\"] = headers = {}",
            "    kwargs[\"params\"] = params = {}",
            "    if auth == \"token_no_scope\":",
            "        token = user.new_api_token()",
            "        headers[\"Authorization\"] = f\"Bearer {token}\"",
            "    elif \"cookie\" in auth:",
            "        cookies = kwargs[\"cookies\"] = await app.login_user(user.name)",
            "        if auth == \"cookie_no_scope\":",
            "            params[\"_xsrf\"] = cookies[\"_xsrf\"]",
            "        if auth == \"cookie_xsrf_mismatch\":",
            "            params[\"_xsrf\"] = \"somethingelse\"",
            "    headers['Sec-Fetch-Mode'] = 'cors'",
            "    r = await async_requests.get(url, **kwargs)",
            "    assert r.status_code == 403",
            "    response = r.json()",
            "    message = response[\"message\"]",
            "    assert expected_message in message",
            "",
            "",
            "# --------------",
            "# User API tests",
            "# --------------",
            "",
            "",
            "def normalize_timestamp(ts):",
            "    \"\"\"Normalize a timestamp",
            "",
            "    For easier comparison",
            "    \"\"\"",
            "    if ts is None:",
            "        return",
            "    return re.sub(r'\\d(\\.\\d+)?', '0', ts)",
            "",
            "",
            "def normalize_user(user):",
            "    \"\"\"Normalize a user model for comparison",
            "",
            "    smooths out user model with things like timestamps",
            "    for easier comparison",
            "    \"\"\"",
            "    for key in ('created', 'last_activity'):",
            "        user[key] = normalize_timestamp(user[key])",
            "    if 'roles' in user:",
            "        user['roles'] = sorted(user['roles'])",
            "    if 'servers' in user:",
            "        for server in user['servers'].values():",
            "            for key in ('started', 'last_activity'):",
            "                server[key] = normalize_timestamp(server[key])",
            "            server['progress_url'] = re.sub(",
            "                r'.*/hub/api', 'PREFIX/hub/api', server['progress_url']",
            "            )",
            "            if isinstance(server['state'], dict) and isinstance(",
            "                server['state'].get('pid', None), int",
            "            ):",
            "                server['state']['pid'] = 0",
            "    return user",
            "",
            "",
            "def fill_user(model):",
            "    \"\"\"Fill a default user model",
            "",
            "    Any unspecified fields will be filled with the defaults",
            "    \"\"\"",
            "    model.setdefault('server', None)",
            "    model.setdefault('kind', 'user')",
            "    model.setdefault('roles', [])",
            "    model.setdefault('groups', [])",
            "    model.setdefault('admin', False)",
            "    model.setdefault('pending', None)",
            "    model.setdefault('created', TIMESTAMP)",
            "    model.setdefault('last_activity', TIMESTAMP)",
            "    model.setdefault('servers', {})",
            "    return model",
            "",
            "",
            "TIMESTAMP = normalize_timestamp(datetime.now().isoformat() + 'Z')",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_get_users(app):",
            "    db = app.db",
            "",
            "    r = await api_request(app, 'users', headers=auth_header(db, 'admin'))",
            "    assert r.status_code == 200",
            "",
            "    users = sorted(r.json(), key=lambda d: d['name'])",
            "    users = [normalize_user(u) for u in users]",
            "    user_model = {",
            "        'name': 'user',",
            "        'admin': False,",
            "        'roles': ['user'],",
            "        'auth_state': None,",
            "    }",
            "    assert users == [",
            "        fill_user(",
            "            {",
            "                'name': 'admin',",
            "                'admin': True,",
            "                'roles': ['admin', 'user'],",
            "                'auth_state': None,",
            "            }",
            "        ),",
            "        fill_user(user_model),",
            "    ]",
            "    r = await api_request(app, 'users', headers=auth_header(db, 'user'))",
            "    assert r.status_code == 403",
            "",
            "",
            "@fixture",
            "def default_page_limit(app):",
            "    \"\"\"Set and return low default page size for testing\"\"\"",
            "    n = 10",
            "    with mock.patch.dict(app.tornado_settings, {\"api_page_default_limit\": n}):",
            "        yield n",
            "",
            "",
            "@fixture",
            "def max_page_limit(app):",
            "    \"\"\"Set and return low max page size for testing\"\"\"",
            "    n = 20",
            "    with mock.patch.dict(app.tornado_settings, {\"api_page_max_limit\": n}):",
            "        yield n",
            "",
            "",
            "@mark.user",
            "@mark.parametrize(",
            "    \"n, offset, limit, accepts_pagination, expected_count, include_stopped_servers\",",
            "    [",
            "        (10, None, None, False, 10, False),",
            "        (10, None, None, True, 10, False),",
            "        (10, 5, None, True, 5, False),",
            "        (10, 5, None, False, 5, False),",
            "        (10, None, 5, True, 5, True),",
            "        (10, 5, 1, True, 1, True),",
            "        (10, 10, 10, True, 0, False),",
            "        (  # default page limit, pagination expected",
            "            30,",
            "            None,",
            "            None,",
            "            True,",
            "            'default',",
            "            False,",
            "        ),",
            "        (",
            "            # default max page limit, pagination not expected",
            "            30,",
            "            None,",
            "            None,",
            "            False,",
            "            'max',",
            "            False,",
            "        ),",
            "        (",
            "            # limit exceeded",
            "            30,",
            "            None,",
            "            500,",
            "            False,",
            "            'max',",
            "            False,",
            "        ),",
            "    ],",
            ")",
            "async def test_get_users_pagination(",
            "    app,",
            "    n,",
            "    offset,",
            "    limit,",
            "    accepts_pagination,",
            "    expected_count,",
            "    default_page_limit,",
            "    max_page_limit,",
            "    include_stopped_servers,",
            "):",
            "    db = app.db",
            "",
            "    if expected_count == 'default':",
            "        expected_count = default_page_limit",
            "    elif expected_count == 'max':",
            "        expected_count = max_page_limit",
            "    # populate users",
            "    usernames = []",
            "",
            "    groups = []",
            "    for i in range(3):",
            "        group = orm.Group(name=f\"pagination-{i}\")",
            "        db.add(group)",
            "    db.commit()",
            "    existing_users = db.query(orm.User).order_by(orm.User.id.asc())",
            "    usernames.extend(u.name for u in existing_users)",
            "",
            "    for i in range(n - existing_users.count()):",
            "        name = new_username()",
            "        usernames.append(name)",
            "        user = add_user(db, app, name=name)",
            "        # add some users to groups",
            "        # make sure group membership doesn't affect pagination count",
            "        if i % 2:",
            "            user.groups = groups",
            "    db.commit()",
            "",
            "    total_users = db.query(orm.User).count()",
            "",
            "    url = 'users'",
            "    params = {}",
            "    if offset:",
            "        params['offset'] = offset",
            "    if limit:",
            "        params['limit'] = limit",
            "    url = url_concat(url, params)",
            "    if include_stopped_servers:",
            "        # assumes limit is set. There doesn't seem to be a way to set valueless query",
            "        # params using url_cat",
            "        url += \"&include_stopped_servers\"",
            "",
            "    headers = auth_header(db, 'admin')",
            "    if accepts_pagination:",
            "        headers['Accept'] = PAGINATION_MEDIA_TYPE",
            "    r = await api_request(app, url, headers=headers)",
            "    assert r.status_code == 200",
            "    response = r.json()",
            "    if accepts_pagination:",
            "        assert set(response) == {",
            "            \"items\",",
            "            \"_pagination\",",
            "        }",
            "        pagination = response[\"_pagination\"]",
            "        if include_stopped_servers and pagination[\"next\"]:",
            "            next_query = parse_qs(",
            "                urlparse(pagination[\"next\"][\"url\"]).query, keep_blank_values=True",
            "            )",
            "            assert \"include_stopped_servers\" in next_query",
            "        users = response[\"items\"]",
            "        assert pagination[\"total\"] == total_users",
            "    else:",
            "        users = response",
            "    assert len(users) == expected_count",
            "    expected_usernames = usernames",
            "    if offset:",
            "        expected_usernames = expected_usernames[offset:]",
            "    expected_usernames = expected_usernames[:expected_count]",
            "",
            "    got_usernames = [u['name'] for u in users]",
            "    assert got_usernames == expected_usernames",
            "",
            "",
            "@mark.user",
            "@mark.parametrize(",
            "    \"state\",",
            "    (\"inactive\", \"active\", \"ready\", \"invalid\"),",
            ")",
            "async def test_get_users_state_filter(app, state):",
            "    db = app.db",
            "",
            "    # has_one_active: one active, one inactive, zero ready",
            "    has_one_active = add_user(db, app=app, name='has_one_active')",
            "    # has_two_active: two active, ready servers",
            "    has_two_active = add_user(db, app=app, name='has_two_active')",
            "    # has_two_inactive: two spawners, neither active",
            "    has_two_inactive = add_user(db, app=app, name='has_two_inactive')",
            "    # has_zero: no Spawners registered at all",
            "    has_zero = add_user(db, app=app, name='has_zero')",
            "    total_users = db.query(orm.User).count()",
            "",
            "    test_usernames = {",
            "        \"has_one_active\",",
            "        \"has_two_active\",",
            "        \"has_two_inactive\",",
            "        \"has_zero\",",
            "    }",
            "",
            "    user_states = {",
            "        \"inactive\": [\"has_two_inactive\", \"has_zero\"],",
            "        \"ready\": [\"has_two_active\"],",
            "        \"active\": [\"has_one_active\", \"has_two_active\"],",
            "        \"invalid\": [],",
            "    }",
            "    expected = user_states[state]",
            "",
            "    def add_spawner(user, name='', active=True, ready=True):",
            "        \"\"\"Add a spawner in a requested state",
            "",
            "        If active, should turn up in an active query",
            "        If active and ready, should turn up in a ready query",
            "        If not active, should turn up in an inactive query",
            "        \"\"\"",
            "        spawner = user.spawners[name]",
            "        db.commit()",
            "        if active:",
            "            orm_server = orm.Server()",
            "            db.add(orm_server)",
            "            db.commit()",
            "            spawner.server = Server(orm_server=orm_server)",
            "            db.commit()",
            "            if not ready:",
            "                spawner._spawn_pending = True",
            "        return spawner",
            "",
            "    for name in (\"\", \"secondary\"):",
            "        add_spawner(has_two_active, name, active=True)",
            "        add_spawner(has_two_inactive, name, active=False)",
            "",
            "    add_spawner(has_one_active, active=True, ready=False)",
            "    add_spawner(has_one_active, \"inactive\", active=False)",
            "",
            "    r = await api_request(",
            "        app, f'users?state={state}', headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    if state == \"invalid\":",
            "        assert r.status_code == 400",
            "        return",
            "    assert r.status_code == 200",
            "",
            "    response = r.json()",
            "    users = response[\"items\"]",
            "    page = response[\"_pagination\"]",
            "",
            "    usernames = sorted(u[\"name\"] for u in users if u[\"name\"] in test_usernames)",
            "    assert usernames == expected",
            "    if state == \"ready\":",
            "        # \"ready\" can't actually get a correct count because it has post-filtering applied",
            "        # but it has an upper bound",
            "        assert page[\"total\"] >= len(users)",
            "    else:",
            "        assert page[\"total\"] == len(users)",
            "",
            "",
            "@mark.user",
            "async def test_get_users_name_filter(app):",
            "    db = app.db",
            "",
            "    add_user(db, app=app, name='q')",
            "    add_user(db, app=app, name='qr')",
            "    add_user(db, app=app, name='qrs')",
            "    add_user(db, app=app, name='qrst')",
            "    added_usernames = {'q', 'qr', 'qrs', 'qrst'}",
            "",
            "    r = await api_request(app, 'users')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert added_usernames.intersection(response_users) == added_usernames",
            "",
            "    r = await api_request(app, 'users?name_filter=q')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['q', 'qr', 'qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qr')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qr', 'qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qrs')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qrst')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qrst']",
            "",
            "",
            "@mark.user",
            "@pytest.mark.parametrize(\"direction\", [\"asc\", \"desc\"])",
            "@pytest.mark.parametrize(\"sort\", [\"id\", \"name\", \"last_activity\"])",
            "async def test_get_users_sort(app, sort, direction):",
            "    db = app.db",
            "",
            "    # 4 users, different order depending on sort field",
            "    orders = {",
            "        \"id\": [\"1\", \"2\", \"3\", \"4\"],",
            "        \"name\": [\"a\", \"b\", \"c\", \"d\"],",
            "        \"last_activity\": [\"never\", \"early\", \"middle\", \"late\"],",
            "    }",
            "    expected_order = orders[sort]",
            "    sort_param = sort",
            "    if direction == \"desc\":",
            "        expected_order.reverse()",
            "        sort_param = \"-\" + sort",
            "",
            "    # create the users, encode the expected sort order in the names",
            "    u = add_user(db, app=app, name='xyz-c-1-middle')",
            "    u.last_activity = utcnow() - timedelta(hours=1)",
            "    u = add_user(db, app=app, name='xyz-a-2-late')",
            "    u.last_activity = utcnow()",
            "    u = add_user(db, app=app, name='xyz-d-3-never')",
            "    u.last_activity = None",
            "    u = add_user(db, app=app, name='xyz-b-4-early')",
            "    u.last_activity = utcnow() - timedelta(days=1)",
            "    app.db.commit()",
            "",
            "    @dataclass",
            "    class UserName:",
            "        \"\"\"Parse username so we can get the current sort field\"\"\"",
            "",
            "        id: str",
            "        name: str",
            "        last_activity: str",
            "",
            "        def __init__(self, username):",
            "            prefix, self.name, self.id, self.last_activity = username.split(\"-\")",
            "",
            "    # fetch 4 users in 2 pages of 2 items each",
            "    # to ensure offset is handled correctly",
            "    params = {",
            "        \"name_filter\": \"xyz\",",
            "        \"sort\": sort_param,",
            "        \"limit\": 2,",
            "    }",
            "",
            "    r = await api_request(",
            "        app, 'users', params=params, headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    assert r.status_code == 200",
            "    page_1 = r.json()",
            "",
            "    assert page_1[\"_pagination\"][\"total\"] == 4",
            "    users = page_1[\"items\"]",
            "    assert len(users) == 2",
            "",
            "    # next page",
            "    params[\"offset\"] = page_1[\"_pagination\"][\"next\"][\"offset\"]",
            "    r = await api_request(",
            "        app, 'users', params=params, headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    assert r.status_code == 200",
            "    page_2 = r.json()",
            "",
            "    # turn user dicts into list of only the relevant component,",
            "    # e.g. { \"name\": \"xyz-a-2-late\" } -> \"late\"",
            "    users.extend(page_2[\"items\"])",
            "    usernames = [UserName(u[\"name\"]) for u in users]",
            "    sorted_fields = [getattr(u, sort) for u in usernames]",
            "    assert sorted_fields == expected_order",
            "",
            "",
            "async def test_get_users_sort_invalid(app):",
            "    r = await api_request(app, \"users\", params={\"sort\": \"servers\"})",
            "    assert r.status_code == 400",
            "    r = await api_request(app, \"users\", params={\"sort\": \"--id\"})",
            "    assert r.status_code == 400",
            "",
            "",
            "@mark.user",
            "async def test_get_self(app):",
            "    db = app.db",
            "",
            "    # basic get self",
            "    r = await api_request(app, 'user')",
            "    r.raise_for_status()",
            "    assert r.json()['kind'] == 'user'",
            "",
            "    # identifying user via oauth token works",
            "    u = add_user(db, app=app, name='orpheus')",
            "    token = uuid.uuid4().hex",
            "    oauth_client = orm.OAuthClient(identifier='eurydice')",
            "    db.add(oauth_client)",
            "    db.commit()",
            "    oauth_token = orm.APIToken(",
            "        token=token,",
            "    )",
            "    db.add(oauth_token)",
            "    oauth_token.user = u.orm_user",
            "    oauth_token.oauth_client = oauth_client",
            "",
            "    db.commit()",
            "    r = await api_request(",
            "        app,",
            "        'user',",
            "        headers={'Authorization': 'token ' + token},",
            "    )",
            "    r.raise_for_status()",
            "    model = r.json()",
            "    assert model['name'] == u.name",
            "    assert model[\"token_id\"] == oauth_token.api_id",
            "",
            "    # invalid auth gets 403",
            "    r = await api_request(",
            "        app,",
            "        'user',",
            "        headers={'Authorization': 'token notvalid'},",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "async def test_get_self_service(app, mockservice):",
            "    r = await api_request(",
            "        app, \"user\", headers={\"Authorization\": f\"token {mockservice.api_token}\"}",
            "    )",
            "    r.raise_for_status()",
            "    service_info = r.json()",
            "",
            "    assert service_info['kind'] == 'service'",
            "    assert service_info['name'] == mockservice.name",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_user(app):",
            "    db = app.db",
            "    name = 'newuser'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert not user.admin",
            "    # assert newuser has default 'user' role",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_get_user(app):",
            "    name = 'user'",
            "    # get own model",
            "    r = await api_request(app, 'users', name, headers=auth_header(app.db, name))",
            "    r.raise_for_status()",
            "    # admin request",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "    )",
            "    r.raise_for_status()",
            "",
            "    user = normalize_user(r.json())",
            "    assert user == fill_user({'name': name, 'roles': ['user'], 'auth_state': None})",
            "",
            "    # admin request, no such user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'nosuchuser',",
            "    )",
            "    assert r.status_code == 404",
            "",
            "    # unauthorized request, no such user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'nosuchuser',",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 404",
            "",
            "    # unauthorized request for existing user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'admin',",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.user",
            "async def test_add_multi_user_bad(app):",
            "    r = await api_request(app, 'users', method='post')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'users', method='post', data='{}')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'users', method='post', data='[]')",
            "    assert r.status_code == 400",
            "",
            "",
            "@mark.user",
            "async def test_add_multi_user_invalid(app):",
            "    app.authenticator.username_pattern = r'w.*'",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data=json.dumps({'usernames': ['Willow', 'Andrew', 'Tara']}),",
            "    )",
            "    app.authenticator.username_pattern = ''",
            "    assert r.status_code == 400",
            "    assert r.json()['message'] == 'Invalid usernames: andrew, tara'",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_multi_user(app):",
            "    db = app.db",
            "    names = ['a', 'b']",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert names == r_names",
            "",
            "    for name in names:",
            "        user = find_user(db, name)",
            "        assert user is not None",
            "        assert user.name == name",
            "        assert not user.admin",
            "        # assert default 'user' role added",
            "        assert orm.Role.find(db, 'user') in user.roles",
            "        assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "    # try to create the same users again",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 409",
            "",
            "    names = ['a', 'b', 'ab']",
            "",
            "    # try to create the same users again",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert r_names == ['ab']",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_multi_user_admin(app):",
            "    db = app.db",
            "    names = ['c', 'd']",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data=json.dumps({'usernames': names, 'admin': True}),",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert names == r_names",
            "",
            "    for name in names:",
            "        user = find_user(db, name)",
            "        assert user is not None",
            "        assert user.name == name",
            "        assert user.admin",
            "        assert orm.Role.find(db, 'user') in user.roles",
            "        assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_add_user_bad(app):",
            "    db = app.db",
            "    name = 'dne_newuser'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 400",
            "    user = find_user(db, name)",
            "    assert user is None",
            "",
            "",
            "@mark.user",
            "async def test_add_user_duplicate(app):",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name)",
            "    # double-check that it exists",
            "    assert user is not None",
            "    r = await api_request(app, 'users', name, method='post')",
            "    # special 409 conflict for creating a user that already exists",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_admin(app):",
            "    db = app.db",
            "    name = 'newadmin'",
            "    r = await api_request(",
            "        app, 'users', name, method='post', data=json.dumps({'admin': True})",
            "    )",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert user.admin",
            "    # assert newadmin has default 'admin' role",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_delete_user(app):",
            "    db = app.db",
            "    mal = add_user(db, name='mal')",
            "    r = await api_request(app, 'users', 'mal', method='delete')",
            "    assert r.status_code == 204",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_make_admin(app):",
            "    db = app.db",
            "    name = 'admin2'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert not user.admin",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "    r = await api_request(",
            "        app, 'users', name, method='patch', data=json.dumps({'admin': True})",
            "    )",
            "",
            "    assert r.status_code == 200",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert user.admin",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_set_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'admin'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "",
            "    r = await api_request(",
            "        app, 'users', name, method='patch', data=json.dumps({'auth_state': auth_state})",
            "    )",
            "",
            "    assert r.status_code == 200",
            "    users_auth_state = await user.get_auth_state()",
            "    assert users_auth_state == auth_state",
            "",
            "",
            "@mark.user",
            "async def test_user_set_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    user_auth_state = await user.get_auth_state()",
            "    assert user_auth_state is None",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        method='patch',",
            "        data=json.dumps({'auth_state': auth_state}),",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 403",
            "    user_auth_state = await user.get_auth_state()",
            "    assert user_auth_state is None",
            "",
            "",
            "@mark.user",
            "async def test_admin_get_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'admin'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    await user.save_auth_state(auth_state)",
            "",
            "    r = await api_request(app, 'users', name)",
            "",
            "    assert r.status_code == 200",
            "    assert r.json()['auth_state'] == auth_state",
            "",
            "",
            "@mark.user",
            "async def test_user_get_auth_state(app, auth_state_enabled):",
            "    # explicitly check that a user will not get their own auth state via the API",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    await user.save_auth_state(auth_state)",
            "",
            "    r = await api_request(app, 'users', name, headers=auth_header(app.db, name))",
            "",
            "    assert r.status_code == 200",
            "    assert 'auth_state' not in r.json()",
            "",
            "",
            "async def test_spawn(app):",
            "    db = app.db",
            "    name = 'wash'",
            "    user = add_user(db, app=app, name=name)",
            "    options = {'s': ['value'], 'i': 5}",
            "    before_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert app_user.spawner.user_options == options",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is None",
            "",
            "    assert spawner.server.base_url == ujoin(app.base_url, f'user/{name}') + '/'",
            "    url = public_url(app, user)",
            "    kwargs = {}",
            "    if app.internal_ssl:",
            "        kwargs['cert'] = (app.internal_ssl_cert, app.internal_ssl_key)",
            "        kwargs[\"verify\"] = app.internal_ssl_ca",
            "    r = await async_requests.get(url, **kwargs)",
            "    assert r.status_code == 200",
            "    assert r.text == spawner.server.base_url",
            "",
            "    r = await async_requests.get(ujoin(url, 'args'), **kwargs)",
            "    assert r.status_code == 200",
            "    argv = r.json()",
            "    assert '--port' not in ' '.join(argv)",
            "    # we pass no CLI args anymore:",
            "    assert len(argv) == 1",
            "    r = await async_requests.get(ujoin(url, 'env'), **kwargs)",
            "    env = r.json()",
            "    for expected in [",
            "        'JUPYTERHUB_USER',",
            "        'JUPYTERHUB_BASE_URL',",
            "        'JUPYTERHUB_API_TOKEN',",
            "        'JUPYTERHUB_SERVICE_URL',",
            "    ]:",
            "        assert expected in env",
            "    if app.subdomain_host:",
            "        assert env['JUPYTERHUB_HOST'] == app.subdomain_host",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    assert r.status_code == 204",
            "",
            "    assert 'pid' not in user.orm_spawners[''].state",
            "    status = await app_user.spawner.poll()",
            "    assert status == 0",
            "",
            "    # check that we cleaned up after ourselves",
            "    assert spawner.server is None",
            "    after_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    assert before_servers == after_servers",
            "    tokens = list(db.query(orm.APIToken).filter(orm.APIToken.user_id == user.id))",
            "    assert tokens == []",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "async def test_user_options(app, username):",
            "    db = app.db",
            "    name = username",
            "    user = add_user(db, app=app, name=name)",
            "    options = {'s': ['value'], 'i': 5}",
            "    before_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == options",
            "    assert spawner.orm_spawner.user_options == options",
            "",
            "    # stop the server",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "",
            "    # orm_spawner still exists and has a reference to the user_options",
            "    assert spawner.orm_spawner.user_options == options",
            "",
            "    # spawn again, no options specified",
            "    # should re-use options from last spawn",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == options",
            "",
            "    # stop the server",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "",
            "    # spawn again, new options specified",
            "    # should override options from last spawn",
            "    new_options = {'key': 'value'}",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(new_options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == new_options",
            "    # saved in db",
            "    assert spawner.orm_spawner.user_options == new_options",
            "",
            "",
            "async def test_spawn_handler(app):",
            "    \"\"\"Test that the requesting Handler is passed to Spawner.handler\"\"\"",
            "    db = app.db",
            "    name = 'salmon'",
            "    user = add_user(db, app=app, name=name)",
            "    app_user = app.users[name]",
            "",
            "    # spawn via API with ?foo=bar",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', params={'foo': 'bar'}",
            "    )",
            "    r.raise_for_status()",
            "",
            "    # verify that request params got passed down",
            "    # implemented in MockSpawner",
            "    kwargs = {}",
            "    if app.external_certs:",
            "        kwargs['verify'] = app.external_certs['files']['ca']",
            "    url = public_url(app, user)",
            "    r = await async_requests.get(ujoin(url, 'env'), **kwargs)",
            "    env = r.json()",
            "    assert 'HANDLER_ARGS' in env",
            "    assert env['HANDLER_ARGS'] == 'foo=bar'",
            "    # make user spawner.handler doesn't persist after spawn finishes",
            "    assert app_user.spawner.handler is None",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "",
            "",
            "@mark.slow",
            "async def test_slow_spawn(app, no_patience, slow_spawn):",
            "    db = app.db",
            "    name = 'zoe'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._spawn_pending",
            "    assert not app_user.spawner._stop_pending",
            "    assert app.users.count_active_users()['pending'] == 1",
            "",
            "    async def wait_spawn():",
            "        while not app_user.running:",
            "            await asyncio.sleep(0.1)",
            "",
            "    await wait_spawn()",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is None",
            "",
            "    async def wait_stop():",
            "        while app_user.spawner._stop_pending:",
            "            await asyncio.sleep(0.1)",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._stop_pending",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._stop_pending",
            "",
            "    await wait_stop()",
            "    assert not app_user.spawner._stop_pending",
            "    assert app_user.spawner is not None",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    # 204 deleted if there's no such server",
            "    assert r.status_code == 204",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    assert app.users.count_active_users()['active'] == 0",
            "",
            "",
            "async def test_never_spawn(app, no_patience, never_spawn):",
            "    db = app.db",
            "    name = 'badger'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._spawn_pending",
            "    assert app.users.count_active_users()['pending'] == 1",
            "",
            "    while app_user.spawner.pending:",
            "        await asyncio.sleep(0.1)",
            "        print(app_user.spawner.pending)",
            "",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is not None",
            "    # failed spawn should decrement pending count",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "async def test_bad_spawn(app, bad_spawn):",
            "    db = app.db",
            "    name = 'prim'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    # check that we don't re-use spawners that failed",
            "    user.spawners[''].reused = True",
            "    assert r.status_code == 500",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    # check that we don't re-use spawners that failed",
            "    spawner = user.spawners['']",
            "    assert not getattr(spawner, 'reused', False)",
            "",
            "",
            "async def test_spawn_nosuch_user(app):",
            "    r = await api_request(app, 'users', \"nosuchuser\", 'server', method='post')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_slow_bad_spawn(app, no_patience, slow_bad_spawn):",
            "    db = app.db",
            "    name = 'zaphod'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    while user.spawner.pending:",
            "        await asyncio.sleep(0.1)",
            "    # spawn failed",
            "    assert not user.running",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "def next_event(it):",
            "    \"\"\"read an event from an eventstream\"\"\"",
            "    while True:",
            "        try:",
            "            line = next(it)",
            "        except StopIteration:",
            "            return",
            "        if line.startswith('data:'):",
            "            return json.loads(line.split(':', 1)[1])",
            "",
            "",
            "@mark.slow",
            "async def test_progress(request, app, no_patience, slow_spawn):",
            "    db = app.db",
            "    name = 'martin'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 0, 'message': 'Server requested'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 50, 'message': 'Spawning server...'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    url = app_user.url",
            "    assert evt == {",
            "        'progress': 100,",
            "        'message': f'Server ready at {url}',",
            "        'html_message': f'Server ready at <a href=\"{url}\">{url}</a>',",
            "        'url': url,",
            "        'ready': True,",
            "    }",
            "",
            "",
            "async def test_progress_not_started(request, app):",
            "    db = app.db",
            "    name = 'nope'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_progress_not_found(request, app):",
            "    db = app.db",
            "    name = 'noserver'",
            "    r = await api_request(app, 'users', 'nosuchuser', 'server/progress')",
            "    assert r.status_code == 404",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server/progress')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_progress_ready(request, app):",
            "    \"\"\"Test progress API when spawner is already started",
            "",
            "    e.g. a race between requesting progress and progress already being complete",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "",
            "",
            "async def test_progress_ready_hook_async_func(request, app):",
            "    \"\"\"Test progress ready hook in Spawner class with an async function\"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    html_message = 'customized html message'",
            "    spawner = app_user.spawner",
            "",
            "    async def custom_progress_ready_hook(spawner, ready_event):",
            "        ready_event['html_message'] = html_message",
            "        return ready_event",
            "",
            "    spawner.progress_ready_hook = custom_progress_ready_hook",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "    assert evt['html_message'] == html_message",
            "",
            "",
            "async def test_progress_ready_hook_sync_func(request, app):",
            "    \"\"\"Test progress ready hook in Spawner class with a sync function\"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    html_message = 'customized html message'",
            "    spawner = app_user.spawner",
            "",
            "    def custom_progress_ready_hook(spawner, ready_event):",
            "        ready_event['html_message'] = html_message",
            "        return ready_event",
            "",
            "    spawner.progress_ready_hook = custom_progress_ready_hook",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "    assert evt['html_message'] == html_message",
            "",
            "",
            "async def test_progress_ready_hook_async_func_exception(request, app):",
            "    \"\"\"Test progress ready hook in Spawner class with an exception in",
            "    an async function",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    html_message = f'Server ready at <a href=\"{app_user.url}\">{app_user.url}</a>'",
            "    spawner = app_user.spawner",
            "",
            "    async def custom_progress_ready_hook(spawner, ready_event):",
            "        ready_event[\"html_message\"] = \".\"",
            "        raise Exception()",
            "",
            "    spawner.progress_ready_hook = custom_progress_ready_hook",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "    assert evt['html_message'] == html_message",
            "",
            "",
            "async def test_progress_bad(request, app, bad_spawn):",
            "    \"\"\"Test progress API when spawner has already failed\"\"\"",
            "    db = app.db",
            "    name = 'simon'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 500",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {",
            "        'progress': 100,",
            "        'failed': True,",
            "        'message': \"Spawn failed: I don't work!\",",
            "    }",
            "",
            "",
            "async def test_progress_bad_slow(request, app, no_patience, slow_bad_spawn):",
            "    \"\"\"Test progress API when spawner fails while watching\"\"\"",
            "    db = app.db",
            "    name = 'eugene'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 0",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 50",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {",
            "        'progress': 100,",
            "        'failed': True,",
            "        'message': \"Spawn failed: I don't work!\",",
            "    }",
            "",
            "",
            "async def progress_forever():",
            "    \"\"\"progress function that yields messages forever\"\"\"",
            "    for i in range(1, 10):",
            "        yield {'progress': i, 'message': f'Stage {i}'}",
            "        # wait a long time before the next event",
            "        await asyncio.sleep(10)",
            "",
            "",
            "async def test_spawn_progress_cutoff(request, app, no_patience, slow_spawn):",
            "    \"\"\"Progress events stop when Spawner finishes",
            "",
            "    even if progress iterator is still going.",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'geddy'",
            "    app_user = add_user(db, app=app, name=name)",
            "    app_user.spawner.progress = progress_forever",
            "    app_user.spawner.delay = 1",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 0",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 1, 'message': 'Stage 1'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "",
            "",
            "async def test_spawn_limit(app, no_patience, slow_spawn, request):",
            "    db = app.db",
            "    p = mock.patch.dict(app.tornado_settings, {'concurrent_spawn_limit': 2})",
            "    p.start()",
            "    request.addfinalizer(p.stop)",
            "",
            "    # start two pending spawns",
            "    names = ['ykka', 'hjarka']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    users[0].spawner._start_future = asyncio.Future()",
            "    users[1].spawner._start_future = asyncio.Future()",
            "    for name in names:",
            "        await api_request(app, 'users', name, 'server', method='post')",
            "    assert app.users.count_active_users()['pending'] == 2",
            "",
            "    # ykka and hjarka's spawns are both pending. Essun should fail with 429",
            "    name = 'essun'",
            "    user = add_user(db, app=app, name=name)",
            "    user.spawner._start_future = asyncio.Future()",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 429",
            "",
            "    # allow ykka to start",
            "    users[0].spawner._start_future.set_result(None)",
            "    # wait for ykka to finish",
            "    while not users[0].running:",
            "        await asyncio.sleep(0.1)",
            "",
            "    assert app.users.count_active_users()['pending'] == 1",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    assert app.users.count_active_users()['pending'] == 2",
            "    users.append(user)",
            "    # allow hjarka and essun to finish starting",
            "    for user in users[1:]:",
            "        user.spawner._start_future.set_result(None)",
            "    while not all(u.running for u in users):",
            "        await asyncio.sleep(0.1)",
            "",
            "    # everybody's running, pending count should be back to 0",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    for u in users:",
            "        u.spawner.delay = 0",
            "        r = await api_request(app, 'users', u.name, 'server', method='delete')",
            "        r.raise_for_status()",
            "    while any(u.spawner.active for u in users):",
            "        await asyncio.sleep(0.1)",
            "",
            "",
            "@mark.slow",
            "async def test_active_server_limit(app, request):",
            "    db = app.db",
            "    p = mock.patch.dict(app.tornado_settings, {'active_server_limit': 2})",
            "    p.start()",
            "    request.addfinalizer(p.stop)",
            "",
            "    # start two pending spawns",
            "    names = ['ykka', 'hjarka']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    for name in names:",
            "        r = await api_request(app, 'users', name, 'server', method='post')",
            "        r.raise_for_status()",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "",
            "    # ykka and hjarka's servers are running. Essun should fail with 429",
            "    name = 'essun'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 429",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "",
            "    # stop one server",
            "    await api_request(app, 'users', names[0], 'server', method='delete')",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 1",
            "    assert counts['ready'] == 1",
            "    assert counts['pending'] == 0",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "    users.append(user)",
            "",
            "    # everybody's running, pending count should be back to 0",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    for u in users:",
            "        if not u.spawner.active:",
            "            continue",
            "        r = await api_request(app, 'users', u.name, 'server', method='delete')",
            "        r.raise_for_status()",
            "",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 0",
            "    assert counts['ready'] == 0",
            "    assert counts['pending'] == 0",
            "",
            "",
            "@mark.slow",
            "async def test_start_stop_race(app, no_patience, slow_spawn):",
            "    user = add_user(app.db, app, name='panda')",
            "    spawner = user.spawner",
            "    # start the server",
            "    r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    assert spawner.pending == 'spawn'",
            "    spawn_future = spawner._spawn_future",
            "    # additional spawns while spawning shouldn't trigger a new spawn",
            "    with mock.patch.object(spawner, 'start') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    assert m.call_count == 0",
            "",
            "    # stop while spawning is okay now",
            "    spawner.delay = 3",
            "    r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 202",
            "    assert spawner.pending == 'stop'",
            "    assert spawn_future.cancelled()",
            "    assert spawner._spawn_future is None",
            "    # make sure we get past deleting from the proxy",
            "    await asyncio.sleep(1)",
            "    # additional stops while stopping shouldn't trigger a new stop",
            "    with mock.patch.object(spawner, 'stop') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 202",
            "    assert m.call_count == 0",
            "    # start while stopping is not allowed",
            "    with mock.patch.object(spawner, 'start') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 400",
            "",
            "    while spawner.active:",
            "        await asyncio.sleep(0.1)",
            "    # start after stop is okay",
            "    r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "",
            "",
            "async def test_get_proxy(app):",
            "    r = await api_request(app, 'proxy')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert list(reply.keys()) == [app.hub.routespec]",
            "",
            "",
            "@mark.parametrize(\"offset\", (0, 1))",
            "async def test_get_proxy_pagination(app, offset):",
            "    r = await api_request(",
            "        app, f'proxy?offset={offset}', headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert set(reply) == {\"items\", \"_pagination\"}",
            "    assert list(reply[\"items\"].keys()) == [app.hub.routespec][offset:]",
            "",
            "",
            "async def test_cookie(app):",
            "    db = app.db",
            "    name = 'patience'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "",
            "    cookies = await app.login_user(name)",
            "    cookie_name = app.hub.cookie_name",
            "    # cookie jar gives '\"cookie-value\"', we want 'cookie-value'",
            "    cookie = cookies[cookie_name][1:-1]",
            "    r = await api_request(app, 'authorizations/cookie', cookie_name, \"nothintoseehere\")",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(",
            "        app, 'authorizations/cookie', cookie_name, quote(cookie, safe='')",
            "    )",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "    # deprecated cookie in body:",
            "    r = await api_request(app, 'authorizations/cookie', cookie_name, data=cookie)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "def normalize_token(token):",
            "    for key in ('created', 'last_activity'):",
            "        token[key] = normalize_timestamp(token[key])",
            "    return token",
            "",
            "",
            "async def test_check_token(app):",
            "    name = 'book'",
            "    user = add_user(app.db, app=app, name=name)",
            "    token = user.new_api_token()",
            "    r = await api_request(app, 'authorizations/token', token)",
            "    r.raise_for_status()",
            "    user_model = r.json()",
            "    assert user_model['name'] == name",
            "    r = await api_request(app, 'authorizations/token', 'notauthorized')",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.parametrize(\"headers, status\", [({}, 404), ({'Authorization': 'token bad'}, 404)])",
            "async def test_get_new_token_deprecated(app, headers, status):",
            "    # request a new token",
            "    r = await api_request(",
            "        app, 'authorizations', 'token', method='post', headers=headers",
            "    )",
            "    assert r.status_code == status",
            "",
            "",
            "@mark.parametrize(",
            "    \"headers, status, note, expires_in\",",
            "    [",
            "        ({}, 201, 'test note', None),",
            "        ({}, 201, '', 100),",
            "        ({'Authorization': 'token bad'}, 403, '', None),",
            "    ],",
            ")",
            "async def test_get_new_token(app, headers, status, note, expires_in):",
            "    options = {}",
            "    if note:",
            "        options['note'] = note",
            "    if expires_in:",
            "        options['expires_in'] = expires_in",
            "    if options:",
            "        body = json.dumps(options)",
            "    else:",
            "        body = ''",
            "    # request a new token",
            "    r = await api_request(",
            "        app, 'users/admin/tokens', method='post', headers=headers, data=body",
            "    )",
            "    assert r.status_code == status",
            "    if status != 201:",
            "        return",
            "    # check the new-token reply",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    assert reply['user'] == 'admin'",
            "    assert reply['created']",
            "    assert 'last_activity' in reply",
            "    if expires_in:",
            "        assert isinstance(reply['expires_at'], str)",
            "    else:",
            "        assert reply['expires_at'] is None",
            "    if note:",
            "        assert reply['note'] == note",
            "    else:",
            "        assert reply['note'] == 'Requested via api'",
            "    token_id = reply['id']",
            "    initial = normalize_token(reply)",
            "    # pop token for later comparison",
            "    initial.pop('token')",
            "",
            "    # check the validity of the new token",
            "    r = await api_request(app, 'users/admin/tokens', token_id)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert normalize_token(reply) == initial",
            "",
            "    # delete the token",
            "    r = await api_request(app, 'users/admin/tokens', token_id, method='delete')",
            "    assert r.status_code == 204",
            "    # verify deletion",
            "    r = await api_request(app, 'users/admin/tokens', token_id)",
            "    assert r.status_code == 404",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"expires_in_max, expires_in, expected\",",
            "    [",
            "        (86400, None, 86400),",
            "        (86400, 86400, 86400),",
            "        (86400, 86401, 'error'),",
            "        (3600, 100, 100),",
            "        (None, None, None),",
            "        (None, 86400, 86400),",
            "    ],",
            ")",
            "async def test_token_expires_in_max(app, user, expires_in_max, expires_in, expected):",
            "    options = {",
            "        \"expires_in\": expires_in,",
            "    }",
            "    # request a new token",
            "    with mock.patch.dict(",
            "        app.tornado_settings, {\"token_expires_in_max_seconds\": expires_in_max}",
            "    ):",
            "        r = await api_request(",
            "            app,",
            "            f'users/{user.name}/tokens',",
            "            method='post',",
            "            data=json.dumps(options),",
            "        )",
            "    if expected == 'error':",
            "        assert r.status_code == 400",
            "        assert f\"must not exceed {expires_in_max}\" in r.json()[\"message\"]",
            "        return",
            "    else:",
            "        assert r.status_code == 201",
            "    token_model = r.json()",
            "    if expected is None:",
            "        assert token_model[\"expires_at\"] is None",
            "    else:",
            "        expected_expires_at = utcnow() + timedelta(seconds=expected)",
            "        expires_at = parse_date(token_model[\"expires_at\"])",
            "        assert abs((expires_at - expected_expires_at).total_seconds()) < 30",
            "",
            "",
            "@mark.parametrize(",
            "    \"as_user, for_user, status\",",
            "    [",
            "        ('admin', 'other', 201),",
            "        ('admin', 'missing', 403),",
            "        ('user', 'other', 403),",
            "        ('user', 'user', 201),",
            "    ],",
            ")",
            "async def test_token_for_user(app, as_user, for_user, status):",
            "    # ensure both users exist",
            "    u = add_user(app.db, app, name=as_user)",
            "    if for_user != 'missing':",
            "        for_user_obj = add_user(app.db, app, name=for_user)",
            "    data = {'username': for_user}",
            "    headers = {'Authorization': f'token {u.new_api_token()}'}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        for_user,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data),",
            "        headers=headers,",
            "    )",
            "    assert r.status_code == status",
            "    reply = r.json()",
            "    if status != 201:",
            "        return",
            "    assert 'token' in reply",
            "",
            "    token_id = reply['id']",
            "    r = await api_request(app, 'users', for_user, 'tokens', token_id, headers=headers)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['user'] == for_user",
            "    if for_user == as_user:",
            "        note = 'Requested via api'",
            "    else:",
            "        note = f'Requested via api by user {as_user}'",
            "    assert reply['note'] == note",
            "",
            "    # delete the token",
            "    r = await api_request(",
            "        app, 'users', for_user, 'tokens', token_id, method='delete', headers=headers",
            "    )",
            "",
            "    assert r.status_code == 204",
            "    r = await api_request(app, 'users', for_user, 'tokens', token_id, headers=headers)",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_token_authenticator_noauth(app):",
            "    \"\"\"Create a token for a user relying on Authenticator.authenticate and no auth header\"\"\"",
            "    name = 'user'",
            "    data = {'auth': {'username': name, 'password': name}}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data) if data else None,",
            "        noauth=True,",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    r = await api_request(app, 'authorizations', 'token', reply['token'])",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "async def test_token_authenticator_dict_noauth(app):",
            "    \"\"\"Create a token for a user relying on Authenticator.authenticate and no auth header\"\"\"",
            "    app.authenticator.auth_state = {'who': 'cares'}",
            "    name = 'user'",
            "    data = {'auth': {'username': name, 'password': name}}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data) if data else None,",
            "        noauth=True,",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    r = await api_request(app, 'authorizations', 'token', reply['token'])",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "@mark.parametrize(",
            "    \"as_user, for_user, status\",",
            "    [",
            "        ('admin', 'other', 200),",
            "        ('admin', 'missing', 404),",
            "        ('user', 'other', 404),",
            "        ('user', 'user', 200),",
            "    ],",
            ")",
            "async def test_token_list(app, as_user, for_user, status):",
            "    u = add_user(app.db, app, name=as_user)",
            "    if for_user != 'missing':",
            "        for_user_obj = add_user(app.db, app, name=for_user)",
            "    headers = {'Authorization': f'token {u.new_api_token()}'}",
            "    r = await api_request(app, 'users', for_user, 'tokens', headers=headers)",
            "    assert r.status_code == status",
            "    if status != 200:",
            "        return",
            "    reply = r.json()",
            "    assert sorted(reply) == ['api_tokens']",
            "    assert len(reply['api_tokens']) == len(for_user_obj.api_tokens)",
            "    assert all(token['user'] == for_user for token in reply['api_tokens'])",
            "    # validate individual token ids",
            "    for token in reply['api_tokens']:",
            "        r = await api_request(",
            "            app, 'users', for_user, 'tokens', token['id'], headers=headers",
            "        )",
            "        r.raise_for_status()",
            "        reply = r.json()",
            "        assert normalize_token(reply) == normalize_token(token)",
            "",
            "",
            "# ---------------",
            "# Group API tests",
            "# ---------------",
            "",
            "",
            "@mark.group",
            "async def test_groups_list(app):",
            "    r = await api_request(app, 'groups')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == []",
            "",
            "    # create two groups",
            "    group = orm.Group(name='alphaflight')",
            "    group_2 = orm.Group(name='betaflight')",
            "    app.db.add(group)",
            "    app.db.add(group_2)",
            "    app.db.commit()",
            "",
            "    r = await api_request(app, 'groups')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        },",
            "        {",
            "            'kind': 'group',",
            "            'name': 'betaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        },",
            "    ]",
            "",
            "    # Test offset for pagination",
            "    r = await api_request(app, \"groups?offset=1\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert r.status_code == 200",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'betaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "    r = await api_request(app, \"groups?offset=10\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == []",
            "",
            "    # Test limit for pagination",
            "    r = await api_request(app, \"groups?limit=1\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert r.status_code == 200",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "    # 0 is rounded up to 1",
            "    r = await api_request(app, \"groups?limit=0\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "",
            "@mark.group",
            "async def test_add_multi_group(app):",
            "    db = app.db",
            "    names = ['group1', 'group2']",
            "    r = await api_request(",
            "        app, 'groups', method='post', data=json.dumps({'groups': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [group['name'] for group in reply]",
            "    assert names == r_names",
            "",
            "    # try to create the same groups again",
            "    r = await api_request(",
            "        app, 'groups', method='post', data=json.dumps({'groups': names})",
            "    )",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.group",
            "async def test_group_get(app):",
            "    group = orm.Group(name='alphaflight')",
            "    app.db.add(group)",
            "    app.db.commit()",
            "    group = orm.Group.find(app.db, name='alphaflight')",
            "    user = add_user(app.db, app=app, name='sasquatch')",
            "    group.users.append(user.orm_user)",
            "    app.db.commit()",
            "",
            "    r = await api_request(app, 'groups/runaways')",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(app, 'groups/alphaflight')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == {",
            "        'kind': 'group',",
            "        'name': 'alphaflight',",
            "        'users': ['sasquatch'],",
            "        'roles': [],",
            "        'properties': {},",
            "    }",
            "",
            "",
            "@mark.group",
            "async def test_group_create_delete(app):",
            "    db = app.db",
            "    user = add_user(app.db, app=app, name='sasquatch')",
            "    r = await api_request(app, 'groups/runaways', method='delete')",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(",
            "        app, 'groups/new', method='post', data=json.dumps({'users': ['doesntexist']})",
            "    )",
            "    assert r.status_code == 400",
            "    assert orm.Group.find(db, name='new') is None",
            "",
            "    r = await api_request(",
            "        app,",
            "        'groups/omegaflight',",
            "        method='post',",
            "        data=json.dumps({'users': ['sasquatch']}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    omegaflight = orm.Group.find(db, name='omegaflight')",
            "    sasquatch = find_user(db, name='sasquatch')",
            "    assert omegaflight in sasquatch.groups",
            "    assert sasquatch in omegaflight.users",
            "",
            "    # create duplicate raises 400",
            "    r = await api_request(app, 'groups/omegaflight', method='post')",
            "    assert r.status_code == 409",
            "",
            "    r = await api_request(app, 'groups/omegaflight', method='delete')",
            "    assert r.status_code == 204",
            "    assert omegaflight not in sasquatch.groups",
            "    assert orm.Group.find(db, name='omegaflight') is None",
            "",
            "    # delete nonexistent gives 404",
            "    r = await api_request(app, 'groups/omegaflight', method='delete')",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.group",
            "async def test_group_add_delete_users(app):",
            "    db = app.db",
            "    group = orm.Group(name='alphaflight')",
            "    app.db.add(group)",
            "    app.db.commit()",
            "    # must specify users",
            "    r = await api_request(app, 'groups/alphaflight/users', method='post', data='{}')",
            "    assert r.status_code == 400",
            "",
            "    names = ['aurora', 'guardian', 'northstar', 'sasquatch', 'shaman', 'snowbird']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    r = await api_request(",
            "        app,",
            "        'groups/alphaflight/users',",
            "        method='post',",
            "        data=json.dumps({'users': names}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    for user in users:",
            "        print(user.name)",
            "        assert [g.name for g in user.groups] == ['alphaflight']",
            "",
            "    group = orm.Group.find(db, name='alphaflight')",
            "    assert sorted(u.name for u in group.users) == sorted(names)",
            "",
            "    r = await api_request(",
            "        app,",
            "        'groups/alphaflight/users',",
            "        method='delete',",
            "        data=json.dumps({'users': names[:2]}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    for user in users[:2]:",
            "        assert user.groups == []",
            "    for user in users[2:]:",
            "        assert [g.name for g in user.groups] == ['alphaflight']",
            "",
            "    group = orm.Group.find(db, name='alphaflight')",
            "    assert sorted(u.name for u in group.users) == sorted(names[2:])",
            "",
            "",
            "@mark.parametrize(",
            "    \"properties\",",
            "    [",
            "        \"\",",
            "        \"str\",",
            "        5,",
            "        [\"list\"],",
            "    ],",
            ")",
            "@mark.group",
            "async def test_group_properties_invalid(app, group, properties):",
            "    if properties:",
            "        json_properties = json.dumps(properties)",
            "    else:",
            "        json_properties = \"\"",
            "    have_properties = {\"a\": 5}",
            "    group.properties = have_properties",
            "    app.db.commit()",
            "    r = await api_request(",
            "        app, f\"groups/{group.name}/properties\", method='put', data=json_properties",
            "    )",
            "    assert r.status_code == 400",
            "    # invalid requests didn't change properties",
            "    assert group.properties == have_properties",
            "",
            "",
            "@mark.group",
            "async def test_group_properties(app, group):",
            "    db = app.db",
            "    # must specify properties",
            "    properties = {",
            "        \"str\": \"x\",",
            "        \"int\": 5,",
            "        \"list\": [\"a\"],",
            "    }",
            "    r = await api_request(",
            "        app,",
            "        f\"groups/{group.name}/properties\",",
            "        method='put',",
            "        data=json.dumps(properties),",
            "    )",
            "    r.raise_for_status()",
            "    assert group.properties == properties",
            "",
            "    r = await api_request(",
            "        app,",
            "        f\"groups/{group.name}/properties\",",
            "        method='put',",
            "        data=\"{}\",",
            "    )",
            "    r.raise_for_status()",
            "    assert group.properties == {}",
            "",
            "",
            "@mark.group",
            "async def test_auth_managed_groups(request, app, group, user):",
            "    group.users.append(user.orm_user)",
            "    app.db.commit()",
            "    app.authenticator.manage_groups = True",
            "    request.addfinalizer(lambda: setattr(app.authenticator, \"manage_groups\", False))",
            "    # create groups",
            "    r = await api_request(app, 'groups', method='post')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'groups/newgroup', method='post')",
            "    assert r.status_code == 400",
            "    # delete groups",
            "    r = await api_request(app, f'groups/{group.name}', method='delete')",
            "    assert r.status_code == 400",
            "    # add users to group",
            "    r = await api_request(",
            "        app,",
            "        f'groups/{group.name}/users',",
            "        method='post',",
            "        data=json.dumps({\"users\": [user.name]}),",
            "    )",
            "    assert r.status_code == 400",
            "    # remove users from group",
            "    r = await api_request(",
            "        app,",
            "        f'groups/{group.name}/users',",
            "        method='delete',",
            "        data=json.dumps({\"users\": [user.name]}),",
            "    )",
            "    assert r.status_code == 400",
            "",
            "",
            "# -----------------",
            "# Service API tests",
            "# -----------------",
            "",
            "",
            "@mark.services",
            "async def test_get_services(app, mockservice_url):",
            "    mockservice = mockservice_url",
            "    db = app.db",
            "    r = await api_request(app, 'services')",
            "    r.raise_for_status()",
            "    assert r.status_code == 200",
            "",
            "    services = r.json()",
            "    assert services == {",
            "        mockservice.name: {",
            "            'kind': 'service',",
            "            'name': mockservice.name,",
            "            'admin': True,",
            "            'roles': ['admin'],",
            "            'command': mockservice.command,",
            "            'pid': mockservice.proc.pid,",
            "            'prefix': mockservice.server.base_url,",
            "            'url': mockservice.url,",
            "            'info': {},",
            "            'display': True,",
            "        }",
            "    }",
            "    r = await api_request(app, 'services', headers=auth_header(db, 'user'))",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.services",
            "async def test_get_service(app, mockservice_url):",
            "    mockservice = mockservice_url",
            "    db = app.db",
            "    r = await api_request(app, f\"services/{mockservice.name}\")",
            "    r.raise_for_status()",
            "    assert r.status_code == 200",
            "",
            "    service = r.json()",
            "    assert service == {",
            "        'kind': 'service',",
            "        'name': mockservice.name,",
            "        'admin': True,",
            "        'roles': ['admin'],",
            "        'command': mockservice.command,",
            "        'pid': mockservice.proc.pid,",
            "        'prefix': mockservice.server.base_url,",
            "        'url': mockservice.url,",
            "        'info': {},",
            "        'display': True,",
            "    }",
            "    r = await api_request(",
            "        app,",
            "        f\"services/{mockservice.name}\",",
            "        headers={'Authorization': f'token {mockservice.api_token}'},",
            "    )",
            "    r.raise_for_status()",
            "",
            "    r = await api_request(",
            "        app, f\"services/{mockservice.name}\", headers=auth_header(db, 'user')",
            "    )",
            "    assert r.status_code == 403",
            "",
            "    r = await api_request(app, \"services/nosuchservice\")",
            "    assert r.status_code == 404",
            "",
            "",
            "@pytest.fixture",
            "def service_admin_user(create_user_with_scopes):",
            "    return create_user_with_scopes('admin:services')",
            "",
            "",
            "@mark.services",
            "async def test_create_service(app, service_admin_user, service_name, service_data):",
            "    db = app.db",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "",
            "    r.raise_for_status()",
            "    assert r.status_code == 201",
            "    assert r.json()['name'] == service_name",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is not None",
            "",
            "    oath_client = (",
            "        db.query(orm.OAuthClient)",
            "        .filter_by(identifier=service_data['oauth_client_id'])",
            "        .first()",
            "    )",
            "    assert oath_client.redirect_uri == service_data['oauth_redirect_uri']",
            "",
            "    assert service_name in app._service_map",
            "    assert (",
            "        app._service_map[service_name].oauth_no_confirm",
            "        == service_data['oauth_no_confirm']",
            "    )",
            "",
            "",
            "@mark.services",
            "async def test_create_service_no_role(app, service_name, service_data):",
            "    db = app.db",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, 'user'),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.services",
            "async def test_create_service_conflict(",
            "    app, service_admin_user, mockservice, service_data, service_name",
            "):",
            "    db = app.db",
            "    app.services = [{'name': service_name}]",
            "    app.init_services()",
            "",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.services",
            "async def test_create_service_duplication(",
            "    app, service_admin_user, service_name, service_data",
            "):",
            "    db = app.db",
            "",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "    assert r.status_code == 201",
            "",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.services",
            "async def test_create_managed_service(",
            "    app, service_admin_user, service_name, service_data",
            "):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['command'] = ['foo']",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 400",
            "    assert 'Can not create managed service' in r.json()['message']",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is None",
            "",
            "",
            "@mark.services",
            "async def test_create_admin_service(app, admin_user, service_name, service_data):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['admin'] = True",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, admin_user.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 201",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is not None",
            "",
            "",
            "@mark.services",
            "async def test_create_admin_service_without_admin_right(",
            "    app, service_admin_user, service_data, service_name",
            "):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['admin'] = True",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 400",
            "    assert 'Not assigning requested scopes' in r.json()['message']",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is None",
            "",
            "",
            "@mark.services",
            "async def test_create_service_with_scope(",
            "    app, create_user_with_scopes, service_name, service_data",
            "):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['oauth_client_allowed_scopes'] = [\"admin:users\"]",
            "    managed_service_data['oauth_client_id'] = \"service-client-with-scope\"",
            "    user_with_scope = create_user_with_scopes('admin:services', 'admin:users')",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, user_with_scope.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 201",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is not None",
            "",
            "",
            "@mark.services",
            "async def test_create_service_without_requested_scope(",
            "    app,",
            "    service_admin_user,",
            "    service_data,",
            "    service_name,",
            "):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['oauth_client_allowed_scopes'] = [\"admin:users\"]",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 400",
            "    assert 'Not assigning requested scopes' in r.json()['message']",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is None",
            "",
            "",
            "@mark.services",
            "async def test_delete_service(app, service_admin_user, service_name, service_data):",
            "    db = app.db",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "    assert r.status_code == 201",
            "",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        method='delete',",
            "    )",
            "    assert r.status_code == 200",
            "",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is None",
            "",
            "    oath_client = (",
            "        db.query(orm.OAuthClient)",
            "        .filter_by(identifier=service_data['oauth_client_id'])",
            "        .first()",
            "    )",
            "    assert oath_client is None",
            "",
            "    assert service_name not in app._service_map",
            "",
            "    r = await api_request(app, f\"services/{service_name}\", method=\"delete\")",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.services",
            "async def test_delete_service_from_config(app, service_admin_user, mockservice):",
            "    db = app.db",
            "    service_name = mockservice.name",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        method='delete',",
            "    )",
            "    assert r.status_code == 405",
            "    assert r.json()['message'] == f'Service {service_name} is not modifiable at runtime'",
            "",
            "",
            "async def test_root_api(app):",
            "    kwargs = {}",
            "    if app.internal_ssl:",
            "        kwargs['cert'] = (app.internal_ssl_cert, app.internal_ssl_key)",
            "        kwargs[\"verify\"] = app.internal_ssl_ca",
            "    r = await api_request(app, bypass_proxy=True)",
            "    r.raise_for_status()",
            "    expected = {'version': jupyterhub.__version__}",
            "    assert r.json() == expected",
            "",
            "",
            "async def test_info(app):",
            "    r = await api_request(app, 'info')",
            "    r.raise_for_status()",
            "    data = r.json()",
            "    assert data['version'] == jupyterhub.__version__",
            "    assert sorted(data) == [",
            "        'authenticator',",
            "        'python',",
            "        'spawner',",
            "        'sys_executable',",
            "        'version',",
            "    ]",
            "    assert data['python'] == sys.version",
            "    assert data['sys_executable'] == sys.executable",
            "    assert data['authenticator'] == {",
            "        'class': 'jupyterhub.tests.mocking.MockPAMAuthenticator',",
            "        'version': jupyterhub.__version__,",
            "    }",
            "    assert data['spawner'] == {",
            "        'class': 'jupyterhub.tests.mocking.MockSpawner',",
            "        'version': jupyterhub.__version__,",
            "    }",
            "",
            "",
            "# ------------------",
            "# Activity API tests",
            "# ------------------",
            "",
            "",
            "async def test_update_activity_403(app, user, admin_user):",
            "    token = user.new_api_token()",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{admin_user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=\"{}\",",
            "        method=\"post\",",
            "    )",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_update_activity_admin(app, user, admin_user):",
            "    token = admin_user.new_api_token(roles=['admin'])",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=json.dumps({\"last_activity\": utcnow().isoformat()}),",
            "        method=\"post\",",
            "    )",
            "    r.raise_for_status()",
            "",
            "",
            "@mark.parametrize(",
            "    \"server_name, fresh\",",
            "    [",
            "        (\"\", True),",
            "        (\"\", False),",
            "        (\"exists\", True),",
            "        (\"exists\", False),",
            "        (\"nope\", True),",
            "        (\"nope\", False),",
            "    ],",
            ")",
            "async def test_update_server_activity(app, user, server_name, fresh):",
            "    token = user.new_api_token()",
            "    now = utcnow()",
            "    internal_now = now.replace(tzinfo=None)",
            "    # we use naive utc internally",
            "    # initialize last_activity for one named and the default server",
            "    for name in (\"\", \"exists\"):",
            "        user.spawners[name].orm_spawner.last_activity = internal_now",
            "    app.db.commit()",
            "",
            "    td = timedelta(minutes=1)",
            "    if fresh:",
            "        activity = now + td",
            "    else:",
            "        activity = now - td",
            "",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=json.dumps(",
            "            {\"servers\": {server_name: {\"last_activity\": activity.isoformat()}}}",
            "        ),",
            "        method=\"post\",",
            "    )",
            "    if server_name == \"nope\":",
            "        assert r.status_code == 400",
            "        reply = r.json()",
            "        assert server_name in reply[\"message\"]",
            "        assert \"No such server\" in reply[\"message\"]",
            "        assert user.name in reply[\"message\"]",
            "        return",
            "",
            "    r.raise_for_status()",
            "",
            "    # check that last activity was updated",
            "",
            "    if fresh:",
            "        expected = activity.replace(tzinfo=None)",
            "    else:",
            "        expected = now.replace(tzinfo=None)",
            "",
            "    assert user.spawners[server_name].orm_spawner.last_activity == expected",
            "",
            "",
            "# -----------------",
            "# General API tests",
            "# -----------------",
            "",
            "",
            "async def test_options(app):",
            "    r = await api_request(app, 'users', method='options')",
            "    r.raise_for_status()",
            "    assert 'Access-Control-Allow-Headers' in r.headers",
            "",
            "",
            "async def test_bad_json_body(app):",
            "    r = await api_request(app, 'users', method='post', data='notjson')",
            "    assert r.status_code == 400",
            "",
            "",
            "# ---------------------------------",
            "# Shutdown MUST always be last test",
            "# ---------------------------------",
            "",
            "",
            "def test_shutdown(app):",
            "    loop = app.io_loop",
            "",
            "    # have to do things a little funky since we are going to stop the loop,",
            "    # which makes gen_test unhappy. So we run the loop ourselves.",
            "",
            "    async def shutdown():",
            "        r = await api_request(",
            "            app,",
            "            'shutdown',",
            "            method='post',",
            "            data=json.dumps({'servers': True, 'proxy': True}),",
            "        )",
            "        return r",
            "",
            "    real_stop = loop.asyncio_loop.stop",
            "",
            "    def stop():",
            "        stop.called = True",
            "        loop.call_later(2, real_stop)",
            "",
            "    real_cleanup = app.cleanup",
            "",
            "    def cleanup():",
            "        cleanup.called = True",
            "        loop.call_later(1, real_cleanup)",
            "",
            "    app.cleanup = cleanup",
            "",
            "    with mock.patch.object(loop.asyncio_loop, 'stop', stop):",
            "        r = loop.run_sync(shutdown, timeout=5)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert cleanup.called",
            "    assert stop.called"
        ],
        "afterPatchFile": [
            "\"\"\"Tests for the REST API.\"\"\"",
            "",
            "import asyncio",
            "import json",
            "import re",
            "import sys",
            "import uuid",
            "from copy import deepcopy",
            "from dataclasses import dataclass",
            "from datetime import datetime, timedelta",
            "from unittest import mock",
            "from urllib.parse import parse_qs, quote, urlparse",
            "",
            "import pytest",
            "from dateutil.parser import parse as parse_date",
            "from pytest import fixture, mark",
            "from tornado.httputil import url_concat",
            "",
            "import jupyterhub",
            "",
            "from .. import orm",
            "from ..apihandlers.base import PAGINATION_MEDIA_TYPE",
            "from ..objects import Server",
            "from ..utils import url_path_join as ujoin",
            "from ..utils import utcnow",
            "from .conftest import new_username",
            "from .utils import (",
            "    add_user,",
            "    api_request,",
            "    async_requests,",
            "    auth_header,",
            "    find_user,",
            "    public_host,",
            "    public_url,",
            ")",
            "",
            "# --------------------",
            "# Authentication tests",
            "# --------------------",
            "",
            "",
            "async def test_auth_api(app):",
            "    db = app.db",
            "    r = await api_request(app, 'authorizations', 'gobbledygook')",
            "    assert r.status_code == 404",
            "",
            "    # make a new cookie token",
            "    user = find_user(db, 'admin')",
            "    api_token = user.new_api_token()",
            "",
            "    # check success:",
            "    r = await api_request(app, 'authorizations/token', api_token)",
            "    assert r.status_code == 200",
            "    reply = r.json()",
            "    assert reply['name'] == user.name",
            "",
            "    # check fail",
            "    r = await api_request(",
            "        app, 'authorizations/token', api_token, headers={'Authorization': 'no sir'}",
            "    )",
            "    assert r.status_code == 403",
            "",
            "    r = await api_request(",
            "        app,",
            "        'authorizations/token',",
            "        api_token,",
            "        headers={'Authorization': f'token: {user.cookie_id}'},",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.parametrize(",
            "    \"content_type, status\",",
            "    [",
            "        (\"text/plain\", 403),",
            "        # accepted, but invalid",
            "        (\"application/json; charset=UTF-8\", 400),",
            "    ],",
            ")",
            "async def test_post_content_type(app, content_type, status):",
            "    url = ujoin(public_host(app), app.hub.base_url)",
            "    host = urlparse(url).netloc",
            "    # add admin user",
            "    user = find_user(app.db, 'admin')",
            "    if user is None:",
            "        user = add_user(app.db, name='admin', admin=True)",
            "    cookies = await app.login_user('admin')",
            "",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data='{}',",
            "        headers={",
            "            \"Authorization\": \"\",",
            "            \"Content-Type\": content_type,",
            "        },",
            "        cookies=cookies,",
            "    )",
            "    assert r.status_code == status",
            "",
            "",
            "@mark.parametrize(\"xsrf_in_url\", [True, False, \"invalid\"])",
            "@mark.parametrize(",
            "    \"method, path\",",
            "    [",
            "        (\"GET\", \"user\"),",
            "        (\"POST\", \"users/{username}/tokens\"),",
            "    ],",
            ")",
            "async def test_xsrf_check(app, username, method, path, xsrf_in_url):",
            "    cookies = await app.login_user(username)",
            "    xsrf = cookies['_xsrf']",
            "    if xsrf_in_url == \"invalid\":",
            "        cookies.pop(\"_xsrf\")",
            "        # a valid old-style tornado xsrf token is no longer valid",
            "        xsrf = cookies['_xsrf'] = (",
            "            \"2|7329b149|d837ced983e8aac7468bc7a61ce3d51a|1708610065\"",
            "        )",
            "",
            "    url = path.format(username=username)",
            "    if xsrf_in_url:",
            "        url = f\"{url}?_xsrf={xsrf}\"",
            "",
            "    r = await api_request(",
            "        app,",
            "        url,",
            "        noauth=True,",
            "        cookies=cookies,",
            "    )",
            "    if xsrf_in_url is True:",
            "        assert r.status_code == 200",
            "    else:",
            "        assert r.status_code == 403",
            "",
            "",
            "@mark.parametrize(",
            "    \"auth, expected_message\",",
            "    [",
            "        (\"\", \"Missing or invalid credentials\"),",
            "        (\"cookie_no_xsrf\", \"'_xsrf' argument missing from GET\"),",
            "        (\"cookie_xsrf_mismatch\", \"XSRF cookie does not match GET argument\"),",
            "        (\"token_no_scope\", \"requires any of [list:users]\"),",
            "        (\"cookie_no_scope\", \"requires any of [list:users]\"),",
            "    ],",
            ")",
            "async def test_permission_error_messages(app, user, auth, expected_message):",
            "    # 1. no credentials, should be 403 and not mention xsrf",
            "",
            "    url = public_url(app, path=\"hub/api/users\")",
            "",
            "    kwargs = {}",
            "    kwargs[\"headers\"] = headers = {}",
            "    kwargs[\"params\"] = params = {}",
            "    if auth == \"token_no_scope\":",
            "        token = user.new_api_token()",
            "        headers[\"Authorization\"] = f\"Bearer {token}\"",
            "    elif \"cookie\" in auth:",
            "        cookies = kwargs[\"cookies\"] = await app.login_user(user.name)",
            "        if auth == \"cookie_no_scope\":",
            "            params[\"_xsrf\"] = cookies[\"_xsrf\"]",
            "        if auth == \"cookie_xsrf_mismatch\":",
            "            params[\"_xsrf\"] = \"somethingelse\"",
            "    headers['Sec-Fetch-Mode'] = 'cors'",
            "    r = await async_requests.get(url, **kwargs)",
            "    assert r.status_code == 403",
            "    response = r.json()",
            "    message = response[\"message\"]",
            "    assert expected_message in message",
            "",
            "",
            "# --------------",
            "# User API tests",
            "# --------------",
            "",
            "",
            "def normalize_timestamp(ts):",
            "    \"\"\"Normalize a timestamp",
            "",
            "    For easier comparison",
            "    \"\"\"",
            "    if ts is None:",
            "        return",
            "    return re.sub(r'\\d(\\.\\d+)?', '0', ts)",
            "",
            "",
            "def normalize_user(user):",
            "    \"\"\"Normalize a user model for comparison",
            "",
            "    smooths out user model with things like timestamps",
            "    for easier comparison",
            "    \"\"\"",
            "    for key in ('created', 'last_activity'):",
            "        user[key] = normalize_timestamp(user[key])",
            "    if 'roles' in user:",
            "        user['roles'] = sorted(user['roles'])",
            "    if 'servers' in user:",
            "        for server in user['servers'].values():",
            "            for key in ('started', 'last_activity'):",
            "                server[key] = normalize_timestamp(server[key])",
            "            server['progress_url'] = re.sub(",
            "                r'.*/hub/api', 'PREFIX/hub/api', server['progress_url']",
            "            )",
            "            if isinstance(server['state'], dict) and isinstance(",
            "                server['state'].get('pid', None), int",
            "            ):",
            "                server['state']['pid'] = 0",
            "    return user",
            "",
            "",
            "def fill_user(model):",
            "    \"\"\"Fill a default user model",
            "",
            "    Any unspecified fields will be filled with the defaults",
            "    \"\"\"",
            "    model.setdefault('server', None)",
            "    model.setdefault('kind', 'user')",
            "    model.setdefault('roles', [])",
            "    model.setdefault('groups', [])",
            "    model.setdefault('admin', False)",
            "    model.setdefault('pending', None)",
            "    model.setdefault('created', TIMESTAMP)",
            "    model.setdefault('last_activity', TIMESTAMP)",
            "    model.setdefault('servers', {})",
            "    return model",
            "",
            "",
            "TIMESTAMP = normalize_timestamp(datetime.now().isoformat() + 'Z')",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_get_users(app):",
            "    db = app.db",
            "",
            "    r = await api_request(app, 'users', headers=auth_header(db, 'admin'))",
            "    assert r.status_code == 200",
            "",
            "    users = sorted(r.json(), key=lambda d: d['name'])",
            "    users = [normalize_user(u) for u in users]",
            "    user_model = {",
            "        'name': 'user',",
            "        'admin': False,",
            "        'roles': ['user'],",
            "        'auth_state': None,",
            "    }",
            "    assert users == [",
            "        fill_user(",
            "            {",
            "                'name': 'admin',",
            "                'admin': True,",
            "                'roles': ['admin', 'user'],",
            "                'auth_state': None,",
            "            }",
            "        ),",
            "        fill_user(user_model),",
            "    ]",
            "    r = await api_request(app, 'users', headers=auth_header(db, 'user'))",
            "    assert r.status_code == 403",
            "",
            "",
            "@fixture",
            "def default_page_limit(app):",
            "    \"\"\"Set and return low default page size for testing\"\"\"",
            "    n = 10",
            "    with mock.patch.dict(app.tornado_settings, {\"api_page_default_limit\": n}):",
            "        yield n",
            "",
            "",
            "@fixture",
            "def max_page_limit(app):",
            "    \"\"\"Set and return low max page size for testing\"\"\"",
            "    n = 20",
            "    with mock.patch.dict(app.tornado_settings, {\"api_page_max_limit\": n}):",
            "        yield n",
            "",
            "",
            "@mark.user",
            "@mark.parametrize(",
            "    \"n, offset, limit, accepts_pagination, expected_count, include_stopped_servers\",",
            "    [",
            "        (10, None, None, False, 10, False),",
            "        (10, None, None, True, 10, False),",
            "        (10, 5, None, True, 5, False),",
            "        (10, 5, None, False, 5, False),",
            "        (10, None, 5, True, 5, True),",
            "        (10, 5, 1, True, 1, True),",
            "        (10, 10, 10, True, 0, False),",
            "        (  # default page limit, pagination expected",
            "            30,",
            "            None,",
            "            None,",
            "            True,",
            "            'default',",
            "            False,",
            "        ),",
            "        (",
            "            # default max page limit, pagination not expected",
            "            30,",
            "            None,",
            "            None,",
            "            False,",
            "            'max',",
            "            False,",
            "        ),",
            "        (",
            "            # limit exceeded",
            "            30,",
            "            None,",
            "            500,",
            "            False,",
            "            'max',",
            "            False,",
            "        ),",
            "    ],",
            ")",
            "async def test_get_users_pagination(",
            "    app,",
            "    n,",
            "    offset,",
            "    limit,",
            "    accepts_pagination,",
            "    expected_count,",
            "    default_page_limit,",
            "    max_page_limit,",
            "    include_stopped_servers,",
            "):",
            "    db = app.db",
            "",
            "    if expected_count == 'default':",
            "        expected_count = default_page_limit",
            "    elif expected_count == 'max':",
            "        expected_count = max_page_limit",
            "    # populate users",
            "    usernames = []",
            "",
            "    groups = []",
            "    for i in range(3):",
            "        group = orm.Group(name=f\"pagination-{i}\")",
            "        db.add(group)",
            "    db.commit()",
            "    existing_users = db.query(orm.User).order_by(orm.User.id.asc())",
            "    usernames.extend(u.name for u in existing_users)",
            "",
            "    for i in range(n - existing_users.count()):",
            "        name = new_username()",
            "        usernames.append(name)",
            "        user = add_user(db, app, name=name)",
            "        # add some users to groups",
            "        # make sure group membership doesn't affect pagination count",
            "        if i % 2:",
            "            user.groups = groups",
            "    db.commit()",
            "",
            "    total_users = db.query(orm.User).count()",
            "",
            "    url = 'users'",
            "    params = {}",
            "    if offset:",
            "        params['offset'] = offset",
            "    if limit:",
            "        params['limit'] = limit",
            "    url = url_concat(url, params)",
            "    if include_stopped_servers:",
            "        # assumes limit is set. There doesn't seem to be a way to set valueless query",
            "        # params using url_cat",
            "        url += \"&include_stopped_servers\"",
            "",
            "    headers = auth_header(db, 'admin')",
            "    if accepts_pagination:",
            "        headers['Accept'] = PAGINATION_MEDIA_TYPE",
            "    r = await api_request(app, url, headers=headers)",
            "    assert r.status_code == 200",
            "    response = r.json()",
            "    if accepts_pagination:",
            "        assert set(response) == {",
            "            \"items\",",
            "            \"_pagination\",",
            "        }",
            "        pagination = response[\"_pagination\"]",
            "        if include_stopped_servers and pagination[\"next\"]:",
            "            next_query = parse_qs(",
            "                urlparse(pagination[\"next\"][\"url\"]).query, keep_blank_values=True",
            "            )",
            "            assert \"include_stopped_servers\" in next_query",
            "        users = response[\"items\"]",
            "        assert pagination[\"total\"] == total_users",
            "    else:",
            "        users = response",
            "    assert len(users) == expected_count",
            "    expected_usernames = usernames",
            "    if offset:",
            "        expected_usernames = expected_usernames[offset:]",
            "    expected_usernames = expected_usernames[:expected_count]",
            "",
            "    got_usernames = [u['name'] for u in users]",
            "    assert got_usernames == expected_usernames",
            "",
            "",
            "@mark.user",
            "@mark.parametrize(",
            "    \"state\",",
            "    (\"inactive\", \"active\", \"ready\", \"invalid\"),",
            ")",
            "async def test_get_users_state_filter(app, state):",
            "    db = app.db",
            "",
            "    # has_one_active: one active, one inactive, zero ready",
            "    has_one_active = add_user(db, app=app, name='has_one_active')",
            "    # has_two_active: two active, ready servers",
            "    has_two_active = add_user(db, app=app, name='has_two_active')",
            "    # has_two_inactive: two spawners, neither active",
            "    has_two_inactive = add_user(db, app=app, name='has_two_inactive')",
            "    # has_zero: no Spawners registered at all",
            "    has_zero = add_user(db, app=app, name='has_zero')",
            "    total_users = db.query(orm.User).count()",
            "",
            "    test_usernames = {",
            "        \"has_one_active\",",
            "        \"has_two_active\",",
            "        \"has_two_inactive\",",
            "        \"has_zero\",",
            "    }",
            "",
            "    user_states = {",
            "        \"inactive\": [\"has_two_inactive\", \"has_zero\"],",
            "        \"ready\": [\"has_two_active\"],",
            "        \"active\": [\"has_one_active\", \"has_two_active\"],",
            "        \"invalid\": [],",
            "    }",
            "    expected = user_states[state]",
            "",
            "    def add_spawner(user, name='', active=True, ready=True):",
            "        \"\"\"Add a spawner in a requested state",
            "",
            "        If active, should turn up in an active query",
            "        If active and ready, should turn up in a ready query",
            "        If not active, should turn up in an inactive query",
            "        \"\"\"",
            "        spawner = user.spawners[name]",
            "        db.commit()",
            "        if active:",
            "            orm_server = orm.Server()",
            "            db.add(orm_server)",
            "            db.commit()",
            "            spawner.server = Server(orm_server=orm_server)",
            "            db.commit()",
            "            if not ready:",
            "                spawner._spawn_pending = True",
            "        return spawner",
            "",
            "    for name in (\"\", \"secondary\"):",
            "        add_spawner(has_two_active, name, active=True)",
            "        add_spawner(has_two_inactive, name, active=False)",
            "",
            "    add_spawner(has_one_active, active=True, ready=False)",
            "    add_spawner(has_one_active, \"inactive\", active=False)",
            "",
            "    r = await api_request(",
            "        app, f'users?state={state}', headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    if state == \"invalid\":",
            "        assert r.status_code == 400",
            "        return",
            "    assert r.status_code == 200",
            "",
            "    response = r.json()",
            "    users = response[\"items\"]",
            "    page = response[\"_pagination\"]",
            "",
            "    usernames = sorted(u[\"name\"] for u in users if u[\"name\"] in test_usernames)",
            "    assert usernames == expected",
            "    if state == \"ready\":",
            "        # \"ready\" can't actually get a correct count because it has post-filtering applied",
            "        # but it has an upper bound",
            "        assert page[\"total\"] >= len(users)",
            "    else:",
            "        assert page[\"total\"] == len(users)",
            "",
            "",
            "@mark.user",
            "async def test_get_users_name_filter(app):",
            "    db = app.db",
            "",
            "    add_user(db, app=app, name='q')",
            "    add_user(db, app=app, name='qr')",
            "    add_user(db, app=app, name='qrs')",
            "    add_user(db, app=app, name='qrst')",
            "    added_usernames = {'q', 'qr', 'qrs', 'qrst'}",
            "",
            "    r = await api_request(app, 'users')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert added_usernames.intersection(response_users) == added_usernames",
            "",
            "    r = await api_request(app, 'users?name_filter=q')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['q', 'qr', 'qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qr')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qr', 'qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qrs')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qrs', 'qrst']",
            "",
            "    r = await api_request(app, 'users?name_filter=qrst')",
            "    assert r.status_code == 200",
            "    response_users = [u.get(\"name\") for u in r.json()]",
            "    assert response_users == ['qrst']",
            "",
            "",
            "@mark.user",
            "@pytest.mark.parametrize(\"direction\", [\"asc\", \"desc\"])",
            "@pytest.mark.parametrize(\"sort\", [\"id\", \"name\", \"last_activity\"])",
            "async def test_get_users_sort(app, sort, direction):",
            "    db = app.db",
            "",
            "    # 4 users, different order depending on sort field",
            "    orders = {",
            "        \"id\": [\"1\", \"2\", \"3\", \"4\"],",
            "        \"name\": [\"a\", \"b\", \"c\", \"d\"],",
            "        \"last_activity\": [\"never\", \"early\", \"middle\", \"late\"],",
            "    }",
            "    expected_order = orders[sort]",
            "    sort_param = sort",
            "    if direction == \"desc\":",
            "        expected_order.reverse()",
            "        sort_param = \"-\" + sort",
            "",
            "    # create the users, encode the expected sort order in the names",
            "    u = add_user(db, app=app, name='xyz-c-1-middle')",
            "    u.last_activity = utcnow() - timedelta(hours=1)",
            "    u = add_user(db, app=app, name='xyz-a-2-late')",
            "    u.last_activity = utcnow()",
            "    u = add_user(db, app=app, name='xyz-d-3-never')",
            "    u.last_activity = None",
            "    u = add_user(db, app=app, name='xyz-b-4-early')",
            "    u.last_activity = utcnow() - timedelta(days=1)",
            "    app.db.commit()",
            "",
            "    @dataclass",
            "    class UserName:",
            "        \"\"\"Parse username so we can get the current sort field\"\"\"",
            "",
            "        id: str",
            "        name: str",
            "        last_activity: str",
            "",
            "        def __init__(self, username):",
            "            prefix, self.name, self.id, self.last_activity = username.split(\"-\")",
            "",
            "    # fetch 4 users in 2 pages of 2 items each",
            "    # to ensure offset is handled correctly",
            "    params = {",
            "        \"name_filter\": \"xyz\",",
            "        \"sort\": sort_param,",
            "        \"limit\": 2,",
            "    }",
            "",
            "    r = await api_request(",
            "        app, 'users', params=params, headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    assert r.status_code == 200",
            "    page_1 = r.json()",
            "",
            "    assert page_1[\"_pagination\"][\"total\"] == 4",
            "    users = page_1[\"items\"]",
            "    assert len(users) == 2",
            "",
            "    # next page",
            "    params[\"offset\"] = page_1[\"_pagination\"][\"next\"][\"offset\"]",
            "    r = await api_request(",
            "        app, 'users', params=params, headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    assert r.status_code == 200",
            "    page_2 = r.json()",
            "",
            "    # turn user dicts into list of only the relevant component,",
            "    # e.g. { \"name\": \"xyz-a-2-late\" } -> \"late\"",
            "    users.extend(page_2[\"items\"])",
            "    usernames = [UserName(u[\"name\"]) for u in users]",
            "    sorted_fields = [getattr(u, sort) for u in usernames]",
            "    assert sorted_fields == expected_order",
            "",
            "",
            "async def test_get_users_sort_invalid(app):",
            "    r = await api_request(app, \"users\", params={\"sort\": \"servers\"})",
            "    assert r.status_code == 400",
            "    r = await api_request(app, \"users\", params={\"sort\": \"--id\"})",
            "    assert r.status_code == 400",
            "",
            "",
            "@mark.user",
            "async def test_get_self(app):",
            "    db = app.db",
            "",
            "    # basic get self",
            "    r = await api_request(app, 'user')",
            "    r.raise_for_status()",
            "    assert r.json()['kind'] == 'user'",
            "",
            "    # identifying user via oauth token works",
            "    u = add_user(db, app=app, name='orpheus')",
            "    token = uuid.uuid4().hex",
            "    oauth_client = orm.OAuthClient(identifier='eurydice')",
            "    db.add(oauth_client)",
            "    db.commit()",
            "    oauth_token = orm.APIToken(",
            "        token=token,",
            "    )",
            "    db.add(oauth_token)",
            "    oauth_token.user = u.orm_user",
            "    oauth_token.oauth_client = oauth_client",
            "",
            "    db.commit()",
            "    r = await api_request(",
            "        app,",
            "        'user',",
            "        headers={'Authorization': 'token ' + token},",
            "    )",
            "    r.raise_for_status()",
            "    model = r.json()",
            "    assert model['name'] == u.name",
            "    assert model[\"token_id\"] == oauth_token.api_id",
            "",
            "    # invalid auth gets 403",
            "    r = await api_request(",
            "        app,",
            "        'user',",
            "        headers={'Authorization': 'token notvalid'},",
            "    )",
            "    assert r.status_code == 403",
            "",
            "",
            "async def test_get_self_service(app, mockservice):",
            "    r = await api_request(",
            "        app, \"user\", headers={\"Authorization\": f\"token {mockservice.api_token}\"}",
            "    )",
            "    r.raise_for_status()",
            "    service_info = r.json()",
            "",
            "    assert service_info['kind'] == 'service'",
            "    assert service_info['name'] == mockservice.name",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_user(app):",
            "    db = app.db",
            "    name = 'newuser'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert not user.admin",
            "    # assert newuser has default 'user' role",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_get_user(app):",
            "    name = 'user'",
            "    # get own model",
            "    r = await api_request(app, 'users', name, headers=auth_header(app.db, name))",
            "    r.raise_for_status()",
            "    # admin request",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "    )",
            "    r.raise_for_status()",
            "",
            "    user = normalize_user(r.json())",
            "    assert user == fill_user({'name': name, 'roles': ['user'], 'auth_state': None})",
            "",
            "    # admin request, no such user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'nosuchuser',",
            "    )",
            "    assert r.status_code == 404",
            "",
            "    # unauthorized request, no such user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'nosuchuser',",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 404",
            "",
            "    # unauthorized request for existing user",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        'admin',",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.user",
            "async def test_add_multi_user_bad(app):",
            "    r = await api_request(app, 'users', method='post')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'users', method='post', data='{}')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'users', method='post', data='[]')",
            "    assert r.status_code == 400",
            "",
            "",
            "@mark.user",
            "async def test_add_multi_user_invalid(app):",
            "    app.authenticator.username_pattern = r'w.*'",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data=json.dumps({'usernames': ['Willow', 'Andrew', 'Tara']}),",
            "    )",
            "    app.authenticator.username_pattern = ''",
            "    assert r.status_code == 400",
            "    assert r.json()['message'] == 'Invalid usernames: andrew, tara'",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "async def test_add_multi_user(app):",
            "    db = app.db",
            "    names = ['a', 'b']",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert names == r_names",
            "",
            "    for name in names:",
            "        user = find_user(db, name)",
            "        assert user is not None",
            "        assert user.name == name",
            "        assert not user.admin",
            "        # assert default 'user' role added",
            "        assert orm.Role.find(db, 'user') in user.roles",
            "        assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "    # try to create the same users again",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 409",
            "",
            "    names = ['a', 'b', 'ab']",
            "",
            "    # try to create the same users again",
            "    r = await api_request(",
            "        app, 'users', method='post', data=json.dumps({'usernames': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert r_names == ['ab']",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "@mark.parametrize(\"is_admin\", [True, False])",
            "async def test_add_multi_user_admin(app, create_user_with_scopes, is_admin):",
            "    db = app.db",
            "    requester = create_user_with_scopes(\"admin:users\")",
            "    requester.admin = is_admin",
            "    db.commit()",
            "    names = ['c', 'd']",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        method='post',",
            "        data=json.dumps({'usernames': names, 'admin': True}),",
            "        name=requester.name,",
            "    )",
            "    if is_admin:",
            "        assert r.status_code == 201",
            "    else:",
            "        assert r.status_code == 403",
            "        return",
            "    reply = r.json()",
            "    r_names = [user['name'] for user in reply]",
            "    assert names == r_names",
            "",
            "    for name in names:",
            "        user = find_user(db, name)",
            "        assert user is not None",
            "        assert user.name == name",
            "        assert user.admin",
            "        assert orm.Role.find(db, 'user') in user.roles",
            "        assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_add_user_bad(app):",
            "    db = app.db",
            "    name = 'dne_newuser'",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 400",
            "    user = find_user(db, name)",
            "    assert user is None",
            "",
            "",
            "@mark.user",
            "async def test_add_user_duplicate(app):",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name)",
            "    # double-check that it exists",
            "    assert user is not None",
            "    r = await api_request(app, 'users', name, method='post')",
            "    # special 409 conflict for creating a user that already exists",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "@mark.parametrize(\"is_admin\", [True, False])",
            "async def test_add_admin(app, create_user_with_scopes, is_admin):",
            "    db = app.db",
            "    name = 'newadmin'",
            "    user = create_user_with_scopes(\"admin:users\")",
            "    user.admin = is_admin",
            "    db.commit()",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        method='post',",
            "        data=json.dumps({'admin': True}),",
            "        name=user.name,",
            "    )",
            "    if is_admin:",
            "        assert r.status_code == 201",
            "    else:",
            "        assert r.status_code == 403",
            "        return",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert user.admin",
            "    # assert newadmin has default 'admin' role",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "async def test_delete_user(app):",
            "    db = app.db",
            "    mal = add_user(db, name='mal')",
            "    r = await api_request(app, 'users', 'mal', method='delete')",
            "    assert r.status_code == 204",
            "",
            "",
            "@mark.user",
            "@mark.role",
            "@mark.parametrize(\"is_admin\", [True, False])",
            "async def test_user_make_admin(app, create_user_with_scopes, is_admin):",
            "    db = app.db",
            "    requester = create_user_with_scopes('admin:users')",
            "    requester.admin = is_admin",
            "    db.commit()",
            "",
            "    name = new_username(\"make_admin\")",
            "    r = await api_request(app, 'users', name, method='post')",
            "    assert r.status_code == 201",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert not user.admin",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') not in user.roles",
            "",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        method='patch',",
            "        data=json.dumps({'admin': True}),",
            "        name=requester.name,",
            "    )",
            "    if is_admin:",
            "        assert r.status_code == 200",
            "    else:",
            "        assert r.status_code == 403",
            "        return",
            "    user = find_user(db, name)",
            "    assert user is not None",
            "    assert user.name == name",
            "    assert user.admin",
            "    assert orm.Role.find(db, 'user') in user.roles",
            "    assert orm.Role.find(db, 'admin') in user.roles",
            "",
            "",
            "@mark.user",
            "@mark.parametrize(\"requester_is_admin\", [True, False])",
            "@mark.parametrize(\"user_is_admin\", [True, False])",
            "async def test_user_set_name(",
            "    app, user, create_user_with_scopes, requester_is_admin, user_is_admin",
            "):",
            "    db = app.db",
            "    requester = create_user_with_scopes('admin:users')",
            "    requester.admin = requester_is_admin",
            "    user.admin = user_is_admin",
            "    db.commit()",
            "    new_name = new_username()",
            "",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        user.name,",
            "        method='patch',",
            "        data=json.dumps({'name': new_name}),",
            "        name=requester.name,",
            "    )",
            "    if requester_is_admin or not user_is_admin:",
            "        assert r.status_code == 200",
            "    else:",
            "        assert r.status_code == 403",
            "        return",
            "    renamed = find_user(db, new_name)",
            "    assert renamed is not None",
            "    assert renamed.name == new_name",
            "    assert renamed.id == user.id",
            "",
            "",
            "@mark.user",
            "async def test_set_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'admin'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "",
            "    r = await api_request(",
            "        app, 'users', name, method='patch', data=json.dumps({'auth_state': auth_state})",
            "    )",
            "",
            "    assert r.status_code == 200",
            "    users_auth_state = await user.get_auth_state()",
            "    assert users_auth_state == auth_state",
            "",
            "",
            "@mark.user",
            "async def test_user_set_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    user_auth_state = await user.get_auth_state()",
            "    assert user_auth_state is None",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        method='patch',",
            "        data=json.dumps({'auth_state': auth_state}),",
            "        headers=auth_header(app.db, name),",
            "    )",
            "    assert r.status_code == 403",
            "    user_auth_state = await user.get_auth_state()",
            "    assert user_auth_state is None",
            "",
            "",
            "@mark.user",
            "async def test_admin_get_auth_state(app, auth_state_enabled):",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'admin'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    await user.save_auth_state(auth_state)",
            "",
            "    r = await api_request(app, 'users', name)",
            "",
            "    assert r.status_code == 200",
            "    assert r.json()['auth_state'] == auth_state",
            "",
            "",
            "@mark.user",
            "async def test_user_get_auth_state(app, auth_state_enabled):",
            "    # explicitly check that a user will not get their own auth state via the API",
            "    auth_state = {'secret': 'hello'}",
            "    db = app.db",
            "    name = 'user'",
            "    user = find_user(db, name, app=app)",
            "    assert user is not None",
            "    assert user.name == name",
            "    await user.save_auth_state(auth_state)",
            "",
            "    r = await api_request(app, 'users', name, headers=auth_header(app.db, name))",
            "",
            "    assert r.status_code == 200",
            "    assert 'auth_state' not in r.json()",
            "",
            "",
            "async def test_spawn(app):",
            "    db = app.db",
            "    name = 'wash'",
            "    user = add_user(db, app=app, name=name)",
            "    options = {'s': ['value'], 'i': 5}",
            "    before_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert app_user.spawner.user_options == options",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is None",
            "",
            "    assert spawner.server.base_url == ujoin(app.base_url, f'user/{name}') + '/'",
            "    url = public_url(app, user)",
            "    kwargs = {}",
            "    if app.internal_ssl:",
            "        kwargs['cert'] = (app.internal_ssl_cert, app.internal_ssl_key)",
            "        kwargs[\"verify\"] = app.internal_ssl_ca",
            "    r = await async_requests.get(url, **kwargs)",
            "    assert r.status_code == 200",
            "    assert r.text == spawner.server.base_url",
            "",
            "    r = await async_requests.get(ujoin(url, 'args'), **kwargs)",
            "    assert r.status_code == 200",
            "    argv = r.json()",
            "    assert '--port' not in ' '.join(argv)",
            "    # we pass no CLI args anymore:",
            "    assert len(argv) == 1",
            "    r = await async_requests.get(ujoin(url, 'env'), **kwargs)",
            "    env = r.json()",
            "    for expected in [",
            "        'JUPYTERHUB_USER',",
            "        'JUPYTERHUB_BASE_URL',",
            "        'JUPYTERHUB_API_TOKEN',",
            "        'JUPYTERHUB_SERVICE_URL',",
            "    ]:",
            "        assert expected in env",
            "    if app.subdomain_host:",
            "        assert env['JUPYTERHUB_HOST'] == app.subdomain_host",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    assert r.status_code == 204",
            "",
            "    assert 'pid' not in user.orm_spawners[''].state",
            "    status = await app_user.spawner.poll()",
            "    assert status == 0",
            "",
            "    # check that we cleaned up after ourselves",
            "    assert spawner.server is None",
            "    after_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    assert before_servers == after_servers",
            "    tokens = list(db.query(orm.APIToken).filter(orm.APIToken.user_id == user.id))",
            "    assert tokens == []",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "async def test_user_options(app, username):",
            "    db = app.db",
            "    name = username",
            "    user = add_user(db, app=app, name=name)",
            "    options = {'s': ['value'], 'i': 5}",
            "    before_servers = sorted(db.query(orm.Server), key=lambda s: s.url)",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == options",
            "    assert spawner.orm_spawner.user_options == options",
            "",
            "    # stop the server",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "",
            "    # orm_spawner still exists and has a reference to the user_options",
            "    assert spawner.orm_spawner.user_options == options",
            "",
            "    # spawn again, no options specified",
            "    # should re-use options from last spawn",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == options",
            "",
            "    # stop the server",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "",
            "    # spawn again, new options specified",
            "    # should override options from last spawn",
            "    new_options = {'key': 'value'}",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', data=json.dumps(new_options)",
            "    )",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "    assert app_user.spawner is not None",
            "    spawner = app_user.spawner",
            "    assert spawner.user_options == new_options",
            "    # saved in db",
            "    assert spawner.orm_spawner.user_options == new_options",
            "",
            "",
            "async def test_spawn_handler(app):",
            "    \"\"\"Test that the requesting Handler is passed to Spawner.handler\"\"\"",
            "    db = app.db",
            "    name = 'salmon'",
            "    user = add_user(db, app=app, name=name)",
            "    app_user = app.users[name]",
            "",
            "    # spawn via API with ?foo=bar",
            "    r = await api_request(",
            "        app, 'users', name, 'server', method='post', params={'foo': 'bar'}",
            "    )",
            "    r.raise_for_status()",
            "",
            "    # verify that request params got passed down",
            "    # implemented in MockSpawner",
            "    kwargs = {}",
            "    if app.external_certs:",
            "        kwargs['verify'] = app.external_certs['files']['ca']",
            "    url = public_url(app, user)",
            "    r = await async_requests.get(ujoin(url, 'env'), **kwargs)",
            "    env = r.json()",
            "    assert 'HANDLER_ARGS' in env",
            "    assert env['HANDLER_ARGS'] == 'foo=bar'",
            "    # make user spawner.handler doesn't persist after spawn finishes",
            "    assert app_user.spawner.handler is None",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "",
            "",
            "@mark.slow",
            "async def test_slow_spawn(app, no_patience, slow_spawn):",
            "    db = app.db",
            "    name = 'zoe'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._spawn_pending",
            "    assert not app_user.spawner._stop_pending",
            "    assert app.users.count_active_users()['pending'] == 1",
            "",
            "    async def wait_spawn():",
            "        while not app_user.running:",
            "            await asyncio.sleep(0.1)",
            "",
            "    await wait_spawn()",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is None",
            "",
            "    async def wait_stop():",
            "        while app_user.spawner._stop_pending:",
            "            await asyncio.sleep(0.1)",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._stop_pending",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    assert r.status_code == 202",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._stop_pending",
            "",
            "    await wait_stop()",
            "    assert not app_user.spawner._stop_pending",
            "    assert app_user.spawner is not None",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    # 204 deleted if there's no such server",
            "    assert r.status_code == 204",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    assert app.users.count_active_users()['active'] == 0",
            "",
            "",
            "async def test_never_spawn(app, no_patience, never_spawn):",
            "    db = app.db",
            "    name = 'badger'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert app_user.spawner is not None",
            "    assert app_user.spawner._spawn_pending",
            "    assert app.users.count_active_users()['pending'] == 1",
            "",
            "    while app_user.spawner.pending:",
            "        await asyncio.sleep(0.1)",
            "        print(app_user.spawner.pending)",
            "",
            "    assert not app_user.spawner._spawn_pending",
            "    status = await app_user.spawner.poll()",
            "    assert status is not None",
            "    # failed spawn should decrement pending count",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "async def test_bad_spawn(app, bad_spawn):",
            "    db = app.db",
            "    name = 'prim'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    # check that we don't re-use spawners that failed",
            "    user.spawners[''].reused = True",
            "    assert r.status_code == 500",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    # check that we don't re-use spawners that failed",
            "    spawner = user.spawners['']",
            "    assert not getattr(spawner, 'reused', False)",
            "",
            "",
            "async def test_spawn_nosuch_user(app):",
            "    r = await api_request(app, 'users', \"nosuchuser\", 'server', method='post')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_slow_bad_spawn(app, no_patience, slow_bad_spawn):",
            "    db = app.db",
            "    name = 'zaphod'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    while user.spawner.pending:",
            "        await asyncio.sleep(0.1)",
            "    # spawn failed",
            "    assert not user.running",
            "    assert app.users.count_active_users()['pending'] == 0",
            "",
            "",
            "def next_event(it):",
            "    \"\"\"read an event from an eventstream\"\"\"",
            "    while True:",
            "        try:",
            "            line = next(it)",
            "        except StopIteration:",
            "            return",
            "        if line.startswith('data:'):",
            "            return json.loads(line.split(':', 1)[1])",
            "",
            "",
            "@mark.slow",
            "async def test_progress(request, app, no_patience, slow_spawn):",
            "    db = app.db",
            "    name = 'martin'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 0, 'message': 'Server requested'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 50, 'message': 'Spawning server...'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    url = app_user.url",
            "    assert evt == {",
            "        'progress': 100,",
            "        'message': f'Server ready at {url}',",
            "        'html_message': f'Server ready at <a href=\"{url}\">{url}</a>',",
            "        'url': url,",
            "        'ready': True,",
            "    }",
            "",
            "",
            "async def test_progress_not_started(request, app):",
            "    db = app.db",
            "    name = 'nope'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server', method='delete')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_progress_not_found(request, app):",
            "    db = app.db",
            "    name = 'noserver'",
            "    r = await api_request(app, 'users', 'nosuchuser', 'server/progress')",
            "    assert r.status_code == 404",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server/progress')",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_progress_ready(request, app):",
            "    \"\"\"Test progress API when spawner is already started",
            "",
            "    e.g. a race between requesting progress and progress already being complete",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "",
            "",
            "async def test_progress_ready_hook_async_func(request, app):",
            "    \"\"\"Test progress ready hook in Spawner class with an async function\"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    html_message = 'customized html message'",
            "    spawner = app_user.spawner",
            "",
            "    async def custom_progress_ready_hook(spawner, ready_event):",
            "        ready_event['html_message'] = html_message",
            "        return ready_event",
            "",
            "    spawner.progress_ready_hook = custom_progress_ready_hook",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "    assert evt['html_message'] == html_message",
            "",
            "",
            "async def test_progress_ready_hook_sync_func(request, app):",
            "    \"\"\"Test progress ready hook in Spawner class with a sync function\"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    html_message = 'customized html message'",
            "    spawner = app_user.spawner",
            "",
            "    def custom_progress_ready_hook(spawner, ready_event):",
            "        ready_event['html_message'] = html_message",
            "        return ready_event",
            "",
            "    spawner.progress_ready_hook = custom_progress_ready_hook",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "    assert evt['html_message'] == html_message",
            "",
            "",
            "async def test_progress_ready_hook_async_func_exception(request, app):",
            "    \"\"\"Test progress ready hook in Spawner class with an exception in",
            "    an async function",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'saga'",
            "    app_user = add_user(db, app=app, name=name)",
            "    html_message = f'Server ready at <a href=\"{app_user.url}\">{app_user.url}</a>'",
            "    spawner = app_user.spawner",
            "",
            "    async def custom_progress_ready_hook(spawner, ready_event):",
            "        ready_event[\"html_message\"] = \".\"",
            "        raise Exception()",
            "",
            "    spawner.progress_ready_hook = custom_progress_ready_hook",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "    assert evt['ready']",
            "    assert evt['url'] == app_user.url",
            "    assert evt['html_message'] == html_message",
            "",
            "",
            "async def test_progress_bad(request, app, bad_spawn):",
            "    \"\"\"Test progress API when spawner has already failed\"\"\"",
            "    db = app.db",
            "    name = 'simon'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 500",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {",
            "        'progress': 100,",
            "        'failed': True,",
            "        'message': \"Spawn failed: I don't work!\",",
            "    }",
            "",
            "",
            "async def test_progress_bad_slow(request, app, no_patience, slow_bad_spawn):",
            "    \"\"\"Test progress API when spawner fails while watching\"\"\"",
            "    db = app.db",
            "    name = 'eugene'",
            "    app_user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    assert r.headers['content-type'] == 'text/event-stream'",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 0",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 50",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {",
            "        'progress': 100,",
            "        'failed': True,",
            "        'message': \"Spawn failed: I don't work!\",",
            "    }",
            "",
            "",
            "async def progress_forever():",
            "    \"\"\"progress function that yields messages forever\"\"\"",
            "    for i in range(1, 10):",
            "        yield {'progress': i, 'message': f'Stage {i}'}",
            "        # wait a long time before the next event",
            "        await asyncio.sleep(10)",
            "",
            "",
            "async def test_spawn_progress_cutoff(request, app, no_patience, slow_spawn):",
            "    \"\"\"Progress events stop when Spawner finishes",
            "",
            "    even if progress iterator is still going.",
            "    \"\"\"",
            "    db = app.db",
            "    name = 'geddy'",
            "    app_user = add_user(db, app=app, name=name)",
            "    app_user.spawner.progress = progress_forever",
            "    app_user.spawner.delay = 1",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    r = await api_request(app, 'users', name, 'server/progress', stream=True)",
            "    r.raise_for_status()",
            "    request.addfinalizer(r.close)",
            "    ex = async_requests.executor",
            "    line_iter = iter(r.iter_lines(decode_unicode=True))",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 0",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt == {'progress': 1, 'message': 'Stage 1'}",
            "    evt = await ex.submit(next_event, line_iter)",
            "    assert evt['progress'] == 100",
            "",
            "",
            "async def test_spawn_limit(app, no_patience, slow_spawn, request):",
            "    db = app.db",
            "    p = mock.patch.dict(app.tornado_settings, {'concurrent_spawn_limit': 2})",
            "    p.start()",
            "    request.addfinalizer(p.stop)",
            "",
            "    # start two pending spawns",
            "    names = ['ykka', 'hjarka']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    users[0].spawner._start_future = asyncio.Future()",
            "    users[1].spawner._start_future = asyncio.Future()",
            "    for name in names:",
            "        await api_request(app, 'users', name, 'server', method='post')",
            "    assert app.users.count_active_users()['pending'] == 2",
            "",
            "    # ykka and hjarka's spawns are both pending. Essun should fail with 429",
            "    name = 'essun'",
            "    user = add_user(db, app=app, name=name)",
            "    user.spawner._start_future = asyncio.Future()",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 429",
            "",
            "    # allow ykka to start",
            "    users[0].spawner._start_future.set_result(None)",
            "    # wait for ykka to finish",
            "    while not users[0].running:",
            "        await asyncio.sleep(0.1)",
            "",
            "    assert app.users.count_active_users()['pending'] == 1",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    assert app.users.count_active_users()['pending'] == 2",
            "    users.append(user)",
            "    # allow hjarka and essun to finish starting",
            "    for user in users[1:]:",
            "        user.spawner._start_future.set_result(None)",
            "    while not all(u.running for u in users):",
            "        await asyncio.sleep(0.1)",
            "",
            "    # everybody's running, pending count should be back to 0",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    for u in users:",
            "        u.spawner.delay = 0",
            "        r = await api_request(app, 'users', u.name, 'server', method='delete')",
            "        r.raise_for_status()",
            "    while any(u.spawner.active for u in users):",
            "        await asyncio.sleep(0.1)",
            "",
            "",
            "@mark.slow",
            "async def test_active_server_limit(app, request):",
            "    db = app.db",
            "    p = mock.patch.dict(app.tornado_settings, {'active_server_limit': 2})",
            "    p.start()",
            "    request.addfinalizer(p.stop)",
            "",
            "    # start two pending spawns",
            "    names = ['ykka', 'hjarka']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    for name in names:",
            "        r = await api_request(app, 'users', name, 'server', method='post')",
            "        r.raise_for_status()",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "",
            "    # ykka and hjarka's servers are running. Essun should fail with 429",
            "    name = 'essun'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 429",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "",
            "    # stop one server",
            "    await api_request(app, 'users', names[0], 'server', method='delete')",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 1",
            "    assert counts['ready'] == 1",
            "    assert counts['pending'] == 0",
            "",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    r.raise_for_status()",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 2",
            "    assert counts['ready'] == 2",
            "    assert counts['pending'] == 0",
            "    users.append(user)",
            "",
            "    # everybody's running, pending count should be back to 0",
            "    assert app.users.count_active_users()['pending'] == 0",
            "    for u in users:",
            "        if not u.spawner.active:",
            "            continue",
            "        r = await api_request(app, 'users', u.name, 'server', method='delete')",
            "        r.raise_for_status()",
            "",
            "    counts = app.users.count_active_users()",
            "    assert counts['active'] == 0",
            "    assert counts['ready'] == 0",
            "    assert counts['pending'] == 0",
            "",
            "",
            "@mark.slow",
            "async def test_start_stop_race(app, no_patience, slow_spawn):",
            "    user = add_user(app.db, app, name='panda')",
            "    spawner = user.spawner",
            "    # start the server",
            "    r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    assert spawner.pending == 'spawn'",
            "    spawn_future = spawner._spawn_future",
            "    # additional spawns while spawning shouldn't trigger a new spawn",
            "    with mock.patch.object(spawner, 'start') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "    assert m.call_count == 0",
            "",
            "    # stop while spawning is okay now",
            "    spawner.delay = 3",
            "    r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 202",
            "    assert spawner.pending == 'stop'",
            "    assert spawn_future.cancelled()",
            "    assert spawner._spawn_future is None",
            "    # make sure we get past deleting from the proxy",
            "    await asyncio.sleep(1)",
            "    # additional stops while stopping shouldn't trigger a new stop",
            "    with mock.patch.object(spawner, 'stop') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='delete')",
            "    assert r.status_code == 202",
            "    assert m.call_count == 0",
            "    # start while stopping is not allowed",
            "    with mock.patch.object(spawner, 'start') as m:",
            "        r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 400",
            "",
            "    while spawner.active:",
            "        await asyncio.sleep(0.1)",
            "    # start after stop is okay",
            "    r = await api_request(app, 'users', user.name, 'server', method='post')",
            "    assert r.status_code == 202",
            "",
            "",
            "async def test_get_proxy(app):",
            "    r = await api_request(app, 'proxy')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert list(reply.keys()) == [app.hub.routespec]",
            "",
            "",
            "@mark.parametrize(\"offset\", (0, 1))",
            "async def test_get_proxy_pagination(app, offset):",
            "    r = await api_request(",
            "        app, f'proxy?offset={offset}', headers={\"Accept\": PAGINATION_MEDIA_TYPE}",
            "    )",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert set(reply) == {\"items\", \"_pagination\"}",
            "    assert list(reply[\"items\"].keys()) == [app.hub.routespec][offset:]",
            "",
            "",
            "async def test_cookie(app):",
            "    db = app.db",
            "    name = 'patience'",
            "    user = add_user(db, app=app, name=name)",
            "    r = await api_request(app, 'users', name, 'server', method='post')",
            "    assert r.status_code == 201",
            "    assert 'pid' in user.orm_spawners[''].state",
            "    app_user = app.users[name]",
            "",
            "    cookies = await app.login_user(name)",
            "    cookie_name = app.hub.cookie_name",
            "    # cookie jar gives '\"cookie-value\"', we want 'cookie-value'",
            "    cookie = cookies[cookie_name][1:-1]",
            "    r = await api_request(app, 'authorizations/cookie', cookie_name, \"nothintoseehere\")",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(",
            "        app, 'authorizations/cookie', cookie_name, quote(cookie, safe='')",
            "    )",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "    # deprecated cookie in body:",
            "    r = await api_request(app, 'authorizations/cookie', cookie_name, data=cookie)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "def normalize_token(token):",
            "    for key in ('created', 'last_activity'):",
            "        token[key] = normalize_timestamp(token[key])",
            "    return token",
            "",
            "",
            "async def test_check_token(app):",
            "    name = 'book'",
            "    user = add_user(app.db, app=app, name=name)",
            "    token = user.new_api_token()",
            "    r = await api_request(app, 'authorizations/token', token)",
            "    r.raise_for_status()",
            "    user_model = r.json()",
            "    assert user_model['name'] == name",
            "    r = await api_request(app, 'authorizations/token', 'notauthorized')",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.parametrize(\"headers, status\", [({}, 404), ({'Authorization': 'token bad'}, 404)])",
            "async def test_get_new_token_deprecated(app, headers, status):",
            "    # request a new token",
            "    r = await api_request(",
            "        app, 'authorizations', 'token', method='post', headers=headers",
            "    )",
            "    assert r.status_code == status",
            "",
            "",
            "@mark.parametrize(",
            "    \"headers, status, note, expires_in\",",
            "    [",
            "        ({}, 201, 'test note', None),",
            "        ({}, 201, '', 100),",
            "        ({'Authorization': 'token bad'}, 403, '', None),",
            "    ],",
            ")",
            "async def test_get_new_token(app, headers, status, note, expires_in):",
            "    options = {}",
            "    if note:",
            "        options['note'] = note",
            "    if expires_in:",
            "        options['expires_in'] = expires_in",
            "    if options:",
            "        body = json.dumps(options)",
            "    else:",
            "        body = ''",
            "    # request a new token",
            "    r = await api_request(",
            "        app, 'users/admin/tokens', method='post', headers=headers, data=body",
            "    )",
            "    assert r.status_code == status",
            "    if status != 201:",
            "        return",
            "    # check the new-token reply",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    assert reply['user'] == 'admin'",
            "    assert reply['created']",
            "    assert 'last_activity' in reply",
            "    if expires_in:",
            "        assert isinstance(reply['expires_at'], str)",
            "    else:",
            "        assert reply['expires_at'] is None",
            "    if note:",
            "        assert reply['note'] == note",
            "    else:",
            "        assert reply['note'] == 'Requested via api'",
            "    token_id = reply['id']",
            "    initial = normalize_token(reply)",
            "    # pop token for later comparison",
            "    initial.pop('token')",
            "",
            "    # check the validity of the new token",
            "    r = await api_request(app, 'users/admin/tokens', token_id)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert normalize_token(reply) == initial",
            "",
            "    # delete the token",
            "    r = await api_request(app, 'users/admin/tokens', token_id, method='delete')",
            "    assert r.status_code == 204",
            "    # verify deletion",
            "    r = await api_request(app, 'users/admin/tokens', token_id)",
            "    assert r.status_code == 404",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"expires_in_max, expires_in, expected\",",
            "    [",
            "        (86400, None, 86400),",
            "        (86400, 86400, 86400),",
            "        (86400, 86401, 'error'),",
            "        (3600, 100, 100),",
            "        (None, None, None),",
            "        (None, 86400, 86400),",
            "    ],",
            ")",
            "async def test_token_expires_in_max(app, user, expires_in_max, expires_in, expected):",
            "    options = {",
            "        \"expires_in\": expires_in,",
            "    }",
            "    # request a new token",
            "    with mock.patch.dict(",
            "        app.tornado_settings, {\"token_expires_in_max_seconds\": expires_in_max}",
            "    ):",
            "        r = await api_request(",
            "            app,",
            "            f'users/{user.name}/tokens',",
            "            method='post',",
            "            data=json.dumps(options),",
            "        )",
            "    if expected == 'error':",
            "        assert r.status_code == 400",
            "        assert f\"must not exceed {expires_in_max}\" in r.json()[\"message\"]",
            "        return",
            "    else:",
            "        assert r.status_code == 201",
            "    token_model = r.json()",
            "    if expected is None:",
            "        assert token_model[\"expires_at\"] is None",
            "    else:",
            "        expected_expires_at = utcnow() + timedelta(seconds=expected)",
            "        expires_at = parse_date(token_model[\"expires_at\"])",
            "        assert abs((expires_at - expected_expires_at).total_seconds()) < 30",
            "",
            "",
            "@mark.parametrize(",
            "    \"as_user, for_user, status\",",
            "    [",
            "        ('admin', 'other', 201),",
            "        ('admin', 'missing', 403),",
            "        ('user', 'other', 403),",
            "        ('user', 'user', 201),",
            "    ],",
            ")",
            "async def test_token_for_user(app, as_user, for_user, status):",
            "    # ensure both users exist",
            "    u = add_user(app.db, app, name=as_user)",
            "    if for_user != 'missing':",
            "        for_user_obj = add_user(app.db, app, name=for_user)",
            "    data = {'username': for_user}",
            "    headers = {'Authorization': f'token {u.new_api_token()}'}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        for_user,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data),",
            "        headers=headers,",
            "    )",
            "    assert r.status_code == status",
            "    reply = r.json()",
            "    if status != 201:",
            "        return",
            "    assert 'token' in reply",
            "",
            "    token_id = reply['id']",
            "    r = await api_request(app, 'users', for_user, 'tokens', token_id, headers=headers)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['user'] == for_user",
            "    if for_user == as_user:",
            "        note = 'Requested via api'",
            "    else:",
            "        note = f'Requested via api by user {as_user}'",
            "    assert reply['note'] == note",
            "",
            "    # delete the token",
            "    r = await api_request(",
            "        app, 'users', for_user, 'tokens', token_id, method='delete', headers=headers",
            "    )",
            "",
            "    assert r.status_code == 204",
            "    r = await api_request(app, 'users', for_user, 'tokens', token_id, headers=headers)",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_token_authenticator_noauth(app):",
            "    \"\"\"Create a token for a user relying on Authenticator.authenticate and no auth header\"\"\"",
            "    name = 'user'",
            "    data = {'auth': {'username': name, 'password': name}}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data) if data else None,",
            "        noauth=True,",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    r = await api_request(app, 'authorizations', 'token', reply['token'])",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "async def test_token_authenticator_dict_noauth(app):",
            "    \"\"\"Create a token for a user relying on Authenticator.authenticate and no auth header\"\"\"",
            "    app.authenticator.auth_state = {'who': 'cares'}",
            "    name = 'user'",
            "    data = {'auth': {'username': name, 'password': name}}",
            "    r = await api_request(",
            "        app,",
            "        'users',",
            "        name,",
            "        'tokens',",
            "        method='post',",
            "        data=json.dumps(data) if data else None,",
            "        noauth=True,",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    assert 'token' in reply",
            "    r = await api_request(app, 'authorizations', 'token', reply['token'])",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply['name'] == name",
            "",
            "",
            "@mark.parametrize(",
            "    \"as_user, for_user, status\",",
            "    [",
            "        ('admin', 'other', 200),",
            "        ('admin', 'missing', 404),",
            "        ('user', 'other', 404),",
            "        ('user', 'user', 200),",
            "    ],",
            ")",
            "async def test_token_list(app, as_user, for_user, status):",
            "    u = add_user(app.db, app, name=as_user)",
            "    if for_user != 'missing':",
            "        for_user_obj = add_user(app.db, app, name=for_user)",
            "    headers = {'Authorization': f'token {u.new_api_token()}'}",
            "    r = await api_request(app, 'users', for_user, 'tokens', headers=headers)",
            "    assert r.status_code == status",
            "    if status != 200:",
            "        return",
            "    reply = r.json()",
            "    assert sorted(reply) == ['api_tokens']",
            "    assert len(reply['api_tokens']) == len(for_user_obj.api_tokens)",
            "    assert all(token['user'] == for_user for token in reply['api_tokens'])",
            "    # validate individual token ids",
            "    for token in reply['api_tokens']:",
            "        r = await api_request(",
            "            app, 'users', for_user, 'tokens', token['id'], headers=headers",
            "        )",
            "        r.raise_for_status()",
            "        reply = r.json()",
            "        assert normalize_token(reply) == normalize_token(token)",
            "",
            "",
            "# ---------------",
            "# Group API tests",
            "# ---------------",
            "",
            "",
            "@mark.group",
            "async def test_groups_list(app):",
            "    r = await api_request(app, 'groups')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == []",
            "",
            "    # create two groups",
            "    group = orm.Group(name='alphaflight')",
            "    group_2 = orm.Group(name='betaflight')",
            "    app.db.add(group)",
            "    app.db.add(group_2)",
            "    app.db.commit()",
            "",
            "    r = await api_request(app, 'groups')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        },",
            "        {",
            "            'kind': 'group',",
            "            'name': 'betaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        },",
            "    ]",
            "",
            "    # Test offset for pagination",
            "    r = await api_request(app, \"groups?offset=1\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert r.status_code == 200",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'betaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "    r = await api_request(app, \"groups?offset=10\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == []",
            "",
            "    # Test limit for pagination",
            "    r = await api_request(app, \"groups?limit=1\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert r.status_code == 200",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "    # 0 is rounded up to 1",
            "    r = await api_request(app, \"groups?limit=0\")",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == [",
            "        {",
            "            'kind': 'group',",
            "            'name': 'alphaflight',",
            "            'users': [],",
            "            'roles': [],",
            "            'properties': {},",
            "        }",
            "    ]",
            "",
            "",
            "@mark.group",
            "async def test_add_multi_group(app):",
            "    db = app.db",
            "    names = ['group1', 'group2']",
            "    r = await api_request(",
            "        app, 'groups', method='post', data=json.dumps({'groups': names})",
            "    )",
            "    assert r.status_code == 201",
            "    reply = r.json()",
            "    r_names = [group['name'] for group in reply]",
            "    assert names == r_names",
            "",
            "    # try to create the same groups again",
            "    r = await api_request(",
            "        app, 'groups', method='post', data=json.dumps({'groups': names})",
            "    )",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.group",
            "async def test_group_get(app):",
            "    group = orm.Group(name='alphaflight')",
            "    app.db.add(group)",
            "    app.db.commit()",
            "    group = orm.Group.find(app.db, name='alphaflight')",
            "    user = add_user(app.db, app=app, name='sasquatch')",
            "    group.users.append(user.orm_user)",
            "    app.db.commit()",
            "",
            "    r = await api_request(app, 'groups/runaways')",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(app, 'groups/alphaflight')",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert reply == {",
            "        'kind': 'group',",
            "        'name': 'alphaflight',",
            "        'users': ['sasquatch'],",
            "        'roles': [],",
            "        'properties': {},",
            "    }",
            "",
            "",
            "@mark.group",
            "async def test_group_create_delete(app):",
            "    db = app.db",
            "    user = add_user(app.db, app=app, name='sasquatch')",
            "    r = await api_request(app, 'groups/runaways', method='delete')",
            "    assert r.status_code == 404",
            "",
            "    r = await api_request(",
            "        app, 'groups/new', method='post', data=json.dumps({'users': ['doesntexist']})",
            "    )",
            "    assert r.status_code == 400",
            "    assert orm.Group.find(db, name='new') is None",
            "",
            "    r = await api_request(",
            "        app,",
            "        'groups/omegaflight',",
            "        method='post',",
            "        data=json.dumps({'users': ['sasquatch']}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    omegaflight = orm.Group.find(db, name='omegaflight')",
            "    sasquatch = find_user(db, name='sasquatch')",
            "    assert omegaflight in sasquatch.groups",
            "    assert sasquatch in omegaflight.users",
            "",
            "    # create duplicate raises 400",
            "    r = await api_request(app, 'groups/omegaflight', method='post')",
            "    assert r.status_code == 409",
            "",
            "    r = await api_request(app, 'groups/omegaflight', method='delete')",
            "    assert r.status_code == 204",
            "    assert omegaflight not in sasquatch.groups",
            "    assert orm.Group.find(db, name='omegaflight') is None",
            "",
            "    # delete nonexistent gives 404",
            "    r = await api_request(app, 'groups/omegaflight', method='delete')",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.group",
            "async def test_group_add_delete_users(app):",
            "    db = app.db",
            "    group = orm.Group(name='alphaflight')",
            "    app.db.add(group)",
            "    app.db.commit()",
            "    # must specify users",
            "    r = await api_request(app, 'groups/alphaflight/users', method='post', data='{}')",
            "    assert r.status_code == 400",
            "",
            "    names = ['aurora', 'guardian', 'northstar', 'sasquatch', 'shaman', 'snowbird']",
            "    users = [add_user(db, app=app, name=name) for name in names]",
            "    r = await api_request(",
            "        app,",
            "        'groups/alphaflight/users',",
            "        method='post',",
            "        data=json.dumps({'users': names}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    for user in users:",
            "        print(user.name)",
            "        assert [g.name for g in user.groups] == ['alphaflight']",
            "",
            "    group = orm.Group.find(db, name='alphaflight')",
            "    assert sorted(u.name for u in group.users) == sorted(names)",
            "",
            "    r = await api_request(",
            "        app,",
            "        'groups/alphaflight/users',",
            "        method='delete',",
            "        data=json.dumps({'users': names[:2]}),",
            "    )",
            "    r.raise_for_status()",
            "",
            "    for user in users[:2]:",
            "        assert user.groups == []",
            "    for user in users[2:]:",
            "        assert [g.name for g in user.groups] == ['alphaflight']",
            "",
            "    group = orm.Group.find(db, name='alphaflight')",
            "    assert sorted(u.name for u in group.users) == sorted(names[2:])",
            "",
            "",
            "@mark.parametrize(",
            "    \"properties\",",
            "    [",
            "        \"\",",
            "        \"str\",",
            "        5,",
            "        [\"list\"],",
            "    ],",
            ")",
            "@mark.group",
            "async def test_group_properties_invalid(app, group, properties):",
            "    if properties:",
            "        json_properties = json.dumps(properties)",
            "    else:",
            "        json_properties = \"\"",
            "    have_properties = {\"a\": 5}",
            "    group.properties = have_properties",
            "    app.db.commit()",
            "    r = await api_request(",
            "        app, f\"groups/{group.name}/properties\", method='put', data=json_properties",
            "    )",
            "    assert r.status_code == 400",
            "    # invalid requests didn't change properties",
            "    assert group.properties == have_properties",
            "",
            "",
            "@mark.group",
            "async def test_group_properties(app, group):",
            "    db = app.db",
            "    # must specify properties",
            "    properties = {",
            "        \"str\": \"x\",",
            "        \"int\": 5,",
            "        \"list\": [\"a\"],",
            "    }",
            "    r = await api_request(",
            "        app,",
            "        f\"groups/{group.name}/properties\",",
            "        method='put',",
            "        data=json.dumps(properties),",
            "    )",
            "    r.raise_for_status()",
            "    assert group.properties == properties",
            "",
            "    r = await api_request(",
            "        app,",
            "        f\"groups/{group.name}/properties\",",
            "        method='put',",
            "        data=\"{}\",",
            "    )",
            "    r.raise_for_status()",
            "    assert group.properties == {}",
            "",
            "",
            "@mark.group",
            "async def test_auth_managed_groups(request, app, group, user):",
            "    group.users.append(user.orm_user)",
            "    app.db.commit()",
            "    app.authenticator.manage_groups = True",
            "    request.addfinalizer(lambda: setattr(app.authenticator, \"manage_groups\", False))",
            "    # create groups",
            "    r = await api_request(app, 'groups', method='post')",
            "    assert r.status_code == 400",
            "    r = await api_request(app, 'groups/newgroup', method='post')",
            "    assert r.status_code == 400",
            "    # delete groups",
            "    r = await api_request(app, f'groups/{group.name}', method='delete')",
            "    assert r.status_code == 400",
            "    # add users to group",
            "    r = await api_request(",
            "        app,",
            "        f'groups/{group.name}/users',",
            "        method='post',",
            "        data=json.dumps({\"users\": [user.name]}),",
            "    )",
            "    assert r.status_code == 400",
            "    # remove users from group",
            "    r = await api_request(",
            "        app,",
            "        f'groups/{group.name}/users',",
            "        method='delete',",
            "        data=json.dumps({\"users\": [user.name]}),",
            "    )",
            "    assert r.status_code == 400",
            "",
            "",
            "# -----------------",
            "# Service API tests",
            "# -----------------",
            "",
            "",
            "@mark.services",
            "async def test_get_services(app, mockservice_url):",
            "    mockservice = mockservice_url",
            "    db = app.db",
            "    r = await api_request(app, 'services')",
            "    r.raise_for_status()",
            "    assert r.status_code == 200",
            "",
            "    services = r.json()",
            "    assert services == {",
            "        mockservice.name: {",
            "            'kind': 'service',",
            "            'name': mockservice.name,",
            "            'admin': True,",
            "            'roles': ['admin'],",
            "            'command': mockservice.command,",
            "            'pid': mockservice.proc.pid,",
            "            'prefix': mockservice.server.base_url,",
            "            'url': mockservice.url,",
            "            'info': {},",
            "            'display': True,",
            "        }",
            "    }",
            "    r = await api_request(app, 'services', headers=auth_header(db, 'user'))",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.services",
            "async def test_get_service(app, mockservice_url):",
            "    mockservice = mockservice_url",
            "    db = app.db",
            "    r = await api_request(app, f\"services/{mockservice.name}\")",
            "    r.raise_for_status()",
            "    assert r.status_code == 200",
            "",
            "    service = r.json()",
            "    assert service == {",
            "        'kind': 'service',",
            "        'name': mockservice.name,",
            "        'admin': True,",
            "        'roles': ['admin'],",
            "        'command': mockservice.command,",
            "        'pid': mockservice.proc.pid,",
            "        'prefix': mockservice.server.base_url,",
            "        'url': mockservice.url,",
            "        'info': {},",
            "        'display': True,",
            "    }",
            "    r = await api_request(",
            "        app,",
            "        f\"services/{mockservice.name}\",",
            "        headers={'Authorization': f'token {mockservice.api_token}'},",
            "    )",
            "    r.raise_for_status()",
            "",
            "    r = await api_request(",
            "        app, f\"services/{mockservice.name}\", headers=auth_header(db, 'user')",
            "    )",
            "    assert r.status_code == 403",
            "",
            "    r = await api_request(app, \"services/nosuchservice\")",
            "    assert r.status_code == 404",
            "",
            "",
            "@pytest.fixture",
            "def service_admin_user(create_user_with_scopes):",
            "    return create_user_with_scopes('admin:services')",
            "",
            "",
            "@mark.services",
            "async def test_create_service(app, service_admin_user, service_name, service_data):",
            "    db = app.db",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "",
            "    r.raise_for_status()",
            "    assert r.status_code == 201",
            "    assert r.json()['name'] == service_name",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is not None",
            "",
            "    oath_client = (",
            "        db.query(orm.OAuthClient)",
            "        .filter_by(identifier=service_data['oauth_client_id'])",
            "        .first()",
            "    )",
            "    assert oath_client.redirect_uri == service_data['oauth_redirect_uri']",
            "",
            "    assert service_name in app._service_map",
            "    assert (",
            "        app._service_map[service_name].oauth_no_confirm",
            "        == service_data['oauth_no_confirm']",
            "    )",
            "",
            "",
            "@mark.services",
            "async def test_create_service_no_role(app, service_name, service_data):",
            "    db = app.db",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, 'user'),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 403",
            "",
            "",
            "@mark.services",
            "async def test_create_service_conflict(",
            "    app, service_admin_user, mockservice, service_data, service_name",
            "):",
            "    db = app.db",
            "    app.services = [{'name': service_name}]",
            "    app.init_services()",
            "",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.services",
            "async def test_create_service_duplication(",
            "    app, service_admin_user, service_name, service_data",
            "):",
            "    db = app.db",
            "",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "    assert r.status_code == 201",
            "",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "    assert r.status_code == 409",
            "",
            "",
            "@mark.services",
            "async def test_create_managed_service(",
            "    app, service_admin_user, service_name, service_data",
            "):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['command'] = ['foo']",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 400",
            "    assert 'Can not create managed service' in r.json()['message']",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is None",
            "",
            "",
            "@mark.services",
            "async def test_create_admin_service(app, admin_user, service_name, service_data):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['admin'] = True",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, admin_user.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 201",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is not None",
            "",
            "",
            "@mark.services",
            "async def test_create_admin_service_without_admin_right(",
            "    app, service_admin_user, service_data, service_name",
            "):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['admin'] = True",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 400",
            "    assert 'Not assigning requested scopes' in r.json()['message']",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is None",
            "",
            "",
            "@mark.services",
            "async def test_create_service_with_scope(",
            "    app, create_user_with_scopes, service_name, service_data",
            "):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['oauth_client_allowed_scopes'] = [\"admin:users\"]",
            "    managed_service_data['oauth_client_id'] = \"service-client-with-scope\"",
            "    user_with_scope = create_user_with_scopes('admin:services', 'admin:users')",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, user_with_scope.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 201",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is not None",
            "",
            "",
            "@mark.services",
            "async def test_create_service_without_requested_scope(",
            "    app,",
            "    service_admin_user,",
            "    service_data,",
            "    service_name,",
            "):",
            "    db = app.db",
            "    managed_service_data = deepcopy(service_data)",
            "    managed_service_data['oauth_client_allowed_scopes'] = [\"admin:users\"]",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(managed_service_data),",
            "        method='post',",
            "    )",
            "",
            "    assert r.status_code == 400",
            "    assert 'Not assigning requested scopes' in r.json()['message']",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is None",
            "",
            "",
            "@mark.services",
            "async def test_delete_service(app, service_admin_user, service_name, service_data):",
            "    db = app.db",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        data=json.dumps(service_data),",
            "        method='post',",
            "    )",
            "    assert r.status_code == 201",
            "",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        method='delete',",
            "    )",
            "    assert r.status_code == 200",
            "",
            "    orm_service = orm.Service.find(db, service_name)",
            "    assert orm_service is None",
            "",
            "    oath_client = (",
            "        db.query(orm.OAuthClient)",
            "        .filter_by(identifier=service_data['oauth_client_id'])",
            "        .first()",
            "    )",
            "    assert oath_client is None",
            "",
            "    assert service_name not in app._service_map",
            "",
            "    r = await api_request(app, f\"services/{service_name}\", method=\"delete\")",
            "    assert r.status_code == 404",
            "",
            "",
            "@mark.services",
            "async def test_delete_service_from_config(app, service_admin_user, mockservice):",
            "    db = app.db",
            "    service_name = mockservice.name",
            "    r = await api_request(",
            "        app,",
            "        f'services/{service_name}',",
            "        headers=auth_header(db, service_admin_user.name),",
            "        method='delete',",
            "    )",
            "    assert r.status_code == 405",
            "    assert r.json()['message'] == f'Service {service_name} is not modifiable at runtime'",
            "",
            "",
            "async def test_root_api(app):",
            "    kwargs = {}",
            "    if app.internal_ssl:",
            "        kwargs['cert'] = (app.internal_ssl_cert, app.internal_ssl_key)",
            "        kwargs[\"verify\"] = app.internal_ssl_ca",
            "    r = await api_request(app, bypass_proxy=True)",
            "    r.raise_for_status()",
            "    expected = {'version': jupyterhub.__version__}",
            "    assert r.json() == expected",
            "",
            "",
            "async def test_info(app):",
            "    r = await api_request(app, 'info')",
            "    r.raise_for_status()",
            "    data = r.json()",
            "    assert data['version'] == jupyterhub.__version__",
            "    assert sorted(data) == [",
            "        'authenticator',",
            "        'python',",
            "        'spawner',",
            "        'sys_executable',",
            "        'version',",
            "    ]",
            "    assert data['python'] == sys.version",
            "    assert data['sys_executable'] == sys.executable",
            "    assert data['authenticator'] == {",
            "        'class': 'jupyterhub.tests.mocking.MockPAMAuthenticator',",
            "        'version': jupyterhub.__version__,",
            "    }",
            "    assert data['spawner'] == {",
            "        'class': 'jupyterhub.tests.mocking.MockSpawner',",
            "        'version': jupyterhub.__version__,",
            "    }",
            "",
            "",
            "# ------------------",
            "# Activity API tests",
            "# ------------------",
            "",
            "",
            "async def test_update_activity_403(app, user, admin_user):",
            "    token = user.new_api_token()",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{admin_user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=\"{}\",",
            "        method=\"post\",",
            "    )",
            "    assert r.status_code == 404",
            "",
            "",
            "async def test_update_activity_admin(app, user, admin_user):",
            "    token = admin_user.new_api_token(roles=['admin'])",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=json.dumps({\"last_activity\": utcnow().isoformat()}),",
            "        method=\"post\",",
            "    )",
            "    r.raise_for_status()",
            "",
            "",
            "@mark.parametrize(",
            "    \"server_name, fresh\",",
            "    [",
            "        (\"\", True),",
            "        (\"\", False),",
            "        (\"exists\", True),",
            "        (\"exists\", False),",
            "        (\"nope\", True),",
            "        (\"nope\", False),",
            "    ],",
            ")",
            "async def test_update_server_activity(app, user, server_name, fresh):",
            "    token = user.new_api_token()",
            "    now = utcnow()",
            "    internal_now = now.replace(tzinfo=None)",
            "    # we use naive utc internally",
            "    # initialize last_activity for one named and the default server",
            "    for name in (\"\", \"exists\"):",
            "        user.spawners[name].orm_spawner.last_activity = internal_now",
            "    app.db.commit()",
            "",
            "    td = timedelta(minutes=1)",
            "    if fresh:",
            "        activity = now + td",
            "    else:",
            "        activity = now - td",
            "",
            "    r = await api_request(",
            "        app,",
            "        f\"users/{user.name}/activity\",",
            "        headers={\"Authorization\": f\"token {token}\"},",
            "        data=json.dumps(",
            "            {\"servers\": {server_name: {\"last_activity\": activity.isoformat()}}}",
            "        ),",
            "        method=\"post\",",
            "    )",
            "    if server_name == \"nope\":",
            "        assert r.status_code == 400",
            "        reply = r.json()",
            "        assert server_name in reply[\"message\"]",
            "        assert \"No such server\" in reply[\"message\"]",
            "        assert user.name in reply[\"message\"]",
            "        return",
            "",
            "    r.raise_for_status()",
            "",
            "    # check that last activity was updated",
            "",
            "    if fresh:",
            "        expected = activity.replace(tzinfo=None)",
            "    else:",
            "        expected = now.replace(tzinfo=None)",
            "",
            "    assert user.spawners[server_name].orm_spawner.last_activity == expected",
            "",
            "",
            "# -----------------",
            "# General API tests",
            "# -----------------",
            "",
            "",
            "async def test_options(app):",
            "    r = await api_request(app, 'users', method='options')",
            "    r.raise_for_status()",
            "    assert 'Access-Control-Allow-Headers' in r.headers",
            "",
            "",
            "async def test_bad_json_body(app):",
            "    r = await api_request(app, 'users', method='post', data='notjson')",
            "    assert r.status_code == 400",
            "",
            "",
            "# ---------------------------------",
            "# Shutdown MUST always be last test",
            "# ---------------------------------",
            "",
            "",
            "def test_shutdown(app):",
            "    loop = app.io_loop",
            "",
            "    # have to do things a little funky since we are going to stop the loop,",
            "    # which makes gen_test unhappy. So we run the loop ourselves.",
            "",
            "    async def shutdown():",
            "        r = await api_request(",
            "            app,",
            "            'shutdown',",
            "            method='post',",
            "            data=json.dumps({'servers': True, 'proxy': True}),",
            "        )",
            "        return r",
            "",
            "    real_stop = loop.asyncio_loop.stop",
            "",
            "    def stop():",
            "        stop.called = True",
            "        loop.call_later(2, real_stop)",
            "",
            "    real_cleanup = app.cleanup",
            "",
            "    def cleanup():",
            "        cleanup.called = True",
            "        loop.call_later(1, real_cleanup)",
            "",
            "    app.cleanup = cleanup",
            "",
            "    with mock.patch.object(loop.asyncio_loop, 'stop', stop):",
            "        r = loop.run_sync(shutdown, timeout=5)",
            "    r.raise_for_status()",
            "    reply = r.json()",
            "    assert cleanup.called",
            "    assert stop.called"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "778": [],
            "787": [],
            "825": [],
            "829": [],
            "831": [],
            "851": [],
            "853": [
                "name"
            ],
            "864": [],
            "866": [],
            "867": []
        },
        "addLocation": []
    }
}