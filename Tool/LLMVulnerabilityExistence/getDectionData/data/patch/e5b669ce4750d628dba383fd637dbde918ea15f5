{
    "IPython/html/base/zmqhandlers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " # Imports"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " #-----------------------------------------------------------------------------"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+try:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    from urllib.parse import urlparse # Py 3"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+except ImportError:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    from urlparse import urlparse # Py 2"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " try:"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     from http.cookies import SimpleCookie  # Py 3"
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " except ImportError:"
            },
            "11": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " #-----------------------------------------------------------------------------"
            },
            "12": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " class ZMQStreamHandler(websocket.WebSocketHandler):"
            },
            "14": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    def same_origin(self):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        \"\"\"Check to see that origin and host match in the headers.\"\"\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        # The difference between version 8 and 13 is that in 8 the"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        # simply \"Origin\"."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        if self.request.headers.get(\"Sec-WebSocket-Version\") in (\"7\", \"8\"):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            origin_header = self.request.headers.get(\"Sec-Websocket-Origin\")"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        else:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            origin_header = self.request.headers.get(\"Origin\")"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        host = self.request.headers.get(\"Host\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        # If no header is provided, assume we can't verify origin"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        if(origin_header is None or host is None):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            return False"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        parsed_origin = urlparse(origin_header)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        origin = parsed_origin.netloc"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        # Check to see that origin matches host directly, including ports"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        return origin == host"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     def clear_cookie(self, *args, **kwargs):"
            },
            "40": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         \"\"\"meaningless for websockets\"\"\""
            },
            "41": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         pass"
            },
            "42": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " class AuthenticatedZMQStreamHandler(ZMQStreamHandler, IPythonHandler):"
            },
            "43": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     def open(self, kernel_id):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        # Check to see that origin matches host directly, including ports"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        if not self.same_origin():"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+            self.log.warn(\"Cross Origin WebSocket Attempt.\")"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            raise web.HTTPError(404)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         self.kernel_id = cast_unicode(kernel_id, 'ascii')"
            },
            "51": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         self.session = Session(config=self.config)"
            },
            "52": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         self.save_on_message = self.on_message"
            },
            "53": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         if self.get_current_user() is None:"
            },
            "54": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "             self.log.warn(\"Couldn't authenticate WebSocket connection\")"
            },
            "55": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "             raise web.HTTPError(403)"
            },
            "56": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.on_message = self.save_on_message"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        self.on_message = self.save_on_message"
            }
        },
        "frontPatchFile": [
            "\"\"\"Tornado handlers for WebSocket <-> ZMQ sockets.",
            "",
            "Authors:",
            "",
            "* Brian Granger",
            "\"\"\"",
            "",
            "#-----------------------------------------------------------------------------",
            "#  Copyright (C) 2008-2011  The IPython Development Team",
            "#",
            "#  Distributed under the terms of the BSD License.  The full license is in",
            "#  the file COPYING, distributed as part of this software.",
            "#-----------------------------------------------------------------------------",
            "",
            "#-----------------------------------------------------------------------------",
            "# Imports",
            "#-----------------------------------------------------------------------------",
            "",
            "try:",
            "    from http.cookies import SimpleCookie  # Py 3",
            "except ImportError:",
            "    from Cookie import SimpleCookie  # Py 2",
            "import logging",
            "from tornado import web",
            "from tornado import websocket",
            "",
            "from zmq.utils import jsonapi",
            "",
            "from IPython.kernel.zmq.session import Session",
            "from IPython.utils.jsonutil import date_default",
            "from IPython.utils.py3compat import PY3, cast_unicode",
            "",
            "from .handlers import IPythonHandler",
            "",
            "#-----------------------------------------------------------------------------",
            "# ZMQ handlers",
            "#-----------------------------------------------------------------------------",
            "",
            "class ZMQStreamHandler(websocket.WebSocketHandler):",
            "    ",
            "    def clear_cookie(self, *args, **kwargs):",
            "        \"\"\"meaningless for websockets\"\"\"",
            "        pass",
            "",
            "    def _reserialize_reply(self, msg_list):",
            "        \"\"\"Reserialize a reply message using JSON.",
            "",
            "        This takes the msg list from the ZMQ socket, unserializes it using",
            "        self.session and then serializes the result using JSON. This method",
            "        should be used by self._on_zmq_reply to build messages that can",
            "        be sent back to the browser.",
            "        \"\"\"",
            "        idents, msg_list = self.session.feed_identities(msg_list)",
            "        msg = self.session.unserialize(msg_list)",
            "        try:",
            "            msg['header'].pop('date')",
            "        except KeyError:",
            "            pass",
            "        try:",
            "            msg['parent_header'].pop('date')",
            "        except KeyError:",
            "            pass",
            "        msg.pop('buffers')",
            "        return jsonapi.dumps(msg, default=date_default)",
            "",
            "    def _on_zmq_reply(self, msg_list):",
            "        # Sometimes this gets triggered when the on_close method is scheduled in the",
            "        # eventloop but hasn't been called.",
            "        if self.stream.closed(): return",
            "        try:",
            "            msg = self._reserialize_reply(msg_list)",
            "        except Exception:",
            "            self.log.critical(\"Malformed message: %r\" % msg_list, exc_info=True)",
            "        else:",
            "            self.write_message(msg)",
            "",
            "    def allow_draft76(self):",
            "        \"\"\"Allow draft 76, until browsers such as Safari update to RFC 6455.",
            "        ",
            "        This has been disabled by default in tornado in release 2.2.0, and",
            "        support will be removed in later versions.",
            "        \"\"\"",
            "        return True",
            "",
            "",
            "class AuthenticatedZMQStreamHandler(ZMQStreamHandler, IPythonHandler):",
            "",
            "    def open(self, kernel_id):",
            "        self.kernel_id = cast_unicode(kernel_id, 'ascii')",
            "        self.session = Session(config=self.config)",
            "        self.save_on_message = self.on_message",
            "        self.on_message = self.on_first_message",
            "",
            "    def _inject_cookie_message(self, msg):",
            "        \"\"\"Inject the first message, which is the document cookie,",
            "        for authentication.\"\"\"",
            "        if not PY3 and isinstance(msg, unicode):",
            "            # Cookie constructor doesn't accept unicode strings",
            "            # under Python 2.x for some reason",
            "            msg = msg.encode('utf8', 'replace')",
            "        try:",
            "            identity, msg = msg.split(':', 1)",
            "            self.session.session = cast_unicode(identity, 'ascii')",
            "        except Exception:",
            "            logging.error(\"First ws message didn't have the form 'identity:[cookie]' - %r\", msg)",
            "        ",
            "        try:",
            "            self.request._cookies = SimpleCookie(msg)",
            "        except:",
            "            self.log.warn(\"couldn't parse cookie string: %s\",msg, exc_info=True)",
            "",
            "    def on_first_message(self, msg):",
            "        self._inject_cookie_message(msg)",
            "        if self.get_current_user() is None:",
            "            self.log.warn(\"Couldn't authenticate WebSocket connection\")",
            "            raise web.HTTPError(403)",
            "        self.on_message = self.save_on_message"
        ],
        "afterPatchFile": [
            "\"\"\"Tornado handlers for WebSocket <-> ZMQ sockets.",
            "",
            "Authors:",
            "",
            "* Brian Granger",
            "\"\"\"",
            "",
            "#-----------------------------------------------------------------------------",
            "#  Copyright (C) 2008-2011  The IPython Development Team",
            "#",
            "#  Distributed under the terms of the BSD License.  The full license is in",
            "#  the file COPYING, distributed as part of this software.",
            "#-----------------------------------------------------------------------------",
            "",
            "#-----------------------------------------------------------------------------",
            "# Imports",
            "#-----------------------------------------------------------------------------",
            "",
            "try:",
            "    from urllib.parse import urlparse # Py 3",
            "except ImportError:",
            "    from urlparse import urlparse # Py 2",
            "",
            "try:",
            "    from http.cookies import SimpleCookie  # Py 3",
            "except ImportError:",
            "    from Cookie import SimpleCookie  # Py 2",
            "import logging",
            "from tornado import web",
            "from tornado import websocket",
            "",
            "from zmq.utils import jsonapi",
            "",
            "from IPython.kernel.zmq.session import Session",
            "from IPython.utils.jsonutil import date_default",
            "from IPython.utils.py3compat import PY3, cast_unicode",
            "",
            "from .handlers import IPythonHandler",
            "",
            "#-----------------------------------------------------------------------------",
            "# ZMQ handlers",
            "#-----------------------------------------------------------------------------",
            "",
            "class ZMQStreamHandler(websocket.WebSocketHandler):",
            "",
            "    def same_origin(self):",
            "        \"\"\"Check to see that origin and host match in the headers.\"\"\"",
            "",
            "        # The difference between version 8 and 13 is that in 8 the",
            "        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's",
            "        # simply \"Origin\".",
            "        if self.request.headers.get(\"Sec-WebSocket-Version\") in (\"7\", \"8\"):",
            "            origin_header = self.request.headers.get(\"Sec-Websocket-Origin\")",
            "        else:",
            "            origin_header = self.request.headers.get(\"Origin\")",
            "",
            "        host = self.request.headers.get(\"Host\")",
            "",
            "        # If no header is provided, assume we can't verify origin",
            "        if(origin_header is None or host is None):",
            "            return False",
            "",
            "        parsed_origin = urlparse(origin_header)",
            "        origin = parsed_origin.netloc",
            "",
            "        # Check to see that origin matches host directly, including ports",
            "        return origin == host",
            "",
            "    def clear_cookie(self, *args, **kwargs):",
            "        \"\"\"meaningless for websockets\"\"\"",
            "        pass",
            "",
            "    def _reserialize_reply(self, msg_list):",
            "        \"\"\"Reserialize a reply message using JSON.",
            "",
            "        This takes the msg list from the ZMQ socket, unserializes it using",
            "        self.session and then serializes the result using JSON. This method",
            "        should be used by self._on_zmq_reply to build messages that can",
            "        be sent back to the browser.",
            "        \"\"\"",
            "        idents, msg_list = self.session.feed_identities(msg_list)",
            "        msg = self.session.unserialize(msg_list)",
            "        try:",
            "            msg['header'].pop('date')",
            "        except KeyError:",
            "            pass",
            "        try:",
            "            msg['parent_header'].pop('date')",
            "        except KeyError:",
            "            pass",
            "        msg.pop('buffers')",
            "        return jsonapi.dumps(msg, default=date_default)",
            "",
            "    def _on_zmq_reply(self, msg_list):",
            "        # Sometimes this gets triggered when the on_close method is scheduled in the",
            "        # eventloop but hasn't been called.",
            "        if self.stream.closed(): return",
            "        try:",
            "            msg = self._reserialize_reply(msg_list)",
            "        except Exception:",
            "            self.log.critical(\"Malformed message: %r\" % msg_list, exc_info=True)",
            "        else:",
            "            self.write_message(msg)",
            "",
            "    def allow_draft76(self):",
            "        \"\"\"Allow draft 76, until browsers such as Safari update to RFC 6455.",
            "        ",
            "        This has been disabled by default in tornado in release 2.2.0, and",
            "        support will be removed in later versions.",
            "        \"\"\"",
            "        return True",
            "",
            "",
            "class AuthenticatedZMQStreamHandler(ZMQStreamHandler, IPythonHandler):",
            "",
            "    def open(self, kernel_id):",
            "        # Check to see that origin matches host directly, including ports",
            "        if not self.same_origin():",
            "            self.log.warn(\"Cross Origin WebSocket Attempt.\")",
            "            raise web.HTTPError(404)",
            "",
            "        self.kernel_id = cast_unicode(kernel_id, 'ascii')",
            "        self.session = Session(config=self.config)",
            "        self.save_on_message = self.on_message",
            "        self.on_message = self.on_first_message",
            "",
            "    def _inject_cookie_message(self, msg):",
            "        \"\"\"Inject the first message, which is the document cookie,",
            "        for authentication.\"\"\"",
            "        if not PY3 and isinstance(msg, unicode):",
            "            # Cookie constructor doesn't accept unicode strings",
            "            # under Python 2.x for some reason",
            "            msg = msg.encode('utf8', 'replace')",
            "        try:",
            "            identity, msg = msg.split(':', 1)",
            "            self.session.session = cast_unicode(identity, 'ascii')",
            "        except Exception:",
            "            logging.error(\"First ws message didn't have the form 'identity:[cookie]' - %r\", msg)",
            "        ",
            "        try:",
            "            self.request._cookies = SimpleCookie(msg)",
            "        except:",
            "            self.log.warn(\"couldn't parse cookie string: %s\",msg, exc_info=True)",
            "",
            "    def on_first_message(self, msg):",
            "        self._inject_cookie_message(msg)",
            "        if self.get_current_user() is None:",
            "            self.log.warn(\"Couldn't authenticate WebSocket connection\")",
            "            raise web.HTTPError(403)",
            "        self.on_message = self.save_on_message"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "40": [
                "ZMQStreamHandler"
            ],
            "117": [
                "AuthenticatedZMQStreamHandler",
                "on_first_message"
            ]
        },
        "addLocation": []
    }
}