{
    "FreeTAKServer/controllers/configuration/MainConfig.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     if not os.path.exists(yaml_path):"
            },
            "2": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        SecretKey = str(os.environ.get('FTS_SECRET_KEY', 'vnkdjnfjknfl1232#'))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         OptimizeAPI = True"
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         MainLoopDelay = int(os.environ.get('FTS_MAINLOOP_DELAY', 100))"
            },
            "8": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             ConnectionMessage = str(os.environ.get(\"FTS_CONNECTION_MESSAGE\", yamlConfig[\"System\"].get(\"FTS_CONNECTION_MESSAGE\", f'Welcome to FreeTAKServer {version}. The Parrot is not dead. It\u2019s just resting')))"
            },
            "9": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "             DataBaseType = str(os.environ.get(\"FTS_DATABASE_TYPE\", yamlConfig[\"System\"].get(\"FTS_DATABASE_TYPE\", \"SQLite\")))"
            },
            "10": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "             OptimizeAPI = bool(os.environ.get(\"FTS_OPTIMIZE_API\", yamlConfig[\"System\"].get(\"FTS_OPTIMIZE_API\", True)))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+            SecretKey = str(os.environ.get('FTS_SECRET_KEY', yamlConfig[\"System\"].get(\"FTS_SECRET_KEY\", 'vnkdjnfjknfl1232#')))"
            },
            "12": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         else:"
            },
            "14": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "             MainLoopDelay = int(os.environ.get('FTS_MAINLOOP_DELAY',  1))"
            }
        },
        "frontPatchFile": [
            "import os",
            "import yaml",
            "currentPath = os.path.dirname(os.path.abspath(__file__))",
            "from pathlib import Path",
            "",
            "",
            "class MainConfig:",
            "    \"\"\"",
            "    this is the main configuration file and is the only one which",
            "    should need to be changed",
            "    \"\"\"",
            "",
            "    # the version information of the server (recommended to leave as default)",
            "    version = 'FreeTAKServer-1.9.8 Public'",
            "    #",
            "    yaml_path = str(os.environ.get('FTS_CONFIG_PATH', '/opt/FTSConfig.yaml'))",
            "",
            "    python_version = 'python3.8'",
            "",
            "    userpath = '/usr/local/lib/'",
            "",
            "    try:",
            "        import socket",
            "        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)",
            "        s.connect((\"8.8.8.8\", 80))",
            "        ip = s.getsockname()[0]",
            "        s.close()",
            "    except:",
            "        ip = \"0.0.0.0\"",
            "",
            "    if not os.path.exists(yaml_path):",
            "",
            "        OptimizeAPI = True",
            "",
            "        MainLoopDelay = int(os.environ.get('FTS_MAINLOOP_DELAY', 100))",
            "",
            "        # this is the port to which clients will connect",
            "        CoTServicePort = int(os.environ.get('FTS_COT_PORT', 8087))",
            "",
            "        SSLCoTServicePort = int(os.environ.get('FTS_SSLCOT_PORT', 8089))",
            "",
            "        # this needs to be changed for private data packages to work",
            "        DataPackageServiceDefaultIP = str(os.environ.get('FTS_DP_ADDRESS', ip))",
            "",
            "        # User Connection package IP needs to be set to the IP which is used when creating the connection in your tak device",
            "        UserConnectionIP = str(os.environ.get('FTS_USER_ADDRESS', ip))",
            "",
            "        # api port",
            "        APIPort = os.environ.get('FTS_API_PORT', 19023)",
            "",
            "        # Federation port",
            "        FederationPort = os.environ.get('FTS_FED_PORT', 9000)",
            "",
            "        # api IP",
            "        APIIP = os.environ.get('FTS_API_ADDRESS', '0.0.0.0')",
            "",
            "        # whether or not to save CoT's to the DB",
            "        SaveCoTToDB = bool(os.environ.get('FTS_COT_TO_DB', True))",
            "",
            "        # this should be set before startup",
            "        DBFilePath = str(os.environ.get('FTS_DB_PATH', r'/opt/FTSDataBase.db'))",
            "",
            "        MainPath = str(os.environ.get(\"FTS_MAINPATH\", Path(fr'{userpath}{python_version}/dist-packages/FreeTAKServer')))",
            "",
            "        certsPath = str(os.environ.get('FTS_CERTS_PATH', fr'{MainPath}/certs'))",
            "",
            "        ExCheckMainPath = str(os.environ.get('FTS_EXCHECK_PATH', Path(fr'{MainPath}/ExCheck')))",
            "",
            "        ExCheckFilePath = str(os.environ.get('FTS_EXCHECK_TEMPLATE_PATH', Path(fr'{MainPath}/ExCheck/template')))",
            "",
            "        ExCheckChecklistFilePath = str(",
            "            os.environ.get(\"FTS_EXCHECK_CHECKLIST_PATH\", Path(fr'{MainPath}/ExCheck/checklist')))",
            "",
            "        DataPackageFilePath = str(",
            "            os.environ.get(\"FTS_DATAPACKAGE_PATH\", Path(fr'{MainPath}/FreeTAKServerDataPackageFolder')))",
            "",
            "        LogFilePath = str(os.environ.get(\"FTS_LOGFILE_PATH\", Path(fr\"{MainPath}/Logs\")))",
            "",
            "        federationKeyPassword = str(os.environ.get('FTS_FED_PASSWORD', 'defaultpass'))",
            "",
            "        keyDir = str(os.environ.get(\"FTS_SERVER_KEYDIR\", Path(fr'{certsPath}/server.key')))",
            "",
            "        pemDir = str(os.environ.get(\"FTS_SERVER_PEMDIR\", Path(fr'{certsPath}/server.pem')))  # or crt",
            "",
            "        testPem = str(os.environ.get(\"FTS_TESTCLIENT_PEMDIR\", pemDir))",
            "",
            "        testKey = str(os.environ.get(\"FTS_TESTCLIENT_KEYDIR\", keyDir))",
            "",
            "        unencryptedKey = str(os.environ.get(\"FTS_UNENCRYPTED_KEYDIR\", Path(fr'{certsPath}/server.key.unencrypted')))",
            "",
            "        p12Dir = str(os.environ.get(\"FTS_SERVER_P12DIR\", Path(fr'{certsPath}/server.p12')))",
            "",
            "        CA = str(os.environ.get(\"FTS_CADIR\", Path(fr'{certsPath}/ca.pem')))",
            "",
            "        CAkey = str(os.environ.get(\"FTS_CAKEYDIR\", Path(fr'{certsPath}/ca.key')))",
            "",
            "        federationCert = str(os.environ.get(\"FTS_FEDERATION_CERTDIR\", Path(fr'{certsPath}/server.pem')))",
            "",
            "        federationKey = str(os.environ.get(\"FTS_FEDERATION_KEYDIR\", Path(fr'{certsPath}/server.key')))",
            "",
            "        federationKeyPassword = str(os.environ.get(\"FTS_FEDERATION_KEYPASS\", 'defaultpass'))",
            "",
            "        password = str(os.environ.get('FTS_CLIENT_CERT_PASSWORD', 'supersecret'))",
            "",
            "        websocketkey = str(os.environ.get('FTS_WEBSOCKET_KEY', \"YourWebsocketKey\"))",
            "",
            "        CRLFile = str(os.environ.get('FTS_CRLDIR', fr\"{certsPath}/FTS_CRL.json\"))",
            "",
            "        # set to None if you don't want a message sent",
            "        ConnectionMessage = f'Welcome to FreeTAKServer {version}. The Parrot is not dead. It\u2019s just resting'",
            "",
            "        DataBaseType = str(\"SQLite\")",
            "",
            "    else:",
            "        content = open(yaml_path).read()",
            "        yamlConfig = yaml.safe_load(content)",
            "",
            "        # number of milliseconds to wait between each iteration of main loop",
            "        # decreasing will increase CPU usage and server performance",
            "        # increasing will decrease CPU usage and server performance",
            "        if yamlConfig.get(\"System\"):",
            "            MainLoopDelay = int(os.environ.get('FTS_MAINLOOP_DELAY', yamlConfig[\"System\"].get(\"FTS_MAINLOOP_DELAY\", 1)))",
            "            # set to None if you don't want a message sent",
            "            ConnectionMessage = str(os.environ.get(\"FTS_CONNECTION_MESSAGE\", yamlConfig[\"System\"].get(\"FTS_CONNECTION_MESSAGE\", f'Welcome to FreeTAKServer {version}. The Parrot is not dead. It\u2019s just resting')))",
            "            DataBaseType = str(os.environ.get(\"FTS_DATABASE_TYPE\", yamlConfig[\"System\"].get(\"FTS_DATABASE_TYPE\", \"SQLite\")))",
            "            OptimizeAPI = bool(os.environ.get(\"FTS_OPTIMIZE_API\", yamlConfig[\"System\"].get(\"FTS_OPTIMIZE_API\", True)))",
            "",
            "        else:",
            "            MainLoopDelay = int(os.environ.get('FTS_MAINLOOP_DELAY',  1))",
            "            ConnectionMessage = str(os.environ.get(\"FTS_CONNECTION_MESSAGE\", f'Welcome to FreeTAKServer {version}. The Parrot is not dead. It\u2019s just resting'))",
            "            DataBaseType = str(os.environ.get(\"FTS_DATABASE_TYPE\", \"SQLite\"))",
            "            OptimizeAPI = bool(os.environ.get(\"FTS_OPTIMIZE_API\", True))",
            "",
            "        if yamlConfig.get(\"Addresses\"):",
            "            # this is the port to which clients will connect",
            "            CoTServicePort = int(os.environ.get('FTS_COT_PORT', yamlConfig[\"Addresses\"].get('FTS_COT_PORT', 8087)))",
            "",
            "            SSLCoTServicePort = int(os.environ.get('FTS_SSLCOT_PORT', yamlConfig[\"Addresses\"].get('FTS_SSLCOT_PORT', 8089)))",
            "",
            "            # this needs to be changed for private data packages to work",
            "            DataPackageServiceDefaultIP = str(os.environ.get('FTS_DP_ADDRESS', yamlConfig[\"Addresses\"].get('FTS_DP_ADDRESS', ip)))",
            "",
            "            # User Connection package IP needs to be set to the IP which is used when creating the connection in your tak device",
            "            UserConnectionIP = str(os.environ.get('FTS_USER_ADDRESS', yamlConfig[\"Addresses\"].get(\"FTS_USER_ADDRESS\", ip)))",
            "",
            "            # api port",
            "            APIPort = int(os.environ.get('FTS_API_PORT', yamlConfig[\"Addresses\"].get(\"FTS_API_PORT\", 19023)))",
            "",
            "            # Federation port",
            "            FederationPort = int(os.environ.get('FTS_FED_PORT', yamlConfig[\"Addresses\"].get(\"FTS_FED_PORT\", 9000)))",
            "",
            "            # api IP",
            "            APIIP = str(os.environ.get('FTS_API_ADDRESS', yamlConfig[\"Addresses\"].get(\"FTS_API_ADDRESS\", \"0.0.0.0\")))",
            "        else:",
            "",
            "            # this is the port to which clients will connect",
            "            CoTServicePort = int(os.environ.get('FTS_COT_PORT', 8087))",
            "",
            "            SSLCoTServicePort = int(os.environ.get('FTS_SSLCOT_PORT', 8089))",
            "",
            "            # this needs to be changed for private data packages to work",
            "            DataPackageServiceDefaultIP = str(os.environ.get('FTS_DP_ADDRESS', \"0.0.0.0\"))",
            "",
            "            # User Connection package IP needs to be set to the IP which is used when creating the connection in your tak device",
            "            UserConnectionIP = str(os.environ.get('FTS_USER_ADDRESS', \"0.0.0.0\"))",
            "",
            "            # api port",
            "            APIPort = os.environ.get('FTS_API_PORT', 19023)",
            "",
            "            # Federation port",
            "            FederationPort = os.environ.get('FTS_FED_PORT', 9000)",
            "",
            "            # api IP",
            "            APIIP = os.environ.get('FTS_API_ADDRESS', '0.0.0.0')",
            "",
            "        if yamlConfig.get(\"FileSystem\"):",
            "",
            "            DBFilePath = str(os.environ.get('FTS_DB_PATH', yamlConfig[\"FileSystem\"].get(\"FTS_DB_PATH\", \"/opt/FreeTAKServer.db\")))",
            "",
            "            # whether or not to save CoT's to the DB",
            "            SaveCoTToDB = bool(os.environ.get('FTS_COT_TO_DB', yamlConfig[\"FileSystem\"].get(\"FTS_COT_TO_DB\")))",
            "",
            "            MainPath = str(os.environ.get(\"FTS_MAINPATH\", yamlConfig[\"FileSystem\"].get(\"FTS_MAINPATH\", Path(fr'{userpath}{python_version}/dist-packages/FreeTAKServer'))))",
            "",
            "            certsPath = str(os.environ.get('FTS_CERTS_PATH', yamlConfig[\"FileSystem\"].get(\"FTS_CERTS_PATH\", fr'{MainPath}/certs')))",
            "",
            "            ExCheckMainPath = str(os.environ.get('FTS_EXCHECK_PATH', yamlConfig[\"FileSystem\"].get(\"FTS_EXCHECK_PATH\",Path(fr'{MainPath}/ExCheck'))))",
            "",
            "            ExCheckFilePath = str(os.environ.get('FTS_EXCHECK_TEMPLATE_PATH', yamlConfig[\"FileSystem\"].get(\"FTS_EXCHECK_TEMPLATE_PATH\", Path(fr'{MainPath}/ExCheck/template'))))",
            "",
            "            ExCheckChecklistFilePath = str(os.environ.get(\"FTS_EXCHECK_CHECKLIST_PATH\", yamlConfig[\"FileSystem\"].get(\"FTS_EXCHECK_CHECKLIST_PATH\", Path(fr'{MainPath}/ExCheck/checklist'))))",
            "",
            "            DataPackageFilePath = str(os.environ.get(\"FTS_DATAPACKAGE_PATH\", yamlConfig[\"FileSystem\"].get(\"FTS_DATAPACKAGE_PATH\", Path(fr'{MainPath}/FreeTAKServerDataPackageFolder'))))",
            "",
            "            LogFilePath = str(os.environ.get(\"FTS_LOGFILE_PATH\", yamlConfig[\"FileSystem\"].get(\"FTS_LOGFILE_PATH\", Path(fr\"{MainPath}/Logs\"))))",
            "",
            "        else:",
            "            # whether or not to save CoT's to the DB",
            "            SaveCoTToDB = bool(os.environ.get('FTS_COT_TO_DB', True))",
            "",
            "            # this should be set before startup",
            "            DBFilePath = str(os.environ.get('FTS_DB_PATH', r'/root/FTSDataBase.db'))",
            "",
            "            MainPath = str(",
            "                os.environ.get(\"FTS_MAINPATH\", Path(fr'{userpath}{python_version}/dist-packages/FreeTAKServer')))",
            "",
            "            certsPath = str(os.environ.get('FTS_CERTS_PATH', fr'{MainPath}/certs'))",
            "",
            "            ExCheckMainPath = str(os.environ.get('FTS_EXCHECK_PATH', Path(fr'{MainPath}/ExCheck')))",
            "",
            "            ExCheckFilePath = str(os.environ.get('FTS_EXCHECK_TEMPLATE_PATH', Path(fr'{MainPath}/ExCheck/template')))",
            "",
            "            ExCheckChecklistFilePath = str(",
            "                os.environ.get(\"FTS_EXCHECK_CHECKLIST_PATH\", Path(fr'{MainPath}/ExCheck/checklist')))",
            "",
            "            DataPackageFilePath = str(",
            "                os.environ.get(\"FTS_DATAPACKAGE_PATH\", Path(fr'{MainPath}/FreeTAKServerDataPackageFolder')))",
            "",
            "            LogFilePath = str(os.environ.get(\"FTS_LOGFILE_PATH\", Path(fr\"{MainPath}/Logs\")))",
            "",
            "",
            "        if yamlConfig.get(\"Certs\"):",
            "            keyDir = str(os.environ.get(\"FTS_SERVER_KEYDIR\", yamlConfig[\"Certs\"].get(\"FTS_SERVER_KEYDIR\", Path(fr'{certsPath}/server.key'))))",
            "",
            "            pemDir = str(os.environ.get(\"FTS_SERVER_PEMDIR\",yamlConfig[\"Certs\"].get(\"FTS_SERVER_PEMDIR\", Path(fr'{certsPath}/server.pem')))) # or crt",
            "",
            "            testPem = str(os.environ.get(\"FTS_TESTCLIENT_PEMDIR\",yamlConfig[\"Certs\"].get(\"FTS_TESTCLIENT_PEMDIR\", fr'{certsPath}/Client.pem')))",
            "",
            "            testKey = str(os.environ.get(\"FTS_TESTCLIENT_KEYDIR\",yamlConfig[\"Certs\"].get(\"FTS_TESTCLIENT_KEYDIR\", fr'{certsPath}/Client.key')))",
            "",
            "            unencryptedKey = str(os.environ.get(\"FTS_UNENCRYPTED_KEYDIR\", yamlConfig[\"Certs\"].get(\"FTS_UNENCRYPTED_KEYDIR\", Path(fr'{certsPath}/server.key.unencrypted'))))",
            "",
            "            p12Dir = str(os.environ.get(\"FTS_SERVER_P12DIR\", yamlConfig[\"Certs\"].get(\"FTS_SERVER_P12DIR\", Path(fr'{certsPath}/server.p12'))))",
            "",
            "            CA = str(os.environ.get(\"FTS_CADIR\", yamlConfig[\"Certs\"].get(\"FTS_CADIR\",Path(fr'{certsPath}/ca.pem'))))",
            "",
            "            CAkey = str(os.environ.get(\"FTS_CAKEYDIR\", yamlConfig[\"Certs\"].get(\"FTS_CAKEYDIR\",Path(fr'{certsPath}/ca.key'))))",
            "",
            "            federationCert = str(os.environ.get(\"FTS_FEDERATION_CERTDIR\", yamlConfig[\"Certs\"].get(\"FTS_FEDERATION_CERTDIR\", Path(fr'{certsPath}/server.pem'))))",
            "",
            "            federationKey = str(os.environ.get(\"FTS_FEDERATION_KEYDIR\", yamlConfig[\"Certs\"].get(\"FTS_FEDERATION_KEYDIR\", Path(fr'{certsPath}/server.key'))))",
            "",
            "            federationKeyPassword = str(os.environ.get(\"FTS_FEDERATION_KEYPASS\", yamlConfig[\"Certs\"].get(\"FTS_FEDERATION_KEYPASS\", None)))",
            "",
            "            password = str(os.environ.get('FTS_CLIENT_CERT_PASSWORD', yamlConfig[\"Certs\"].get(\"FTS_CLIENT_CERT_PASSWORD\", 'supersecret')))",
            "",
            "            websocketkey = str(os.environ.get('FTS_WEBSOCKET_KEY', yamlConfig[\"Certs\"].get(\"FTS_WEBSOCKET_KEY\", \"YourWebsocketKey\")))",
            "",
            "            CRLFile = str(os.environ.get('FTS_CRLDIR', yamlConfig[\"Certs\"].get(\"FTS_CRLDIR\", fr\"{certsPath}/FTS_CRL.json\")))",
            "        else:",
            "            federationKeyPassword = str(os.environ.get('FTS_FED_PASSWORD', 'defaultpass'))",
            "",
            "            keyDir = str(os.environ.get(\"FTS_SERVER_KEYDIR\", Path(fr'{certsPath}/server.key')))",
            "",
            "            pemDir = str(os.environ.get(\"FTS_SERVER_PEMDIR\", Path(fr'{certsPath}/server.pem')))  # or crt",
            "",
            "            testPem = str(os.environ.get(\"FTS_TESTCLIENT_PEMDIR\", pemDir))",
            "",
            "            testKey = str(os.environ.get(\"FTS_TESTCLIENT_KEYDIR\", keyDir))",
            "",
            "            unencryptedKey = str(os.environ.get(\"FTS_UNENCRYPTED_KEYDIR\", Path(fr'{certsPath}/server.key.unencrypted')))",
            "",
            "            p12Dir = str(os.environ.get(\"FTS_SERVER_P12DIR\", Path(fr'{certsPath}/server.p12')))",
            "",
            "            CA = str(os.environ.get(\"FTS_CADIR\", Path(fr'{certsPath}/ca.pem')))",
            "",
            "            CAkey = str(os.environ.get(\"FTS_CAKEYDIR\", Path(fr'{certsPath}/ca.key')))",
            "",
            "            federationCert = str(os.environ.get(\"FTS_FEDERATION_CERTDIR\", Path(fr'{certsPath}/server.pem')))",
            "",
            "            federationKey = str(os.environ.get(\"FTS_FEDERATION_KEYDIR\", Path(fr'{certsPath}/server.key')))",
            "",
            "            federationKeyPassword = str(os.environ.get(\"FTS_FEDERATION_KEYPASS\", 'defaultpass'))",
            "",
            "            password = str(os.environ.get('FTS_CLIENT_CERT_PASSWORD', 'supersecret'))",
            "",
            "            websocketkey = str(os.environ.get('FTS_WEBSOCKET_KEY', \"YourWebsocketKey\"))",
            "",
            "            CRLFile = str(os.environ.get('FTS_CRLDIR', fr\"{certsPath}/FTS_CRL.json\"))",
            "",
            "",
            "",
            "    # allowed ip's to access CLI commands",
            "    AllowedCLIIPs = ['127.0.0.1']",
            "",
            "    # IP for CLI to access",
            "    CLIIP = '127.0.0.1'",
            "",
            "    APIVersion = \"1.9.5\"",
            "",
            "    # format of API message header should be {Authentication: Bearer 'TOKEN'}",
            "    from uuid import uuid4",
            "    id = str(uuid4())",
            "",
            "    nodeID = os.environ.get('FTS_NODE_ID', f\"FreeTAKServer-{id}\")",
            "",
            "    # location to backup client packages",
            "    clientPackages = str(Path(fr'{MainPath}/certs/ClientPackages'))",
            "",
            "    first_start = False"
        ],
        "afterPatchFile": [
            "import os",
            "import yaml",
            "currentPath = os.path.dirname(os.path.abspath(__file__))",
            "from pathlib import Path",
            "",
            "",
            "class MainConfig:",
            "    \"\"\"",
            "    this is the main configuration file and is the only one which",
            "    should need to be changed",
            "    \"\"\"",
            "",
            "    # the version information of the server (recommended to leave as default)",
            "    version = 'FreeTAKServer-1.9.8 Public'",
            "    #",
            "    yaml_path = str(os.environ.get('FTS_CONFIG_PATH', '/opt/FTSConfig.yaml'))",
            "",
            "    python_version = 'python3.8'",
            "",
            "    userpath = '/usr/local/lib/'",
            "",
            "    try:",
            "        import socket",
            "        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)",
            "        s.connect((\"8.8.8.8\", 80))",
            "        ip = s.getsockname()[0]",
            "        s.close()",
            "    except:",
            "        ip = \"0.0.0.0\"",
            "",
            "    if not os.path.exists(yaml_path):",
            "",
            "        SecretKey = str(os.environ.get('FTS_SECRET_KEY', 'vnkdjnfjknfl1232#'))",
            "",
            "        OptimizeAPI = True",
            "",
            "        MainLoopDelay = int(os.environ.get('FTS_MAINLOOP_DELAY', 100))",
            "",
            "        # this is the port to which clients will connect",
            "        CoTServicePort = int(os.environ.get('FTS_COT_PORT', 8087))",
            "",
            "        SSLCoTServicePort = int(os.environ.get('FTS_SSLCOT_PORT', 8089))",
            "",
            "        # this needs to be changed for private data packages to work",
            "        DataPackageServiceDefaultIP = str(os.environ.get('FTS_DP_ADDRESS', ip))",
            "",
            "        # User Connection package IP needs to be set to the IP which is used when creating the connection in your tak device",
            "        UserConnectionIP = str(os.environ.get('FTS_USER_ADDRESS', ip))",
            "",
            "        # api port",
            "        APIPort = os.environ.get('FTS_API_PORT', 19023)",
            "",
            "        # Federation port",
            "        FederationPort = os.environ.get('FTS_FED_PORT', 9000)",
            "",
            "        # api IP",
            "        APIIP = os.environ.get('FTS_API_ADDRESS', '0.0.0.0')",
            "",
            "        # whether or not to save CoT's to the DB",
            "        SaveCoTToDB = bool(os.environ.get('FTS_COT_TO_DB', True))",
            "",
            "        # this should be set before startup",
            "        DBFilePath = str(os.environ.get('FTS_DB_PATH', r'/opt/FTSDataBase.db'))",
            "",
            "        MainPath = str(os.environ.get(\"FTS_MAINPATH\", Path(fr'{userpath}{python_version}/dist-packages/FreeTAKServer')))",
            "",
            "        certsPath = str(os.environ.get('FTS_CERTS_PATH', fr'{MainPath}/certs'))",
            "",
            "        ExCheckMainPath = str(os.environ.get('FTS_EXCHECK_PATH', Path(fr'{MainPath}/ExCheck')))",
            "",
            "        ExCheckFilePath = str(os.environ.get('FTS_EXCHECK_TEMPLATE_PATH', Path(fr'{MainPath}/ExCheck/template')))",
            "",
            "        ExCheckChecklistFilePath = str(",
            "            os.environ.get(\"FTS_EXCHECK_CHECKLIST_PATH\", Path(fr'{MainPath}/ExCheck/checklist')))",
            "",
            "        DataPackageFilePath = str(",
            "            os.environ.get(\"FTS_DATAPACKAGE_PATH\", Path(fr'{MainPath}/FreeTAKServerDataPackageFolder')))",
            "",
            "        LogFilePath = str(os.environ.get(\"FTS_LOGFILE_PATH\", Path(fr\"{MainPath}/Logs\")))",
            "",
            "        federationKeyPassword = str(os.environ.get('FTS_FED_PASSWORD', 'defaultpass'))",
            "",
            "        keyDir = str(os.environ.get(\"FTS_SERVER_KEYDIR\", Path(fr'{certsPath}/server.key')))",
            "",
            "        pemDir = str(os.environ.get(\"FTS_SERVER_PEMDIR\", Path(fr'{certsPath}/server.pem')))  # or crt",
            "",
            "        testPem = str(os.environ.get(\"FTS_TESTCLIENT_PEMDIR\", pemDir))",
            "",
            "        testKey = str(os.environ.get(\"FTS_TESTCLIENT_KEYDIR\", keyDir))",
            "",
            "        unencryptedKey = str(os.environ.get(\"FTS_UNENCRYPTED_KEYDIR\", Path(fr'{certsPath}/server.key.unencrypted')))",
            "",
            "        p12Dir = str(os.environ.get(\"FTS_SERVER_P12DIR\", Path(fr'{certsPath}/server.p12')))",
            "",
            "        CA = str(os.environ.get(\"FTS_CADIR\", Path(fr'{certsPath}/ca.pem')))",
            "",
            "        CAkey = str(os.environ.get(\"FTS_CAKEYDIR\", Path(fr'{certsPath}/ca.key')))",
            "",
            "        federationCert = str(os.environ.get(\"FTS_FEDERATION_CERTDIR\", Path(fr'{certsPath}/server.pem')))",
            "",
            "        federationKey = str(os.environ.get(\"FTS_FEDERATION_KEYDIR\", Path(fr'{certsPath}/server.key')))",
            "",
            "        federationKeyPassword = str(os.environ.get(\"FTS_FEDERATION_KEYPASS\", 'defaultpass'))",
            "",
            "        password = str(os.environ.get('FTS_CLIENT_CERT_PASSWORD', 'supersecret'))",
            "",
            "        websocketkey = str(os.environ.get('FTS_WEBSOCKET_KEY', \"YourWebsocketKey\"))",
            "",
            "        CRLFile = str(os.environ.get('FTS_CRLDIR', fr\"{certsPath}/FTS_CRL.json\"))",
            "",
            "        # set to None if you don't want a message sent",
            "        ConnectionMessage = f'Welcome to FreeTAKServer {version}. The Parrot is not dead. It\u2019s just resting'",
            "",
            "        DataBaseType = str(\"SQLite\")",
            "",
            "    else:",
            "        content = open(yaml_path).read()",
            "        yamlConfig = yaml.safe_load(content)",
            "",
            "        # number of milliseconds to wait between each iteration of main loop",
            "        # decreasing will increase CPU usage and server performance",
            "        # increasing will decrease CPU usage and server performance",
            "        if yamlConfig.get(\"System\"):",
            "            MainLoopDelay = int(os.environ.get('FTS_MAINLOOP_DELAY', yamlConfig[\"System\"].get(\"FTS_MAINLOOP_DELAY\", 1)))",
            "            # set to None if you don't want a message sent",
            "            ConnectionMessage = str(os.environ.get(\"FTS_CONNECTION_MESSAGE\", yamlConfig[\"System\"].get(\"FTS_CONNECTION_MESSAGE\", f'Welcome to FreeTAKServer {version}. The Parrot is not dead. It\u2019s just resting')))",
            "            DataBaseType = str(os.environ.get(\"FTS_DATABASE_TYPE\", yamlConfig[\"System\"].get(\"FTS_DATABASE_TYPE\", \"SQLite\")))",
            "            OptimizeAPI = bool(os.environ.get(\"FTS_OPTIMIZE_API\", yamlConfig[\"System\"].get(\"FTS_OPTIMIZE_API\", True)))",
            "            SecretKey = str(os.environ.get('FTS_SECRET_KEY', yamlConfig[\"System\"].get(\"FTS_SECRET_KEY\", 'vnkdjnfjknfl1232#')))",
            "",
            "        else:",
            "            MainLoopDelay = int(os.environ.get('FTS_MAINLOOP_DELAY',  1))",
            "            ConnectionMessage = str(os.environ.get(\"FTS_CONNECTION_MESSAGE\", f'Welcome to FreeTAKServer {version}. The Parrot is not dead. It\u2019s just resting'))",
            "            DataBaseType = str(os.environ.get(\"FTS_DATABASE_TYPE\", \"SQLite\"))",
            "            OptimizeAPI = bool(os.environ.get(\"FTS_OPTIMIZE_API\", True))",
            "",
            "        if yamlConfig.get(\"Addresses\"):",
            "            # this is the port to which clients will connect",
            "            CoTServicePort = int(os.environ.get('FTS_COT_PORT', yamlConfig[\"Addresses\"].get('FTS_COT_PORT', 8087)))",
            "",
            "            SSLCoTServicePort = int(os.environ.get('FTS_SSLCOT_PORT', yamlConfig[\"Addresses\"].get('FTS_SSLCOT_PORT', 8089)))",
            "",
            "            # this needs to be changed for private data packages to work",
            "            DataPackageServiceDefaultIP = str(os.environ.get('FTS_DP_ADDRESS', yamlConfig[\"Addresses\"].get('FTS_DP_ADDRESS', ip)))",
            "",
            "            # User Connection package IP needs to be set to the IP which is used when creating the connection in your tak device",
            "            UserConnectionIP = str(os.environ.get('FTS_USER_ADDRESS', yamlConfig[\"Addresses\"].get(\"FTS_USER_ADDRESS\", ip)))",
            "",
            "            # api port",
            "            APIPort = int(os.environ.get('FTS_API_PORT', yamlConfig[\"Addresses\"].get(\"FTS_API_PORT\", 19023)))",
            "",
            "            # Federation port",
            "            FederationPort = int(os.environ.get('FTS_FED_PORT', yamlConfig[\"Addresses\"].get(\"FTS_FED_PORT\", 9000)))",
            "",
            "            # api IP",
            "            APIIP = str(os.environ.get('FTS_API_ADDRESS', yamlConfig[\"Addresses\"].get(\"FTS_API_ADDRESS\", \"0.0.0.0\")))",
            "        else:",
            "",
            "            # this is the port to which clients will connect",
            "            CoTServicePort = int(os.environ.get('FTS_COT_PORT', 8087))",
            "",
            "            SSLCoTServicePort = int(os.environ.get('FTS_SSLCOT_PORT', 8089))",
            "",
            "            # this needs to be changed for private data packages to work",
            "            DataPackageServiceDefaultIP = str(os.environ.get('FTS_DP_ADDRESS', \"0.0.0.0\"))",
            "",
            "            # User Connection package IP needs to be set to the IP which is used when creating the connection in your tak device",
            "            UserConnectionIP = str(os.environ.get('FTS_USER_ADDRESS', \"0.0.0.0\"))",
            "",
            "            # api port",
            "            APIPort = os.environ.get('FTS_API_PORT', 19023)",
            "",
            "            # Federation port",
            "            FederationPort = os.environ.get('FTS_FED_PORT', 9000)",
            "",
            "            # api IP",
            "            APIIP = os.environ.get('FTS_API_ADDRESS', '0.0.0.0')",
            "",
            "        if yamlConfig.get(\"FileSystem\"):",
            "",
            "            DBFilePath = str(os.environ.get('FTS_DB_PATH', yamlConfig[\"FileSystem\"].get(\"FTS_DB_PATH\", \"/opt/FreeTAKServer.db\")))",
            "",
            "            # whether or not to save CoT's to the DB",
            "            SaveCoTToDB = bool(os.environ.get('FTS_COT_TO_DB', yamlConfig[\"FileSystem\"].get(\"FTS_COT_TO_DB\")))",
            "",
            "            MainPath = str(os.environ.get(\"FTS_MAINPATH\", yamlConfig[\"FileSystem\"].get(\"FTS_MAINPATH\", Path(fr'{userpath}{python_version}/dist-packages/FreeTAKServer'))))",
            "",
            "            certsPath = str(os.environ.get('FTS_CERTS_PATH', yamlConfig[\"FileSystem\"].get(\"FTS_CERTS_PATH\", fr'{MainPath}/certs')))",
            "",
            "            ExCheckMainPath = str(os.environ.get('FTS_EXCHECK_PATH', yamlConfig[\"FileSystem\"].get(\"FTS_EXCHECK_PATH\",Path(fr'{MainPath}/ExCheck'))))",
            "",
            "            ExCheckFilePath = str(os.environ.get('FTS_EXCHECK_TEMPLATE_PATH', yamlConfig[\"FileSystem\"].get(\"FTS_EXCHECK_TEMPLATE_PATH\", Path(fr'{MainPath}/ExCheck/template'))))",
            "",
            "            ExCheckChecklistFilePath = str(os.environ.get(\"FTS_EXCHECK_CHECKLIST_PATH\", yamlConfig[\"FileSystem\"].get(\"FTS_EXCHECK_CHECKLIST_PATH\", Path(fr'{MainPath}/ExCheck/checklist'))))",
            "",
            "            DataPackageFilePath = str(os.environ.get(\"FTS_DATAPACKAGE_PATH\", yamlConfig[\"FileSystem\"].get(\"FTS_DATAPACKAGE_PATH\", Path(fr'{MainPath}/FreeTAKServerDataPackageFolder'))))",
            "",
            "            LogFilePath = str(os.environ.get(\"FTS_LOGFILE_PATH\", yamlConfig[\"FileSystem\"].get(\"FTS_LOGFILE_PATH\", Path(fr\"{MainPath}/Logs\"))))",
            "",
            "        else:",
            "            # whether or not to save CoT's to the DB",
            "            SaveCoTToDB = bool(os.environ.get('FTS_COT_TO_DB', True))",
            "",
            "            # this should be set before startup",
            "            DBFilePath = str(os.environ.get('FTS_DB_PATH', r'/root/FTSDataBase.db'))",
            "",
            "            MainPath = str(",
            "                os.environ.get(\"FTS_MAINPATH\", Path(fr'{userpath}{python_version}/dist-packages/FreeTAKServer')))",
            "",
            "            certsPath = str(os.environ.get('FTS_CERTS_PATH', fr'{MainPath}/certs'))",
            "",
            "            ExCheckMainPath = str(os.environ.get('FTS_EXCHECK_PATH', Path(fr'{MainPath}/ExCheck')))",
            "",
            "            ExCheckFilePath = str(os.environ.get('FTS_EXCHECK_TEMPLATE_PATH', Path(fr'{MainPath}/ExCheck/template')))",
            "",
            "            ExCheckChecklistFilePath = str(",
            "                os.environ.get(\"FTS_EXCHECK_CHECKLIST_PATH\", Path(fr'{MainPath}/ExCheck/checklist')))",
            "",
            "            DataPackageFilePath = str(",
            "                os.environ.get(\"FTS_DATAPACKAGE_PATH\", Path(fr'{MainPath}/FreeTAKServerDataPackageFolder')))",
            "",
            "            LogFilePath = str(os.environ.get(\"FTS_LOGFILE_PATH\", Path(fr\"{MainPath}/Logs\")))",
            "",
            "",
            "        if yamlConfig.get(\"Certs\"):",
            "            keyDir = str(os.environ.get(\"FTS_SERVER_KEYDIR\", yamlConfig[\"Certs\"].get(\"FTS_SERVER_KEYDIR\", Path(fr'{certsPath}/server.key'))))",
            "",
            "            pemDir = str(os.environ.get(\"FTS_SERVER_PEMDIR\",yamlConfig[\"Certs\"].get(\"FTS_SERVER_PEMDIR\", Path(fr'{certsPath}/server.pem')))) # or crt",
            "",
            "            testPem = str(os.environ.get(\"FTS_TESTCLIENT_PEMDIR\",yamlConfig[\"Certs\"].get(\"FTS_TESTCLIENT_PEMDIR\", fr'{certsPath}/Client.pem')))",
            "",
            "            testKey = str(os.environ.get(\"FTS_TESTCLIENT_KEYDIR\",yamlConfig[\"Certs\"].get(\"FTS_TESTCLIENT_KEYDIR\", fr'{certsPath}/Client.key')))",
            "",
            "            unencryptedKey = str(os.environ.get(\"FTS_UNENCRYPTED_KEYDIR\", yamlConfig[\"Certs\"].get(\"FTS_UNENCRYPTED_KEYDIR\", Path(fr'{certsPath}/server.key.unencrypted'))))",
            "",
            "            p12Dir = str(os.environ.get(\"FTS_SERVER_P12DIR\", yamlConfig[\"Certs\"].get(\"FTS_SERVER_P12DIR\", Path(fr'{certsPath}/server.p12'))))",
            "",
            "            CA = str(os.environ.get(\"FTS_CADIR\", yamlConfig[\"Certs\"].get(\"FTS_CADIR\",Path(fr'{certsPath}/ca.pem'))))",
            "",
            "            CAkey = str(os.environ.get(\"FTS_CAKEYDIR\", yamlConfig[\"Certs\"].get(\"FTS_CAKEYDIR\",Path(fr'{certsPath}/ca.key'))))",
            "",
            "            federationCert = str(os.environ.get(\"FTS_FEDERATION_CERTDIR\", yamlConfig[\"Certs\"].get(\"FTS_FEDERATION_CERTDIR\", Path(fr'{certsPath}/server.pem'))))",
            "",
            "            federationKey = str(os.environ.get(\"FTS_FEDERATION_KEYDIR\", yamlConfig[\"Certs\"].get(\"FTS_FEDERATION_KEYDIR\", Path(fr'{certsPath}/server.key'))))",
            "",
            "            federationKeyPassword = str(os.environ.get(\"FTS_FEDERATION_KEYPASS\", yamlConfig[\"Certs\"].get(\"FTS_FEDERATION_KEYPASS\", None)))",
            "",
            "            password = str(os.environ.get('FTS_CLIENT_CERT_PASSWORD', yamlConfig[\"Certs\"].get(\"FTS_CLIENT_CERT_PASSWORD\", 'supersecret')))",
            "",
            "            websocketkey = str(os.environ.get('FTS_WEBSOCKET_KEY', yamlConfig[\"Certs\"].get(\"FTS_WEBSOCKET_KEY\", \"YourWebsocketKey\")))",
            "",
            "            CRLFile = str(os.environ.get('FTS_CRLDIR', yamlConfig[\"Certs\"].get(\"FTS_CRLDIR\", fr\"{certsPath}/FTS_CRL.json\")))",
            "        else:",
            "            federationKeyPassword = str(os.environ.get('FTS_FED_PASSWORD', 'defaultpass'))",
            "",
            "            keyDir = str(os.environ.get(\"FTS_SERVER_KEYDIR\", Path(fr'{certsPath}/server.key')))",
            "",
            "            pemDir = str(os.environ.get(\"FTS_SERVER_PEMDIR\", Path(fr'{certsPath}/server.pem')))  # or crt",
            "",
            "            testPem = str(os.environ.get(\"FTS_TESTCLIENT_PEMDIR\", pemDir))",
            "",
            "            testKey = str(os.environ.get(\"FTS_TESTCLIENT_KEYDIR\", keyDir))",
            "",
            "            unencryptedKey = str(os.environ.get(\"FTS_UNENCRYPTED_KEYDIR\", Path(fr'{certsPath}/server.key.unencrypted')))",
            "",
            "            p12Dir = str(os.environ.get(\"FTS_SERVER_P12DIR\", Path(fr'{certsPath}/server.p12')))",
            "",
            "            CA = str(os.environ.get(\"FTS_CADIR\", Path(fr'{certsPath}/ca.pem')))",
            "",
            "            CAkey = str(os.environ.get(\"FTS_CAKEYDIR\", Path(fr'{certsPath}/ca.key')))",
            "",
            "            federationCert = str(os.environ.get(\"FTS_FEDERATION_CERTDIR\", Path(fr'{certsPath}/server.pem')))",
            "",
            "            federationKey = str(os.environ.get(\"FTS_FEDERATION_KEYDIR\", Path(fr'{certsPath}/server.key')))",
            "",
            "            federationKeyPassword = str(os.environ.get(\"FTS_FEDERATION_KEYPASS\", 'defaultpass'))",
            "",
            "            password = str(os.environ.get('FTS_CLIENT_CERT_PASSWORD', 'supersecret'))",
            "",
            "            websocketkey = str(os.environ.get('FTS_WEBSOCKET_KEY', \"YourWebsocketKey\"))",
            "",
            "            CRLFile = str(os.environ.get('FTS_CRLDIR', fr\"{certsPath}/FTS_CRL.json\"))",
            "",
            "",
            "",
            "    # allowed ip's to access CLI commands",
            "    AllowedCLIIPs = ['127.0.0.1']",
            "",
            "    # IP for CLI to access",
            "    CLIIP = '127.0.0.1'",
            "",
            "    APIVersion = \"1.9.5\"",
            "",
            "    # format of API message header should be {Authentication: Bearer 'TOKEN'}",
            "    from uuid import uuid4",
            "    id = str(uuid4())",
            "",
            "    nodeID = os.environ.get('FTS_NODE_ID', f\"FreeTAKServer-{id}\")",
            "",
            "    # location to backup client packages",
            "    clientPackages = str(Path(fr'{MainPath}/certs/ClientPackages'))",
            "",
            "    first_start = False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "FreeTAKServer.controllers.configuration.MainConfig.MainConfig.AllowedCLIIPs",
            "FreeTAKServer.controllers.configuration.MainConfig.MainConfig.self"
        ]
    },
    "FreeTAKServer/controllers/services/DataPackageServer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import os"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import random"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import string"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+import re"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import traceback"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import defusedxml.ElementTree as ET"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from logging.handlers import RotatingFileHandler"
            },
            "7": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " app = Flask(__name__)  # create the Flask app"
            },
            "8": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " app.config['SQLALCHEMY_DATABASE_URI'] = DatabaseConfiguration().DataBaseConnectionString"
            },
            "9": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False"
            },
            "10": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-app.config[\"SECRET_KEY\"] = 'vnkdjnfjknfl1232#'"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+app.config[\"SECRET_KEY\"] = MainConfig.SecretKey"
            },
            "12": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " cors = CORS(app, resources={r\"/*\": {\"origins\": \"*\"}})"
            },
            "13": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " app.config['CORS_HEADERS'] = 'Content-Type'"
            },
            "14": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " def hello():"
            },
            "16": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     return 'hello world'"
            },
            "17": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " @app.route('/Alive')"
            },
            "20": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " def alive():"
            },
            "21": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     return 'DataPackage service alive', 200"
            },
            "22": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     # to store locally"
            },
            "23": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     try:"
            },
            "24": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         feeds = dbController.query_videostream(column=[\"FullXmlString\"])"
            },
            "25": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        app.logger.info(f\"Found {len(feeds)} video feeds in {const.DATABASE}\")  # pylint: disable=no-member; member does exist"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        app.logger.info("
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            f\"Found {len(feeds)} video feeds in {const.DATABASE}\")  # pylint: disable=no-member; member does exist"
            },
            "28": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         if len(feeds) == 0:"
            },
            "29": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "             return (\"No video feeds found\", 500)"
            },
            "30": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "         all_feeds = \"\""
            },
            "31": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "             # Check that no other feeds with the same UID have been received"
            },
            "32": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "             streams = dbController.query_videostream(query=f'uid = \"{uid}\"')"
            },
            "33": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             if len(streams) > 0:"
            },
            "34": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                app.logger.info(f\"Already received feed with UID={uid} (alias = {alias})\")  # pylint: disable=no-member; member does exist"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+                app.logger.info("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+                    f\"Already received feed with UID={uid} (alias = {alias})\")  # pylint: disable=no-member; member does exist"
            },
            "37": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "                 continue  # Ignore this feed if there are duplicates"
            },
            "38": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            app.logger.info(f\"Inserting video feed into database: {request.data.decode('utf-8')}\")  # pylint: disable=no-member; member does exist"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            app.logger.info("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+                f\"Inserting video feed into database: {request.data.decode('utf-8')}\")  # pylint: disable=no-member; member does exist"
            },
            "41": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "             dbController.create_videostream(FullXmlString=ET.tostring(xml_feed), Protocol=protocol, Alias=alias,"
            },
            "42": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "                                             uid=uid, Address=address, Port=port, RoverPort=rover_port,"
            },
            "43": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "                                             IgnoreEmbeddedKlv=ignore_klv, PreferredMacAddress=preferred_mac, Path=path,"
            },
            "44": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     from FreeTAKServer.model.ServiceObjects.SSLDataPackageVariables import SSLDataPackageVariables"
            },
            "45": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     logger.info('dataoackage upload started')"
            },
            "46": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     file_hash = request.args.get('hash')"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+    if not validate_hash(file_hash):"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        return \"invalid hash sent\", 500"
            },
            "49": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     app.logger.info(f\"Data Package hash = {str(file_hash)}\")"
            },
            "50": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "     letters = string.ascii_letters"
            },
            "51": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     uid = ''.join(random.choice(letters) for i in range(4))"
            },
            "52": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 200,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 201,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 202,
                "PatchRowcode": " @app.route('/Marti/api/sync/metadata/<hash>/tool', methods=[const.GET])"
            },
            "55": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@cross_origin(send_wildcard = True)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+@cross_origin(send_wildcard=True)"
            },
            "57": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 204,
                "PatchRowcode": " def getDataPackageTool(hash):"
            },
            "58": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "     from flask import make_response"
            },
            "59": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "     file_list = os.listdir(os.path.join(Path(str(dp_directory)), Path(str(hash))))"
            },
            "60": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "     app.logger.info(f\"Data packages in the database: {packages}\")"
            },
            "61": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "     return str(packages)"
            },
            "62": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 222,
                "PatchRowcode": " @app.route('/Marti/sync/content', methods=const.HTTPMETHODS)"
            },
            "65": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 223,
                "PatchRowcode": " def specificPackage():"
            },
            "66": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "     from defusedxml import ElementTree as etree"
            },
            "67": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         else:"
            },
            "68": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "             obj = dbController.query_ExCheck(verbose=True, query=f'hash = \"{hash}\"')"
            },
            "69": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "             data = etree.parse(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(obj[0].data.filename))))"
            },
            "70": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data.getroot().find('checklistTasks').find(\"checklistTask\").find(\"uid\").text = data.getroot().find('checklistTasks').find(\"checklistTask\").find(\"checklistUid\").text"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+            data.getroot().find('checklistTasks').find(\"checklistTask\").find(\"uid\").text = data.getroot().find("
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+                'checklistTasks').find(\"checklistTask\").find(\"checklistUid\").text"
            },
            "73": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "             output = etree.tostring(data)"
            },
            "74": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "             return output"
            },
            "75": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 262,
                "PatchRowcode": " "
            },
            "76": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "     return 'data package service is up, good job.'"
            },
            "77": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 288,
                "PatchRowcode": " "
            },
            "78": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "80": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#exCheckStuff"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+# exCheckStuff"
            },
            "82": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 291,
                "PatchRowcode": " from flask import Flask, request"
            },
            "83": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 292,
                "PatchRowcode": " from FreeTAKServer.controllers.ExCheckControllers.templateToJsonSerializer import templateSerializer"
            },
            "84": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 293,
                "PatchRowcode": " from FreeTAKServer.controllers.DatabaseControllers.DatabaseController import DatabaseController"
            },
            "85": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 294,
                "PatchRowcode": " from FreeTAKServer.controllers.configuration.MainConfig import MainConfig"
            },
            "86": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 295,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+"
            },
            "88": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 297,
                "PatchRowcode": " @app.route('/Marti/api/missions/exchecktemplates/changes', methods=['GET'])"
            },
            "89": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 298,
                "PatchRowcode": " def check_changes():"
            },
            "90": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "     try:"
            },
            "91": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     except Exception as e:"
            },
            "92": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "         print('exception in check changes' + str(e))"
            },
            "93": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 309,
                "PatchRowcode": " "
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+"
            },
            "95": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 311,
                "PatchRowcode": " @app.route('/Marti/api/missions/exchecktemplates/subscription', methods=['PUT'])"
            },
            "96": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 312,
                "PatchRowcode": " def request_subscription():"
            },
            "97": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "     try:"
            },
            "98": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 319,
                "PatchRowcode": "     except Exception as e:"
            },
            "99": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "         print('exception in request_subscription' + str(e))"
            },
            "100": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 321,
                "PatchRowcode": " "
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+"
            },
            "102": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 323,
                "PatchRowcode": " @app.route('/Marti/api/missions/exchecktemplates', methods=['GET'])"
            },
            "103": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 324,
                "PatchRowcode": " def exchecktemplates():"
            },
            "104": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "     try:"
            },
            "105": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "         return templateSerializer().convert_object_to_json(DatabaseController().query_ExCheck())"
            },
            "106": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "     except Exception as e:"
            },
            "107": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "         print(e)"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+"
            },
            "110": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 334,
                "PatchRowcode": " @app.route('/Marti/api/missions/ExCheckTemplates', methods=['GET'])"
            },
            "111": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": 335,
                "PatchRowcode": " def ExCheckTemplates():"
            },
            "112": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "     try:"
            },
            "113": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "     except Exception as e:"
            },
            "114": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "         print(e)"
            },
            "115": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 343,
                "PatchRowcode": " "
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+"
            },
            "117": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 345,
                "PatchRowcode": " @app.route('/Marti/api/missions/<templateuid>/subscription', methods=['DELETE', 'PUT'])"
            },
            "118": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 346,
                "PatchRowcode": " def missionupdate(templateuid):"
            },
            "119": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "     from flask import request"
            },
            "120": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "     uid = request.args.get('uid')"
            },
            "121": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "     return '', 200"
            },
            "122": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 350,
                "PatchRowcode": " "
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+"
            },
            "124": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 352,
                "PatchRowcode": " @app.route('/Marti/api/excheck/template', methods=['POST'])"
            },
            "125": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 353,
                "PatchRowcode": " def template():"
            },
            "126": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "     try:"
            },
            "127": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "         uid = object.data.uid"
            },
            "128": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "         temp = etree.fromstring(XMI)"
            },
            "129": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "         cot = etree.fromstring(xmlstring)"
            },
            "130": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        resources = cot.find('detail').find('mission').find('MissionChanges').find('MissionChange').find('contentResource')"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+        resources = cot.find('detail').find('mission').find('MissionChanges').find('MissionChange').find("
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+            'contentResource')"
            },
            "133": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "         resources.find('filename').text = temp.find('checklistDetails').find('uid').text + '.xml'"
            },
            "134": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "         resources.findall('keywords')[0].text = temp.find('checklistDetails').find('name').text"
            },
            "135": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "         resources.findall('keywords')[1].text = temp.find('checklistDetails').find('description').text"
            },
            "136": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "     except Exception as e:"
            },
            "137": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "         print(str(e))"
            },
            "138": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 398,
                "PatchRowcode": " "
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+"
            },
            "140": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 400,
                "PatchRowcode": " @app.route('/Marti/api/excheck/<subscription>/start', methods=['POST'])"
            },
            "141": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 401,
                "PatchRowcode": " def startList(subscription):"
            },
            "142": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "     import uuid"
            },
            "143": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "         taskuid = task.find('uid')"
            },
            "144": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": 442,
                "PatchRowcode": "         taskuid.text = str(uuid.uuid4())"
            },
            "145": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": 443,
                "PatchRowcode": " "
            },
            "146": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "147": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 444,
                "PatchRowcode": "     with open("
            },
            "148": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": 445,
                "PatchRowcode": "             str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(uid + '.xml'))),"
            },
            "149": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "             'w+') as file:"
            },
            "150": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "         y = etree.tostring(xml)"
            },
            "151": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "         file.write(etree.tostring(xml).decode())"
            },
            "152": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "         file.close()"
            },
            "153": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 450,
                "PatchRowcode": " "
            },
            "154": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    excheckobj = dbController.query_ExCheck(f'ExCheckData.uid = \"{subscription}\"', verbose=True,)[0]"
            },
            "155": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    dbController.create_Excheckchecklist(startTime=datetime.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S.%fZ'), creatorUid = request.args.get('clientUid'), description = request.args.get('description'), callsign = request.args.get('callsign'), name = request.args.get('name'), uid = uid, filename = f'{uid}.xml', template = excheckobj)"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+    excheckobj = dbController.query_ExCheck(f'ExCheckData.uid = \"{subscription}\"', verbose=True, )[0]"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+    dbController.create_Excheckchecklist(startTime=datetime.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S.%fZ'),"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+                                         creatorUid=request.args.get('clientUid'),"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+                                         description=request.args.get('description'),"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+                                         callsign=request.args.get('callsign'), name=request.args.get('name'), uid=uid,"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+                                         filename=f'{uid}.xml', template=excheckobj)"
            },
            "162": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 457,
                "PatchRowcode": " "
            },
            "163": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 458,
                "PatchRowcode": "     return str(open(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(uid + '.xml'))), 'r').read()), 200"
            },
            "164": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 459,
                "PatchRowcode": " "
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+"
            },
            "166": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 461,
                "PatchRowcode": " @app.route('/Marti/api/excheck/checklist/<checklistid>')"
            },
            "167": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": 462,
                "PatchRowcode": " def accesschecklist(checklistid):"
            },
            "168": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "     return str(open(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistid + '.xml'))),"
            },
            "169": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-              'r').read())"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+                    'r').read())"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+"
            },
            "172": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 466,
                "PatchRowcode": " "
            },
            "173": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 467,
                "PatchRowcode": " @app.route('/Marti/api/excheck/checklist/<checklistid>/task/<taskid>', methods=['PUT'])"
            },
            "174": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 468,
                "PatchRowcode": " def updatetemplate(checklistid, taskid):"
            },
            "175": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 475,
                "PatchRowcode": "     import uuid"
            },
            "176": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 476,
                "PatchRowcode": "     import hashlib"
            },
            "177": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": 477,
                "PatchRowcode": " "
            },
            "178": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "179": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 478,
                "PatchRowcode": "     data = request.data"
            },
            "180": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 479,
                "PatchRowcode": " "
            },
            "181": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "     xml = etree.parse("
            },
            "182": {
                "beforePatchRowNumber": 485,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "     object.detail.mission.MissionChanges.MissionChange.creatorUid.setINTAG(request.args.get(\"clientUid\"))"
            },
            "183": {
                "beforePatchRowNumber": 486,
                "afterPatchRowNumber": 507,
                "PatchRowcode": "     object.detail.mission.MissionChanges.MissionChange.missionName.setINTAG(checklistid)"
            },
            "184": {
                "beforePatchRowNumber": 487,
                "afterPatchRowNumber": 508,
                "PatchRowcode": "     object.detail.mission.MissionChanges.MissionChange.type.setINTAG(\"ADD_CONTENT\")"
            },
            "185": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    object.detail.mission.MissionChanges.MissionChange.contentResource.filename.setINTAG(taskid+'.xml')"
            },
            "186": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    object.detail.mission.MissionChanges.MissionChange.contentResource.hash.setINTAG(str(hashlib.sha256(str(open(MainConfig.ExCheckChecklistFilePath + '/' + checklistid + '.xml', 'r')).encode()).hexdigest()))"
            },
            "187": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+    object.detail.mission.MissionChanges.MissionChange.contentResource.filename.setINTAG(taskid + '.xml')"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 510,
                "PatchRowcode": "+    object.detail.mission.MissionChanges.MissionChange.contentResource.hash.setINTAG(str(hashlib.sha256("
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 511,
                "PatchRowcode": "+        str(open(MainConfig.ExCheckChecklistFilePath + '/' + checklistid + '.xml', 'r')).encode()).hexdigest()))"
            },
            "190": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 512,
                "PatchRowcode": "     object.detail.mission.MissionChanges.MissionChange.contentResource.keywords.setINTAG('Task')"
            },
            "191": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": 513,
                "PatchRowcode": "     object.detail.mission.MissionChanges.MissionChange.contentResource.name.setINTAG(taskid)"
            },
            "192": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": 514,
                "PatchRowcode": "     object.detail.mission.MissionChanges.MissionChange.contentResource.size.setINTAG(str(len(data)))"
            },
            "193": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    #TODO: change this value"
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 515,
                "PatchRowcode": "+    # TODO: change this value"
            },
            "195": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 516,
                "PatchRowcode": "     object.detail.mission.MissionChanges.MissionChange.contentResource.submitter.setINTAG('atak')"
            },
            "196": {
                "beforePatchRowNumber": 495,
                "afterPatchRowNumber": 517,
                "PatchRowcode": "     object.detail.mission.MissionChanges.MissionChange.contentResource.uid.setINTAG(taskid)"
            },
            "197": {
                "beforePatchRowNumber": 496,
                "afterPatchRowNumber": 518,
                "PatchRowcode": " "
            },
            "198": {
                "beforePatchRowNumber": 497,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "199": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "200": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": 519,
                "PatchRowcode": "     '''object = etree.fromstring(templateex)"
            },
            "201": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": 520,
                "PatchRowcode": "     object.uid = uuid.uuid4()"
            },
            "202": {
                "beforePatchRowNumber": 501,
                "afterPatchRowNumber": 521,
                "PatchRowcode": "     object.find('detail').find('mission').type= \"CHANGE\""
            },
            "203": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 536,
                "PatchRowcode": "     rawcot.xmlString = xml"
            },
            "204": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 537,
                "PatchRowcode": " "
            },
            "205": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 538,
                "PatchRowcode": "     PIPE.put(rawcot)"
            },
            "206": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    #PIPE.send()"
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 539,
                "PatchRowcode": "+    # PIPE.send()"
            },
            "208": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": 540,
                "PatchRowcode": " "
            },
            "209": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": 541,
                "PatchRowcode": "     return '', 200"
            },
            "210": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": 542,
                "PatchRowcode": " "
            },
            "211": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 543,
                "PatchRowcode": "+"
            },
            "212": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": 544,
                "PatchRowcode": " @app.route('/Marti/sync/content')"
            },
            "213": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": 545,
                "PatchRowcode": " def sync():"
            },
            "214": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "     # this endpoint was triggered on attempting to create new template from existing template"
            },
            "215": {
                "beforePatchRowNumber": 529,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "     uid = request.args.get('uid')"
            },
            "216": {
                "beforePatchRowNumber": 530,
                "afterPatchRowNumber": 551,
                "PatchRowcode": "     return '', 200"
            },
            "217": {
                "beforePatchRowNumber": 531,
                "afterPatchRowNumber": 552,
                "PatchRowcode": " "
            },
            "218": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 553,
                "PatchRowcode": "+"
            },
            "219": {
                "beforePatchRowNumber": 532,
                "afterPatchRowNumber": 554,
                "PatchRowcode": " @app.route('/Marti/api/excheck/checklist/active', methods=[\"GET\"])"
            },
            "220": {
                "beforePatchRowNumber": 533,
                "afterPatchRowNumber": 555,
                "PatchRowcode": " def activechecklists():"
            },
            "221": {
                "beforePatchRowNumber": 534,
                "afterPatchRowNumber": 556,
                "PatchRowcode": "     from os import listdir"
            },
            "222": {
                "beforePatchRowNumber": 541,
                "afterPatchRowNumber": 563,
                "PatchRowcode": " "
            },
            "223": {
                "beforePatchRowNumber": 542,
                "afterPatchRowNumber": 564,
                "PatchRowcode": "     for file in listdir(MainConfig.ExCheckChecklistFilePath):"
            },
            "224": {
                "beforePatchRowNumber": 543,
                "afterPatchRowNumber": 565,
                "PatchRowcode": "         checklist = Element('checklist')"
            },
            "225": {
                "beforePatchRowNumber": 544,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        xmldetails = etree.parse(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(file)))).getroot().find('checklistDetails')"
            },
            "226": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 566,
                "PatchRowcode": "+        xmldetails = etree.parse(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(file)))).getroot().find("
            },
            "227": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 567,
                "PatchRowcode": "+            'checklistDetails')"
            },
            "228": {
                "beforePatchRowNumber": 545,
                "afterPatchRowNumber": 568,
                "PatchRowcode": "         checklist.append(xmldetails)"
            },
            "229": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 569,
                "PatchRowcode": "         checklist.append(Element('checklistColumns'))"
            },
            "230": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 570,
                "PatchRowcode": "         checklist.append(Element('checklistTasks'))"
            },
            "231": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": 571,
                "PatchRowcode": "         rootxml.append(checklist)"
            },
            "232": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": 572,
                "PatchRowcode": " "
            },
            "233": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "     xml = etree.tostring(rootxml)"
            },
            "234": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 574,
                "PatchRowcode": "     return xml"
            },
            "235": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 575,
                "PatchRowcode": "+"
            },
            "236": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 576,
                "PatchRowcode": "+"
            },
            "237": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 577,
                "PatchRowcode": "+def validate_hash(file_hash: str) -> bool:"
            },
            "238": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 578,
                "PatchRowcode": "+    \"\"\" this function takes a file hash and validates it's"
            },
            "239": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 579,
                "PatchRowcode": "+    content to avoid RCE and XSS attacks"
            },
            "240": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 580,
                "PatchRowcode": "+"
            },
            "241": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 581,
                "PatchRowcode": "+    Args:"
            },
            "242": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 582,
                "PatchRowcode": "+        file_hash:"
            },
            "243": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 583,
                "PatchRowcode": "+    \"\"\""
            },
            "244": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 584,
                "PatchRowcode": "+    if re.match(\"^[A-Za-z0-9_-]*$\", file_hash):"
            },
            "245": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 585,
                "PatchRowcode": "+        return True"
            },
            "246": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 586,
                "PatchRowcode": "+    else:"
            },
            "247": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 587,
                "PatchRowcode": "+        return False"
            },
            "248": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 588,
                "PatchRowcode": "+"
            },
            "249": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 589,
                "PatchRowcode": "+"
            },
            "250": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 590,
                "PatchRowcode": " class FlaskFunctions:"
            },
            "251": {
                "beforePatchRowNumber": 553,
                "afterPatchRowNumber": 591,
                "PatchRowcode": " "
            },
            "252": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": 592,
                "PatchRowcode": "     def __init__(self):"
            },
            "253": {
                "beforePatchRowNumber": 645,
                "afterPatchRowNumber": 683,
                "PatchRowcode": "         global USINGSSL"
            },
            "254": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": 684,
                "PatchRowcode": "         return USINGSSL"
            },
            "255": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": 685,
                "PatchRowcode": " "
            },
            "256": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 686,
                "PatchRowcode": "+"
            },
            "257": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": 687,
                "PatchRowcode": " if __name__ == \"__main__\":"
            },
            "258": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": 688,
                "PatchRowcode": "     pass"
            }
        },
        "frontPatchFile": [
            "\"\"\"this module is responsible for running the DataPackage service",
            "as it utilizes flask, each method represents an endpoint",
            "this web server is responsible for all HTTP queries to",
            "FTS from an ATAK client\"\"\"",
            "import logging",
            "import os",
            "import random",
            "import string",
            "import traceback",
            "import defusedxml.ElementTree as ET",
            "from logging.handlers import RotatingFileHandler",
            "from pathlib import Path, PurePath",
            "from FreeTAKServer.controllers.configuration.DataPackageServerConstants import DataPackageServerConstants",
            "from FreeTAKServer.controllers.configuration.SQLcommands import SQLcommands",
            "from FreeTAKServer.controllers.configuration.LoggingConstants import LoggingConstants",
            "from FreeTAKServer.controllers.CreateLoggerController import CreateLoggerController",
            "from FreeTAKServer.controllers.DatabaseControllers.DatabaseController import DatabaseController",
            "from FreeTAKServer.controllers.configuration.DatabaseConfiguration import DatabaseConfiguration",
            "import eventlet",
            "from FreeTAKServer.controllers.configuration.MainConfig import MainConfig",
            "from flask_cors import CORS, cross_origin",
            "",
            "from flask_sqlalchemy import SQLAlchemy",
            "from flask import Flask, request, send_file",
            "from flask.logging import default_handler",
            "",
            "dbController = DatabaseController()",
            "",
            "loggingConstants = LoggingConstants(log_name=\"FTS-DataPackage_Service\")",
            "logger = CreateLoggerController(\"FTS-DataPackage_Service\", logging_constants=loggingConstants).getLogger()",
            "",
            "log = logging.getLogger('werkzeug')",
            "log.setLevel(logging.ERROR)",
            "",
            "USINGSSL = False",
            "",
            "sql = SQLcommands()",
            "const = DataPackageServerConstants()",
            "log = LoggingConstants()",
            "",
            "app = Flask(__name__)  # create the Flask app",
            "app.config['SQLALCHEMY_DATABASE_URI'] = DatabaseConfiguration().DataBaseConnectionString",
            "app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False",
            "app.config[\"SECRET_KEY\"] = 'vnkdjnfjknfl1232#'",
            "cors = CORS(app, resources={r\"/*\": {\"origins\": \"*\"}})",
            "app.config['CORS_HEADERS'] = 'Content-Type'",
            "",
            "db = SQLAlchemy(app)",
            "# TODO: verify session life cycle in dbController doesnt break this logic",
            "dbController.session = db.session",
            "file_dir = os.path.dirname(os.path.realpath(__file__))",
            "dp_directory = MainConfig.DataPackageFilePath",
            "",
            "if not os.path.exists(MainConfig.ExCheckMainPath):",
            "    os.mkdir(MainConfig.ExCheckMainPath)",
            "",
            "if not os.path.exists(MainConfig.ExCheckChecklistFilePath):",
            "    os.mkdir(MainConfig.ExCheckChecklistFilePath)",
            "",
            "if not os.path.exists(MainConfig.ExCheckFilePath):",
            "    os.mkdir(MainConfig.ExCheckFilePath)",
            "# Set up logging",
            "\"\"\"if not Path(log.LOGDIRECTORY).exists():",
            "    print(f\"Creating directory at {log.LOGDIRECTORY}\")",
            "    os.makedirs(log.LOGDIRECTORY)\"\"\"",
            "app.logger.removeHandler(default_handler)  # pylint: disable=no-member; member does exist",
            "formatter = logging.Formatter(log.LOGFORMAT)",
            "file_handler = RotatingFileHandler(",
            "    log.HTTPLOG,",
            "    maxBytes=log.MAXFILESIZE,",
            "    backupCount=log.BACKUPCOUNT",
            ")",
            "file_handler.setFormatter(formatter)",
            "file_handler.setLevel(logging.ERROR)",
            "",
            "",
            "# app.logger.addHandler(file_handler)",
            "# console_handler = logging.StreamHandler(sys.stdout)",
            "# console_handler.setFormatter(formatter)",
            "# console_handler.setLevel(logging.DEBUG)",
            "# app.logger.addHandler(console_handler)",
            "# app.logger.setLevel(logging.DEBUG)",
            "",
            "@app.route('/')",
            "def hello():",
            "    return 'hello world'",
            "",
            "@app.route('/Alive')",
            "def alive():",
            "    return 'DataPackage service alive', 200",
            "",
            "",
            "@app.route(\"/Marti/vcm\", methods=[const.GET])",
            "def get_all_video_links():",
            "    # This is called when the user selects the Download button in the Videos window. It",
            "    # expects an XML listing of all known feeds, so the user can pick and choose which ones",
            "    # to store locally",
            "    try:",
            "        feeds = dbController.query_videostream(column=[\"FullXmlString\"])",
            "        app.logger.info(f\"Found {len(feeds)} video feeds in {const.DATABASE}\")  # pylint: disable=no-member; member does exist",
            "        if len(feeds) == 0:",
            "            return (\"No video feeds found\", 500)",
            "        all_feeds = \"\"",
            "        for feed in feeds:",
            "            # 'feed' is a tuple with one element, so we only append that",
            "            all_feeds += feed.FullXmlString.decode(\"utf-8\")",
            "        return f\"<videoConnections>{all_feeds}</videoConnections>\"",
            "    except:",
            "        app.logger.error(traceback.format_exc())  # pylint: disable=no-member; member does exist",
            "        return \"Error\", 500",
            "",
            "",
            "@app.route(\"/Marti/vcm\", methods=[const.POST])",
            "def insert_video_link():",
            "    try:",
            "        xml_root = ET.fromstring(request.data.decode(\"utf-8\"))",
            "        for xml_feed in xml_root:",
            "            protocol = xml_feed.find(\"protocol\").text",
            "            alias = xml_feed.find(\"alias\").text",
            "            uid = xml_feed.find(\"uid\").text",
            "            address = xml_feed.find(\"address\").text",
            "            port = xml_feed.find(\"port\").text",
            "            rover_port = xml_feed.find(\"roverPort\").text",
            "            ignore_klv = xml_feed.find(\"ignoreEmbeddedKLV\").text",
            "            preferred_mac = xml_feed.find(\"preferredMacAddress\").text",
            "            path = xml_feed.find(\"path\").text",
            "            buf = xml_feed.find(\"buffer\").text",
            "            timeout = xml_feed.find(\"timeout\").text",
            "            rtsp_reliable = xml_feed.find(\"rtspReliable\").text",
            "            # Check that no other feeds with the same UID have been received",
            "            streams = dbController.query_videostream(query=f'uid = \"{uid}\"')",
            "            if len(streams) > 0:",
            "                app.logger.info(f\"Already received feed with UID={uid} (alias = {alias})\")  # pylint: disable=no-member; member does exist",
            "                continue  # Ignore this feed if there are duplicates",
            "            app.logger.info(f\"Inserting video feed into database: {request.data.decode('utf-8')}\")  # pylint: disable=no-member; member does exist",
            "            dbController.create_videostream(FullXmlString=ET.tostring(xml_feed), Protocol=protocol, Alias=alias,",
            "                                            uid=uid, Address=address, Port=port, RoverPort=rover_port,",
            "                                            IgnoreEmbeddedKlv=ignore_klv, PreferredMacAddress=preferred_mac, Path=path,",
            "                                            Buffer=buf, Timeout=timeout, RtspReliable=rtsp_reliable)",
            "",
            "        return \"Okay\", 200",
            "    except:",
            "        app.logger.error(traceback.format_exc())",
            "        return \"Error\", 500",
            "",
            "",
            "@app.route('/Marti/api/version/config', methods=[const.GET])",
            "def versionConfig():",
            "    logger.info('sending client version json')",
            "    return const.VERSIONJSON",
            "",
            "",
            "@app.route('/Marti/api/clientEndPoints', methods=[const.GET])",
            "def clientEndPoint():",
            "    logger.info('sending client version info')",
            "    return const.versionInfo",
            "",
            "",
            "@app.route('/Marti/sync/missionupload', methods=[const.POST])",
            "def upload():",
            "    from FreeTAKServer.model.ServiceObjects.SSLDataPackageVariables import SSLDataPackageVariables",
            "    logger.info('dataoackage upload started')",
            "    file_hash = request.args.get('hash')",
            "    app.logger.info(f\"Data Package hash = {str(file_hash)}\")",
            "    letters = string.ascii_letters",
            "    uid = ''.join(random.choice(letters) for i in range(4))",
            "    uid = 'uid-' + str(uid)",
            "    filename = request.args.get('filename')",
            "    creatorUid = request.args.get('creatorUid')",
            "    file = request.files.getlist('assetfile')[0]",
            "    directory = Path(dp_directory, file_hash)",
            "    if not Path.exists(directory):",
            "        os.mkdir(str(directory))",
            "    file.save(os.path.join(str(directory), filename))",
            "    fileSize = Path(str(directory), filename).stat().st_size",
            "    callsign = str(",
            "        FlaskFunctions().getSubmissionUser(creatorUid,",
            "                                           dbController))  # fetchone() gives a tuple, so only grab the first element",
            "    FlaskFunctions().create_dp(dbController, uid=uid, Name=filename, Hash=file_hash, SubmissionUser=callsign,",
            "                               CreatorUid=creatorUid, Size=fileSize)",
            "    if USINGSSL == False:",
            "        return \"http://\" + IP + ':' + str(HTTPPORT) + \"/Marti/api/sync/metadata/\" + file_hash + \"/tool\"",
            "",
            "    else:",
            "        return \"https://\" + IP + ':' + str(HTTPPORT) + \"/Marti/api/sync/metadata/\" + file_hash + \"/tool\"",
            "",
            "",
            "@app.route('/Marti/api/sync/metadata/<hash>/tool', methods=[const.PUT])",
            "def putDataPackageTool(hash):",
            "    if request.data == b'private':",
            "        dbController.update_datapackage(query=f'Hash = \"{hash}\"', column_value={\"Privacy\": 1})",
            "    return \"Okay\", 200",
            "",
            "",
            "@app.route('/Marti/api/sync/metadata/<hash>/tool', methods=[const.GET])",
            "@cross_origin(send_wildcard = True)",
            "def getDataPackageTool(hash):",
            "    from flask import make_response",
            "    file_list = os.listdir(os.path.join(Path(str(dp_directory)), Path(str(hash))))",
            "    path = PurePath(dp_directory, str(hash), file_list[0])",
            "    app.logger.info(f\"Sending data package from {str(path)}\")",
            "    resp = send_file(str(path))",
            "    return resp",
            "",
            "",
            "@app.route('/Marti/sync/search', methods=[const.GET])",
            "def retrieveData():",
            "    logger.info('sync search tirggerd')",
            "    keyword = request.args.get('keyword')",
            "    packages = FlaskFunctions().getAllPackages()",
            "    app.logger.info(f\"Data packages in the database: {packages}\")",
            "    return str(packages)",
            "",
            "@app.route('/Marti/sync/content', methods=const.HTTPMETHODS)",
            "def specificPackage():",
            "    from defusedxml import ElementTree as etree",
            "    from os import listdir",
            "    if request.method == 'GET' and request.args.get('uid') != None:",
            "        data = request.data",
            "        taskuid = request.args.get('uid')",
            "        for file in listdir(MainConfig.ExCheckChecklistFilePath):",
            "            xml = etree.parse(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(file)))).getroot()",
            "",
            "            tasks = xml.find('checklistTasks')",
            "            for task in tasks:",
            "                uid = task.find('uid')",
            "                if str(uid.text) == str(taskuid):",
            "                    return etree.tostring(task)",
            "                else:",
            "                    pass",
            "        for file in listdir(MainConfig.ExCheckFilePath):",
            "            xml = etree.parse(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(file)))).getroot()",
            "            if xml.find(\"checklistDetails\").find('uid').text == str(taskuid):",
            "                return etree.tostring(xml)",
            "",
            "    else:",
            "        hash = request.args.get('hash')",
            "        import hashlib",
            "        if os.path.exists(str(PurePath(Path(dp_directory), Path(hash)))):",
            "            logger.info('marti sync content triggerd')",
            "            app.logger.debug(str(PurePath(Path(dp_directory), Path(hash))))",
            "            file_list = os.listdir(str(PurePath(Path(dp_directory), Path(hash))))",
            "            app.logger.debug(PurePath(Path(const.DATAPACKAGEFOLDER), Path(hash), Path(file_list[0])))",
            "            path = PurePath(dp_directory, str(hash), file_list[0])",
            "            app.logger.debug(str(path))",
            "            return send_file(str(path))",
            "        else:",
            "            obj = dbController.query_ExCheck(verbose=True, query=f'hash = \"{hash}\"')",
            "            data = etree.parse(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(obj[0].data.filename))))",
            "            data.getroot().find('checklistTasks').find(\"checklistTask\").find(\"uid\").text = data.getroot().find('checklistTasks').find(\"checklistTask\").find(\"checklistUid\").text",
            "            output = etree.tostring(data)",
            "            return output",
            "",
            "",
            "@app.route('/Marti/api/version', methods=[const.GET])",
            "def returnVersion():",
            "    logger.info('api version triggered')",
            "    return const.versionInfo",
            "",
            "",
            "@app.route('/Marti/sync/missionquery', methods=const.HTTPMETHODS)",
            "def checkPresent():",
            "    logger.info('synce missionquery triggered')",
            "    hash = request.args.get('hash')",
            "    if FlaskFunctions().hashIsPresent(hash, dbController):",
            "        app.logger.info(f\"Data package with hash {hash} exists\")",
            "        if USINGSSL == False:",
            "            return \"http://\" + IP + ':' + str(HTTPPORT) + \"/Marti/api/sync/metadata/\" + hash + \"/tool\"",
            "        else:",
            "            return \"https://\" + IP + ':' + str(HTTPPORT) + \"/Marti/api/sync/metadata/\" + hash + \"/tool\"",
            "    else:",
            "        app.logger.info(f\"Data package with hash {hash} does not exist\")",
            "        return '404', 404",
            "",
            "",
            "@app.route('/')",
            "def home():",
            "    return 'data package service is up, good job.'",
            "",
            "",
            "",
            "#exCheckStuff",
            "from flask import Flask, request",
            "from FreeTAKServer.controllers.ExCheckControllers.templateToJsonSerializer import templateSerializer",
            "from FreeTAKServer.controllers.DatabaseControllers.DatabaseController import DatabaseController",
            "from FreeTAKServer.controllers.configuration.MainConfig import MainConfig",
            "",
            "@app.route('/Marti/api/missions/exchecktemplates/changes', methods=['GET'])",
            "def check_changes():",
            "    try:",
            "        # example return data {\"version\":\"2\",\"type\":\"MissionChange\",\"data\":[],\"nodeId\":\"TAK-Server-a6htdf93\"}",
            "        # this endpoint should return any excheck template change since specified time",
            "        # TODO: learn what squached represents",
            "        request.args.get('squached')",
            "        # the time since last connect and the length of time to check for changes",
            "        request.args.get('start')",
            "        return '{\"version\":\"2\",\"type\":\"MissionChange\",\"data\":[{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:10.346Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:10.366Z\",\"contentResource\":{\"filename\":\"d5d2bc15-f6ab-49e7-a408-5f7fe600ca3e.xml\",\"keywords\":[\"test bravo\",\"this is in db\",\"FEATHER\"],\"mimeType\":\"application/xml\",\"name\":\"d5d2bc15-f6ab-49e7-a408-5f7fe600ca3e\",\"submissionTime\":\"2020-10-20T00:18:57.157Z\",\"submitter\":\"testbravo\",\"uid\":\"d5d2bc15-f6ab-49e7-a408-5f7fe600ca3e\",\"hash\":\"d94a49a958422a451b352b6ebd8b0741780214b1c2da4b0d41e6fca8e3674082\",\"size\":2155,\"tool\":\"ExCheck\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:10.235Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:10.307Z\",\"contentResource\":{\"hash\":\"f1197a7ec99442864b26fb58b993869303cd7ad4a7d6139611c0d42cd1ff156b\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:10.186Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:10.199Z\",\"contentResource\":{\"filename\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462.xml\",\"keywords\":[\"ddd\",\"wadasdsa\",\"FEATHER\"],\"mimeType\":\"application/xml\",\"name\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462\",\"submissionTime\":\"2020-10-23T15:28:59.943Z\",\"submitter\":\"testbravo\",\"uid\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462\",\"hash\":\"19597a47b4be14f9ee527630cf0dc7fb6b6de222502eab41b6c488e4371fb40b\",\"size\":1747,\"tool\":\"ExCheck\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:10.017Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:10.127Z\",\"contentResource\":{\"hash\":\"60aac7efcdf2d7001b8ad0d812e1d1528e252e01be130a6f6285b69943f8d633\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:09.842Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:09.875Z\",\"contentResource\":{\"filename\":\"173992a0-d18d-46bb-b178-759011299d60.xml\",\"keywords\":[\"temp\",\"temp 1\",\"FEATHER\"],\"mimeType\":\"application/xml\",\"name\":\"173992a0-d18d-46bb-b178-759011299d60\",\"submissionTime\":\"2020-10-19T23:21:03.934Z\",\"submitter\":\"testbravo\",\"uid\":\"173992a0-d18d-46bb-b178-759011299d60\",\"hash\":\"41482b4776bb7735654e8ddde2ad02032909b50ab4df5d8de55f99ebe6bc805d\",\"size\":1461,\"tool\":\"ExCheck\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:07.103Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:07.138Z\",\"contentResource\":{\"hash\":\"5bc1ac8bdbc28fc13ec002b60215a9c45874384e8fc754286c5d907a80219fc5\"}},{\"type\":\"ADD_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T15:28:59.947Z\",\"creatorUid\":\"S-1-5-21-2720623347-3037847324-4167270909-1002\",\"serverTime\":\"2020-10-23T15:28:59.963Z\",\"contentResource\":{\"filename\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462.xml\",\"keywords\":[\"ddd\",\"wadasdsa\",\"FEATHER\"],\"mimeType\":\"application/xml\",\"name\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462\",\"submissionTime\":\"2020-10-23T15:28:59.943Z\",\"submitter\":\"testbravo\",\"uid\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462\",\"hash\":\"19597a47b4be14f9ee527630cf0dc7fb6b6de222502eab41b6c488e4371fb40b\",\"size\":1747,\"tool\":\"ExCheck\"}},{\"type\":\"ADD_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T15:26:45.110Z\",\"creatorUid\":\"S-1-5-21-2720623347-3037847324-4167270909-1002\",\"serverTime\":\"2020-10-23T15:26:45.116Z\"}],\"nodeId\":\"TAK-Server-560c34e9\"}'",
            "    except Exception as e:",
            "        print('exception in check changes' + str(e))",
            "",
            "@app.route('/Marti/api/missions/exchecktemplates/subscription', methods=['PUT'])",
            "def request_subscription():",
            "    try:",
            "        # this endpoint allows for the client to request a new subscription",
            "        # possibly the uid of the client db also contains create_time and mission_id",
            "        print(request.args.get('uid'))",
            "",
            "        return ('', 200)",
            "    except Exception as e:",
            "        print('exception in request_subscription' + str(e))",
            "",
            "@app.route('/Marti/api/missions/exchecktemplates', methods=['GET'])",
            "def exchecktemplates():",
            "    try:",
            "        # when no data available",
            "        # return b'{\"version\":\"2\",\"type\":\"Mission\",\"data\":[{\"name\":\"exchecktemplates\",\"description\":\"\",\"chatRoom\":\"\",\"tool\":\"ExCheck\",\"keywords\":[],\"creatorUid\":\"ExCheck\",\"createTime\":\"2020-10-19T22:37:39.290Z\",\"externalData\":[],\"uids\":[],\"contents\":[]}],\"nodeId\":\"TAK-Server-560c34e9\"}'",
            "        # when data available",
            "        return templateSerializer().convert_object_to_json(DatabaseController().query_ExCheck())",
            "    except Exception as e:",
            "        print(e)",
            "@app.route('/Marti/api/missions/ExCheckTemplates', methods=['GET'])",
            "def ExCheckTemplates():",
            "    try:",
            "        # when no data available",
            "        # return b'{\"version\":\"2\",\"type\":\"Mission\",\"data\":[{\"name\":\"exchecktemplates\",\"description\":\"\",\"chatRoom\":\"\",\"tool\":\"ExCheck\",\"keywords\":[],\"creatorUid\":\"ExCheck\",\"createTime\":\"2020-10-19T22:37:39.290Z\",\"externalData\":[],\"uids\":[],\"contents\":[]}],\"nodeId\":\"TAK-Server-560c34e9\"}'",
            "        # when data available",
            "        return templateSerializer().convert_object_to_json(DatabaseController().query_ExCheck())",
            "    except Exception as e:",
            "        print(e)",
            "",
            "@app.route('/Marti/api/missions/<templateuid>/subscription', methods=['DELETE', 'PUT'])",
            "def missionupdate(templateuid):",
            "    from flask import request",
            "    uid = request.args.get('uid')",
            "    return '', 200",
            "",
            "@app.route('/Marti/api/excheck/template', methods=['POST'])",
            "def template():",
            "    try:",
            "        import uuid",
            "        xmlstring = f'<?xml version=\"1.0\"?><event version=\"2.0\" uid=\"{uuid.uuid4()}\" type=\"t-x-m-c\" time=\"2020-11-28T17:45:51.000Z\" start=\"2020-11-28T17:45:51.000Z\" stale=\"2020-11-28T17:46:11.000Z\" how=\"h-g-i-g-o\"><point lat=\"0.00000000\" lon=\"0.00000000\" hae=\"0.00000000\" ce=\"9999999\" le=\"9999999\" /><detail><mission type=\"CHANGE\" tool=\"ExCheck\" name=\"exchecktemplates\" authorUid=\"S-1-5-21-2720623347-3037847324-4167270909-1002\"><MissionChanges><MissionChange><contentResource><filename>61b01475-ad44-4300-addc-a9474ebf67b0.xml</filename><hash>018cd5786bd6c2e603beef30d6a59987b72944a60de9e11562297c35ebdb7fd6</hash><keywords>test init</keywords><keywords>dessc init</keywords><keywords>FEATHER</keywords><mimeType>application/xml</mimeType><name>61b01475-ad44-4300-addc-a9474ebf67b0</name><size>1522</size><submissionTime>2020-11-28T17:45:47.980Z</submissionTime><submitter>wintak</submitter><tool>ExCheck</tool><uid>61b01475-ad44-4300-addc-a9474ebf67b0</uid></contentResource><creatorUid>S-1-5-21-2720623347-3037847324-4167270909-1002</creatorUid><missionName>exchecktemplates</missionName><timestamp>2020-11-28T17:45:47.983Z</timestamp><type>ADD_CONTENT</type></MissionChange></MissionChanges></mission></detail></event>'",
            "        # this is where the client will post the xmi of a template",
            "        from flask import request",
            "        from datetime import datetime",
            "        from defusedxml import ElementTree as etree",
            "        import hashlib",
            "        # possibly the uid of the client submitting the template",
            "        Y = request",
            "        uid = request.args.get('clientUid')",
            "        XMI = request.data.decode()",
            "        serializer = templateSerializer(XMI)",
            "        object = serializer.convert_template_to_object()",
            "        object.timestamp = datetime.strptime(object.timestamp, \"%Y-%m-%dT%H:%M:%S.%fZ\")",
            "        serializer.create_DB_object(object)",
            "        xml = etree.fromstring(XMI)",
            "        tasks = xml.find('checklistTasks')",
            "        path = str(PurePath(Path(MainConfig.ExCheckFilePath), Path(f'{object.data.uid}.xml')))",
            "        with open(path, 'w+') as file:",
            "            file.write(XMI)",
            "            file.close()",
            "",
            "        uid = object.data.uid",
            "        temp = etree.fromstring(XMI)",
            "        cot = etree.fromstring(xmlstring)",
            "        resources = cot.find('detail').find('mission').find('MissionChanges').find('MissionChange').find('contentResource')",
            "        resources.find('filename').text = temp.find('checklistDetails').find('uid').text + '.xml'",
            "        resources.findall('keywords')[0].text = temp.find('checklistDetails').find('name').text",
            "        resources.findall('keywords')[1].text = temp.find('checklistDetails').find('description').text",
            "        resources.findall('keywords')[2].text = temp.find('checklistDetails').find('creatorCallsign').text",
            "        resources.find('uid').text = temp.find('checklistDetails').find('uid').text",
            "        resources.find('name').text = temp.find('checklistDetails').find('uid').text",
            "        resources.find('size').text = str(len(XMI))",
            "        resources.find('hash').text = str(hashlib.sha256(str(XMI).encode()).hexdigest())",
            "        z = etree.tostring(cot)",
            "        from FreeTAKServer.model.testobj import testobj",
            "        object = testobj()",
            "        object.xmlString = z",
            "        PIPE.put(object)",
            "        return str(uid), 200",
            "    except Exception as e:",
            "        print(str(e))",
            "",
            "@app.route('/Marti/api/excheck/<subscription>/start', methods=['POST'])",
            "def startList(subscription):",
            "    import uuid",
            "    from defusedxml import ElementTree as etree",
            "    from xml.etree.ElementTree import Element",
            "    import datetime",
            "    uid = str(uuid.uuid4())",
            "    r = request",
            "    # client uid",
            "    request.args.get('clientUid')",
            "    # name of template",
            "    request.args.get('name')",
            "    # description of template",
            "    request.args.get('description')",
            "    # startTime of template",
            "    startTime = request.args.get('startTime')",
            "    # callsign of submission user",
            "    request.args.get('callsign')",
            "",
            "    with open(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(f'{uid}.xml'))), 'w+') as file:",
            "        file.write(str(open(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(f'{subscription}.xml'))), 'r').read()))",
            "        file.close()",
            "",
            "    xml = etree.parse(",
            "        MainConfig.ExCheckChecklistFilePath + '/' + uid + '.xml').getroot()",
            "",
            "    starttime = Element('startTime')",
            "    starttime.text = startTime",
            "    details = xml.find('checklistDetails')",
            "    if details.find('startTime') == None:",
            "",
            "        details.append(starttime)",
            "    else:",
            "        details.find('startTime').text = startTime",
            "    uids = details.find('uid')",
            "    uids.text = uid",
            "    details.find('description').text = request.args.get('description')",
            "    details.find('name').text = request.args.get('name')",
            "",
            "    tasks = xml.find('checklistTasks')",
            "    for task in tasks:",
            "        taskuid = task.find('uid')",
            "        taskuid.text = str(uuid.uuid4())",
            "",
            "",
            "    with open(",
            "            str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(uid + '.xml'))),",
            "            'w+') as file:",
            "        y = etree.tostring(xml)",
            "        file.write(etree.tostring(xml).decode())",
            "        file.close()",
            "",
            "    excheckobj = dbController.query_ExCheck(f'ExCheckData.uid = \"{subscription}\"', verbose=True,)[0]",
            "    dbController.create_Excheckchecklist(startTime=datetime.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S.%fZ'), creatorUid = request.args.get('clientUid'), description = request.args.get('description'), callsign = request.args.get('callsign'), name = request.args.get('name'), uid = uid, filename = f'{uid}.xml', template = excheckobj)",
            "",
            "    return str(open(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(uid + '.xml'))), 'r').read()), 200",
            "",
            "@app.route('/Marti/api/excheck/checklist/<checklistid>')",
            "def accesschecklist(checklistid):",
            "    return str(open(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistid + '.xml'))),",
            "              'r').read())",
            "",
            "@app.route('/Marti/api/excheck/checklist/<checklistid>/task/<taskid>', methods=['PUT'])",
            "def updatetemplate(checklistid, taskid):",
            "    from flask import request",
            "    from defusedxml import ElementTree as etree",
            "    from FreeTAKServer.controllers.SpecificCoTControllers.SendExcheckUpdateController import SendExcheckUpdateController",
            "    from FreeTAKServer.controllers.XMLCoTController import XMLCoTController",
            "    from FreeTAKServer.model.FTSModel.Event import Event",
            "    from FreeTAKServer.model.RawCoT import RawCoT",
            "    import uuid",
            "    import hashlib",
            "",
            "",
            "    data = request.data",
            "",
            "    xml = etree.parse(",
            "        str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistid + '.xml')))).getroot()",
            "    updatedTask = etree.fromstring(data)",
            "    tasks = xml.find('checklistTasks')",
            "    index = 0",
            "    for task in tasks:",
            "        index += 1",
            "        uid = task.find('uid')",
            "        if uid.text == taskid:",
            "            tasks.remove(task)",
            "            tasks.insert(index, updatedTask)",
            "        else:",
            "            pass",
            "    with open(",
            "            str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistid + '.xml'))), 'w+') as file:",
            "        file.write(etree.tostring(xml).decode())",
            "        file.close()",
            "",
            "    # Create Object to send to client",
            "    object = Event.ExcheckUpdate()",
            "    object.setuid(str(uuid.uuid4()))",
            "    object.setversion('2.0')",
            "    object.detail.mission.settype(\"CHANGE\")",
            "    object.detail.mission.settool(\"ExCheck\")",
            "    object.detail.mission.setname(checklistid)",
            "    object.detail.mission.setauthorUid(request.args.get(\"clientUid\"))",
            "    object.detail.mission.MissionChanges.MissionChange.creatorUid.setINTAG(request.args.get(\"clientUid\"))",
            "    object.detail.mission.MissionChanges.MissionChange.missionName.setINTAG(checklistid)",
            "    object.detail.mission.MissionChanges.MissionChange.type.setINTAG(\"ADD_CONTENT\")",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.filename.setINTAG(taskid+'.xml')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.hash.setINTAG(str(hashlib.sha256(str(open(MainConfig.ExCheckChecklistFilePath + '/' + checklistid + '.xml', 'r')).encode()).hexdigest()))",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.keywords.setINTAG('Task')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.name.setINTAG(taskid)",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.size.setINTAG(str(len(data)))",
            "    #TODO: change this value",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.submitter.setINTAG('atak')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.uid.setINTAG(taskid)",
            "",
            "",
            "",
            "    '''object = etree.fromstring(templateex)",
            "    object.uid = uuid.uuid4()",
            "    object.find('detail').find('mission').type= \"CHANGE\"",
            "    object.find('detail').find('mission').name = taskid",
            "    object.find('detail').find('mission').Uid = request.args.get(\"clientUid\")",
            "    object.find('detail').find('mission').find('MissionChanges').find('MissionChange').find('creatorUid').text = request.args.get(\"clientUid\")",
            "    object.find('detail').find('mission').find('MissionChanges').find('MissionChange').find('missionName').text = taskid",
            "    object.find('detail').find('mission').find('MissionChanges').find('MissionChange').find('filename').text = checklistid+'.xml'",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.hash.setINTAG(str(hashlib.sha256(str(data).encode()).hexdigest()))",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.keywords.setINTAG('Task')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.name.setINTAG(checklistid)",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.size.setINTAG(str(len(data)))",
            "    #TODO: change this value",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.submitter.setINTAG('test')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.uid.setINTAG(checklistid)'''",
            "    rawcot = RawCoT()",
            "    xml = XMLCoTController().serialize_model_to_CoT(object)",
            "    rawcot.xmlString = xml",
            "",
            "    PIPE.put(rawcot)",
            "    #PIPE.send()",
            "",
            "    return '', 200",
            "",
            "@app.route('/Marti/sync/content')",
            "def sync():",
            "    # this endpoint was triggered on attempting to create new template from existing template",
            "    # likely the hash of the excheck",
            "    y = request",
            "    request.args.get('hash')",
            "    uid = request.args.get('uid')",
            "    return '', 200",
            "",
            "@app.route('/Marti/api/excheck/checklist/active', methods=[\"GET\"])",
            "def activechecklists():",
            "    from os import listdir",
            "    from FreeTAKServer.model.FTSModel.Checklists import Checklists",
            "    from FreeTAKServer.model.FTSModel.Checklist import Checklist",
            "    from xml.etree.ElementTree import Element",
            "    from defusedxml import ElementTree as etree",
            "    checklists = Checklists.Checklist()",
            "    rootxml = Element('checklists')",
            "",
            "    for file in listdir(MainConfig.ExCheckChecklistFilePath):",
            "        checklist = Element('checklist')",
            "        xmldetails = etree.parse(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(file)))).getroot().find('checklistDetails')",
            "        checklist.append(xmldetails)",
            "        checklist.append(Element('checklistColumns'))",
            "        checklist.append(Element('checklistTasks'))",
            "        rootxml.append(checklist)",
            "",
            "    xml = etree.tostring(rootxml)",
            "    return xml",
            "class FlaskFunctions:",
            "",
            "    def __init__(self):",
            "        self.callsigns = []",
            "",
            "    def create_dp(self, dbController, **args):",
            "        return dbController.create_datapackage(**args)",
            "",
            "    def hashIsPresent(self, hash, dbControl):",
            "        data = dbControl.query_datapackage(query=f'Hash = \"{hash}\"')",
            "        return len(data) > 0",
            "",
            "    def getSubmissionUser(self, UID, dbControl):",
            "        callsign = dbControl.query_user(query=f'uid = \"{UID}\"', column=['callsign'])",
            "        return callsign",
            "",
            "    def getAllPackages(self):",
            "        data = DatabaseController().query_datapackage(\"Privacy = 0\")",
            "        package_dict = {",
            "            \"resultCount\": len(data),",
            "            \"results\": []",
            "        }",
            "        for i in data:",
            "            package_dict[\"results\"].append({",
            "                \"UID\": i.uid,",
            "                \"Name\": i.Name,",
            "                \"Hash\": i.Hash,",
            "                \"PrimaryKey\": i.PrimaryKey,",
            "                \"SubmissionDateTime\": str(i.SubmissionDateTime.strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\")),",
            "                \"SubmissionUser\": i.SubmissionUser,",
            "                \"CreatorUid\": i.CreatorUid,",
            "                \"Keywords\": i.Keywords,",
            "                \"MIMEType\": i.MIMEType,",
            "                \"Size\": i.Size",
            "            })",
            "        return package_dict",
            "",
            "    def startup(self, ip, port, pipe):",
            "        try:",
            "            from eventlet import wsgi",
            "",
            "            global IP, HTTPPORT",
            "            IP = ip",
            "            HTTPPORT = port",
            "            # Make sure the data package directory exists",
            "            if not Path(dp_directory).exists():",
            "                app.logger.info(f\"Creating directory at {str(dp_directory)}\")",
            "                os.makedirs(str(dp_directory))",
            "            # Create the relevant database tables",
            "            print(const.IP)",
            "            print(HTTPPORT)",
            "            # app.run(host='0.0.0.0', port=8080)",
            "            wsgi.server(eventlet.listen((DataPackageServerConstants().IP, int(HTTPPORT))), app)",
            "",
            "        except Exception as e:",
            "            logger.error('there has been an exception in Data Package service startup ' + str(e))",
            "            return -1",
            "",
            "    def stop(self):",
            "        func = request.environ.get('werkzeug.server.shutdown')",
            "        if func is None:",
            "            raise RuntimeError('Not running with the Werkzeug Server')",
            "        func()",
            "",
            "    def setIP(self, IP_to_be_set):",
            "        global IP",
            "        IP = IP_to_be_set",
            "",
            "    def getIP(self):",
            "        global IP",
            "        return IP",
            "",
            "    def setHTTPPORT(self, HTTPPORTToBeSet):",
            "        global HTTPPORT",
            "        HTTPPORT = HTTPPORTToBeSet",
            "",
            "    def getHTTPPort(self):",
            "        global HTTPPORT",
            "        return HTTPPORT",
            "",
            "    def setPIPE(self, PIPEtoBeSet):",
            "        global PIPE",
            "        PIPE = PIPEtoBeSet",
            "",
            "    def getPIPE(self):",
            "        global PIPE",
            "        return PIPE",
            "",
            "    def setSSL(self, SSL: bool):",
            "        global USINGSSL",
            "        USINGSSL = SSL",
            "",
            "    def getSSL(self):",
            "        global USINGSSL",
            "        return USINGSSL",
            "",
            "if __name__ == \"__main__\":",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"this module is responsible for running the DataPackage service",
            "as it utilizes flask, each method represents an endpoint",
            "this web server is responsible for all HTTP queries to",
            "FTS from an ATAK client\"\"\"",
            "import logging",
            "import os",
            "import random",
            "import string",
            "import re",
            "import traceback",
            "import defusedxml.ElementTree as ET",
            "from logging.handlers import RotatingFileHandler",
            "from pathlib import Path, PurePath",
            "from FreeTAKServer.controllers.configuration.DataPackageServerConstants import DataPackageServerConstants",
            "from FreeTAKServer.controllers.configuration.SQLcommands import SQLcommands",
            "from FreeTAKServer.controllers.configuration.LoggingConstants import LoggingConstants",
            "from FreeTAKServer.controllers.CreateLoggerController import CreateLoggerController",
            "from FreeTAKServer.controllers.DatabaseControllers.DatabaseController import DatabaseController",
            "from FreeTAKServer.controllers.configuration.DatabaseConfiguration import DatabaseConfiguration",
            "import eventlet",
            "from FreeTAKServer.controllers.configuration.MainConfig import MainConfig",
            "from flask_cors import CORS, cross_origin",
            "",
            "from flask_sqlalchemy import SQLAlchemy",
            "from flask import Flask, request, send_file",
            "from flask.logging import default_handler",
            "",
            "dbController = DatabaseController()",
            "",
            "loggingConstants = LoggingConstants(log_name=\"FTS-DataPackage_Service\")",
            "logger = CreateLoggerController(\"FTS-DataPackage_Service\", logging_constants=loggingConstants).getLogger()",
            "",
            "log = logging.getLogger('werkzeug')",
            "log.setLevel(logging.ERROR)",
            "",
            "USINGSSL = False",
            "",
            "sql = SQLcommands()",
            "const = DataPackageServerConstants()",
            "log = LoggingConstants()",
            "",
            "app = Flask(__name__)  # create the Flask app",
            "app.config['SQLALCHEMY_DATABASE_URI'] = DatabaseConfiguration().DataBaseConnectionString",
            "app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False",
            "app.config[\"SECRET_KEY\"] = MainConfig.SecretKey",
            "cors = CORS(app, resources={r\"/*\": {\"origins\": \"*\"}})",
            "app.config['CORS_HEADERS'] = 'Content-Type'",
            "",
            "db = SQLAlchemy(app)",
            "# TODO: verify session life cycle in dbController doesnt break this logic",
            "dbController.session = db.session",
            "file_dir = os.path.dirname(os.path.realpath(__file__))",
            "dp_directory = MainConfig.DataPackageFilePath",
            "",
            "if not os.path.exists(MainConfig.ExCheckMainPath):",
            "    os.mkdir(MainConfig.ExCheckMainPath)",
            "",
            "if not os.path.exists(MainConfig.ExCheckChecklistFilePath):",
            "    os.mkdir(MainConfig.ExCheckChecklistFilePath)",
            "",
            "if not os.path.exists(MainConfig.ExCheckFilePath):",
            "    os.mkdir(MainConfig.ExCheckFilePath)",
            "# Set up logging",
            "\"\"\"if not Path(log.LOGDIRECTORY).exists():",
            "    print(f\"Creating directory at {log.LOGDIRECTORY}\")",
            "    os.makedirs(log.LOGDIRECTORY)\"\"\"",
            "app.logger.removeHandler(default_handler)  # pylint: disable=no-member; member does exist",
            "formatter = logging.Formatter(log.LOGFORMAT)",
            "file_handler = RotatingFileHandler(",
            "    log.HTTPLOG,",
            "    maxBytes=log.MAXFILESIZE,",
            "    backupCount=log.BACKUPCOUNT",
            ")",
            "file_handler.setFormatter(formatter)",
            "file_handler.setLevel(logging.ERROR)",
            "",
            "",
            "# app.logger.addHandler(file_handler)",
            "# console_handler = logging.StreamHandler(sys.stdout)",
            "# console_handler.setFormatter(formatter)",
            "# console_handler.setLevel(logging.DEBUG)",
            "# app.logger.addHandler(console_handler)",
            "# app.logger.setLevel(logging.DEBUG)",
            "",
            "@app.route('/')",
            "def hello():",
            "    return 'hello world'",
            "",
            "",
            "@app.route('/Alive')",
            "def alive():",
            "    return 'DataPackage service alive', 200",
            "",
            "",
            "@app.route(\"/Marti/vcm\", methods=[const.GET])",
            "def get_all_video_links():",
            "    # This is called when the user selects the Download button in the Videos window. It",
            "    # expects an XML listing of all known feeds, so the user can pick and choose which ones",
            "    # to store locally",
            "    try:",
            "        feeds = dbController.query_videostream(column=[\"FullXmlString\"])",
            "        app.logger.info(",
            "            f\"Found {len(feeds)} video feeds in {const.DATABASE}\")  # pylint: disable=no-member; member does exist",
            "        if len(feeds) == 0:",
            "            return (\"No video feeds found\", 500)",
            "        all_feeds = \"\"",
            "        for feed in feeds:",
            "            # 'feed' is a tuple with one element, so we only append that",
            "            all_feeds += feed.FullXmlString.decode(\"utf-8\")",
            "        return f\"<videoConnections>{all_feeds}</videoConnections>\"",
            "    except:",
            "        app.logger.error(traceback.format_exc())  # pylint: disable=no-member; member does exist",
            "        return \"Error\", 500",
            "",
            "",
            "@app.route(\"/Marti/vcm\", methods=[const.POST])",
            "def insert_video_link():",
            "    try:",
            "        xml_root = ET.fromstring(request.data.decode(\"utf-8\"))",
            "        for xml_feed in xml_root:",
            "            protocol = xml_feed.find(\"protocol\").text",
            "            alias = xml_feed.find(\"alias\").text",
            "            uid = xml_feed.find(\"uid\").text",
            "            address = xml_feed.find(\"address\").text",
            "            port = xml_feed.find(\"port\").text",
            "            rover_port = xml_feed.find(\"roverPort\").text",
            "            ignore_klv = xml_feed.find(\"ignoreEmbeddedKLV\").text",
            "            preferred_mac = xml_feed.find(\"preferredMacAddress\").text",
            "            path = xml_feed.find(\"path\").text",
            "            buf = xml_feed.find(\"buffer\").text",
            "            timeout = xml_feed.find(\"timeout\").text",
            "            rtsp_reliable = xml_feed.find(\"rtspReliable\").text",
            "            # Check that no other feeds with the same UID have been received",
            "            streams = dbController.query_videostream(query=f'uid = \"{uid}\"')",
            "            if len(streams) > 0:",
            "                app.logger.info(",
            "                    f\"Already received feed with UID={uid} (alias = {alias})\")  # pylint: disable=no-member; member does exist",
            "                continue  # Ignore this feed if there are duplicates",
            "            app.logger.info(",
            "                f\"Inserting video feed into database: {request.data.decode('utf-8')}\")  # pylint: disable=no-member; member does exist",
            "            dbController.create_videostream(FullXmlString=ET.tostring(xml_feed), Protocol=protocol, Alias=alias,",
            "                                            uid=uid, Address=address, Port=port, RoverPort=rover_port,",
            "                                            IgnoreEmbeddedKlv=ignore_klv, PreferredMacAddress=preferred_mac, Path=path,",
            "                                            Buffer=buf, Timeout=timeout, RtspReliable=rtsp_reliable)",
            "",
            "        return \"Okay\", 200",
            "    except:",
            "        app.logger.error(traceback.format_exc())",
            "        return \"Error\", 500",
            "",
            "",
            "@app.route('/Marti/api/version/config', methods=[const.GET])",
            "def versionConfig():",
            "    logger.info('sending client version json')",
            "    return const.VERSIONJSON",
            "",
            "",
            "@app.route('/Marti/api/clientEndPoints', methods=[const.GET])",
            "def clientEndPoint():",
            "    logger.info('sending client version info')",
            "    return const.versionInfo",
            "",
            "",
            "@app.route('/Marti/sync/missionupload', methods=[const.POST])",
            "def upload():",
            "    from FreeTAKServer.model.ServiceObjects.SSLDataPackageVariables import SSLDataPackageVariables",
            "    logger.info('dataoackage upload started')",
            "    file_hash = request.args.get('hash')",
            "    if not validate_hash(file_hash):",
            "        return \"invalid hash sent\", 500",
            "    app.logger.info(f\"Data Package hash = {str(file_hash)}\")",
            "    letters = string.ascii_letters",
            "    uid = ''.join(random.choice(letters) for i in range(4))",
            "    uid = 'uid-' + str(uid)",
            "    filename = request.args.get('filename')",
            "    creatorUid = request.args.get('creatorUid')",
            "    file = request.files.getlist('assetfile')[0]",
            "    directory = Path(dp_directory, file_hash)",
            "    if not Path.exists(directory):",
            "        os.mkdir(str(directory))",
            "    file.save(os.path.join(str(directory), filename))",
            "    fileSize = Path(str(directory), filename).stat().st_size",
            "    callsign = str(",
            "        FlaskFunctions().getSubmissionUser(creatorUid,",
            "                                           dbController))  # fetchone() gives a tuple, so only grab the first element",
            "    FlaskFunctions().create_dp(dbController, uid=uid, Name=filename, Hash=file_hash, SubmissionUser=callsign,",
            "                               CreatorUid=creatorUid, Size=fileSize)",
            "    if USINGSSL == False:",
            "        return \"http://\" + IP + ':' + str(HTTPPORT) + \"/Marti/api/sync/metadata/\" + file_hash + \"/tool\"",
            "",
            "    else:",
            "        return \"https://\" + IP + ':' + str(HTTPPORT) + \"/Marti/api/sync/metadata/\" + file_hash + \"/tool\"",
            "",
            "",
            "@app.route('/Marti/api/sync/metadata/<hash>/tool', methods=[const.PUT])",
            "def putDataPackageTool(hash):",
            "    if request.data == b'private':",
            "        dbController.update_datapackage(query=f'Hash = \"{hash}\"', column_value={\"Privacy\": 1})",
            "    return \"Okay\", 200",
            "",
            "",
            "@app.route('/Marti/api/sync/metadata/<hash>/tool', methods=[const.GET])",
            "@cross_origin(send_wildcard=True)",
            "def getDataPackageTool(hash):",
            "    from flask import make_response",
            "    file_list = os.listdir(os.path.join(Path(str(dp_directory)), Path(str(hash))))",
            "    path = PurePath(dp_directory, str(hash), file_list[0])",
            "    app.logger.info(f\"Sending data package from {str(path)}\")",
            "    resp = send_file(str(path))",
            "    return resp",
            "",
            "",
            "@app.route('/Marti/sync/search', methods=[const.GET])",
            "def retrieveData():",
            "    logger.info('sync search tirggerd')",
            "    keyword = request.args.get('keyword')",
            "    packages = FlaskFunctions().getAllPackages()",
            "    app.logger.info(f\"Data packages in the database: {packages}\")",
            "    return str(packages)",
            "",
            "",
            "@app.route('/Marti/sync/content', methods=const.HTTPMETHODS)",
            "def specificPackage():",
            "    from defusedxml import ElementTree as etree",
            "    from os import listdir",
            "    if request.method == 'GET' and request.args.get('uid') != None:",
            "        data = request.data",
            "        taskuid = request.args.get('uid')",
            "        for file in listdir(MainConfig.ExCheckChecklistFilePath):",
            "            xml = etree.parse(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(file)))).getroot()",
            "",
            "            tasks = xml.find('checklistTasks')",
            "            for task in tasks:",
            "                uid = task.find('uid')",
            "                if str(uid.text) == str(taskuid):",
            "                    return etree.tostring(task)",
            "                else:",
            "                    pass",
            "        for file in listdir(MainConfig.ExCheckFilePath):",
            "            xml = etree.parse(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(file)))).getroot()",
            "            if xml.find(\"checklistDetails\").find('uid').text == str(taskuid):",
            "                return etree.tostring(xml)",
            "",
            "    else:",
            "        hash = request.args.get('hash')",
            "        import hashlib",
            "        if os.path.exists(str(PurePath(Path(dp_directory), Path(hash)))):",
            "            logger.info('marti sync content triggerd')",
            "            app.logger.debug(str(PurePath(Path(dp_directory), Path(hash))))",
            "            file_list = os.listdir(str(PurePath(Path(dp_directory), Path(hash))))",
            "            app.logger.debug(PurePath(Path(const.DATAPACKAGEFOLDER), Path(hash), Path(file_list[0])))",
            "            path = PurePath(dp_directory, str(hash), file_list[0])",
            "            app.logger.debug(str(path))",
            "            return send_file(str(path))",
            "        else:",
            "            obj = dbController.query_ExCheck(verbose=True, query=f'hash = \"{hash}\"')",
            "            data = etree.parse(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(obj[0].data.filename))))",
            "            data.getroot().find('checklistTasks').find(\"checklistTask\").find(\"uid\").text = data.getroot().find(",
            "                'checklistTasks').find(\"checklistTask\").find(\"checklistUid\").text",
            "            output = etree.tostring(data)",
            "            return output",
            "",
            "",
            "@app.route('/Marti/api/version', methods=[const.GET])",
            "def returnVersion():",
            "    logger.info('api version triggered')",
            "    return const.versionInfo",
            "",
            "",
            "@app.route('/Marti/sync/missionquery', methods=const.HTTPMETHODS)",
            "def checkPresent():",
            "    logger.info('synce missionquery triggered')",
            "    hash = request.args.get('hash')",
            "    if FlaskFunctions().hashIsPresent(hash, dbController):",
            "        app.logger.info(f\"Data package with hash {hash} exists\")",
            "        if USINGSSL == False:",
            "            return \"http://\" + IP + ':' + str(HTTPPORT) + \"/Marti/api/sync/metadata/\" + hash + \"/tool\"",
            "        else:",
            "            return \"https://\" + IP + ':' + str(HTTPPORT) + \"/Marti/api/sync/metadata/\" + hash + \"/tool\"",
            "    else:",
            "        app.logger.info(f\"Data package with hash {hash} does not exist\")",
            "        return '404', 404",
            "",
            "",
            "@app.route('/')",
            "def home():",
            "    return 'data package service is up, good job.'",
            "",
            "",
            "# exCheckStuff",
            "from flask import Flask, request",
            "from FreeTAKServer.controllers.ExCheckControllers.templateToJsonSerializer import templateSerializer",
            "from FreeTAKServer.controllers.DatabaseControllers.DatabaseController import DatabaseController",
            "from FreeTAKServer.controllers.configuration.MainConfig import MainConfig",
            "",
            "",
            "@app.route('/Marti/api/missions/exchecktemplates/changes', methods=['GET'])",
            "def check_changes():",
            "    try:",
            "        # example return data {\"version\":\"2\",\"type\":\"MissionChange\",\"data\":[],\"nodeId\":\"TAK-Server-a6htdf93\"}",
            "        # this endpoint should return any excheck template change since specified time",
            "        # TODO: learn what squached represents",
            "        request.args.get('squached')",
            "        # the time since last connect and the length of time to check for changes",
            "        request.args.get('start')",
            "        return '{\"version\":\"2\",\"type\":\"MissionChange\",\"data\":[{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:10.346Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:10.366Z\",\"contentResource\":{\"filename\":\"d5d2bc15-f6ab-49e7-a408-5f7fe600ca3e.xml\",\"keywords\":[\"test bravo\",\"this is in db\",\"FEATHER\"],\"mimeType\":\"application/xml\",\"name\":\"d5d2bc15-f6ab-49e7-a408-5f7fe600ca3e\",\"submissionTime\":\"2020-10-20T00:18:57.157Z\",\"submitter\":\"testbravo\",\"uid\":\"d5d2bc15-f6ab-49e7-a408-5f7fe600ca3e\",\"hash\":\"d94a49a958422a451b352b6ebd8b0741780214b1c2da4b0d41e6fca8e3674082\",\"size\":2155,\"tool\":\"ExCheck\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:10.235Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:10.307Z\",\"contentResource\":{\"hash\":\"f1197a7ec99442864b26fb58b993869303cd7ad4a7d6139611c0d42cd1ff156b\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:10.186Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:10.199Z\",\"contentResource\":{\"filename\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462.xml\",\"keywords\":[\"ddd\",\"wadasdsa\",\"FEATHER\"],\"mimeType\":\"application/xml\",\"name\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462\",\"submissionTime\":\"2020-10-23T15:28:59.943Z\",\"submitter\":\"testbravo\",\"uid\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462\",\"hash\":\"19597a47b4be14f9ee527630cf0dc7fb6b6de222502eab41b6c488e4371fb40b\",\"size\":1747,\"tool\":\"ExCheck\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:10.017Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:10.127Z\",\"contentResource\":{\"hash\":\"60aac7efcdf2d7001b8ad0d812e1d1528e252e01be130a6f6285b69943f8d633\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:09.842Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:09.875Z\",\"contentResource\":{\"filename\":\"173992a0-d18d-46bb-b178-759011299d60.xml\",\"keywords\":[\"temp\",\"temp 1\",\"FEATHER\"],\"mimeType\":\"application/xml\",\"name\":\"173992a0-d18d-46bb-b178-759011299d60\",\"submissionTime\":\"2020-10-19T23:21:03.934Z\",\"submitter\":\"testbravo\",\"uid\":\"173992a0-d18d-46bb-b178-759011299d60\",\"hash\":\"41482b4776bb7735654e8ddde2ad02032909b50ab4df5d8de55f99ebe6bc805d\",\"size\":1461,\"tool\":\"ExCheck\"}},{\"type\":\"REMOVE_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T16:44:07.103Z\",\"creatorUid\":\"CN=testalpha,OU=Dev,O=FTS,L=Yarmouth,ST=NS,C=CA\",\"serverTime\":\"2020-10-23T16:44:07.138Z\",\"contentResource\":{\"hash\":\"5bc1ac8bdbc28fc13ec002b60215a9c45874384e8fc754286c5d907a80219fc5\"}},{\"type\":\"ADD_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T15:28:59.947Z\",\"creatorUid\":\"S-1-5-21-2720623347-3037847324-4167270909-1002\",\"serverTime\":\"2020-10-23T15:28:59.963Z\",\"contentResource\":{\"filename\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462.xml\",\"keywords\":[\"ddd\",\"wadasdsa\",\"FEATHER\"],\"mimeType\":\"application/xml\",\"name\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462\",\"submissionTime\":\"2020-10-23T15:28:59.943Z\",\"submitter\":\"testbravo\",\"uid\":\"4b730e6a-e2d8-48aa-9b9c-36dc09a0c462\",\"hash\":\"19597a47b4be14f9ee527630cf0dc7fb6b6de222502eab41b6c488e4371fb40b\",\"size\":1747,\"tool\":\"ExCheck\"}},{\"type\":\"ADD_CONTENT\",\"missionName\":\"exchecktemplates\",\"timestamp\":\"2020-10-23T15:26:45.110Z\",\"creatorUid\":\"S-1-5-21-2720623347-3037847324-4167270909-1002\",\"serverTime\":\"2020-10-23T15:26:45.116Z\"}],\"nodeId\":\"TAK-Server-560c34e9\"}'",
            "    except Exception as e:",
            "        print('exception in check changes' + str(e))",
            "",
            "",
            "@app.route('/Marti/api/missions/exchecktemplates/subscription', methods=['PUT'])",
            "def request_subscription():",
            "    try:",
            "        # this endpoint allows for the client to request a new subscription",
            "        # possibly the uid of the client db also contains create_time and mission_id",
            "        print(request.args.get('uid'))",
            "",
            "        return ('', 200)",
            "    except Exception as e:",
            "        print('exception in request_subscription' + str(e))",
            "",
            "",
            "@app.route('/Marti/api/missions/exchecktemplates', methods=['GET'])",
            "def exchecktemplates():",
            "    try:",
            "        # when no data available",
            "        # return b'{\"version\":\"2\",\"type\":\"Mission\",\"data\":[{\"name\":\"exchecktemplates\",\"description\":\"\",\"chatRoom\":\"\",\"tool\":\"ExCheck\",\"keywords\":[],\"creatorUid\":\"ExCheck\",\"createTime\":\"2020-10-19T22:37:39.290Z\",\"externalData\":[],\"uids\":[],\"contents\":[]}],\"nodeId\":\"TAK-Server-560c34e9\"}'",
            "        # when data available",
            "        return templateSerializer().convert_object_to_json(DatabaseController().query_ExCheck())",
            "    except Exception as e:",
            "        print(e)",
            "",
            "",
            "@app.route('/Marti/api/missions/ExCheckTemplates', methods=['GET'])",
            "def ExCheckTemplates():",
            "    try:",
            "        # when no data available",
            "        # return b'{\"version\":\"2\",\"type\":\"Mission\",\"data\":[{\"name\":\"exchecktemplates\",\"description\":\"\",\"chatRoom\":\"\",\"tool\":\"ExCheck\",\"keywords\":[],\"creatorUid\":\"ExCheck\",\"createTime\":\"2020-10-19T22:37:39.290Z\",\"externalData\":[],\"uids\":[],\"contents\":[]}],\"nodeId\":\"TAK-Server-560c34e9\"}'",
            "        # when data available",
            "        return templateSerializer().convert_object_to_json(DatabaseController().query_ExCheck())",
            "    except Exception as e:",
            "        print(e)",
            "",
            "",
            "@app.route('/Marti/api/missions/<templateuid>/subscription', methods=['DELETE', 'PUT'])",
            "def missionupdate(templateuid):",
            "    from flask import request",
            "    uid = request.args.get('uid')",
            "    return '', 200",
            "",
            "",
            "@app.route('/Marti/api/excheck/template', methods=['POST'])",
            "def template():",
            "    try:",
            "        import uuid",
            "        xmlstring = f'<?xml version=\"1.0\"?><event version=\"2.0\" uid=\"{uuid.uuid4()}\" type=\"t-x-m-c\" time=\"2020-11-28T17:45:51.000Z\" start=\"2020-11-28T17:45:51.000Z\" stale=\"2020-11-28T17:46:11.000Z\" how=\"h-g-i-g-o\"><point lat=\"0.00000000\" lon=\"0.00000000\" hae=\"0.00000000\" ce=\"9999999\" le=\"9999999\" /><detail><mission type=\"CHANGE\" tool=\"ExCheck\" name=\"exchecktemplates\" authorUid=\"S-1-5-21-2720623347-3037847324-4167270909-1002\"><MissionChanges><MissionChange><contentResource><filename>61b01475-ad44-4300-addc-a9474ebf67b0.xml</filename><hash>018cd5786bd6c2e603beef30d6a59987b72944a60de9e11562297c35ebdb7fd6</hash><keywords>test init</keywords><keywords>dessc init</keywords><keywords>FEATHER</keywords><mimeType>application/xml</mimeType><name>61b01475-ad44-4300-addc-a9474ebf67b0</name><size>1522</size><submissionTime>2020-11-28T17:45:47.980Z</submissionTime><submitter>wintak</submitter><tool>ExCheck</tool><uid>61b01475-ad44-4300-addc-a9474ebf67b0</uid></contentResource><creatorUid>S-1-5-21-2720623347-3037847324-4167270909-1002</creatorUid><missionName>exchecktemplates</missionName><timestamp>2020-11-28T17:45:47.983Z</timestamp><type>ADD_CONTENT</type></MissionChange></MissionChanges></mission></detail></event>'",
            "        # this is where the client will post the xmi of a template",
            "        from flask import request",
            "        from datetime import datetime",
            "        from defusedxml import ElementTree as etree",
            "        import hashlib",
            "        # possibly the uid of the client submitting the template",
            "        Y = request",
            "        uid = request.args.get('clientUid')",
            "        XMI = request.data.decode()",
            "        serializer = templateSerializer(XMI)",
            "        object = serializer.convert_template_to_object()",
            "        object.timestamp = datetime.strptime(object.timestamp, \"%Y-%m-%dT%H:%M:%S.%fZ\")",
            "        serializer.create_DB_object(object)",
            "        xml = etree.fromstring(XMI)",
            "        tasks = xml.find('checklistTasks')",
            "        path = str(PurePath(Path(MainConfig.ExCheckFilePath), Path(f'{object.data.uid}.xml')))",
            "        with open(path, 'w+') as file:",
            "            file.write(XMI)",
            "            file.close()",
            "",
            "        uid = object.data.uid",
            "        temp = etree.fromstring(XMI)",
            "        cot = etree.fromstring(xmlstring)",
            "        resources = cot.find('detail').find('mission').find('MissionChanges').find('MissionChange').find(",
            "            'contentResource')",
            "        resources.find('filename').text = temp.find('checklistDetails').find('uid').text + '.xml'",
            "        resources.findall('keywords')[0].text = temp.find('checklistDetails').find('name').text",
            "        resources.findall('keywords')[1].text = temp.find('checklistDetails').find('description').text",
            "        resources.findall('keywords')[2].text = temp.find('checklistDetails').find('creatorCallsign').text",
            "        resources.find('uid').text = temp.find('checklistDetails').find('uid').text",
            "        resources.find('name').text = temp.find('checklistDetails').find('uid').text",
            "        resources.find('size').text = str(len(XMI))",
            "        resources.find('hash').text = str(hashlib.sha256(str(XMI).encode()).hexdigest())",
            "        z = etree.tostring(cot)",
            "        from FreeTAKServer.model.testobj import testobj",
            "        object = testobj()",
            "        object.xmlString = z",
            "        PIPE.put(object)",
            "        return str(uid), 200",
            "    except Exception as e:",
            "        print(str(e))",
            "",
            "",
            "@app.route('/Marti/api/excheck/<subscription>/start', methods=['POST'])",
            "def startList(subscription):",
            "    import uuid",
            "    from defusedxml import ElementTree as etree",
            "    from xml.etree.ElementTree import Element",
            "    import datetime",
            "    uid = str(uuid.uuid4())",
            "    r = request",
            "    # client uid",
            "    request.args.get('clientUid')",
            "    # name of template",
            "    request.args.get('name')",
            "    # description of template",
            "    request.args.get('description')",
            "    # startTime of template",
            "    startTime = request.args.get('startTime')",
            "    # callsign of submission user",
            "    request.args.get('callsign')",
            "",
            "    with open(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(f'{uid}.xml'))), 'w+') as file:",
            "        file.write(str(open(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(f'{subscription}.xml'))), 'r').read()))",
            "        file.close()",
            "",
            "    xml = etree.parse(",
            "        MainConfig.ExCheckChecklistFilePath + '/' + uid + '.xml').getroot()",
            "",
            "    starttime = Element('startTime')",
            "    starttime.text = startTime",
            "    details = xml.find('checklistDetails')",
            "    if details.find('startTime') == None:",
            "",
            "        details.append(starttime)",
            "    else:",
            "        details.find('startTime').text = startTime",
            "    uids = details.find('uid')",
            "    uids.text = uid",
            "    details.find('description').text = request.args.get('description')",
            "    details.find('name').text = request.args.get('name')",
            "",
            "    tasks = xml.find('checklistTasks')",
            "    for task in tasks:",
            "        taskuid = task.find('uid')",
            "        taskuid.text = str(uuid.uuid4())",
            "",
            "    with open(",
            "            str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(uid + '.xml'))),",
            "            'w+') as file:",
            "        y = etree.tostring(xml)",
            "        file.write(etree.tostring(xml).decode())",
            "        file.close()",
            "",
            "    excheckobj = dbController.query_ExCheck(f'ExCheckData.uid = \"{subscription}\"', verbose=True, )[0]",
            "    dbController.create_Excheckchecklist(startTime=datetime.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S.%fZ'),",
            "                                         creatorUid=request.args.get('clientUid'),",
            "                                         description=request.args.get('description'),",
            "                                         callsign=request.args.get('callsign'), name=request.args.get('name'), uid=uid,",
            "                                         filename=f'{uid}.xml', template=excheckobj)",
            "",
            "    return str(open(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(uid + '.xml'))), 'r').read()), 200",
            "",
            "",
            "@app.route('/Marti/api/excheck/checklist/<checklistid>')",
            "def accesschecklist(checklistid):",
            "    return str(open(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistid + '.xml'))),",
            "                    'r').read())",
            "",
            "",
            "@app.route('/Marti/api/excheck/checklist/<checklistid>/task/<taskid>', methods=['PUT'])",
            "def updatetemplate(checklistid, taskid):",
            "    from flask import request",
            "    from defusedxml import ElementTree as etree",
            "    from FreeTAKServer.controllers.SpecificCoTControllers.SendExcheckUpdateController import SendExcheckUpdateController",
            "    from FreeTAKServer.controllers.XMLCoTController import XMLCoTController",
            "    from FreeTAKServer.model.FTSModel.Event import Event",
            "    from FreeTAKServer.model.RawCoT import RawCoT",
            "    import uuid",
            "    import hashlib",
            "",
            "    data = request.data",
            "",
            "    xml = etree.parse(",
            "        str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistid + '.xml')))).getroot()",
            "    updatedTask = etree.fromstring(data)",
            "    tasks = xml.find('checklistTasks')",
            "    index = 0",
            "    for task in tasks:",
            "        index += 1",
            "        uid = task.find('uid')",
            "        if uid.text == taskid:",
            "            tasks.remove(task)",
            "            tasks.insert(index, updatedTask)",
            "        else:",
            "            pass",
            "    with open(",
            "            str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistid + '.xml'))), 'w+') as file:",
            "        file.write(etree.tostring(xml).decode())",
            "        file.close()",
            "",
            "    # Create Object to send to client",
            "    object = Event.ExcheckUpdate()",
            "    object.setuid(str(uuid.uuid4()))",
            "    object.setversion('2.0')",
            "    object.detail.mission.settype(\"CHANGE\")",
            "    object.detail.mission.settool(\"ExCheck\")",
            "    object.detail.mission.setname(checklistid)",
            "    object.detail.mission.setauthorUid(request.args.get(\"clientUid\"))",
            "    object.detail.mission.MissionChanges.MissionChange.creatorUid.setINTAG(request.args.get(\"clientUid\"))",
            "    object.detail.mission.MissionChanges.MissionChange.missionName.setINTAG(checklistid)",
            "    object.detail.mission.MissionChanges.MissionChange.type.setINTAG(\"ADD_CONTENT\")",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.filename.setINTAG(taskid + '.xml')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.hash.setINTAG(str(hashlib.sha256(",
            "        str(open(MainConfig.ExCheckChecklistFilePath + '/' + checklistid + '.xml', 'r')).encode()).hexdigest()))",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.keywords.setINTAG('Task')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.name.setINTAG(taskid)",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.size.setINTAG(str(len(data)))",
            "    # TODO: change this value",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.submitter.setINTAG('atak')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.uid.setINTAG(taskid)",
            "",
            "    '''object = etree.fromstring(templateex)",
            "    object.uid = uuid.uuid4()",
            "    object.find('detail').find('mission').type= \"CHANGE\"",
            "    object.find('detail').find('mission').name = taskid",
            "    object.find('detail').find('mission').Uid = request.args.get(\"clientUid\")",
            "    object.find('detail').find('mission').find('MissionChanges').find('MissionChange').find('creatorUid').text = request.args.get(\"clientUid\")",
            "    object.find('detail').find('mission').find('MissionChanges').find('MissionChange').find('missionName').text = taskid",
            "    object.find('detail').find('mission').find('MissionChanges').find('MissionChange').find('filename').text = checklistid+'.xml'",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.hash.setINTAG(str(hashlib.sha256(str(data).encode()).hexdigest()))",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.keywords.setINTAG('Task')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.name.setINTAG(checklistid)",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.size.setINTAG(str(len(data)))",
            "    #TODO: change this value",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.submitter.setINTAG('test')",
            "    object.detail.mission.MissionChanges.MissionChange.contentResource.uid.setINTAG(checklistid)'''",
            "    rawcot = RawCoT()",
            "    xml = XMLCoTController().serialize_model_to_CoT(object)",
            "    rawcot.xmlString = xml",
            "",
            "    PIPE.put(rawcot)",
            "    # PIPE.send()",
            "",
            "    return '', 200",
            "",
            "",
            "@app.route('/Marti/sync/content')",
            "def sync():",
            "    # this endpoint was triggered on attempting to create new template from existing template",
            "    # likely the hash of the excheck",
            "    y = request",
            "    request.args.get('hash')",
            "    uid = request.args.get('uid')",
            "    return '', 200",
            "",
            "",
            "@app.route('/Marti/api/excheck/checklist/active', methods=[\"GET\"])",
            "def activechecklists():",
            "    from os import listdir",
            "    from FreeTAKServer.model.FTSModel.Checklists import Checklists",
            "    from FreeTAKServer.model.FTSModel.Checklist import Checklist",
            "    from xml.etree.ElementTree import Element",
            "    from defusedxml import ElementTree as etree",
            "    checklists = Checklists.Checklist()",
            "    rootxml = Element('checklists')",
            "",
            "    for file in listdir(MainConfig.ExCheckChecklistFilePath):",
            "        checklist = Element('checklist')",
            "        xmldetails = etree.parse(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(file)))).getroot().find(",
            "            'checklistDetails')",
            "        checklist.append(xmldetails)",
            "        checklist.append(Element('checklistColumns'))",
            "        checklist.append(Element('checklistTasks'))",
            "        rootxml.append(checklist)",
            "",
            "    xml = etree.tostring(rootxml)",
            "    return xml",
            "",
            "",
            "def validate_hash(file_hash: str) -> bool:",
            "    \"\"\" this function takes a file hash and validates it's",
            "    content to avoid RCE and XSS attacks",
            "",
            "    Args:",
            "        file_hash:",
            "    \"\"\"",
            "    if re.match(\"^[A-Za-z0-9_-]*$\", file_hash):",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "class FlaskFunctions:",
            "",
            "    def __init__(self):",
            "        self.callsigns = []",
            "",
            "    def create_dp(self, dbController, **args):",
            "        return dbController.create_datapackage(**args)",
            "",
            "    def hashIsPresent(self, hash, dbControl):",
            "        data = dbControl.query_datapackage(query=f'Hash = \"{hash}\"')",
            "        return len(data) > 0",
            "",
            "    def getSubmissionUser(self, UID, dbControl):",
            "        callsign = dbControl.query_user(query=f'uid = \"{UID}\"', column=['callsign'])",
            "        return callsign",
            "",
            "    def getAllPackages(self):",
            "        data = DatabaseController().query_datapackage(\"Privacy = 0\")",
            "        package_dict = {",
            "            \"resultCount\": len(data),",
            "            \"results\": []",
            "        }",
            "        for i in data:",
            "            package_dict[\"results\"].append({",
            "                \"UID\": i.uid,",
            "                \"Name\": i.Name,",
            "                \"Hash\": i.Hash,",
            "                \"PrimaryKey\": i.PrimaryKey,",
            "                \"SubmissionDateTime\": str(i.SubmissionDateTime.strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\")),",
            "                \"SubmissionUser\": i.SubmissionUser,",
            "                \"CreatorUid\": i.CreatorUid,",
            "                \"Keywords\": i.Keywords,",
            "                \"MIMEType\": i.MIMEType,",
            "                \"Size\": i.Size",
            "            })",
            "        return package_dict",
            "",
            "    def startup(self, ip, port, pipe):",
            "        try:",
            "            from eventlet import wsgi",
            "",
            "            global IP, HTTPPORT",
            "            IP = ip",
            "            HTTPPORT = port",
            "            # Make sure the data package directory exists",
            "            if not Path(dp_directory).exists():",
            "                app.logger.info(f\"Creating directory at {str(dp_directory)}\")",
            "                os.makedirs(str(dp_directory))",
            "            # Create the relevant database tables",
            "            print(const.IP)",
            "            print(HTTPPORT)",
            "            # app.run(host='0.0.0.0', port=8080)",
            "            wsgi.server(eventlet.listen((DataPackageServerConstants().IP, int(HTTPPORT))), app)",
            "",
            "        except Exception as e:",
            "            logger.error('there has been an exception in Data Package service startup ' + str(e))",
            "            return -1",
            "",
            "    def stop(self):",
            "        func = request.environ.get('werkzeug.server.shutdown')",
            "        if func is None:",
            "            raise RuntimeError('Not running with the Werkzeug Server')",
            "        func()",
            "",
            "    def setIP(self, IP_to_be_set):",
            "        global IP",
            "        IP = IP_to_be_set",
            "",
            "    def getIP(self):",
            "        global IP",
            "        return IP",
            "",
            "    def setHTTPPORT(self, HTTPPORTToBeSet):",
            "        global HTTPPORT",
            "        HTTPPORT = HTTPPORTToBeSet",
            "",
            "    def getHTTPPort(self):",
            "        global HTTPPORT",
            "        return HTTPPORT",
            "",
            "    def setPIPE(self, PIPEtoBeSet):",
            "        global PIPE",
            "        PIPE = PIPEtoBeSet",
            "",
            "    def getPIPE(self):",
            "        global PIPE",
            "        return PIPE",
            "",
            "    def setSSL(self, SSL: bool):",
            "        global USINGSSL",
            "        USINGSSL = SSL",
            "",
            "    def getSSL(self):",
            "        global USINGSSL",
            "        return USINGSSL",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "44": [],
            "100": [
                "get_all_video_links"
            ],
            "133": [
                "insert_video_link"
            ],
            "135": [
                "insert_video_link"
            ],
            "196": [],
            "250": [
                "specificPackage"
            ],
            "281": [],
            "282": [],
            "365": [
                "template"
            ],
            "427": [
                "startList"
            ],
            "435": [
                "startList"
            ],
            "436": [
                "startList"
            ],
            "443": [
                "accesschecklist"
            ],
            "456": [
                "updatetemplate"
            ],
            "488": [
                "updatetemplate"
            ],
            "489": [
                "updatetemplate"
            ],
            "493": [
                "updatetemplate"
            ],
            "497": [
                "updatetemplate"
            ],
            "498": [
                "updatetemplate"
            ],
            "519": [
                "updatetemplate"
            ],
            "544": [
                "activechecklists"
            ]
        },
        "addLocation": []
    },
    "FreeTAKServer/controllers/services/RestAPI.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " socketio.init_app(app, cors_allowed_origins=\"*\")"
            },
            "1": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " APIPipe = None"
            },
            "2": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " CommandPipe = None"
            },
            "3": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-app.config[\"SECRET_KEY\"] = 'vnkdjnfjknfl1232#'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+app.config[\"SECRET_KEY\"] = MainConfig.SecretKey"
            },
            "5": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " eventDict = {}"
            },
            "6": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from flask import Flask, request, jsonify, session",
            "from flask_sqlalchemy import SQLAlchemy",
            "from flask_socketio import SocketIO, emit",
            "from flask_httpauth import HTTPTokenAuth",
            "from flask_login import current_user, LoginManager",
            "import threading",
            "from functools import wraps",
            "import uuid",
            "import datetime as dt",
            "from FreeTAKServer.controllers.configuration.LoggingConstants import LoggingConstants",
            "import datetime",
            "from defusedxml import ElementTree as etree",
            "from FreeTAKServer.model.FTSModel.Event import Event",
            "from FreeTAKServer.model.RawCoT import RawCoT",
            "from FreeTAKServer.controllers.ApplyFullJsonController import ApplyFullJsonController",
            "from FreeTAKServer.controllers.XMLCoTController import XMLCoTController",
            "from FreeTAKServer.model.ServiceObjects.FTS import FTS",
            "from FreeTAKServer.controllers.configuration.RestAPIVariables import RestAPIVariables as vars",
            "from FreeTAKServer.model.SimpleClient import SimpleClient",
            "from FreeTAKServer.controllers.DatabaseControllers.DatabaseController import DatabaseController",
            "from FreeTAKServer.controllers.configuration.DatabaseConfiguration import DatabaseConfiguration",
            "from FreeTAKServer.controllers.RestMessageControllers.SendChatController import SendChatController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendDeleteVideoStreamController import \\",
            "    SendDeleteVideoStreamController",
            "from FreeTAKServer.controllers.serializers.xml_serializer import XmlSerializer",
            "import os",
            "import shutil",
            "import json",
            "from flask_cors import CORS",
            "from FreeTAKServer.controllers.RestMessageControllers.SendSimpleCoTController import SendSimpleCoTController, \\",
            "    UpdateSimpleCoTController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendPresenceController import SendPresenceController, \\",
            "    UpdatePresenceController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendEmergencyController import SendEmergencyController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendSensorDroneController import SendSensorDroneController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendSPISensorController import SendSPISensorController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendImageryVideoController import SendImageryVideoController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendRouteController import SendRouteController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendVideoStreamController import SendVideoStreamController",
            "from FreeTAKServer.controllers.configuration.MainConfig import MainConfig",
            "from FreeTAKServer.controllers.JsonController import JsonController",
            "from FreeTAKServer.controllers.serializers.SqlAlchemyObjectController import SqlAlchemyObjectController",
            "",
            "dbController = DatabaseController()",
            "",
            "UpdateArray = []",
            "StartTime = None",
            "",
            "functionNames = vars()",
            "functionNames.function_names()",
            "",
            "jsonVars = vars()",
            "jsonVars.json_vars()",
            "",
            "restMethods = vars()",
            "restMethods.rest_methods()",
            "",
            "defaultValues = vars()",
            "defaultValues.default_values()",
            "",
            "app = Flask(__name__)",
            "login_manager = LoginManager()",
            "login_manager.init_app(app)",
            "auth = HTTPTokenAuth(scheme='Bearer')",
            "app.config['SQLALCHEMY_DATABASE_URI'] = DatabaseConfiguration().DataBaseConnectionString",
            "app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False",
            "db = SQLAlchemy(app)",
            "dbController.session = db.session",
            "CORS(app)",
            "socketio = SocketIO(app, async_handlers=True, async_mode=\"eventlet\")",
            "socketio.init_app(app, cors_allowed_origins=\"*\")",
            "APIPipe = None",
            "CommandPipe = None",
            "app.config[\"SECRET_KEY\"] = 'vnkdjnfjknfl1232#'",
            "eventDict = {}",
            "",
            "",
            "@app.errorhandler(404)",
            "def page_not_found(e):",
            "    return 'this endpoint does not exist'",
            "",
            "",
            "@auth.verify_token",
            "def verify_token(token):",
            "    if token:",
            "        output = dbController.query_APIUser(query=f'token = \"{token}\"')",
            "        if output:",
            "            return output[0].Username",
            "        else:",
            "            output = dbController.query_systemUser(query=f'token = \"{token}\"')",
            "            if output:",
            "                output = output[0]",
            "                r = request",
            "                dbController.create_APICall(user_id=output.uid, timestamp=dt.datetime.now(), content=request.data,",
            "                                            endpoint=request.base_url)",
            "                return output.name",
            "",
            "",
            "@login_manager.user_loader",
            "def load_user(user_id):",
            "    return User.get(user_id)",
            "",
            "",
            "def socket_auth(session=None):",
            "    def innerfunc(x):",
            "        def wrapper(*args, **kwargs):",
            "            if hasattr(session, 'authenticated') and session.authenticated:",
            "                x(*args, **kwargs)",
            "            else:",
            "                pass",
            "",
            "        return wrapper",
            "",
            "    return innerfunc",
            "",
            "",
            "@app.route('/Alive')",
            "def sessions():",
            "    return b'API is running', 200",
            "",
            "",
            "@socketio.on('connect')",
            "def connection():",
            "    emit('connectUpdate', json.dumps({\"starttime\": str(StartTime), \"version\": str(MainConfig.version)}))",
            "",
            "",
            "@socketio.on('authenticate')",
            "def authenticate(token):",
            "    if json.loads(token)[\"Authenticate\"] == MainConfig.websocketkey:",
            "        emit('authentication', json.dumps({'successful': 'True'}))",
            "        session.authenticated = True  # pylint: disable=assigning-non-slot; this is necessary to save a client's state",
            "    else:",
            "        emit('authentication', json.dumps({'successful': 'False'}))",
            "",
            "",
            "@socketio.on('users')",
            "@socket_auth(session=session)",
            "def show_users(empty=None):",
            "    output = dbController.query_user()",
            "    for i in range(0, len(output)):",
            "        try:",
            "            original = output[i]",
            "            output[i] = output[i].__dict__",
            "            print(output[i])",
            "            try:",
            "                output[i]['callsign'] = original.CoT.detail.contact.callsign",
            "                output[i]['team'] = original.CoT.detail._group.name",
            "            except:",
            "                output[i]['callsign'] = \"undefined\"",
            "                output[i]['team'] = \"undefined\"",
            "            del (output[i]['_sa_instance_state'])",
            "            del (output[i]['CoT_id'])",
            "            del (output[i]['CoT'])",
            "        except Exception as e:",
            "            print(e)",
            "    socketio.emit('userUpdate', json.dumps({\"Users\": output}))",
            "",
            "",
            "@socketio.on('logs')",
            "@socket_auth(session=session)",
            "def return_logs(time):",
            "    log_data = {'log_data': []}",
            "    for line in reversed(open(LoggingConstants().ERRORLOG, \"r\").readlines()):",
            "        try:",
            "            timeoflog = line.split(\" : \")[1]",
            "            if datetime.datetime.strptime(timeoflog, '%Y-%m-%d %H:%M:%S,%f') > datetime.datetime.strptime(",
            "                    json.loads(time)[\"time\"], '%Y-%m-%d %H:%M:%S,%f'):",
            "                outline = {\"time\": '', \"type\": '', 'file': '', 'message': ''}",
            "                line_segments = line.split(\" : \")",
            "                outline[\"type\"] = line_segments[0]",
            "                outline[\"time\"] = line_segments[1]",
            "                outline[\"file\"] = line_segments[2]",
            "                outline[\"message\"] = \" : \".join(line_segments[3:-1])",
            "                log_data['log_data'].append(outline)",
            "            else:",
            "                break",
            "        except:",
            "            pass",
            "    for num in range(1, 6):",
            "        try:",
            "            for line in reversed(open(LoggingConstants().ERRORLOG + '.' + str(num), \"r\").readlines()):",
            "                try:",
            "                    timeoflog = line.split(\" : \")[1]",
            "                    if datetime.datetime.strptime(timeoflog, '%Y-%m-%d %H:%M:%S,%f') > datetime.datetime.strptime(",
            "                            json.loads(time)[\"time\"], '%Y-%m-%d %H:%M:%S,%f'):",
            "                        outline = {\"time\": '', \"type\": '', 'file': '', 'message': ''}",
            "                        line_segments = line.split(\" : \")",
            "                        outline[\"type\"] = line_segments[0]",
            "                        outline[\"time\"] = line_segments[1]",
            "                        outline[\"file\"] = line_segments[2]",
            "                        outline[\"message\"] = line_segments[3]",
            "                        log_data['log_data'].append(outline)",
            "                    else:",
            "                        break",
            "                except:",
            "                    pass",
            "        except:",
            "            pass",
            "    emit(\"logUpdate\", json.dumps(log_data))",
            "",
            "",
            "@socketio.on('serviceInfo')",
            "@socket_auth(session=session)",
            "def show_service_info(empty=None):",
            "    mapping = {\"start\": \"on\", \"stop\": \"off\", \"\": \"\"}",
            "    FTSServerStatusObject = getStatus()",
            "    tcpcot = FTSServerStatusObject.CoTService",
            "    sslcot = FTSServerStatusObject.SSLCoTService",
            "    restapi = FTSServerStatusObject.RestAPIService",
            "    tcpdp = FTSServerStatusObject.TCPDataPackageService",
            "    ssldp = FTSServerStatusObject.SSLDataPackageService",
            "    fedserver = FTSServerStatusObject.FederationServerService",
            "    jsonObject = {\"services\":",
            "                      {\"TCP_CoT_service\": {\"status\": mapping[tcpcot.CoTServiceStatus], \"port\": tcpcot.CoTServicePort},",
            "                       \"SSL_CoT_service\": {\"status\": mapping[sslcot.SSLCoTServiceStatus],",
            "                                           \"port\": sslcot.SSLCoTServicePort},",
            "                       \"TCP_DataPackage_service\": {\"status\": mapping[tcpdp.TCPDataPackageServiceStatus],",
            "                                                   \"port\": tcpdp.TCPDataPackageServicePort},",
            "                       \"SSL_DataPackage_service\": {\"status\": mapping[ssldp.SSLDataPackageServiceStatus],",
            "                                                   \"port\": ssldp.SSLDataPackageServicePort},",
            "                       \"Federation_server_service\": {\"status\": mapping[fedserver.FederationServerServiceStatus],",
            "                                                     \"port\": fedserver.FederationServerServicePort},",
            "                       \"Rest_API_service\": {\"status\": mapping[restapi.RestAPIServiceStatus],",
            "                                            \"port\": restapi.RestAPIServicePort}},",
            "                  \"ip\": tcpdp.TCPDataPackageServiceIP",
            "                  }",
            "    emit('serviceInfoUpdate', json.dumps(jsonObject))",
            "",
            "",
            "def getStatus():",
            "    CommandPipe.put([functionNames.checkStatus])",
            "    out = CommandPipe.get()",
            "    while hasattr(out, \"CoTService\") == False:",
            "        out = CommandPipe.get()",
            "    return out",
            "",
            "",
            "@socketio.on(\"serverHealth\")",
            "@socket_auth(session=session)",
            "def serverHealth(empty=None):",
            "    import psutil",
            "    import pathlib",
            "    import os",
            "    disk_usage = int(psutil.disk_usage(str(pathlib.Path(os.getcwd()).anchor)).percent)",
            "    memory_usage = int(psutil.virtual_memory().percent)",
            "    cpu_usage = int(psutil.cpu_percent(interval=0.1))",
            "    jsondata = {",
            "        \"CPU\": cpu_usage,",
            "        \"memory\": memory_usage,",
            "        \"disk\": disk_usage",
            "    }",
            "    emit('serverHealthUpdate', json.dumps(jsondata))",
            "",
            "",
            "@socketio.on('systemStatus')",
            "@socket_auth(session=session)",
            "def systemStatus(update=None):",
            "    print('system status running')",
            "    from FreeTAKServer.controllers.ServerStatusController import ServerStatusController",
            "    currentStatus = getStatus()",
            "    statusObject = ServerStatusController(currentStatus)",
            "    jsondata = ApplyFullJsonController().serialize_model_to_json(statusObject)",
            "    emit('systemStatusUpdate', json.dumps(jsondata))",
            "",
            "",
            "@socketio.on('changeServiceInfo')",
            "@socket_auth(session=session)",
            "def updateSystemStatus(update):",
            "    # TODO: add documentation",
            "    changeStatus(json.loads(update))",
            "    show_service_info()",
            "",
            "",
            "@socketio.on('systemUsers')",
            "@socket_auth(session=session)",
            "def systemUsers(empty=None):",
            "    systemUserArray = DatabaseController().query_systemUser()",
            "    jsondata = {\"SystemUsers\": []}",
            "    for user in systemUserArray:",
            "        userjson = {}",
            "        userjson['Name'] = user.name",
            "        userjson[\"Group\"] = user.group",
            "        userjson[\"Token\"] = user.token",
            "        userjson[\"Password\"] = user.password",
            "        userjson[\"Certs\"] = user.certificate_package_name",
            "        userjson[\"Uid\"] = user.uid",
            "        jsondata[\"SystemUsers\"].append(userjson)",
            "",
            "    emit('systemUsersUpdate', json.dumps(jsondata))",
            "",
            "",
            "@socketio.on('updateSystemUser')",
            "@socket_auth(session=session)",
            "def updateSystemUser(jsondata):",
            "    \"\"\" this socket event updates an existing system user entry in the database. User id must be provided if user with specified id doesnt",
            "    exist operation will return an error",
            "",
            "    example request:",
            "    {\"systemUsers\": [",
            "            {\"uid\": \"existing user id\", \"password\": \"new user password\", \"token\": \"new user token\", \"group\": \"new user group\"}",
            "        ]",
            "    }",
            "",
            "    Args:",
            "        jsondata: dict",
            "",
            "    Returns:",
            "",
            "    \"\"\"",
            "    for systemuser in json.loads(jsondata)['systemUsers']:",
            "        update_column = {}",
            "",
            "        if \"token\" in systemuser:",
            "            update_column[\"token\"] = str(systemuser[\"token\"])",
            "        if \"password\" in systemuser:",
            "            update_column[\"password\"] = str(systemuser[\"password\"])",
            "        if \"group\" in systemuser:",
            "            update_column[\"group\"] = str(systemuser[\"group\"])",
            "        dbController.update_systemUser(query=f'uid = \"{systemuser[\"uid\"]}\"', column_value=update_column)",
            "        return 200",
            "",
            "",
            "@socketio.on('addSystemUser')",
            "@socket_auth(session=session)",
            "def addSystemUser(jsondata):",
            "    from FreeTAKServer.controllers import certificate_generation",
            "    import uuid",
            "    try:",
            "        for systemuser in json.loads(jsondata)['systemUsers']:",
            "            if systemuser[\"Certs\"] == \"true\":",
            "                # create certs",
            "                certificate_generation.AtakOfTheCerts().bake(common_name=systemuser[\"Name\"])",
            "                certificate_generation.generate_zip(user_filename=systemuser[\"Name\"] + '.p12')",
            "                # add DP",
            "                import string",
            "                import random",
            "                from pathlib import PurePath, Path",
            "                import hashlib",
            "                from defusedxml import ElementTree as etree",
            "                import shutil",
            "                import os",
            "                dp_directory = str(PurePath(Path(MainConfig.DataPackageFilePath)))",
            "                openfile = open(str(PurePath(Path(str(MainConfig.clientPackages), systemuser[\"Name\"] + '.zip'))),",
            "                                mode='rb')",
            "                file_hash = str(hashlib.sha256(openfile.read()).hexdigest())",
            "                openfile.close()",
            "                newDirectory = str(PurePath(Path(dp_directory), Path(file_hash)))",
            "                os.mkdir(newDirectory)",
            "                shutil.copy(str(PurePath(Path(str(MainConfig.clientPackages), systemuser[\"Name\"] + '.zip'))),",
            "                            str(PurePath(Path(newDirectory), Path(systemuser[\"Name\"] + '.zip'))))",
            "                fileSize = Path(str(newDirectory), systemuser[\"Name\"] + '.zip').stat().st_size",
            "                dbController.create_datapackage(uid=str(uuid.uuid4()), Name=systemuser[\"Name\"] + '.zip', Hash=file_hash,",
            "                                                SubmissionUser='server',",
            "                                                CreatorUid='server-uid', Size=fileSize, Privacy=1)",
            "                dbController.create_systemUser(name=systemuser[\"Name\"], group=systemuser[\"Group\"],",
            "                                               token=systemuser[\"Token\"], password=systemuser[\"Password\"],",
            "                                               uid=str(uuid.uuid4()),",
            "                                               certificate_package_name=systemuser[\"Name\"] + '.zip')",
            "                import datetime as dt",
            "                DATETIME_FMT = \"%Y-%m-%dT%H:%M:%S.%fZ\"",
            "                timer = dt.datetime",
            "                now = timer.utcnow()",
            "                zulu = now.strftime(DATETIME_FMT)",
            "                add = dt.timedelta(seconds=600)",
            "                stale_part = dt.datetime.strptime(zulu, DATETIME_FMT) + add",
            "                stale = stale_part.strftime(DATETIME_FMT)",
            "                timer = dt.datetime",
            "                now = timer.utcnow()",
            "                zulu = now.strftime(DATETIME_FMT)",
            "                time = zulu",
            "                from FreeTAKServer.controllers.SpecificCoTControllers.SendOtherController import SendOtherController",
            "                from FreeTAKServer.model.RawCoT import RawCoT",
            "                cot = RawCoT()",
            "                DPIP = getStatus().TCPDataPackageService.TCPDataPackageServiceIP",
            "                clientXML = f'<?xml version=\"1.0\"?><event version=\"2.0\" uid=\"{str(uuid.uuid4())}\" type=\"b-f-t-r\" time=\"{time}\" start=\"{time}\" stale=\"{stale}\" how=\"h-e\"><point lat=\"43.85570300\" lon=\"-66.10801200\" hae=\"19.55866360\" ce=\"3.21600008\" le=\"nan\" /><detail><fileshare filename=\"{systemuser[\"Name\"]}\" senderUrl=\"{DPIP}:8080/Marti/api/sync/metadata/{str(file_hash)}/tool\" sizeInBytes=\"{fileSize}\" sha256=\"{str(file_hash)}\" senderUid=\"{\"server-uid\"}\" senderCallsign=\"{\"server\"}\" name=\"{systemuser[\"Name\"] + \".zip\"}\" /><ackrequest uid=\"{uuid.uuid4()}\" ackrequested=\"true\" tag=\"{systemuser[\"Name\"] + \".zip\"}\" /><marti><dest callsign=\"{systemuser[\"Name\"]}\" /></marti></detail></event>'",
            "                cot.xmlString = clientXML.encode()",
            "                newCoT = SendOtherController(cot, addToDB=False)",
            "                APIPipe.put(newCoT.getObject())",
            "",
            "            else:",
            "                dbController.create_systemUser(name=systemuser[\"Name\"], group=systemuser[\"Group\"],",
            "                                               token=systemuser[\"Token\"], password=systemuser[\"Password\"],",
            "                                               uid=str(uuid.uuid4()))",
            "    except Exception as e:",
            "        print(e)",
            "        return str(e), 500",
            "",
            "",
            "@socketio.on(\"removeSystemUser\")",
            "@socket_auth(session=session)",
            "def removeSystemUser(jsondata):",
            "    from FreeTAKServer.controllers.certificate_generation import revoke_certificate",
            "    jsondata = json.loads(jsondata)",
            "    for systemUser in jsondata[\"systemUsers\"]:",
            "        uid = systemUser[\"uid\"]",
            "        systemUser = dbController.query_systemUser(query=f'uid = \"{uid}\"')[0]",
            "        na = systemUser.name",
            "        revoke_certificate(username=na)",
            "        certificate_package_name = systemUser.certificate_package_name",
            "        dbController.remove_systemUser(f'uid = \"{uid}\"')",
            "        obj = dbController.query_datapackage(f'Name = \"{certificate_package_name}\"')",
            "        # TODO: make this coherent with constants",
            "        currentPath = MainConfig.DataPackageFilePath",
            "        shutil.rmtree(f'{str(currentPath)}/{obj[0].Hash}')",
            "        dbController.remove_datapackage(f'Hash = \"{obj[0].Hash}\"')",
            "        os.remove(MainConfig.certsPath + f\"/{na}.pem\")",
            "        os.remove(MainConfig.certsPath + f\"/{na}.key\")",
            "        os.remove(MainConfig.certsPath + f\"/{na}.p12\")",
            "",
            "",
            "@socketio.on(\"events\")",
            "@socket_auth(session=session)",
            "def events(empty=None):",
            "    current_notifications = Notification()",
            "    # socketio.emit(json.dumps([current_notifications.logErrors, current_notifications.emergencys]))",
            "    emit(\"eventsUpdate\", {\"events\": current_notifications.logErrors + current_notifications.emergencys})",
            "",
            "",
            "@app.route('/ManageNotification/getNotification', methods=[\"GET\"])",
            "def notification():",
            "    current_notifications = Notification()",
            "    return json.dumps({\"logErrors\": current_notifications.logErrors, \"emergencys\": current_notifications.emergencys})",
            "",
            "",
            "def getlogErrors():",
            "    output = []",
            "    for line in reversed(open(LoggingConstants().ERRORLOG, \"r\").readlines()):",
            "        try:",
            "            outline = {\"time\": '', \"type\": '', 'file': '', 'message': ''}",
            "            line_segments = line.split(\" : \")",
            "            if line_segments[0] != \"CRITICAL\":",
            "                continue",
            "            outline[\"type\"] = line_segments[0]",
            "            outline[\"time\"] = line_segments[1]",
            "            outline[\"file\"] = line_segments[2]",
            "            if len(line_segments) > 4:",
            "                outline[\"message\"] = \" : \".join(line_segments[3:-1])",
            "            else:",
            "                outline[\"message\"] = line_segments[3]",
            "            output.append(outline)",
            "        except:",
            "            pass",
            "    for num in range(1, 6):",
            "        try:",
            "            for line in reversed(open(LoggingConstants().ERRORLOG + '.' + str(num), \"r\").readlines()):",
            "                try:",
            "                    timeoflog = line.split(\" : \")[1]",
            "                    outline = {\"time\": '', \"type\": '', 'file': '', 'message': ''}",
            "                    line_segments = line.split(\" : \")",
            "                    if line_segments[0] != \"CRITICAL\":",
            "                        continue",
            "                    outline[\"type\"] = line_segments[0]",
            "                    outline[\"time\"] = line_segments[1]",
            "                    outline[\"file\"] = line_segments[2]",
            "                    outline[\"message\"] = line_segments[3]",
            "                    output.append(outline)",
            "                except:",
            "                    pass",
            "        except:",
            "            pass",
            "    return output",
            "",
            "",
            "def getemergencys():",
            "    output = dbController.query_ActiveEmergency()",
            "    for i in range(0, len(output)):",
            "        try:",
            "            original = output[i]",
            "            output[i] = output[i].__dict__",
            "            output[i][\"lat\"] = original.event.point.lat",
            "            output[i][\"lon\"] = original.event.point.lon",
            "            output[i][\"type\"] = original.event.detail.emergency.type",
            "            output[i][\"name\"] = original.event.detail.contact.callsign",
            "            del (output[i]['_sa_instance_state'])",
            "            del (output[i]['event'])",
            "        except:",
            "            pass",
            "    return output",
            "",
            "",
            "class Notification:",
            "    def __init__(self):",
            "        try:",
            "            self.emergencys = [i[\"name\"] + \" \" + i[\"type\"] for i in getemergencys()]",
            "        except:",
            "            self.emergencys = []",
            "        try:",
            "            self.logErrors = [i[\"message\"] for i in getlogErrors()]",
            "        except:",
            "            self.logErrors = []",
            "",
            "",
            "@app.route(\"/SendGeoChat\", methods=[restMethods.POST])",
            "@auth.login_required()",
            "def SendGeoChat():",
            "    try:",
            "        json = request.json",
            "        modelObject = Event.GeoChat()",
            "        out = ApplyFullJsonController().serializeJsonToModel(modelObject, json)",
            "        xml = XMLCoTController().serialize_model_to_CoT(out, 'event')",
            "        from FreeTAKServer.controllers.SpecificCoTControllers.SendGeoChatController import SendGeoChatController",
            "        rawcot = RawCoT()",
            "        rawcot.xmlString = xml",
            "        rawcot.clientInformation = None",
            "        object = SendGeoChatController(rawcot)",
            "        APIPipe.put(object.getObject())",
            "        return '200', 200",
            "    except Exception as e:",
            "        print(e)",
            "",
            "",
            "@app.route(\"/ManagePresence\")",
            "@auth.login_required()",
            "def ManagePresence():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManagePresence/postPresence\", methods=[restMethods.POST])",
            "@auth.login_required",
            "def postPresence():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_presence_post(jsondata)",
            "        Presence = SendPresenceController(jsonobj).getCoTObject()",
            "        APIPipe.put(Presence)",
            "        return Presence.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManagePresence/putPresence\", methods=[\"PUT\"])",
            "@auth.login_required",
            "def putPresence():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_presence_post(jsondata)",
            "        Presence = UpdatePresenceController(jsonobj).getCoTObject()",
            "        APIPipe.put(Presence)",
            "        return Presence.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageRoute\")",
            "@auth.login_required()",
            "def ManageRoute():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManageRoute/postRoute\", methods=[\"POST\"])",
            "@auth.login_required()",
            "def postRoute():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_route_post(jsondata)",
            "        Route = SendRouteController(jsonobj).getCoTObject()",
            "        APIPipe.put(Route)",
            "        return Route.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageCoT/getZoneCoT\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getZoneCoT():",
            "    try:",
            "        from math import sqrt, degrees, cos, sin, radians, atan2",
            "        from sqlalchemy import or_, and_",
            "        jsondata = request.get_json(force=True)",
            "        radius = int(jsondata[\"radius\"])",
            "        lat = (int(jsondata[\"latitude\"]))",
            "        lon = int(jsondata[\"longitude\"])",
            "        lat_abs = abs(lat)",
            "        lon_abs = abs(lon)",
            "        import geopy",
            "        from geopy.distance import distance",
            "        from FreeTAKServer.model.SQLAlchemy.CoTTables.Point import Point",
            "        from FreeTAKServer.model.SQLAlchemy.Event import Event",
            "        from FreeTAKServer.model.RestMessages.RestEnumerations import RestEnumerations",
            "        import re",
            "        radius_in_deg = (geopy.units.degrees(arcseconds=geopy.units.nautical(meters=radius))) / 2",
            "",
            "        results = dbController.query_CoT(query=[Event.point.has(or_(and_(Point.lon < 0, Point.lat < 0, (",
            "                    (((Point.lon * -1) - lon_abs) * 111302.62) + (",
            "                        ((Point.lat * -1) - lat_abs) * 110574.61)) <= radius + 10), and_(Point.lon < 0, Point.lat >= 0,",
            "                                                                                         ((((",
            "                                                                                                        Point.lon * -1) - lon_abs) * 111302.62) + (",
            "                                                                                                      (",
            "                                                                                                                  Point.lat - lat_abs) * 110574.61)) <= radius + 10),",
            "                                                                    and_(Point.lon >= 0, Point.lat < 0, (",
            "                                                                                ((Point.lon - lon_abs) * 111302.62) + ((",
            "                                                                                                                                   (",
            "                                                                                                                                               Point.lat * -1) - lat_abs) * 110574.61)) <= radius + 10),",
            "                                                                    and_(Point.lon >= 0, Point.lat >= 0, (",
            "                                                                                ((Point.lon - lon_abs) * 111302.62) + ((",
            "                                                                                                                                   Point.lat - lat_abs) * 110574.61)) <= radius + 10)))])",
            "        print(results)",
            "        output = []",
            "        for result in results:",
            "            try:",
            "                dLon = (result.point.lon - lon)",
            "                x = cos(radians(result.point.lat)) * sin(radians(dLon))",
            "                y = cos(radians(lat)) * sin(radians(result.point.lat)) - sin(radians(lat)) * cos(",
            "                    radians(result.point.lat)) * cos(radians(dLon))",
            "                brng = atan2(x, y)",
            "                brng = degrees(brng)",
            "                type_pattern = [type for type in list(RestEnumerations.supportedTypeEnumerations.values()) if",
            "                                re.fullmatch(type, result.type)][0]",
            "                index_number = list(RestEnumerations.supportedTypeEnumerations.values()).index(type_pattern)",
            "                type = list(RestEnumerations.supportedTypeEnumerations.keys())[index_number]",
            "                print(type)",
            "                part1 = result.type.split(type_pattern.split('.')[0])",
            "                part2 = '-' + part1[1].split(type_pattern.split('.')[1])[0] + '-'",
            "                attitude = list(RestEnumerations.attitude.keys())[list(RestEnumerations.attitude.values()).index(part2)]",
            "                print(attitude)",
            "                # attitude = RestEnumerations.attitude['-'+type.split(type_pattern.split('.')[0])[1].split(type_pattern.split('.')[1])+'-']",
            "",
            "                output.append({\"latitude\": result.point.lat,",
            "                               \"longitude\": result.point.lon,",
            "                               \"distance\": distance((result.point.lon, result.point.lat), (lon, lat)).m,",
            "                               \"direction\": brng,",
            "                               \"type\": type,",
            "                               \"attitude\": attitude",
            "                               })",
            "            except Exception as e:",
            "                pass",
            "        return json.dumps(output)",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageGeoObject\")",
            "@auth.login_required()",
            "def ManageGeoObject():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManageGeoObject/getGeoObject\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getGeoObject():",
            "    try:",
            "        from math import sqrt, degrees, cos, sin, radians, atan2",
            "        from sqlalchemy import or_, and_",
            "        # jsondata = request.get_json(force=True)",
            "        radius = request.args.get(\"radius\", default=100, type=int)",
            "        lat = request.args.get(\"latitude\", default=0, type=float)",
            "        lon = request.args.get(\"longitude\", default=0, type=float)",
            "        expectedAttitude = request.args.get(\"attitude\", default=\"*\", type=str)",
            "        lat_abs = lat",
            "        lon_abs = lon",
            "        import geopy",
            "        from geopy.distance import distance",
            "        from FreeTAKServer.model.SQLAlchemy.CoTTables.Point import Point",
            "        from FreeTAKServer.model.SQLAlchemy.Event import Event",
            "        from FreeTAKServer.model.RestMessages.RestEnumerations import RestEnumerations",
            "        import re",
            "        radius_in_deg = (geopy.units.degrees(arcseconds=geopy.units.nautical(meters=radius))) / 2",
            "        if lat_abs >= 0 and lon_abs >= 0:",
            "            results = dbController.query_CoT(query=[Event.point.has(and_(",
            "                Point.lon >= 0,",
            "                Point.lat >= 0,",
            "                or_(",
            "                    and_(",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10,",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) > 0),",
            "                    and_((",
            "                                 ((lon_abs - Point.lon) * 111302.62) + (",
            "                                     (lon_abs - Point.lat) * 110574.61)) <= radius + 10,",
            "                         (((lon_abs - Point.lon) * 111302.62) + ((lon_abs - Point.lat) * 110574.61)) > 0))))])",
            "        elif lon_abs < 0 and lat_abs < 0:",
            "            results = dbController.query_CoT(query=[Event.point.has(and_(",
            "                Point.lon < 0,",
            "                Point.lat < 0,",
            "                or_(",
            "                    and_(",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) > 0,",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10),",
            "                    and_(",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) > 0,",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) <= radius + 10)",
            "                )",
            "            ))])",
            "",
            "        elif lon_abs < 0 and lat_abs > 0:",
            "            results = dbController.query_CoT(query=[Event.point.has(and_(",
            "                Point.lon < 0,",
            "                Point.lat >= 0,",
            "                or_(",
            "                    and_(",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10,",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) > 0),",
            "                    and_(",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) <= radius + 10,",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) > 0)",
            "                )))])",
            "",
            "        elif lon_abs > 0 and lat_abs < 0:",
            "            results = dbController.query_CoT(query=[Event.point.has(and_(",
            "                Point.lon >= 0,",
            "                Point.lat < 0,",
            "                or_(",
            "",
            "                    and_(",
            "",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) <= radius + 10,",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) > 0),",
            "                    and_(",
            "",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10,",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) > 0))",
            "",
            "            ))])",
            "",
            "        else:",
            "            return \"unsupported coordinates\"",
            "",
            "        \"\"\"                 and_(",
            "                            Point.lon < 0,",
            "                            Point.lat < 0,",
            "                            ((((Point.lon * -1) - lon_abs) * 111302.62) + (((Point.lat * -1) - lat_abs) * 110574.61)) > 0,",
            "                            ((((Point.lon * -1) - lon_abs) * 111302.62) + (((Point.lat * -1) - lat_abs) * 110574.61)) <= radius + 10),",
            "            ",
            "                        and_(",
            "                            Point.lon < 0,",
            "                            Point.lat >= 0,",
            "                            or_(",
            "                                and_(",
            "                                    ((((Point.lon * -1) - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10,",
            "                                    ((((Point.lon * -1) - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61))> 0),",
            "                                and_(",
            "                                    ((((lon_abs * -1) - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) <= radius + 10,",
            "                                    ((((lon_abs * -1) - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) > 0)",
            "                            ),",
            "            ",
            "                        ),",
            "                        and_(",
            "                            Point.lon >= 0,",
            "                            Point.lat < 0,",
            "                            (((Point.lon - lon_abs) * 111302.62) + (((Point.lat * -1) - lat_abs) * 110574.61)) <= radius + 10,",
            "                            (((Point.lon - lon_abs) * 111302.62) + (((Point.lat * -1) - lat_abs) * 110574.61))>0),\"\"\"",
            "",
            "        print(results)",
            "        output = []",
            "        for result in results:",
            "            try:",
            "                print(result.uid)",
            "                dLon = (result.point.lon - lon)",
            "                x = cos(radians(result.point.lat)) * sin(radians(dLon))",
            "                y = cos(radians(lat)) * sin(radians(result.point.lat)) - sin(radians(lat)) * cos(",
            "                    radians(result.point.lat)) * cos(radians(dLon))",
            "                brng = atan2(x, y)",
            "                brng = degrees(brng)",
            "                type_pattern = [type for type in list(RestEnumerations.supportedTypeEnumerations.values()) if",
            "                                re.fullmatch(type, result.type)]",
            "                print(type_pattern)",
            "                type_pattern = type_pattern[0]",
            "                index_number = list(RestEnumerations.supportedTypeEnumerations.values()).index(type_pattern)",
            "                print(index_number)",
            "                type = list(RestEnumerations.supportedTypeEnumerations.keys())[index_number]",
            "                print(type)",
            "                part1 = result.type.split(type_pattern.split('.')[0])",
            "                part2 = '-' + part1[1].split(type_pattern.split('.')[1])[0] + '-'",
            "                attitude = list(RestEnumerations.attitude.keys())[list(RestEnumerations.attitude.values()).index(part2)]",
            "                if attitude == expectedAttitude or expectedAttitude == \"*\":",
            "                    pass",
            "                else:",
            "                    continue",
            "                print(attitude)",
            "                # attitude = RestEnumerations.attitude['-'+type.split(type_pattern.split('.')[0])[1].split(type_pattern.split('.')[1])+'-']",
            "",
            "                output.append({\"latitude\": result.point.lat,",
            "                               \"longitude\": result.point.lon,",
            "                               \"distance\": distance((result.point.lon, result.point.lat), (lon, lat)).m,",
            "                               \"direction\": brng,",
            "                               \"type\": type,",
            "                               \"attitude\": attitude",
            "                               })",
            "            except Exception as e:",
            "                print(e)",
            "        return json.dumps(output)",
            "",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageGeoObject/postGeoObject\", methods=[restMethods.POST])",
            "@auth.login_required",
            "def postGeoObject():",
            "    try:",
            "        from geopy import Point, distance",
            "        from json import dumps",
            "        print(\"posting geo object\")",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'attitude': 'friend', 'geoObject': 'Ground', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_geoobject_post(jsondata)",
            "        if \"distance\" in jsondata:",
            "            start_point = Point(jsonobj.getlatitude(), jsonobj.getlongitude())",
            "            d = distance.distance(meters=jsondata[\"distance\"])",
            "            if \"bearing\" in jsondata:",
            "                end_point = d.destination(point=start_point, bearing=jsondata[\"bearing\"])",
            "            else:",
            "                end_point = d.destination(point=start_point, bearing=360)",
            "            jsonobj.setlatitude(end_point.latitude)",
            "            jsonobj.setlongitude(end_point.longitude)",
            "",
            "        simpleCoTObject = SendSimpleCoTController(jsonobj).getCoTObject()",
            "        print(\"putting in queue\")",
            "        APIPipe.put(simpleCoTObject)",
            "        print(simpleCoTObject.xmlString)",
            "        print('put in queue')",
            "        return simpleCoTObject.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageGeoObject/putGeoObject\", methods=[\"PUT\"])",
            "@auth.login_required",
            "def putGeoObject():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'attitude': 'friend', 'geoObject': 'Ground', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        if \"uid\" in jsondata:",
            "            jsonobj = JsonController().serialize_geoobject_post(jsondata)",
            "            simpleCoTObject = UpdateSimpleCoTController(jsonobj).getCoTObject()",
            "            simpleCoTObject.modelObject.setuid(jsondata[\"uid\"])",
            "            simpleCoTObject.setXmlString(XMLCoTController().serialize_model_to_CoT(simpleCoTObject.modelObject))",
            "            APIPipe.put(simpleCoTObject)",
            "            return simpleCoTObject.modelObject.getuid(), 200",
            "        else:",
            "            raise Exception(\"uid is a required parameter\")",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageVideoStream\")",
            "@auth.login_required()",
            "def ManageVideoStream():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManageVideoStream/getVideoStream\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getVideoStream():",
            "    try:",
            "",
            "        # changed below line to access _Video table directly instead of using full stack call",
            "        # to make this endpoint more robust as well as prevent issues where post does not create",
            "        # full stack entries",
            "",
            "        # changed the main return from a list to an object to facilitate further development",
            "        from json import dumps",
            "        from urllib import parse",
            "        from FreeTAKServer.model.SQLAlchemy.CoTTables.Sensor import Sensor",
            "",
            "        output = dbController.query_video()",
            "        return_value = {\"video_stream\": {}}",
            "        for value in output:",
            "            value_obj = return_value[\"video_stream\"][str(value.PrimaryKey)] = {}",
            "            if value.url:",
            "                value_obj[\"url\"] = parse.urlparse(value.url).path",
            "            if value.ConnectionEntry:",
            "                if value.ConnectionEntry.path:",
            "                    value_obj[\"path\"] = value.ConnectionEntry.path",
            "                if value.ConnectionEntry.port:",
            "                    value_obj[\"port\"] = value.ConnectionEntry.port",
            "                if value.ConnectionEntry.address:",
            "                    value_obj[\"address\"] = value.ConnectionEntry.address",
            "        return dumps(return_value), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageVideoStream/deleteVideoStream\", methods=[restMethods.DELETE])",
            "@auth.login_required",
            "def deleteVideoStream():",
            "    try:",
            "        from json import dumps",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_video_stream_delete(jsondata)",
            "        EmergencyObject = SendDeleteVideoStreamController(jsonobj).getCoTObject()",
            "        APIPipe.put(EmergencyObject)",
            "        return 'success', 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageVideoStream/postVideoStream\", methods=[\"POST\"])",
            "@auth.login_required()",
            "def postVideoStream():",
            "    \"\"\"this method contains the logic for the endpoints which saves the contents of a new videostream to",
            "    the db and sends a CoT to all connected clients containing stream information.\"\"\"",
            "    from FreeTAKServer.model.FTSModel.Event import Event",
            "    from lxml.etree import tostring  # pylint: disable=no-name-in-module; name is in module",
            "    try:",
            "        jsondata = request.get_json(force=True)",
            "",
            "        # the following prevents duplicate entries being added to the db",
            "        url = jsondata[\"streamAddress\"] + \":\" + jsondata[\"streamPort\"] + jsondata[\"streamPath\"]",
            "        video_streams = dbController.query_videostream()",
            "",
            "        for video in video_streams:",
            "            if video.url == url:",
            "                sqlalchemy_obj = dbController.query_CoT(f'uid=\"{video.PrimaryKey}\"')[0]",
            "                modelObject = SqlAlchemyObjectController().convert_sqlalchemy_to_modelobject(sqlalchemy_obj,",
            "                                                                                             Event.VideoStream())",
            "                xmlString = tostring(XmlSerializer().from_fts_object_to_format(modelObject))",
            "                modelObject.xmlString = xmlString",
            "                APIPipe.put(modelObject)",
            "                return \"entry already exists in db \" + str(video.PrimaryKey) + \" resending existing entry\", 201",
            "",
            "        simpleCoTObject = SendVideoStreamController(jsondata).getCoTObject()",
            "        print(\"putting in queue\")",
            "        APIPipe.put(simpleCoTObject)",
            "        print(simpleCoTObject.xmlString)",
            "        print('put in queue')",
            "        return simpleCoTObject.modelObject.getuid(), 200",
            "",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "\"\"\"@app.route(\"/ManageGeoObject/getGeoObject\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getGeoObject():",
            "    try:",
            "        from FreeTAKServer.model.RestMessages.RestEnumerations import RestEnumerations",
            "        return jsonify(list(RestEnumerations().supportedTypeEnumerations.keys()))",
            "    except Exception as e:",
            "        return e, 500\"\"\"",
            "",
            "",
            "@app.route(\"/ManageChat\")",
            "@auth.login_required()",
            "def ManageChat():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManageChat/postChatToAll\", methods=[restMethods.POST])",
            "@auth.login_required",
            "def postChatToAll():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'message': 'test abc', 'sender': 'natha'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_chat_post(jsondata)",
            "        ChatObject = SendChatController(jsonobj).getCoTObject()",
            "        APIPipe.put(ChatObject)",
            "        return 'success', 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageEmergency/getEmergency\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getEmergency():",
            "    try:",
            "        output = getemergencys()",
            "        return jsonify(json_list=output), 200",
            "    except Exception as e:",
            "        return str(e), 200",
            "",
            "",
            "@app.route(\"/ManageEmergency/postEmergency\", methods=[restMethods.POST])",
            "@auth.login_required",
            "def postEmergency():",
            "    try:",
            "        from json import dumps",
            "",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_emergency_post(jsondata)",
            "        EmergencyObject = SendEmergencyController(jsonobj).getCoTObject()",
            "        APIPipe.put(EmergencyObject)",
            "        return EmergencyObject.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 200",
            "",
            "",
            "@app.route(\"/ManageEmergency/deleteEmergency\", methods=[restMethods.DELETE])",
            "@auth.login_required",
            "def deleteEmergency():",
            "    try:",
            "        from json import dumps",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_emergency_delete(jsondata)",
            "        EmergencyObject = SendEmergencyController(jsonobj).getCoTObject()",
            "        APIPipe.put(EmergencyObject)",
            "        return 'success', 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/Sensor\")",
            "@auth.login_required",
            "def sensor():",
            "    pass",
            "",
            "",
            "@app.route(\"/Sensor/postDrone\", methods=[\"POST\"])",
            "@auth.login_required",
            "def postDroneSensor():",
            "    try:",
            "        from json import dumps",
            "",
            "        jsondata = request.get_json(force=True)",
            "        print(jsondata)",
            "        jsonobj = JsonController().serialize_drone_sensor_post(jsondata)",
            "        DroneObject = SendSensorDroneController(jsonobj).getCoTObject()",
            "",
            "        print(DroneObject.xmlString)",
            "        APIPipe.put(DroneObject)",
            "        if jsonobj.getSPILongitude() or jsonobj.getSPILatitude() or jsonobj.getSPIName():",
            "            jsonobjSPI = JsonController().serialize_spi_post(jsondata)",
            "            jsonobjSPI.setlatitude(jsonobj.getSPILatitude())",
            "            jsonobjSPI.setlongitude(jsonobj.getSPILongitude())",
            "            jsonobjSPI.setname(jsonobj.getSPIName())",
            "            jsonobjSPI.setdroneUid(DroneObject.modelObject.getuid())",
            "            SPISensor = SendSPISensorController(jsonobjSPI).getCoTObject()",
            "            APIPipe.put(SPISensor)",
            "            return json.dumps({\"uid\": DroneObject.modelObject.getuid(), \"SPI_uid\": SPISensor.modelObject.getuid()}), 200",
            "        return DroneObject.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 200",
            "",
            "",
            "@app.route(\"/Sensor/postSPI\", methods=[\"POST\"])",
            "@auth.login_required",
            "def postSPI():",
            "    try:",
            "        from json import dumps",
            "",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_spi_post(jsondata)",
            "        SPIObject = SendSPISensorController(jsonobj).getCoTObject()",
            "        APIPipe.put(SPIObject)",
            "        return SPIObject.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 200",
            "",
            "",
            "@app.route(\"/MapVid\", methods=[\"POST\"])",
            "@auth.login_required",
            "def mapvid():",
            "    from json import dumps",
            "    jsondata = request.get_json(force=True)",
            "    jsonobj = JsonController().serialize_imagery_video(jsondata)",
            "    ImagerVideoObject = SendImageryVideoController(jsonobj).getCoTObject()",
            "    APIPipe.put(ImagerVideoObject)",
            "    return 200",
            "",
            "",
            "@app.route(\"/AuthenticateUser\", methods=[\"GET\"])",
            "@auth.login_required",
            "def authenticate_user():",
            "    try:",
            "        print('request made')",
            "        username = request.args.get(\"username\")",
            "        password = request.args.get(\"password\")",
            "        try:",
            "            user = dbController.query_systemUser(query=(f'name = \"{username}\"'))[0]",
            "        except Exception as e:",
            "            print(e)",
            "            return None",
            "        if user.password == password:",
            "            print(\"query made\")",
            "            user.metadata = None",
            "            user.query = None",
            "            user.query_class = None",
            "            user._decl_class_registry = None",
            "            user._sa_class_manager = None",
            "            user._sa_instance_state = None",
            "            user._modified_event = None",
            "            print(\"done setting to none\")",
            "            json_user = user.__dict__",
            "            print(json_user)",
            "            del (json_user[\"_sa_class_manager\"])",
            "            del (json_user[\"_sa_instance_state\"])",
            "            del (json_user[\"_modified_event\"])",
            "            del (json_user[\"_decl_class_registry\"])",
            "            print('done defining dict')",
            "            return_data = json.dumps({\"uid\": json_user[\"uid\"]})",
            "            print('returning data ' + str(return_data))",
            "            return return_data",
            "        else:",
            "            return None",
            "    except Exception as e:",
            "        print(e)",
            "        return e, 500",
            "",
            "",
            "@app.route(\"/ManageEmergency\")",
            "@auth.login_required",
            "def Emergency():",
            "    pass",
            "",
            "",
            "# @app.route(\"/ConnectionMessage\", methods=[restMethods.POST])",
            "def ConnectionMessage():",
            "    \"\"\"this endpoint is responsible for generating the CoT equivalen to the content of the JSON sent",
            "    and then forwarding this CoT to all connected clients\"\"\"",
            "    try:",
            "        json = request.json",
            "        modelObject = Event.GeoChat()",
            "        out = ApplyFullJsonController().serializeJsonToModel(modelObject, json)",
            "        xml = XMLCoTController().serialize_model_to_CoT(out, 'event')",
            "        from FreeTAKServer.controllers.RestMessageControllers.SendChatController import SendChatController",
            "        rawcot = RawCoT()",
            "        rawcot.xmlString = xml",
            "        rawcot.clientInformation = None",
            "        object = SendChatController(rawcot).getCoTObject()",
            "        object.type = \"connmessage\"",
            "        APIPipe.put(object.SendGeoChat)",
            "        return '200', 200",
            "    except Exception as e:",
            "        print(e)",
            "",
            "",
            "@app.route(\"/APIUser\", methods=[restMethods.GET, restMethods.POST, restMethods.DELETE])",
            "def APIUser():",
            "    if request.remote_addr in MainConfig.AllowedCLIIPs:",
            "        try:",
            "            if request.method == restMethods.POST:",
            "                json = request.get_json()",
            "                dbController.create_APIUser(Username=json['username'], Token=json['token'])",
            "                return 'success', 200",
            "",
            "            elif request.method == restMethods.DELETE:",
            "                json = request.get_json()",
            "                username = json['username']",
            "                dbController.remove_APIUser(query=f'Username = \"{username}\"')",
            "                return 'success', 200",
            "",
            "            elif request.method == restMethods.GET:",
            "                output = dbController.query_APIUser()",
            "                for i in range(0, len(output)):",
            "                    output[i] = output[i].__dict__",
            "                    del (output[i]['_sa_instance_state'])",
            "                    del (output[i]['PrimaryKey'])",
            "                    del (output[i]['uid'])",
            "                return jsonify(json_list=output), 200",
            "",
            "        except Exception as e:",
            "            return str(e), 500",
            "    else:",
            "        return 'endpoint can only be accessed by approved IPs', 401",
            "",
            "",
            "@app.route(\"/RecentCoT\", methods=[restMethods.GET])",
            "def RecentCoT():",
            "    import time",
            "    time.sleep(10)",
            "    return b'1234'",
            "",
            "",
            "@app.route(\"/URL\", methods=[restMethods.GET])",
            "def URLGET():",
            "    data = request.args",
            "    print(data)",
            "    return 'completed', 200",
            "",
            "",
            "@app.route(\"/Clients\", methods=[restMethods.GET])",
            "def Clients():",
            "    try:",
            "        if request.remote_addr in MainConfig.AllowedCLIIPs:",
            "            CommandPipe.put([functionNames.Clients])",
            "            out = CommandPipe.get()",
            "            returnValue = []",
            "            for client in out:",
            "                returnValue.append(ApplyFullJsonController().serialize_model_to_json(client))",
            "            dumps = json.dumps(returnValue)",
            "            return dumps",
            "        else:",
            "            return 'endpoint can only be accessed by approved IPs', 401",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route('/FederationTable', methods=[restMethods.GET, restMethods.POST, \"PUT\", restMethods.DELETE])",
            "@auth.login_required()",
            "def FederationTable():",
            "    try:",
            "        import random",
            "        if request.method == restMethods.GET:",
            "            output = dbController.query_ActiveFederation()",
            "            for i in range(0, len(output)):",
            "                output[i] = output[i].__dict__",
            "                del (output[i]['_sa_instance_state'])",
            "            output2 = dbController.query_Federation()",
            "            for i in range(0, len(output2)):",
            "                output2[i] = output2[i].__dict__",
            "                del (output2[i]['_sa_instance_state'])",
            "",
            "            return jsonify(activeFederations=output, federations=output2), 200",
            "",
            "        elif request.method == restMethods.POST:",
            "            import uuid",
            "            jsondata = json.loads(request.data)",
            "            new_outgoing_federations = jsondata[\"outgoingFederations\"]",
            "            for new_fed in new_outgoing_federations:",
            "                id = str(uuid.uuid4())",
            "                dbController.create_Federation(**new_fed, id=id)",
            "                if new_fed[\"status\"] == \"Enabled\":",
            "                    CommandPipe.put((id, \"CREATE\"))",
            "                else:",
            "                    pass",
            "            return '', 200",
            "",
            "        elif request.method == \"PUT\":",
            "            jsondata = json.loads(request.data)",
            "            federations = jsondata[\"federations\"]",
            "            for fed in federations:",
            "                old_fed = dbController.query_Federation(f'id = \"{fed[\"id\"]}\"')[0]",
            "                old_status = old_fed.status",
            "                old_id = old_fed.id",
            "                dbController.update_Federation(column_value=fed, query=f'id = \"{fed[\"id\"]}\"')",
            "                if \"status\" in fed:",
            "                    if fed[\"status\"] == \"Enabled\":",
            "",
            "                        if old_status != \"Enabled\":",
            "                            CommandPipe.put((old_id, \"CREATE\"))",
            "                        else:",
            "                            pass",
            "                    elif fed[\"status\"] == \"Disabled\":",
            "                        if old_status != \"Disabled\":",
            "                            CommandPipe.put((old_id, \"DELETE\"))",
            "                        else:",
            "                            pass",
            "                    else:",
            "                        pass",
            "            return '', 200",
            "",
            "        elif request.method == \"DELETE\":",
            "            jsondata = json.loads(request.data)",
            "            federations = jsondata[\"federations\"]",
            "            for fed in federations:",
            "                fedInstance = dbController.query_Federation(f'id = \"{fed[\"id\"]}\"')[0]",
            "                if fedInstance.status == \"Enabled\":",
            "                    CommandPipe.put((fedInstance.id, \"DELETE\"))",
            "                else:",
            "                    pass",
            "                dbController.remove_Federation(f'id = \"{fed[\"id\"]}\"')",
            "            return '', 200",
            "",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route('/ManageKML/postKML', methods=[restMethods.POST])",
            "@auth.login_required()",
            "def create_kml():",
            "    try:",
            "        from pykml.factory import KML_ElementMaker as KML",
            "        from pykml import parser",
            "        from pathlib import Path, PurePath",
            "        from lxml import etree",
            "        import hashlib",
            "        from zipfile import ZipFile",
            "        from lxml.etree import SubElement, Element  # pylint: disable=no-name-in-module",
            "        from geopy import Nominatim",
            "        dp_directory = str(PurePath(Path(MainConfig.DataPackageFilePath)))",
            "        jsondata = request.get_json(force=True)",
            "        name = jsondata[\"name\"]",
            "        main = parser.fromstring('<kml xmlns=\"http://www.opengis.net/kml/2.2\"/>')",
            "        root = KML.Document()",
            "        main[0].append(root)",
            "        root[0].append(KML.description(name))",
            "        root[0].append(KML.Folder())",
            "        root.Folder[0].append(KML.Placemark())",
            "        root.Folder.Placemark[0].append(KML.name(name))",
            "        root.Folder.Placemark[0].append(KML.ExtendedData())",
            "        if jsondata.get(\"longitude\") and jsondata.get(\"latitude\"):",
            "            root.Folder.Placemark[0].append(",
            "                KML.Point(KML.coordinates(str(jsondata[\"longitude\"]) + \",\" + str(jsondata[\"latitude\"]))))",
            "        elif jsondata.get(\"address\"):",
            "            locator = Nominatim(user_agent=str(uuid.uuid4()))",
            "            location = locator.geocode(jsondata.get(\"address\"))",
            "            root.Folder.Placemark[0].append(",
            "                KML.Point(KML.coordinates(str(location.longitude) + \",\" + str(location.latitude))))",
            "        else:",
            "            root.Folder.Placemark[0].append(",
            "                KML.Point(KML.coordinates(str(0) + \",\" + str(0))))",
            "        attribs = root.Folder.Placemark.ExtendedData[0]",
            "        for key, value in jsondata[\"body\"].items():",
            "            attribs.append(KML.Data(KML.value(value), name=key))",
            "",
            "        # create DP",
            "        tempuid = str(uuid.uuid4())",
            "        app.logger.info(f\"Data Package hash = {str(tempuid)}\")",
            "        directory = Path(dp_directory, tempuid)",
            "        if not Path.exists(directory):",
            "            os.mkdir(str(directory))",
            "        filepath = str(PurePath(Path(directory), Path(name)))",
            "        data_stringified = etree.tostring(main)",
            "        with open(filepath, mode=\"wb+\") as file:",
            "",
            "            with ZipFile(file, mode='a') as zip:",
            "                print(zip.infolist())",
            "                uidtemp = uuid.uuid4()",
            "                if \"MANIFEST/manifest.xml\" not in [member.filename for member in zip.infolist()]:",
            "                    manifestXML = Element(\"MissionPackageManifest\", version=\"2\")",
            "                    config = SubElement(manifestXML, \"Configuration\")",
            "                    SubElement(config, \"Parameter\", name=\"name\", value=name)",
            "                    SubElement(config, \"Parameter\", name=\"uid\", value=str(uidtemp))",
            "                    zip.writestr(str(uidtemp.hex) + \"/\" + name + \".kml\", data_stringified)",
            "                    contents = SubElement(manifestXML, \"Contents\")",
            "                    for fileName in zip.namelist():",
            "                        SubElement(contents, \"Content\", ignore=\"false\", zipEntry=str(fileName))",
            "                    # manifest = zip.open('MANIFEST\\\\manifest.xml', mode=\"w\")",
            "                    zip.writestr('MANIFEST\\\\manifest.xml', etree.tostring(manifestXML))",
            "",
            "                    print(zip.namelist())",
            "                    file.seek(0)",
            "                else:",
            "                    pass",
            "",
            "        openfile = open(str(PurePath(Path(str(directory), name))), mode='rb')",
            "        file_hash = str(hashlib.sha256(openfile.read()).hexdigest())",
            "        openfile.close()",
            "        newDirectory = str(PurePath(Path(dp_directory), Path(file_hash)))",
            "        os.rename(str(PurePath(Path(directory))), newDirectory)",
            "        fileSize = Path(str(newDirectory), name).stat().st_size",
            "        uid = str(uuid.uuid4())",
            "        dbController.create_datapackage(uid=uid, Name=name, Hash=file_hash, SubmissionUser='server',",
            "                                        CreatorUid='server-uid', Size=fileSize)",
            "",
            "        # broacast DP",
            "        broadcast_datapackage(uid)",
            "",
            "        return \"successful\", 200",
            "    except Exception as e:",
            "        print(\"exception is \" + str(e))",
            "",
            "",
            "@app.route('/BroadcastDataPackage', methods=[restMethods.POST])",
            "@auth.login_required()",
            "def broadcast_datapackage(uid):",
            "    import datetime as dt",
            "    DATETIME_FMT = \"%Y-%m-%dT%H:%M:%S.%fZ\"",
            "    timer = dt.datetime",
            "    now = timer.utcnow()",
            "    zulu = now.strftime(DATETIME_FMT)",
            "    add = dt.timedelta(seconds=600)",
            "    stale_part = dt.datetime.strptime(zulu, DATETIME_FMT) + add",
            "    stale = stale_part.strftime(DATETIME_FMT)",
            "    timer = dt.datetime",
            "    now = timer.utcnow()",
            "    zulu = now.strftime(DATETIME_FMT)",
            "    time = zulu",
            "    from FreeTAKServer.controllers.SpecificCoTControllers.SendOtherController import SendOtherController",
            "    from FreeTAKServer.model.RawCoT import RawCoT",
            "    cot = RawCoT()",
            "    DPIP = getStatus().TCPDataPackageService.TCPDataPackageServiceIP",
            "    DPObj = dbController.query_datapackage(f'uid = \"{uid}\"')[0]",
            "    clientXML = f'<?xml version=\"1.0\"?><event version=\"2.0\" uid=\"{str(uuid.uuid4())}\" type=\"b-f-t-r\" time=\"{time}\" start=\"{time}\" stale=\"{stale}\" how=\"h-e\"><point lat=\"43.85570300\" lon=\"-66.10801200\" hae=\"19.55866360\" ce=\"3.21600008\" le=\"nan\" /><detail><fileshare filename=\"{DPObj.Name + \".zip\"}\" senderUrl=\"{DPIP}:8080/Marti/api/sync/metadata/{DPObj.Hash}/tool\" sizeInBytes=\"{DPObj.Size}\" sha256=\"{str(DPObj.Hash)}\" senderUid=\"server-uid\" senderCallsign=\"server\" name=\"{DPObj.Name}\" /><ackrequest uid=\"{uuid.uuid4()}\" ackrequested=\"true\" tag=\"{DPObj.Name}\" /></detail></event>'",
            "    cot.xmlString = clientXML.encode()",
            "    newCoT = SendOtherController(cot, addToDB=False)",
            "    APIPipe.put(newCoT.getObject())",
            "",
            "",
            "@app.route('/DataPackageTable', methods=[restMethods.GET, restMethods.POST, restMethods.DELETE, \"PUT\"])",
            "@auth.login_required()",
            "def DataPackageTable():",
            "    from pathlib import Path",
            "    if request.method == \"GET\":",
            "        output = dbController.query_datapackage()",
            "        for i in range(0, len(output)):",
            "            output[i] = output[i].__dict__",
            "            del (output[i]['_sa_instance_state'])",
            "            del (output[i]['CreatorUid'])",
            "            del (output[i]['MIMEType'])",
            "            del (output[i]['uid'])",
            "        return jsonify(json_list=output), 200",
            "",
            "    elif request.method == \"DELETE\":",
            "        jsondata = json.loads(request.data)",
            "        Hashes = jsondata['DataPackages']",
            "        for hash in Hashes:",
            "            Hash = hash['hash']",
            "            print(Hash)",
            "            obj = dbController.query_datapackage(f'Hash = \"{Hash}\"')",
            "            print(obj)",
            "            # TODO: make this coherent with constants",
            "            currentPath = MainConfig.DataPackageFilePath",
            "            shutil.rmtree(f'{str(currentPath)}/{obj[0].Hash}')",
            "            dbController.remove_datapackage(f'Hash = \"{Hash}\"')",
            "        return '200', 200",
            "",
            "    elif request.method == \"POST\":",
            "        try:",
            "            import string",
            "            import random",
            "            from pathlib import PurePath, Path",
            "            import hashlib",
            "            from zipfile import ZipFile",
            "            from defusedxml import ElementTree as etree",
            "            import uuid",
            "            from lxml.etree import SubElement, Element  # pylint: disable=no-name-in-module",
            "            dp_directory = str(PurePath(Path(MainConfig.DataPackageFilePath)))",
            "            letters = string.ascii_letters",
            "            # uid = ''.join(random.choice(letters) for i in range(4))",
            "            # uid = 'uid-' + str(uid)",
            "            uid = str(uuid.uuid4())",
            "            filename = request.args.get('filename')",
            "            creatorUid = request.args.get('creatorUid')",
            "            file = request.files.getlist('assetfile')[0]",
            "            with ZipFile(file, mode='a') as zip:",
            "                print(zip.infolist())",
            "                if \"MANIFEST/manifest.xml\" not in [member.filename for member in zip.infolist()]:",
            "                    manifestXML = Element(\"MissionPackageManifest\", version=\"2\")",
            "                    config = SubElement(manifestXML, \"Configuration\")",
            "                    SubElement(config, \"Parameter\", name=\"uid\", value=uid)",
            "                    SubElement(config, \"Parameter\", name=\"name\", value=filename)",
            "",
            "                    contents = SubElement(manifestXML, \"Contents\")",
            "                    for fileName in zip.namelist():",
            "                        SubElement(contents, \"Content\", ignore=\"false\", zipEntry=str(fileName))",
            "                    # manifest = zip.open('MANIFEST\\\\manifest.xml', mode=\"w\")",
            "                    zip.writestr('MANIFEST\\\\manifest.xml', etree.tostring(manifestXML))",
            "                    print(zip.namelist())",
            "                    file.seek(0)",
            "                else:",
            "                    pass",
            "",
            "            tempuid = str(uuid.uuid4())",
            "            app.logger.info(f\"Data Package hash = {str(tempuid)}\")",
            "            directory = Path(dp_directory, tempuid)",
            "            if not Path.exists(directory):",
            "                os.mkdir(str(directory))",
            "            file.seek(0)",
            "            filepath = str(PurePath(Path(directory), Path(filename)))",
            "            file.save(filepath)",
            "            openfile = open(str(PurePath(Path(str(directory), filename))), mode='rb')",
            "            file_hash = str(hashlib.sha256(openfile.read()).hexdigest())",
            "            openfile.close()",
            "            newDirectory = str(PurePath(Path(dp_directory), Path(file_hash)))",
            "            os.rename(str(PurePath(Path(directory))), newDirectory)",
            "            fileSize = Path(str(newDirectory), filename).stat().st_size",
            "            if creatorUid == None:",
            "                callsign = str(dbController.query_user(query=f'uid = \"server-uid\"', column=[",
            "                    'callsign']))  # fetchone() gives a tuple, so only grab the first element",
            "                dbController.create_datapackage(uid=uid, Name=filename, Hash=file_hash, SubmissionUser='server',",
            "                                                CreatorUid='server-uid', Size=fileSize)",
            "            else:",
            "                callsign = str(dbController.query_user(query=f'uid = f\"{creatorUid}\"', column=[",
            "                    'callsign']))  # fetchone() gives a tuple, so only grab the first element",
            "                dbController.create_datapackage(uid=uid, Name=filename, Hash=file_hash, SubmissionUser=callsign,",
            "                                                CreatorUid=creatorUid, Size=fileSize)",
            "            return 'successful', 200",
            "        except Exception as e:",
            "            return str(e), 500",
            "",
            "    elif request.method == \"PUT\":",
            "        updatedata = json.loads(request.data)",
            "        DataPackages = updatedata['DataPackages']",
            "        for dp in DataPackages:",
            "            updateDict = {}",
            "            if 'Privacy' in dp:",
            "                updateDict[\"Privacy\"] = int(dp[\"Privacy\"])",
            "            if \"Keywords\" in dp:",
            "                updateDict[\"Keywords\"] = dp[\"Keywords\"]",
            "            if \"Name\" in dp:",
            "                updateDict[\"Name\"] = dp[\"Name\"]",
            "            dbController.update_datapackage(query=f'PrimaryKey = {dp[\"PrimaryKey\"]}', column_value=updateDict)",
            "        return \"success\", 200",
            "",
            "",
            "@app.route(\"/MissionTable\", methods=['GET', 'POST', 'DELETE'])",
            "@auth.login_required()",
            "def mission_table():",
            "    try:",
            "        if request.method == \"GET\":",
            "            import random",
            "",
            "            jsondata = {",
            "                \"version\": \"3\",",
            "                \"type\": \"Mission\",",
            "                \"data\": [],",
            "                \"nodeId\": \"6ff99444fa124679a3943ee90308a44c9d794c02-e5a5-42b5-b4c8-625203ea1287\"",
            "            }",
            "            return json.dumps(jsondata)",
            "        elif request.method == \"POST\":",
            "            return b'', 200",
            "        elif request.method == \"DELETE\":",
            "            return b'', 200",
            "    except Exception as e:",
            "        return e, 500",
            "",
            "",
            "@app.route(\"/ExCheckTable\", methods=[\"GET\", \"POST\", \"DELETE\"])",
            "@auth.login_required()",
            "def excheck_table():",
            "    try:",
            "        from os import listdir",
            "        from pathlib import PurePath, Path",
            "        from datetime import datetime",
            "        from flask import request",
            "        if request.method == \"GET\":",
            "            jsondata = {\"ExCheck\": {'Templates': [], 'Checklists': []}}",
            "            from FreeTAKServer.controllers.ExCheckControllers.templateToJsonSerializer import templateSerializer",
            "            excheckTemplates = DatabaseController().query_ExCheck()",
            "            for template in excheckTemplates:",
            "                templateData = template.data",
            "                templatejson = {",
            "                    \"filename\": templateData.filename,",
            "                    \"name\": templateData.keywords.name,",
            "                    \"submissionTime\": templateData.submissionTime,",
            "                    \"submitter\": str(",
            "                        dbController.query_user(query=f'uid = \"{template.creatorUid}\"', column=['callsign'])),",
            "                    \"uid\": templateData.uid,",
            "                    \"hash\": templateData.hash,",
            "                    \"size\": templateData.size,",
            "                    \"description\": templateData.keywords.description",
            "                }",
            "                jsondata[\"ExCheck\"]['Templates'].append(templatejson)",
            "            excheckChecklists = DatabaseController().query_ExCheckChecklist()",
            "            for checklist in excheckChecklists:",
            "                try:",
            "                    templatename = checklist.template.data.name",
            "                except AttributeError:",
            "                    templatename = \"template removed\"",
            "                checklistjson = {",
            "                    \"filename\": checklist.filename,",
            "                    \"name\": checklist.name,",
            "                    \"startTime\": datetime.strftime(checklist.startTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"),",
            "                    \"submitter\": checklist.callsign,",
            "                    \"uid\": checklist.uid,",
            "                    \"description\": checklist.description,",
            "                    \"template\": templatename",
            "                }",
            "                jsondata[\"ExCheck\"]['Checklists'].append(checklistjson)",
            "            return json.dumps(jsondata), 200",
            "",
            "        elif request.method == \"DELETE\":",
            "            jsondata = request.data",
            "            ExCheckArray = json.loads(jsondata)[\"ExCheck\"]",
            "            for item in ExCheckArray[\"Templates\"]:",
            "                templateitem = DatabaseController().query_ExCheck(f'ExCheckData.uid = \"{item[\"uid\"]}\"', verbose=True)[0]",
            "                os.remove(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(templateitem.data.filename))))",
            "                DatabaseController().remove_ExCheck(f'PrimaryKey = \"{templateitem.PrimaryKey}\"')",
            "            for item in ExCheckArray[\"Checklists\"]:",
            "                checklistitem = DatabaseController().query_ExCheckChecklist(f'uid = \"{item[\"uid\"]}\"')[0]",
            "                os.remove(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistitem.filename))))",
            "                DatabaseController().remove_ExCheckChecklist(f'uid = \"{item[\"uid\"]}\"')",
            "            return 'success', 200",
            "        elif request.method == \"POST\":",
            "            try:",
            "                import uuid",
            "                from FreeTAKServer.controllers.ExCheckControllers.templateToJsonSerializer import templateSerializer",
            "                xmlstring = f'<?xml version=\"1.0\"?><event version=\"2.0\" uid=\"{uuid.uuid4()}\" type=\"t-x-m-c\" time=\"2020-11-28T17:45:51.000Z\" start=\"2020-11-28T17:45:51.000Z\" stale=\"2020-11-28T17:46:11.000Z\" how=\"h-g-i-g-o\"><point lat=\"0.00000000\" lon=\"0.00000000\" hae=\"0.00000000\" ce=\"9999999\" le=\"9999999\" /><detail><mission type=\"CHANGE\" tool=\"ExCheck\" name=\"exchecktemplates\" authorUid=\"S-1-5-21-2720623347-3037847324-4167270909-1002\"><MissionChanges><MissionChange><contentResource><filename>61b01475-ad44-4300-addc-a9474ebf67b0.xml</filename><hash>018cd5786bd6c2e603beef30d6a59987b72944a60de9e11562297c35ebdb7fd6</hash><keywords>test init</keywords><keywords>dessc init</keywords><keywords>FEATHER</keywords><mimeType>application/xml</mimeType><name>61b01475-ad44-4300-addc-a9474ebf67b0</name><size>1522</size><submissionTime>2020-11-28T17:45:47.980Z</submissionTime><submitter>wintak</submitter><tool>ExCheck</tool><uid>61b01475-ad44-4300-addc-a9474ebf67b0</uid></contentResource><creatorUid>S-1-5-21-2720623347-3037847324-4167270909-1002</creatorUid><missionName>exchecktemplates</missionName><timestamp>2020-11-28T17:45:47.983Z</timestamp><type>ADD_CONTENT</type></MissionChange></MissionChanges></mission></detail></event>'",
            "                # this is where the client will post the xmi of a template",
            "                from datetime import datetime",
            "                from defusedxml import ElementTree as etree",
            "                import hashlib",
            "                # possibly the uid of the client submitting the template",
            "                authoruid = request.args.get('clientUid')",
            "                if not authoruid:",
            "                    authoruid = 'server-uid'",
            "                XMI = request.data.decode()",
            "                serializer = templateSerializer(XMI)",
            "                object = serializer.convert_template_to_object()",
            "                object.timestamp = datetime.strptime(object.timestamp, \"%Y-%m-%dT%H:%M:%S.%fZ\")",
            "                serializer.create_DB_object(object)",
            "                xml = etree.fromstring(XMI)",
            "                path = str(PurePath(Path(MainConfig.ExCheckFilePath), Path(f'{object.data.uid}.xml')))",
            "                with open(path, 'w+') as file:",
            "                    file.write(XMI)",
            "                    file.close()",
            "",
            "                uid = object.data.uid",
            "                temp = etree.fromstring(XMI)",
            "                cot = etree.fromstring(xmlstring)",
            "                cot.find('detail').find('mission').set(\"authorUid\", authoruid)",
            "                resources = cot.find('detail').find('mission').find('MissionChanges').find('MissionChange').find(",
            "                    'contentResource')",
            "                resources.find('filename').text = temp.find('checklistDetails').find('uid').text + '.xml'",
            "                resources.findall('keywords')[0].text = temp.find('checklistDetails').find('name').text",
            "                resources.findall('keywords')[1].text = temp.find('checklistDetails').find('description').text",
            "                resources.findall('keywords')[2].text = temp.find('checklistDetails').find('creatorCallsign').text",
            "                resources.find('uid').text = temp.find('checklistDetails').find('uid').text",
            "                resources.find('name').text = temp.find('checklistDetails').find('uid').text",
            "                resources.find('size').text = str(len(XMI))",
            "                resources.find('hash').text = str(hashlib.sha256(str(XMI).encode()).hexdigest())",
            "                z = etree.tostring(cot)",
            "                from FreeTAKServer.model.testobj import testobj",
            "                object = testobj()",
            "                object.xmlString = z",
            "                APIPipe.put(object)",
            "                return str(uid), 200",
            "            except Exception as e:",
            "                print(str(e))",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route('/checkStatus', methods=[restMethods.GET])",
            "@auth.login_required()",
            "def check_status():",
            "    try:",
            "",
            "        if request.remote_addr in MainConfig.AllowedCLIIPs:",
            "            CommandPipe.put([functionNames.checkStatus])",
            "            FTSServerStatusObject = CommandPipe.get()",
            "            out = ApplyFullJsonController().serialize_model_to_json(FTSServerStatusObject)",
            "            return json.dumps(out), 200",
            "        else:",
            "            return 'endpoint can only be accessed by approved IPs', 401",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route('/manageAPI/getHelp', methods=[restMethods.GET])",
            "def help():",
            "    try:",
            "        from flask import url_for",
            "        message = {\"APIVersion\": str(MainConfig.APIVersion),",
            "                   \"SupportedEndpoints\": [url_for(i.endpoint, **(i.defaults or {})) for i in app.url_map.iter_rules() if",
            "                                          i.endpoint != 'static']",
            "                   }",
            "        return json.dumps(message)",
            "    except Exception as e:",
            "        return e, 500",
            "",
            "",
            "# @app.route('/changeStatus', methods=[restMethods.POST])",
            "# @auth.login_required()",
            "def changeStatus(jsonmessage):",
            "    # TODO: modify to better support format",
            "    mappings = {\"on\": \"start\", \"off\": \"stop\", \"\": \"\"}",
            "    try:",
            "        import json",
            "        if not jsonmessage:",
            "            jsonmessage = json.loads(request.data)",
            "        FTSObject = FTS()",
            "        json = jsonmessage[\"services\"]",
            "        ip = jsonmessage.get(\"ip\")",
            "        if jsonVars.COTSERVICE in json:",
            "            CoTService = json[jsonVars.COTSERVICE]",
            "            try:",
            "                FTSObject.CoTService.CoTServicePort = int(CoTService.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.CoTService.CoTServicePort = ''",
            "            FTSObject.CoTService.CoTServiceStatus = mappings[CoTService.get(\"status\")]",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.DATAPACKAGESERVICE in json:",
            "",
            "            DPService = json.get(jsonVars.DATAPACKAGESERVICE)",
            "            try:",
            "                FTSObject.TCPDataPackageService.TCPDataPackageServicePort = int(DPService.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.TCPDataPackageService.TCPDataPackageServicePort = ''",
            "            FTSObject.TCPDataPackageService.TCPDataPackageServiceStatus = mappings[DPService.get(\"status\")]",
            "",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.SSLDATAPACKAGESERVICE in json:",
            "",
            "            DPService = json.get(jsonVars.SSLDATAPACKAGESERVICE)",
            "            try:",
            "                FTSObject.SSLDataPackageService.SSLDataPackageServicePort = int(DPService.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.SSLDataPackageService.SSLDataPackageServicePort = ''",
            "            FTSObject.SSLDataPackageService.SSLDataPackageServiceStatus = mappings[DPService.get(\"status\")]",
            "",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.SSLCOTSERVICE in json:",
            "",
            "            SSLCoTservice = json[jsonVars.SSLCOTSERVICE]",
            "            try:",
            "                FTSObject.SSLCoTService.SSLCoTServicePort = int(SSLCoTservice.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.SSLCoTService.SSLCoTServicePort = ''",
            "            FTSObject.SSLCoTService.SSLCoTServiceStatus = mappings[SSLCoTservice.get(\"status\")]",
            "",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.FEDERATIONSERVERSERVICE in json:",
            "",
            "            FederationServerService = json.get(jsonVars.FEDERATIONSERVERSERVICE)",
            "            try:",
            "                FTSObject.FederationServerService.FederationServerServicePort = int(",
            "                    FederationServerService.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.FederationServerService.FederationServerServicePort = ''",
            "            FTSObject.FederationServerService.FederationServerServiceStatus = mappings[",
            "                FederationServerService.get('status')]",
            "",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.RESTAPISERVICE in json:",
            "",
            "            RESTAPISERVICE = json.get(jsonVars.RESTAPISERVICE)",
            "            try:",
            "                FTSObject.RestAPIService.RestAPIServicePort = int(RESTAPISERVICE.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.RestAPIService.RestAPIServicePort = ''",
            "            FTSObject.RestAPIService.RestAPIServiceStatus = mappings[RESTAPISERVICE.get(\"status\")]",
            "",
            "        else:",
            "            pass",
            "        FTSObject.SSLDataPackageService.SSLDataPackageServiceIP = ip",
            "        FTSObject.TCPDataPackageService.TCPDataPackageServiceIP = ip",
            "        CommandPipe.put([functionNames.Status, FTSObject])",
            "        out = CommandPipe.get()",
            "        return '200', 200",
            "",
            "    except Exception as e:",
            "        return '500', 500",
            "",
            "",
            "def submitData(dataRaw):",
            "    global APIPipe",
            "    print(APIPipe)",
            "    data = RawCoT()",
            "    data.clientInformation = \"SERVER\"",
            "    data.xmlString = dataRaw.encode()",
            "    APIPipe.put([data])",
            "",
            "",
            "def emitUpdates(Updates):",
            "    data = [SimpleClient()]",
            "    data[0].callsign = ''",
            "    data[0].team = ''",
            "    data[0].ip = ''",
            "    returnValue = []",
            "    for client in data:",
            "        returnValue.append(ApplyFullJsonController().serialize_model_to_json(client))",
            "    socketio.emit('up', json.dumps(returnValue), broadcast=True)",
            "    data = Updates",
            "    for client in data:",
            "        returnValue.append(ApplyFullJsonController().serialize_model_to_json(client))",
            "    socketio.emit('up', json.dumps(returnValue), broadcast=True)",
            "    return 1",
            "",
            "",
            "class RestAPI:",
            "    def __init__(self):",
            "        pass",
            "",
            "    def startup(self, APIPipea, CommandPipea, IP, Port, starttime):",
            "        print('running api')",
            "        global APIPipe, CommandPipe, StartTime",
            "        StartTime = starttime",
            "        APIPipe = APIPipea",
            "        CommandPipe = CommandPipea",
            "        socketio.run(app, host=IP, port=Port)",
            "        # try below if something breaks",
            "        # socketio.run(app, host='0.0.0.0', port=10984, debug=True, use_reloader=False)",
            "",
            "    def serializeJsonToModel(self, model, Json):",
            "        for key, value in Json.items():",
            "            if isinstance(value, dict):",
            "                submodel = getattr(model, key)",
            "                out = self.serializeJsonToModel(submodel, value)",
            "                setattr(model, key, out)",
            "            else:",
            "                setattr(model, key, value)",
            "        return model",
            "",
            "",
            "if __name__ == '__main__':",
            "    excheck_table()",
            "    #    app.run(host=\"127.0.0.1\", port=80)"
        ],
        "afterPatchFile": [
            "from flask import Flask, request, jsonify, session",
            "from flask_sqlalchemy import SQLAlchemy",
            "from flask_socketio import SocketIO, emit",
            "from flask_httpauth import HTTPTokenAuth",
            "from flask_login import current_user, LoginManager",
            "import threading",
            "from functools import wraps",
            "import uuid",
            "import datetime as dt",
            "from FreeTAKServer.controllers.configuration.LoggingConstants import LoggingConstants",
            "import datetime",
            "from defusedxml import ElementTree as etree",
            "from FreeTAKServer.model.FTSModel.Event import Event",
            "from FreeTAKServer.model.RawCoT import RawCoT",
            "from FreeTAKServer.controllers.ApplyFullJsonController import ApplyFullJsonController",
            "from FreeTAKServer.controllers.XMLCoTController import XMLCoTController",
            "from FreeTAKServer.model.ServiceObjects.FTS import FTS",
            "from FreeTAKServer.controllers.configuration.RestAPIVariables import RestAPIVariables as vars",
            "from FreeTAKServer.model.SimpleClient import SimpleClient",
            "from FreeTAKServer.controllers.DatabaseControllers.DatabaseController import DatabaseController",
            "from FreeTAKServer.controllers.configuration.DatabaseConfiguration import DatabaseConfiguration",
            "from FreeTAKServer.controllers.RestMessageControllers.SendChatController import SendChatController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendDeleteVideoStreamController import \\",
            "    SendDeleteVideoStreamController",
            "from FreeTAKServer.controllers.serializers.xml_serializer import XmlSerializer",
            "import os",
            "import shutil",
            "import json",
            "from flask_cors import CORS",
            "from FreeTAKServer.controllers.RestMessageControllers.SendSimpleCoTController import SendSimpleCoTController, \\",
            "    UpdateSimpleCoTController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendPresenceController import SendPresenceController, \\",
            "    UpdatePresenceController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendEmergencyController import SendEmergencyController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendSensorDroneController import SendSensorDroneController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendSPISensorController import SendSPISensorController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendImageryVideoController import SendImageryVideoController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendRouteController import SendRouteController",
            "from FreeTAKServer.controllers.RestMessageControllers.SendVideoStreamController import SendVideoStreamController",
            "from FreeTAKServer.controllers.configuration.MainConfig import MainConfig",
            "from FreeTAKServer.controllers.JsonController import JsonController",
            "from FreeTAKServer.controllers.serializers.SqlAlchemyObjectController import SqlAlchemyObjectController",
            "",
            "dbController = DatabaseController()",
            "",
            "UpdateArray = []",
            "StartTime = None",
            "",
            "functionNames = vars()",
            "functionNames.function_names()",
            "",
            "jsonVars = vars()",
            "jsonVars.json_vars()",
            "",
            "restMethods = vars()",
            "restMethods.rest_methods()",
            "",
            "defaultValues = vars()",
            "defaultValues.default_values()",
            "",
            "app = Flask(__name__)",
            "login_manager = LoginManager()",
            "login_manager.init_app(app)",
            "auth = HTTPTokenAuth(scheme='Bearer')",
            "app.config['SQLALCHEMY_DATABASE_URI'] = DatabaseConfiguration().DataBaseConnectionString",
            "app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False",
            "db = SQLAlchemy(app)",
            "dbController.session = db.session",
            "CORS(app)",
            "socketio = SocketIO(app, async_handlers=True, async_mode=\"eventlet\")",
            "socketio.init_app(app, cors_allowed_origins=\"*\")",
            "APIPipe = None",
            "CommandPipe = None",
            "app.config[\"SECRET_KEY\"] = MainConfig.SecretKey",
            "eventDict = {}",
            "",
            "",
            "@app.errorhandler(404)",
            "def page_not_found(e):",
            "    return 'this endpoint does not exist'",
            "",
            "",
            "@auth.verify_token",
            "def verify_token(token):",
            "    if token:",
            "        output = dbController.query_APIUser(query=f'token = \"{token}\"')",
            "        if output:",
            "            return output[0].Username",
            "        else:",
            "            output = dbController.query_systemUser(query=f'token = \"{token}\"')",
            "            if output:",
            "                output = output[0]",
            "                r = request",
            "                dbController.create_APICall(user_id=output.uid, timestamp=dt.datetime.now(), content=request.data,",
            "                                            endpoint=request.base_url)",
            "                return output.name",
            "",
            "",
            "@login_manager.user_loader",
            "def load_user(user_id):",
            "    return User.get(user_id)",
            "",
            "",
            "def socket_auth(session=None):",
            "    def innerfunc(x):",
            "        def wrapper(*args, **kwargs):",
            "            if hasattr(session, 'authenticated') and session.authenticated:",
            "                x(*args, **kwargs)",
            "            else:",
            "                pass",
            "",
            "        return wrapper",
            "",
            "    return innerfunc",
            "",
            "",
            "@app.route('/Alive')",
            "def sessions():",
            "    return b'API is running', 200",
            "",
            "",
            "@socketio.on('connect')",
            "def connection():",
            "    emit('connectUpdate', json.dumps({\"starttime\": str(StartTime), \"version\": str(MainConfig.version)}))",
            "",
            "",
            "@socketio.on('authenticate')",
            "def authenticate(token):",
            "    if json.loads(token)[\"Authenticate\"] == MainConfig.websocketkey:",
            "        emit('authentication', json.dumps({'successful': 'True'}))",
            "        session.authenticated = True  # pylint: disable=assigning-non-slot; this is necessary to save a client's state",
            "    else:",
            "        emit('authentication', json.dumps({'successful': 'False'}))",
            "",
            "",
            "@socketio.on('users')",
            "@socket_auth(session=session)",
            "def show_users(empty=None):",
            "    output = dbController.query_user()",
            "    for i in range(0, len(output)):",
            "        try:",
            "            original = output[i]",
            "            output[i] = output[i].__dict__",
            "            print(output[i])",
            "            try:",
            "                output[i]['callsign'] = original.CoT.detail.contact.callsign",
            "                output[i]['team'] = original.CoT.detail._group.name",
            "            except:",
            "                output[i]['callsign'] = \"undefined\"",
            "                output[i]['team'] = \"undefined\"",
            "            del (output[i]['_sa_instance_state'])",
            "            del (output[i]['CoT_id'])",
            "            del (output[i]['CoT'])",
            "        except Exception as e:",
            "            print(e)",
            "    socketio.emit('userUpdate', json.dumps({\"Users\": output}))",
            "",
            "",
            "@socketio.on('logs')",
            "@socket_auth(session=session)",
            "def return_logs(time):",
            "    log_data = {'log_data': []}",
            "    for line in reversed(open(LoggingConstants().ERRORLOG, \"r\").readlines()):",
            "        try:",
            "            timeoflog = line.split(\" : \")[1]",
            "            if datetime.datetime.strptime(timeoflog, '%Y-%m-%d %H:%M:%S,%f') > datetime.datetime.strptime(",
            "                    json.loads(time)[\"time\"], '%Y-%m-%d %H:%M:%S,%f'):",
            "                outline = {\"time\": '', \"type\": '', 'file': '', 'message': ''}",
            "                line_segments = line.split(\" : \")",
            "                outline[\"type\"] = line_segments[0]",
            "                outline[\"time\"] = line_segments[1]",
            "                outline[\"file\"] = line_segments[2]",
            "                outline[\"message\"] = \" : \".join(line_segments[3:-1])",
            "                log_data['log_data'].append(outline)",
            "            else:",
            "                break",
            "        except:",
            "            pass",
            "    for num in range(1, 6):",
            "        try:",
            "            for line in reversed(open(LoggingConstants().ERRORLOG + '.' + str(num), \"r\").readlines()):",
            "                try:",
            "                    timeoflog = line.split(\" : \")[1]",
            "                    if datetime.datetime.strptime(timeoflog, '%Y-%m-%d %H:%M:%S,%f') > datetime.datetime.strptime(",
            "                            json.loads(time)[\"time\"], '%Y-%m-%d %H:%M:%S,%f'):",
            "                        outline = {\"time\": '', \"type\": '', 'file': '', 'message': ''}",
            "                        line_segments = line.split(\" : \")",
            "                        outline[\"type\"] = line_segments[0]",
            "                        outline[\"time\"] = line_segments[1]",
            "                        outline[\"file\"] = line_segments[2]",
            "                        outline[\"message\"] = line_segments[3]",
            "                        log_data['log_data'].append(outline)",
            "                    else:",
            "                        break",
            "                except:",
            "                    pass",
            "        except:",
            "            pass",
            "    emit(\"logUpdate\", json.dumps(log_data))",
            "",
            "",
            "@socketio.on('serviceInfo')",
            "@socket_auth(session=session)",
            "def show_service_info(empty=None):",
            "    mapping = {\"start\": \"on\", \"stop\": \"off\", \"\": \"\"}",
            "    FTSServerStatusObject = getStatus()",
            "    tcpcot = FTSServerStatusObject.CoTService",
            "    sslcot = FTSServerStatusObject.SSLCoTService",
            "    restapi = FTSServerStatusObject.RestAPIService",
            "    tcpdp = FTSServerStatusObject.TCPDataPackageService",
            "    ssldp = FTSServerStatusObject.SSLDataPackageService",
            "    fedserver = FTSServerStatusObject.FederationServerService",
            "    jsonObject = {\"services\":",
            "                      {\"TCP_CoT_service\": {\"status\": mapping[tcpcot.CoTServiceStatus], \"port\": tcpcot.CoTServicePort},",
            "                       \"SSL_CoT_service\": {\"status\": mapping[sslcot.SSLCoTServiceStatus],",
            "                                           \"port\": sslcot.SSLCoTServicePort},",
            "                       \"TCP_DataPackage_service\": {\"status\": mapping[tcpdp.TCPDataPackageServiceStatus],",
            "                                                   \"port\": tcpdp.TCPDataPackageServicePort},",
            "                       \"SSL_DataPackage_service\": {\"status\": mapping[ssldp.SSLDataPackageServiceStatus],",
            "                                                   \"port\": ssldp.SSLDataPackageServicePort},",
            "                       \"Federation_server_service\": {\"status\": mapping[fedserver.FederationServerServiceStatus],",
            "                                                     \"port\": fedserver.FederationServerServicePort},",
            "                       \"Rest_API_service\": {\"status\": mapping[restapi.RestAPIServiceStatus],",
            "                                            \"port\": restapi.RestAPIServicePort}},",
            "                  \"ip\": tcpdp.TCPDataPackageServiceIP",
            "                  }",
            "    emit('serviceInfoUpdate', json.dumps(jsonObject))",
            "",
            "",
            "def getStatus():",
            "    CommandPipe.put([functionNames.checkStatus])",
            "    out = CommandPipe.get()",
            "    while hasattr(out, \"CoTService\") == False:",
            "        out = CommandPipe.get()",
            "    return out",
            "",
            "",
            "@socketio.on(\"serverHealth\")",
            "@socket_auth(session=session)",
            "def serverHealth(empty=None):",
            "    import psutil",
            "    import pathlib",
            "    import os",
            "    disk_usage = int(psutil.disk_usage(str(pathlib.Path(os.getcwd()).anchor)).percent)",
            "    memory_usage = int(psutil.virtual_memory().percent)",
            "    cpu_usage = int(psutil.cpu_percent(interval=0.1))",
            "    jsondata = {",
            "        \"CPU\": cpu_usage,",
            "        \"memory\": memory_usage,",
            "        \"disk\": disk_usage",
            "    }",
            "    emit('serverHealthUpdate', json.dumps(jsondata))",
            "",
            "",
            "@socketio.on('systemStatus')",
            "@socket_auth(session=session)",
            "def systemStatus(update=None):",
            "    print('system status running')",
            "    from FreeTAKServer.controllers.ServerStatusController import ServerStatusController",
            "    currentStatus = getStatus()",
            "    statusObject = ServerStatusController(currentStatus)",
            "    jsondata = ApplyFullJsonController().serialize_model_to_json(statusObject)",
            "    emit('systemStatusUpdate', json.dumps(jsondata))",
            "",
            "",
            "@socketio.on('changeServiceInfo')",
            "@socket_auth(session=session)",
            "def updateSystemStatus(update):",
            "    # TODO: add documentation",
            "    changeStatus(json.loads(update))",
            "    show_service_info()",
            "",
            "",
            "@socketio.on('systemUsers')",
            "@socket_auth(session=session)",
            "def systemUsers(empty=None):",
            "    systemUserArray = DatabaseController().query_systemUser()",
            "    jsondata = {\"SystemUsers\": []}",
            "    for user in systemUserArray:",
            "        userjson = {}",
            "        userjson['Name'] = user.name",
            "        userjson[\"Group\"] = user.group",
            "        userjson[\"Token\"] = user.token",
            "        userjson[\"Password\"] = user.password",
            "        userjson[\"Certs\"] = user.certificate_package_name",
            "        userjson[\"Uid\"] = user.uid",
            "        jsondata[\"SystemUsers\"].append(userjson)",
            "",
            "    emit('systemUsersUpdate', json.dumps(jsondata))",
            "",
            "",
            "@socketio.on('updateSystemUser')",
            "@socket_auth(session=session)",
            "def updateSystemUser(jsondata):",
            "    \"\"\" this socket event updates an existing system user entry in the database. User id must be provided if user with specified id doesnt",
            "    exist operation will return an error",
            "",
            "    example request:",
            "    {\"systemUsers\": [",
            "            {\"uid\": \"existing user id\", \"password\": \"new user password\", \"token\": \"new user token\", \"group\": \"new user group\"}",
            "        ]",
            "    }",
            "",
            "    Args:",
            "        jsondata: dict",
            "",
            "    Returns:",
            "",
            "    \"\"\"",
            "    for systemuser in json.loads(jsondata)['systemUsers']:",
            "        update_column = {}",
            "",
            "        if \"token\" in systemuser:",
            "            update_column[\"token\"] = str(systemuser[\"token\"])",
            "        if \"password\" in systemuser:",
            "            update_column[\"password\"] = str(systemuser[\"password\"])",
            "        if \"group\" in systemuser:",
            "            update_column[\"group\"] = str(systemuser[\"group\"])",
            "        dbController.update_systemUser(query=f'uid = \"{systemuser[\"uid\"]}\"', column_value=update_column)",
            "        return 200",
            "",
            "",
            "@socketio.on('addSystemUser')",
            "@socket_auth(session=session)",
            "def addSystemUser(jsondata):",
            "    from FreeTAKServer.controllers import certificate_generation",
            "    import uuid",
            "    try:",
            "        for systemuser in json.loads(jsondata)['systemUsers']:",
            "            if systemuser[\"Certs\"] == \"true\":",
            "                # create certs",
            "                certificate_generation.AtakOfTheCerts().bake(common_name=systemuser[\"Name\"])",
            "                certificate_generation.generate_zip(user_filename=systemuser[\"Name\"] + '.p12')",
            "                # add DP",
            "                import string",
            "                import random",
            "                from pathlib import PurePath, Path",
            "                import hashlib",
            "                from defusedxml import ElementTree as etree",
            "                import shutil",
            "                import os",
            "                dp_directory = str(PurePath(Path(MainConfig.DataPackageFilePath)))",
            "                openfile = open(str(PurePath(Path(str(MainConfig.clientPackages), systemuser[\"Name\"] + '.zip'))),",
            "                                mode='rb')",
            "                file_hash = str(hashlib.sha256(openfile.read()).hexdigest())",
            "                openfile.close()",
            "                newDirectory = str(PurePath(Path(dp_directory), Path(file_hash)))",
            "                os.mkdir(newDirectory)",
            "                shutil.copy(str(PurePath(Path(str(MainConfig.clientPackages), systemuser[\"Name\"] + '.zip'))),",
            "                            str(PurePath(Path(newDirectory), Path(systemuser[\"Name\"] + '.zip'))))",
            "                fileSize = Path(str(newDirectory), systemuser[\"Name\"] + '.zip').stat().st_size",
            "                dbController.create_datapackage(uid=str(uuid.uuid4()), Name=systemuser[\"Name\"] + '.zip', Hash=file_hash,",
            "                                                SubmissionUser='server',",
            "                                                CreatorUid='server-uid', Size=fileSize, Privacy=1)",
            "                dbController.create_systemUser(name=systemuser[\"Name\"], group=systemuser[\"Group\"],",
            "                                               token=systemuser[\"Token\"], password=systemuser[\"Password\"],",
            "                                               uid=str(uuid.uuid4()),",
            "                                               certificate_package_name=systemuser[\"Name\"] + '.zip')",
            "                import datetime as dt",
            "                DATETIME_FMT = \"%Y-%m-%dT%H:%M:%S.%fZ\"",
            "                timer = dt.datetime",
            "                now = timer.utcnow()",
            "                zulu = now.strftime(DATETIME_FMT)",
            "                add = dt.timedelta(seconds=600)",
            "                stale_part = dt.datetime.strptime(zulu, DATETIME_FMT) + add",
            "                stale = stale_part.strftime(DATETIME_FMT)",
            "                timer = dt.datetime",
            "                now = timer.utcnow()",
            "                zulu = now.strftime(DATETIME_FMT)",
            "                time = zulu",
            "                from FreeTAKServer.controllers.SpecificCoTControllers.SendOtherController import SendOtherController",
            "                from FreeTAKServer.model.RawCoT import RawCoT",
            "                cot = RawCoT()",
            "                DPIP = getStatus().TCPDataPackageService.TCPDataPackageServiceIP",
            "                clientXML = f'<?xml version=\"1.0\"?><event version=\"2.0\" uid=\"{str(uuid.uuid4())}\" type=\"b-f-t-r\" time=\"{time}\" start=\"{time}\" stale=\"{stale}\" how=\"h-e\"><point lat=\"43.85570300\" lon=\"-66.10801200\" hae=\"19.55866360\" ce=\"3.21600008\" le=\"nan\" /><detail><fileshare filename=\"{systemuser[\"Name\"]}\" senderUrl=\"{DPIP}:8080/Marti/api/sync/metadata/{str(file_hash)}/tool\" sizeInBytes=\"{fileSize}\" sha256=\"{str(file_hash)}\" senderUid=\"{\"server-uid\"}\" senderCallsign=\"{\"server\"}\" name=\"{systemuser[\"Name\"] + \".zip\"}\" /><ackrequest uid=\"{uuid.uuid4()}\" ackrequested=\"true\" tag=\"{systemuser[\"Name\"] + \".zip\"}\" /><marti><dest callsign=\"{systemuser[\"Name\"]}\" /></marti></detail></event>'",
            "                cot.xmlString = clientXML.encode()",
            "                newCoT = SendOtherController(cot, addToDB=False)",
            "                APIPipe.put(newCoT.getObject())",
            "",
            "            else:",
            "                dbController.create_systemUser(name=systemuser[\"Name\"], group=systemuser[\"Group\"],",
            "                                               token=systemuser[\"Token\"], password=systemuser[\"Password\"],",
            "                                               uid=str(uuid.uuid4()))",
            "    except Exception as e:",
            "        print(e)",
            "        return str(e), 500",
            "",
            "",
            "@socketio.on(\"removeSystemUser\")",
            "@socket_auth(session=session)",
            "def removeSystemUser(jsondata):",
            "    from FreeTAKServer.controllers.certificate_generation import revoke_certificate",
            "    jsondata = json.loads(jsondata)",
            "    for systemUser in jsondata[\"systemUsers\"]:",
            "        uid = systemUser[\"uid\"]",
            "        systemUser = dbController.query_systemUser(query=f'uid = \"{uid}\"')[0]",
            "        na = systemUser.name",
            "        revoke_certificate(username=na)",
            "        certificate_package_name = systemUser.certificate_package_name",
            "        dbController.remove_systemUser(f'uid = \"{uid}\"')",
            "        obj = dbController.query_datapackage(f'Name = \"{certificate_package_name}\"')",
            "        # TODO: make this coherent with constants",
            "        currentPath = MainConfig.DataPackageFilePath",
            "        shutil.rmtree(f'{str(currentPath)}/{obj[0].Hash}')",
            "        dbController.remove_datapackage(f'Hash = \"{obj[0].Hash}\"')",
            "        os.remove(MainConfig.certsPath + f\"/{na}.pem\")",
            "        os.remove(MainConfig.certsPath + f\"/{na}.key\")",
            "        os.remove(MainConfig.certsPath + f\"/{na}.p12\")",
            "",
            "",
            "@socketio.on(\"events\")",
            "@socket_auth(session=session)",
            "def events(empty=None):",
            "    current_notifications = Notification()",
            "    # socketio.emit(json.dumps([current_notifications.logErrors, current_notifications.emergencys]))",
            "    emit(\"eventsUpdate\", {\"events\": current_notifications.logErrors + current_notifications.emergencys})",
            "",
            "",
            "@app.route('/ManageNotification/getNotification', methods=[\"GET\"])",
            "def notification():",
            "    current_notifications = Notification()",
            "    return json.dumps({\"logErrors\": current_notifications.logErrors, \"emergencys\": current_notifications.emergencys})",
            "",
            "",
            "def getlogErrors():",
            "    output = []",
            "    for line in reversed(open(LoggingConstants().ERRORLOG, \"r\").readlines()):",
            "        try:",
            "            outline = {\"time\": '', \"type\": '', 'file': '', 'message': ''}",
            "            line_segments = line.split(\" : \")",
            "            if line_segments[0] != \"CRITICAL\":",
            "                continue",
            "            outline[\"type\"] = line_segments[0]",
            "            outline[\"time\"] = line_segments[1]",
            "            outline[\"file\"] = line_segments[2]",
            "            if len(line_segments) > 4:",
            "                outline[\"message\"] = \" : \".join(line_segments[3:-1])",
            "            else:",
            "                outline[\"message\"] = line_segments[3]",
            "            output.append(outline)",
            "        except:",
            "            pass",
            "    for num in range(1, 6):",
            "        try:",
            "            for line in reversed(open(LoggingConstants().ERRORLOG + '.' + str(num), \"r\").readlines()):",
            "                try:",
            "                    timeoflog = line.split(\" : \")[1]",
            "                    outline = {\"time\": '', \"type\": '', 'file': '', 'message': ''}",
            "                    line_segments = line.split(\" : \")",
            "                    if line_segments[0] != \"CRITICAL\":",
            "                        continue",
            "                    outline[\"type\"] = line_segments[0]",
            "                    outline[\"time\"] = line_segments[1]",
            "                    outline[\"file\"] = line_segments[2]",
            "                    outline[\"message\"] = line_segments[3]",
            "                    output.append(outline)",
            "                except:",
            "                    pass",
            "        except:",
            "            pass",
            "    return output",
            "",
            "",
            "def getemergencys():",
            "    output = dbController.query_ActiveEmergency()",
            "    for i in range(0, len(output)):",
            "        try:",
            "            original = output[i]",
            "            output[i] = output[i].__dict__",
            "            output[i][\"lat\"] = original.event.point.lat",
            "            output[i][\"lon\"] = original.event.point.lon",
            "            output[i][\"type\"] = original.event.detail.emergency.type",
            "            output[i][\"name\"] = original.event.detail.contact.callsign",
            "            del (output[i]['_sa_instance_state'])",
            "            del (output[i]['event'])",
            "        except:",
            "            pass",
            "    return output",
            "",
            "",
            "class Notification:",
            "    def __init__(self):",
            "        try:",
            "            self.emergencys = [i[\"name\"] + \" \" + i[\"type\"] for i in getemergencys()]",
            "        except:",
            "            self.emergencys = []",
            "        try:",
            "            self.logErrors = [i[\"message\"] for i in getlogErrors()]",
            "        except:",
            "            self.logErrors = []",
            "",
            "",
            "@app.route(\"/SendGeoChat\", methods=[restMethods.POST])",
            "@auth.login_required()",
            "def SendGeoChat():",
            "    try:",
            "        json = request.json",
            "        modelObject = Event.GeoChat()",
            "        out = ApplyFullJsonController().serializeJsonToModel(modelObject, json)",
            "        xml = XMLCoTController().serialize_model_to_CoT(out, 'event')",
            "        from FreeTAKServer.controllers.SpecificCoTControllers.SendGeoChatController import SendGeoChatController",
            "        rawcot = RawCoT()",
            "        rawcot.xmlString = xml",
            "        rawcot.clientInformation = None",
            "        object = SendGeoChatController(rawcot)",
            "        APIPipe.put(object.getObject())",
            "        return '200', 200",
            "    except Exception as e:",
            "        print(e)",
            "",
            "",
            "@app.route(\"/ManagePresence\")",
            "@auth.login_required()",
            "def ManagePresence():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManagePresence/postPresence\", methods=[restMethods.POST])",
            "@auth.login_required",
            "def postPresence():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_presence_post(jsondata)",
            "        Presence = SendPresenceController(jsonobj).getCoTObject()",
            "        APIPipe.put(Presence)",
            "        return Presence.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManagePresence/putPresence\", methods=[\"PUT\"])",
            "@auth.login_required",
            "def putPresence():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_presence_post(jsondata)",
            "        Presence = UpdatePresenceController(jsonobj).getCoTObject()",
            "        APIPipe.put(Presence)",
            "        return Presence.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageRoute\")",
            "@auth.login_required()",
            "def ManageRoute():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManageRoute/postRoute\", methods=[\"POST\"])",
            "@auth.login_required()",
            "def postRoute():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_route_post(jsondata)",
            "        Route = SendRouteController(jsonobj).getCoTObject()",
            "        APIPipe.put(Route)",
            "        return Route.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageCoT/getZoneCoT\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getZoneCoT():",
            "    try:",
            "        from math import sqrt, degrees, cos, sin, radians, atan2",
            "        from sqlalchemy import or_, and_",
            "        jsondata = request.get_json(force=True)",
            "        radius = int(jsondata[\"radius\"])",
            "        lat = (int(jsondata[\"latitude\"]))",
            "        lon = int(jsondata[\"longitude\"])",
            "        lat_abs = abs(lat)",
            "        lon_abs = abs(lon)",
            "        import geopy",
            "        from geopy.distance import distance",
            "        from FreeTAKServer.model.SQLAlchemy.CoTTables.Point import Point",
            "        from FreeTAKServer.model.SQLAlchemy.Event import Event",
            "        from FreeTAKServer.model.RestMessages.RestEnumerations import RestEnumerations",
            "        import re",
            "        radius_in_deg = (geopy.units.degrees(arcseconds=geopy.units.nautical(meters=radius))) / 2",
            "",
            "        results = dbController.query_CoT(query=[Event.point.has(or_(and_(Point.lon < 0, Point.lat < 0, (",
            "                    (((Point.lon * -1) - lon_abs) * 111302.62) + (",
            "                        ((Point.lat * -1) - lat_abs) * 110574.61)) <= radius + 10), and_(Point.lon < 0, Point.lat >= 0,",
            "                                                                                         ((((",
            "                                                                                                        Point.lon * -1) - lon_abs) * 111302.62) + (",
            "                                                                                                      (",
            "                                                                                                                  Point.lat - lat_abs) * 110574.61)) <= radius + 10),",
            "                                                                    and_(Point.lon >= 0, Point.lat < 0, (",
            "                                                                                ((Point.lon - lon_abs) * 111302.62) + ((",
            "                                                                                                                                   (",
            "                                                                                                                                               Point.lat * -1) - lat_abs) * 110574.61)) <= radius + 10),",
            "                                                                    and_(Point.lon >= 0, Point.lat >= 0, (",
            "                                                                                ((Point.lon - lon_abs) * 111302.62) + ((",
            "                                                                                                                                   Point.lat - lat_abs) * 110574.61)) <= radius + 10)))])",
            "        print(results)",
            "        output = []",
            "        for result in results:",
            "            try:",
            "                dLon = (result.point.lon - lon)",
            "                x = cos(radians(result.point.lat)) * sin(radians(dLon))",
            "                y = cos(radians(lat)) * sin(radians(result.point.lat)) - sin(radians(lat)) * cos(",
            "                    radians(result.point.lat)) * cos(radians(dLon))",
            "                brng = atan2(x, y)",
            "                brng = degrees(brng)",
            "                type_pattern = [type for type in list(RestEnumerations.supportedTypeEnumerations.values()) if",
            "                                re.fullmatch(type, result.type)][0]",
            "                index_number = list(RestEnumerations.supportedTypeEnumerations.values()).index(type_pattern)",
            "                type = list(RestEnumerations.supportedTypeEnumerations.keys())[index_number]",
            "                print(type)",
            "                part1 = result.type.split(type_pattern.split('.')[0])",
            "                part2 = '-' + part1[1].split(type_pattern.split('.')[1])[0] + '-'",
            "                attitude = list(RestEnumerations.attitude.keys())[list(RestEnumerations.attitude.values()).index(part2)]",
            "                print(attitude)",
            "                # attitude = RestEnumerations.attitude['-'+type.split(type_pattern.split('.')[0])[1].split(type_pattern.split('.')[1])+'-']",
            "",
            "                output.append({\"latitude\": result.point.lat,",
            "                               \"longitude\": result.point.lon,",
            "                               \"distance\": distance((result.point.lon, result.point.lat), (lon, lat)).m,",
            "                               \"direction\": brng,",
            "                               \"type\": type,",
            "                               \"attitude\": attitude",
            "                               })",
            "            except Exception as e:",
            "                pass",
            "        return json.dumps(output)",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageGeoObject\")",
            "@auth.login_required()",
            "def ManageGeoObject():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManageGeoObject/getGeoObject\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getGeoObject():",
            "    try:",
            "        from math import sqrt, degrees, cos, sin, radians, atan2",
            "        from sqlalchemy import or_, and_",
            "        # jsondata = request.get_json(force=True)",
            "        radius = request.args.get(\"radius\", default=100, type=int)",
            "        lat = request.args.get(\"latitude\", default=0, type=float)",
            "        lon = request.args.get(\"longitude\", default=0, type=float)",
            "        expectedAttitude = request.args.get(\"attitude\", default=\"*\", type=str)",
            "        lat_abs = lat",
            "        lon_abs = lon",
            "        import geopy",
            "        from geopy.distance import distance",
            "        from FreeTAKServer.model.SQLAlchemy.CoTTables.Point import Point",
            "        from FreeTAKServer.model.SQLAlchemy.Event import Event",
            "        from FreeTAKServer.model.RestMessages.RestEnumerations import RestEnumerations",
            "        import re",
            "        radius_in_deg = (geopy.units.degrees(arcseconds=geopy.units.nautical(meters=radius))) / 2",
            "        if lat_abs >= 0 and lon_abs >= 0:",
            "            results = dbController.query_CoT(query=[Event.point.has(and_(",
            "                Point.lon >= 0,",
            "                Point.lat >= 0,",
            "                or_(",
            "                    and_(",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10,",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) > 0),",
            "                    and_((",
            "                                 ((lon_abs - Point.lon) * 111302.62) + (",
            "                                     (lon_abs - Point.lat) * 110574.61)) <= radius + 10,",
            "                         (((lon_abs - Point.lon) * 111302.62) + ((lon_abs - Point.lat) * 110574.61)) > 0))))])",
            "        elif lon_abs < 0 and lat_abs < 0:",
            "            results = dbController.query_CoT(query=[Event.point.has(and_(",
            "                Point.lon < 0,",
            "                Point.lat < 0,",
            "                or_(",
            "                    and_(",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) > 0,",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10),",
            "                    and_(",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) > 0,",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) <= radius + 10)",
            "                )",
            "            ))])",
            "",
            "        elif lon_abs < 0 and lat_abs > 0:",
            "            results = dbController.query_CoT(query=[Event.point.has(and_(",
            "                Point.lon < 0,",
            "                Point.lat >= 0,",
            "                or_(",
            "                    and_(",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10,",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) > 0),",
            "                    and_(",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) <= radius + 10,",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) > 0)",
            "                )))])",
            "",
            "        elif lon_abs > 0 and lat_abs < 0:",
            "            results = dbController.query_CoT(query=[Event.point.has(and_(",
            "                Point.lon >= 0,",
            "                Point.lat < 0,",
            "                or_(",
            "",
            "                    and_(",
            "",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) <= radius + 10,",
            "                        (((lon_abs - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) > 0),",
            "                    and_(",
            "",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10,",
            "                        (((Point.lon - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) > 0))",
            "",
            "            ))])",
            "",
            "        else:",
            "            return \"unsupported coordinates\"",
            "",
            "        \"\"\"                 and_(",
            "                            Point.lon < 0,",
            "                            Point.lat < 0,",
            "                            ((((Point.lon * -1) - lon_abs) * 111302.62) + (((Point.lat * -1) - lat_abs) * 110574.61)) > 0,",
            "                            ((((Point.lon * -1) - lon_abs) * 111302.62) + (((Point.lat * -1) - lat_abs) * 110574.61)) <= radius + 10),",
            "            ",
            "                        and_(",
            "                            Point.lon < 0,",
            "                            Point.lat >= 0,",
            "                            or_(",
            "                                and_(",
            "                                    ((((Point.lon * -1) - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61)) <= radius + 10,",
            "                                    ((((Point.lon * -1) - lon_abs) * 111302.62) + ((Point.lat - lat_abs) * 110574.61))> 0),",
            "                                and_(",
            "                                    ((((lon_abs * -1) - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) <= radius + 10,",
            "                                    ((((lon_abs * -1) - Point.lon) * 111302.62) + ((lat_abs - Point.lat) * 110574.61)) > 0)",
            "                            ),",
            "            ",
            "                        ),",
            "                        and_(",
            "                            Point.lon >= 0,",
            "                            Point.lat < 0,",
            "                            (((Point.lon - lon_abs) * 111302.62) + (((Point.lat * -1) - lat_abs) * 110574.61)) <= radius + 10,",
            "                            (((Point.lon - lon_abs) * 111302.62) + (((Point.lat * -1) - lat_abs) * 110574.61))>0),\"\"\"",
            "",
            "        print(results)",
            "        output = []",
            "        for result in results:",
            "            try:",
            "                print(result.uid)",
            "                dLon = (result.point.lon - lon)",
            "                x = cos(radians(result.point.lat)) * sin(radians(dLon))",
            "                y = cos(radians(lat)) * sin(radians(result.point.lat)) - sin(radians(lat)) * cos(",
            "                    radians(result.point.lat)) * cos(radians(dLon))",
            "                brng = atan2(x, y)",
            "                brng = degrees(brng)",
            "                type_pattern = [type for type in list(RestEnumerations.supportedTypeEnumerations.values()) if",
            "                                re.fullmatch(type, result.type)]",
            "                print(type_pattern)",
            "                type_pattern = type_pattern[0]",
            "                index_number = list(RestEnumerations.supportedTypeEnumerations.values()).index(type_pattern)",
            "                print(index_number)",
            "                type = list(RestEnumerations.supportedTypeEnumerations.keys())[index_number]",
            "                print(type)",
            "                part1 = result.type.split(type_pattern.split('.')[0])",
            "                part2 = '-' + part1[1].split(type_pattern.split('.')[1])[0] + '-'",
            "                attitude = list(RestEnumerations.attitude.keys())[list(RestEnumerations.attitude.values()).index(part2)]",
            "                if attitude == expectedAttitude or expectedAttitude == \"*\":",
            "                    pass",
            "                else:",
            "                    continue",
            "                print(attitude)",
            "                # attitude = RestEnumerations.attitude['-'+type.split(type_pattern.split('.')[0])[1].split(type_pattern.split('.')[1])+'-']",
            "",
            "                output.append({\"latitude\": result.point.lat,",
            "                               \"longitude\": result.point.lon,",
            "                               \"distance\": distance((result.point.lon, result.point.lat), (lon, lat)).m,",
            "                               \"direction\": brng,",
            "                               \"type\": type,",
            "                               \"attitude\": attitude",
            "                               })",
            "            except Exception as e:",
            "                print(e)",
            "        return json.dumps(output)",
            "",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageGeoObject/postGeoObject\", methods=[restMethods.POST])",
            "@auth.login_required",
            "def postGeoObject():",
            "    try:",
            "        from geopy import Point, distance",
            "        from json import dumps",
            "        print(\"posting geo object\")",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'attitude': 'friend', 'geoObject': 'Ground', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_geoobject_post(jsondata)",
            "        if \"distance\" in jsondata:",
            "            start_point = Point(jsonobj.getlatitude(), jsonobj.getlongitude())",
            "            d = distance.distance(meters=jsondata[\"distance\"])",
            "            if \"bearing\" in jsondata:",
            "                end_point = d.destination(point=start_point, bearing=jsondata[\"bearing\"])",
            "            else:",
            "                end_point = d.destination(point=start_point, bearing=360)",
            "            jsonobj.setlatitude(end_point.latitude)",
            "            jsonobj.setlongitude(end_point.longitude)",
            "",
            "        simpleCoTObject = SendSimpleCoTController(jsonobj).getCoTObject()",
            "        print(\"putting in queue\")",
            "        APIPipe.put(simpleCoTObject)",
            "        print(simpleCoTObject.xmlString)",
            "        print('put in queue')",
            "        return simpleCoTObject.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageGeoObject/putGeoObject\", methods=[\"PUT\"])",
            "@auth.login_required",
            "def putGeoObject():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'longitude': '12.345678', 'latitude': '34.5677889', 'attitude': 'friend', 'geoObject': 'Ground', 'how': 'nonCoT', 'name': 'testing123'}",
            "        jsondata = request.get_json(force=True)",
            "        if \"uid\" in jsondata:",
            "            jsonobj = JsonController().serialize_geoobject_post(jsondata)",
            "            simpleCoTObject = UpdateSimpleCoTController(jsonobj).getCoTObject()",
            "            simpleCoTObject.modelObject.setuid(jsondata[\"uid\"])",
            "            simpleCoTObject.setXmlString(XMLCoTController().serialize_model_to_CoT(simpleCoTObject.modelObject))",
            "            APIPipe.put(simpleCoTObject)",
            "            return simpleCoTObject.modelObject.getuid(), 200",
            "        else:",
            "            raise Exception(\"uid is a required parameter\")",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageVideoStream\")",
            "@auth.login_required()",
            "def ManageVideoStream():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManageVideoStream/getVideoStream\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getVideoStream():",
            "    try:",
            "",
            "        # changed below line to access _Video table directly instead of using full stack call",
            "        # to make this endpoint more robust as well as prevent issues where post does not create",
            "        # full stack entries",
            "",
            "        # changed the main return from a list to an object to facilitate further development",
            "        from json import dumps",
            "        from urllib import parse",
            "        from FreeTAKServer.model.SQLAlchemy.CoTTables.Sensor import Sensor",
            "",
            "        output = dbController.query_video()",
            "        return_value = {\"video_stream\": {}}",
            "        for value in output:",
            "            value_obj = return_value[\"video_stream\"][str(value.PrimaryKey)] = {}",
            "            if value.url:",
            "                value_obj[\"url\"] = parse.urlparse(value.url).path",
            "            if value.ConnectionEntry:",
            "                if value.ConnectionEntry.path:",
            "                    value_obj[\"path\"] = value.ConnectionEntry.path",
            "                if value.ConnectionEntry.port:",
            "                    value_obj[\"port\"] = value.ConnectionEntry.port",
            "                if value.ConnectionEntry.address:",
            "                    value_obj[\"address\"] = value.ConnectionEntry.address",
            "        return dumps(return_value), 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageVideoStream/deleteVideoStream\", methods=[restMethods.DELETE])",
            "@auth.login_required",
            "def deleteVideoStream():",
            "    try:",
            "        from json import dumps",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_video_stream_delete(jsondata)",
            "        EmergencyObject = SendDeleteVideoStreamController(jsonobj).getCoTObject()",
            "        APIPipe.put(EmergencyObject)",
            "        return 'success', 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageVideoStream/postVideoStream\", methods=[\"POST\"])",
            "@auth.login_required()",
            "def postVideoStream():",
            "    \"\"\"this method contains the logic for the endpoints which saves the contents of a new videostream to",
            "    the db and sends a CoT to all connected clients containing stream information.\"\"\"",
            "    from FreeTAKServer.model.FTSModel.Event import Event",
            "    from lxml.etree import tostring  # pylint: disable=no-name-in-module; name is in module",
            "    try:",
            "        jsondata = request.get_json(force=True)",
            "",
            "        # the following prevents duplicate entries being added to the db",
            "        url = jsondata[\"streamAddress\"] + \":\" + jsondata[\"streamPort\"] + jsondata[\"streamPath\"]",
            "        video_streams = dbController.query_videostream()",
            "",
            "        for video in video_streams:",
            "            if video.url == url:",
            "                sqlalchemy_obj = dbController.query_CoT(f'uid=\"{video.PrimaryKey}\"')[0]",
            "                modelObject = SqlAlchemyObjectController().convert_sqlalchemy_to_modelobject(sqlalchemy_obj,",
            "                                                                                             Event.VideoStream())",
            "                xmlString = tostring(XmlSerializer().from_fts_object_to_format(modelObject))",
            "                modelObject.xmlString = xmlString",
            "                APIPipe.put(modelObject)",
            "                return \"entry already exists in db \" + str(video.PrimaryKey) + \" resending existing entry\", 201",
            "",
            "        simpleCoTObject = SendVideoStreamController(jsondata).getCoTObject()",
            "        print(\"putting in queue\")",
            "        APIPipe.put(simpleCoTObject)",
            "        print(simpleCoTObject.xmlString)",
            "        print('put in queue')",
            "        return simpleCoTObject.modelObject.getuid(), 200",
            "",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "\"\"\"@app.route(\"/ManageGeoObject/getGeoObject\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getGeoObject():",
            "    try:",
            "        from FreeTAKServer.model.RestMessages.RestEnumerations import RestEnumerations",
            "        return jsonify(list(RestEnumerations().supportedTypeEnumerations.keys()))",
            "    except Exception as e:",
            "        return e, 500\"\"\"",
            "",
            "",
            "@app.route(\"/ManageChat\")",
            "@auth.login_required()",
            "def ManageChat():",
            "    pass",
            "",
            "",
            "@app.route(\"/ManageChat/postChatToAll\", methods=[restMethods.POST])",
            "@auth.login_required",
            "def postChatToAll():",
            "    try:",
            "        from json import dumps",
            "        # jsondata = {'message': 'test abc', 'sender': 'natha'}",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_chat_post(jsondata)",
            "        ChatObject = SendChatController(jsonobj).getCoTObject()",
            "        APIPipe.put(ChatObject)",
            "        return 'success', 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/ManageEmergency/getEmergency\", methods=[restMethods.GET])",
            "@auth.login_required",
            "def getEmergency():",
            "    try:",
            "        output = getemergencys()",
            "        return jsonify(json_list=output), 200",
            "    except Exception as e:",
            "        return str(e), 200",
            "",
            "",
            "@app.route(\"/ManageEmergency/postEmergency\", methods=[restMethods.POST])",
            "@auth.login_required",
            "def postEmergency():",
            "    try:",
            "        from json import dumps",
            "",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_emergency_post(jsondata)",
            "        EmergencyObject = SendEmergencyController(jsonobj).getCoTObject()",
            "        APIPipe.put(EmergencyObject)",
            "        return EmergencyObject.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 200",
            "",
            "",
            "@app.route(\"/ManageEmergency/deleteEmergency\", methods=[restMethods.DELETE])",
            "@auth.login_required",
            "def deleteEmergency():",
            "    try:",
            "        from json import dumps",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_emergency_delete(jsondata)",
            "        EmergencyObject = SendEmergencyController(jsonobj).getCoTObject()",
            "        APIPipe.put(EmergencyObject)",
            "        return 'success', 200",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route(\"/Sensor\")",
            "@auth.login_required",
            "def sensor():",
            "    pass",
            "",
            "",
            "@app.route(\"/Sensor/postDrone\", methods=[\"POST\"])",
            "@auth.login_required",
            "def postDroneSensor():",
            "    try:",
            "        from json import dumps",
            "",
            "        jsondata = request.get_json(force=True)",
            "        print(jsondata)",
            "        jsonobj = JsonController().serialize_drone_sensor_post(jsondata)",
            "        DroneObject = SendSensorDroneController(jsonobj).getCoTObject()",
            "",
            "        print(DroneObject.xmlString)",
            "        APIPipe.put(DroneObject)",
            "        if jsonobj.getSPILongitude() or jsonobj.getSPILatitude() or jsonobj.getSPIName():",
            "            jsonobjSPI = JsonController().serialize_spi_post(jsondata)",
            "            jsonobjSPI.setlatitude(jsonobj.getSPILatitude())",
            "            jsonobjSPI.setlongitude(jsonobj.getSPILongitude())",
            "            jsonobjSPI.setname(jsonobj.getSPIName())",
            "            jsonobjSPI.setdroneUid(DroneObject.modelObject.getuid())",
            "            SPISensor = SendSPISensorController(jsonobjSPI).getCoTObject()",
            "            APIPipe.put(SPISensor)",
            "            return json.dumps({\"uid\": DroneObject.modelObject.getuid(), \"SPI_uid\": SPISensor.modelObject.getuid()}), 200",
            "        return DroneObject.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 200",
            "",
            "",
            "@app.route(\"/Sensor/postSPI\", methods=[\"POST\"])",
            "@auth.login_required",
            "def postSPI():",
            "    try:",
            "        from json import dumps",
            "",
            "        jsondata = request.get_json(force=True)",
            "        jsonobj = JsonController().serialize_spi_post(jsondata)",
            "        SPIObject = SendSPISensorController(jsonobj).getCoTObject()",
            "        APIPipe.put(SPIObject)",
            "        return SPIObject.modelObject.getuid(), 200",
            "    except Exception as e:",
            "        return str(e), 200",
            "",
            "",
            "@app.route(\"/MapVid\", methods=[\"POST\"])",
            "@auth.login_required",
            "def mapvid():",
            "    from json import dumps",
            "    jsondata = request.get_json(force=True)",
            "    jsonobj = JsonController().serialize_imagery_video(jsondata)",
            "    ImagerVideoObject = SendImageryVideoController(jsonobj).getCoTObject()",
            "    APIPipe.put(ImagerVideoObject)",
            "    return 200",
            "",
            "",
            "@app.route(\"/AuthenticateUser\", methods=[\"GET\"])",
            "@auth.login_required",
            "def authenticate_user():",
            "    try:",
            "        print('request made')",
            "        username = request.args.get(\"username\")",
            "        password = request.args.get(\"password\")",
            "        try:",
            "            user = dbController.query_systemUser(query=(f'name = \"{username}\"'))[0]",
            "        except Exception as e:",
            "            print(e)",
            "            return None",
            "        if user.password == password:",
            "            print(\"query made\")",
            "            user.metadata = None",
            "            user.query = None",
            "            user.query_class = None",
            "            user._decl_class_registry = None",
            "            user._sa_class_manager = None",
            "            user._sa_instance_state = None",
            "            user._modified_event = None",
            "            print(\"done setting to none\")",
            "            json_user = user.__dict__",
            "            print(json_user)",
            "            del (json_user[\"_sa_class_manager\"])",
            "            del (json_user[\"_sa_instance_state\"])",
            "            del (json_user[\"_modified_event\"])",
            "            del (json_user[\"_decl_class_registry\"])",
            "            print('done defining dict')",
            "            return_data = json.dumps({\"uid\": json_user[\"uid\"]})",
            "            print('returning data ' + str(return_data))",
            "            return return_data",
            "        else:",
            "            return None",
            "    except Exception as e:",
            "        print(e)",
            "        return e, 500",
            "",
            "",
            "@app.route(\"/ManageEmergency\")",
            "@auth.login_required",
            "def Emergency():",
            "    pass",
            "",
            "",
            "# @app.route(\"/ConnectionMessage\", methods=[restMethods.POST])",
            "def ConnectionMessage():",
            "    \"\"\"this endpoint is responsible for generating the CoT equivalen to the content of the JSON sent",
            "    and then forwarding this CoT to all connected clients\"\"\"",
            "    try:",
            "        json = request.json",
            "        modelObject = Event.GeoChat()",
            "        out = ApplyFullJsonController().serializeJsonToModel(modelObject, json)",
            "        xml = XMLCoTController().serialize_model_to_CoT(out, 'event')",
            "        from FreeTAKServer.controllers.RestMessageControllers.SendChatController import SendChatController",
            "        rawcot = RawCoT()",
            "        rawcot.xmlString = xml",
            "        rawcot.clientInformation = None",
            "        object = SendChatController(rawcot).getCoTObject()",
            "        object.type = \"connmessage\"",
            "        APIPipe.put(object.SendGeoChat)",
            "        return '200', 200",
            "    except Exception as e:",
            "        print(e)",
            "",
            "",
            "@app.route(\"/APIUser\", methods=[restMethods.GET, restMethods.POST, restMethods.DELETE])",
            "def APIUser():",
            "    if request.remote_addr in MainConfig.AllowedCLIIPs:",
            "        try:",
            "            if request.method == restMethods.POST:",
            "                json = request.get_json()",
            "                dbController.create_APIUser(Username=json['username'], Token=json['token'])",
            "                return 'success', 200",
            "",
            "            elif request.method == restMethods.DELETE:",
            "                json = request.get_json()",
            "                username = json['username']",
            "                dbController.remove_APIUser(query=f'Username = \"{username}\"')",
            "                return 'success', 200",
            "",
            "            elif request.method == restMethods.GET:",
            "                output = dbController.query_APIUser()",
            "                for i in range(0, len(output)):",
            "                    output[i] = output[i].__dict__",
            "                    del (output[i]['_sa_instance_state'])",
            "                    del (output[i]['PrimaryKey'])",
            "                    del (output[i]['uid'])",
            "                return jsonify(json_list=output), 200",
            "",
            "        except Exception as e:",
            "            return str(e), 500",
            "    else:",
            "        return 'endpoint can only be accessed by approved IPs', 401",
            "",
            "",
            "@app.route(\"/RecentCoT\", methods=[restMethods.GET])",
            "def RecentCoT():",
            "    import time",
            "    time.sleep(10)",
            "    return b'1234'",
            "",
            "",
            "@app.route(\"/URL\", methods=[restMethods.GET])",
            "def URLGET():",
            "    data = request.args",
            "    print(data)",
            "    return 'completed', 200",
            "",
            "",
            "@app.route(\"/Clients\", methods=[restMethods.GET])",
            "def Clients():",
            "    try:",
            "        if request.remote_addr in MainConfig.AllowedCLIIPs:",
            "            CommandPipe.put([functionNames.Clients])",
            "            out = CommandPipe.get()",
            "            returnValue = []",
            "            for client in out:",
            "                returnValue.append(ApplyFullJsonController().serialize_model_to_json(client))",
            "            dumps = json.dumps(returnValue)",
            "            return dumps",
            "        else:",
            "            return 'endpoint can only be accessed by approved IPs', 401",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route('/FederationTable', methods=[restMethods.GET, restMethods.POST, \"PUT\", restMethods.DELETE])",
            "@auth.login_required()",
            "def FederationTable():",
            "    try:",
            "        import random",
            "        if request.method == restMethods.GET:",
            "            output = dbController.query_ActiveFederation()",
            "            for i in range(0, len(output)):",
            "                output[i] = output[i].__dict__",
            "                del (output[i]['_sa_instance_state'])",
            "            output2 = dbController.query_Federation()",
            "            for i in range(0, len(output2)):",
            "                output2[i] = output2[i].__dict__",
            "                del (output2[i]['_sa_instance_state'])",
            "",
            "            return jsonify(activeFederations=output, federations=output2), 200",
            "",
            "        elif request.method == restMethods.POST:",
            "            import uuid",
            "            jsondata = json.loads(request.data)",
            "            new_outgoing_federations = jsondata[\"outgoingFederations\"]",
            "            for new_fed in new_outgoing_federations:",
            "                id = str(uuid.uuid4())",
            "                dbController.create_Federation(**new_fed, id=id)",
            "                if new_fed[\"status\"] == \"Enabled\":",
            "                    CommandPipe.put((id, \"CREATE\"))",
            "                else:",
            "                    pass",
            "            return '', 200",
            "",
            "        elif request.method == \"PUT\":",
            "            jsondata = json.loads(request.data)",
            "            federations = jsondata[\"federations\"]",
            "            for fed in federations:",
            "                old_fed = dbController.query_Federation(f'id = \"{fed[\"id\"]}\"')[0]",
            "                old_status = old_fed.status",
            "                old_id = old_fed.id",
            "                dbController.update_Federation(column_value=fed, query=f'id = \"{fed[\"id\"]}\"')",
            "                if \"status\" in fed:",
            "                    if fed[\"status\"] == \"Enabled\":",
            "",
            "                        if old_status != \"Enabled\":",
            "                            CommandPipe.put((old_id, \"CREATE\"))",
            "                        else:",
            "                            pass",
            "                    elif fed[\"status\"] == \"Disabled\":",
            "                        if old_status != \"Disabled\":",
            "                            CommandPipe.put((old_id, \"DELETE\"))",
            "                        else:",
            "                            pass",
            "                    else:",
            "                        pass",
            "            return '', 200",
            "",
            "        elif request.method == \"DELETE\":",
            "            jsondata = json.loads(request.data)",
            "            federations = jsondata[\"federations\"]",
            "            for fed in federations:",
            "                fedInstance = dbController.query_Federation(f'id = \"{fed[\"id\"]}\"')[0]",
            "                if fedInstance.status == \"Enabled\":",
            "                    CommandPipe.put((fedInstance.id, \"DELETE\"))",
            "                else:",
            "                    pass",
            "                dbController.remove_Federation(f'id = \"{fed[\"id\"]}\"')",
            "            return '', 200",
            "",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route('/ManageKML/postKML', methods=[restMethods.POST])",
            "@auth.login_required()",
            "def create_kml():",
            "    try:",
            "        from pykml.factory import KML_ElementMaker as KML",
            "        from pykml import parser",
            "        from pathlib import Path, PurePath",
            "        from lxml import etree",
            "        import hashlib",
            "        from zipfile import ZipFile",
            "        from lxml.etree import SubElement, Element  # pylint: disable=no-name-in-module",
            "        from geopy import Nominatim",
            "        dp_directory = str(PurePath(Path(MainConfig.DataPackageFilePath)))",
            "        jsondata = request.get_json(force=True)",
            "        name = jsondata[\"name\"]",
            "        main = parser.fromstring('<kml xmlns=\"http://www.opengis.net/kml/2.2\"/>')",
            "        root = KML.Document()",
            "        main[0].append(root)",
            "        root[0].append(KML.description(name))",
            "        root[0].append(KML.Folder())",
            "        root.Folder[0].append(KML.Placemark())",
            "        root.Folder.Placemark[0].append(KML.name(name))",
            "        root.Folder.Placemark[0].append(KML.ExtendedData())",
            "        if jsondata.get(\"longitude\") and jsondata.get(\"latitude\"):",
            "            root.Folder.Placemark[0].append(",
            "                KML.Point(KML.coordinates(str(jsondata[\"longitude\"]) + \",\" + str(jsondata[\"latitude\"]))))",
            "        elif jsondata.get(\"address\"):",
            "            locator = Nominatim(user_agent=str(uuid.uuid4()))",
            "            location = locator.geocode(jsondata.get(\"address\"))",
            "            root.Folder.Placemark[0].append(",
            "                KML.Point(KML.coordinates(str(location.longitude) + \",\" + str(location.latitude))))",
            "        else:",
            "            root.Folder.Placemark[0].append(",
            "                KML.Point(KML.coordinates(str(0) + \",\" + str(0))))",
            "        attribs = root.Folder.Placemark.ExtendedData[0]",
            "        for key, value in jsondata[\"body\"].items():",
            "            attribs.append(KML.Data(KML.value(value), name=key))",
            "",
            "        # create DP",
            "        tempuid = str(uuid.uuid4())",
            "        app.logger.info(f\"Data Package hash = {str(tempuid)}\")",
            "        directory = Path(dp_directory, tempuid)",
            "        if not Path.exists(directory):",
            "            os.mkdir(str(directory))",
            "        filepath = str(PurePath(Path(directory), Path(name)))",
            "        data_stringified = etree.tostring(main)",
            "        with open(filepath, mode=\"wb+\") as file:",
            "",
            "            with ZipFile(file, mode='a') as zip:",
            "                print(zip.infolist())",
            "                uidtemp = uuid.uuid4()",
            "                if \"MANIFEST/manifest.xml\" not in [member.filename for member in zip.infolist()]:",
            "                    manifestXML = Element(\"MissionPackageManifest\", version=\"2\")",
            "                    config = SubElement(manifestXML, \"Configuration\")",
            "                    SubElement(config, \"Parameter\", name=\"name\", value=name)",
            "                    SubElement(config, \"Parameter\", name=\"uid\", value=str(uidtemp))",
            "                    zip.writestr(str(uidtemp.hex) + \"/\" + name + \".kml\", data_stringified)",
            "                    contents = SubElement(manifestXML, \"Contents\")",
            "                    for fileName in zip.namelist():",
            "                        SubElement(contents, \"Content\", ignore=\"false\", zipEntry=str(fileName))",
            "                    # manifest = zip.open('MANIFEST\\\\manifest.xml', mode=\"w\")",
            "                    zip.writestr('MANIFEST\\\\manifest.xml', etree.tostring(manifestXML))",
            "",
            "                    print(zip.namelist())",
            "                    file.seek(0)",
            "                else:",
            "                    pass",
            "",
            "        openfile = open(str(PurePath(Path(str(directory), name))), mode='rb')",
            "        file_hash = str(hashlib.sha256(openfile.read()).hexdigest())",
            "        openfile.close()",
            "        newDirectory = str(PurePath(Path(dp_directory), Path(file_hash)))",
            "        os.rename(str(PurePath(Path(directory))), newDirectory)",
            "        fileSize = Path(str(newDirectory), name).stat().st_size",
            "        uid = str(uuid.uuid4())",
            "        dbController.create_datapackage(uid=uid, Name=name, Hash=file_hash, SubmissionUser='server',",
            "                                        CreatorUid='server-uid', Size=fileSize)",
            "",
            "        # broacast DP",
            "        broadcast_datapackage(uid)",
            "",
            "        return \"successful\", 200",
            "    except Exception as e:",
            "        print(\"exception is \" + str(e))",
            "",
            "",
            "@app.route('/BroadcastDataPackage', methods=[restMethods.POST])",
            "@auth.login_required()",
            "def broadcast_datapackage(uid):",
            "    import datetime as dt",
            "    DATETIME_FMT = \"%Y-%m-%dT%H:%M:%S.%fZ\"",
            "    timer = dt.datetime",
            "    now = timer.utcnow()",
            "    zulu = now.strftime(DATETIME_FMT)",
            "    add = dt.timedelta(seconds=600)",
            "    stale_part = dt.datetime.strptime(zulu, DATETIME_FMT) + add",
            "    stale = stale_part.strftime(DATETIME_FMT)",
            "    timer = dt.datetime",
            "    now = timer.utcnow()",
            "    zulu = now.strftime(DATETIME_FMT)",
            "    time = zulu",
            "    from FreeTAKServer.controllers.SpecificCoTControllers.SendOtherController import SendOtherController",
            "    from FreeTAKServer.model.RawCoT import RawCoT",
            "    cot = RawCoT()",
            "    DPIP = getStatus().TCPDataPackageService.TCPDataPackageServiceIP",
            "    DPObj = dbController.query_datapackage(f'uid = \"{uid}\"')[0]",
            "    clientXML = f'<?xml version=\"1.0\"?><event version=\"2.0\" uid=\"{str(uuid.uuid4())}\" type=\"b-f-t-r\" time=\"{time}\" start=\"{time}\" stale=\"{stale}\" how=\"h-e\"><point lat=\"43.85570300\" lon=\"-66.10801200\" hae=\"19.55866360\" ce=\"3.21600008\" le=\"nan\" /><detail><fileshare filename=\"{DPObj.Name + \".zip\"}\" senderUrl=\"{DPIP}:8080/Marti/api/sync/metadata/{DPObj.Hash}/tool\" sizeInBytes=\"{DPObj.Size}\" sha256=\"{str(DPObj.Hash)}\" senderUid=\"server-uid\" senderCallsign=\"server\" name=\"{DPObj.Name}\" /><ackrequest uid=\"{uuid.uuid4()}\" ackrequested=\"true\" tag=\"{DPObj.Name}\" /></detail></event>'",
            "    cot.xmlString = clientXML.encode()",
            "    newCoT = SendOtherController(cot, addToDB=False)",
            "    APIPipe.put(newCoT.getObject())",
            "",
            "",
            "@app.route('/DataPackageTable', methods=[restMethods.GET, restMethods.POST, restMethods.DELETE, \"PUT\"])",
            "@auth.login_required()",
            "def DataPackageTable():",
            "    from pathlib import Path",
            "    if request.method == \"GET\":",
            "        output = dbController.query_datapackage()",
            "        for i in range(0, len(output)):",
            "            output[i] = output[i].__dict__",
            "            del (output[i]['_sa_instance_state'])",
            "            del (output[i]['CreatorUid'])",
            "            del (output[i]['MIMEType'])",
            "            del (output[i]['uid'])",
            "        return jsonify(json_list=output), 200",
            "",
            "    elif request.method == \"DELETE\":",
            "        jsondata = json.loads(request.data)",
            "        Hashes = jsondata['DataPackages']",
            "        for hash in Hashes:",
            "            Hash = hash['hash']",
            "            print(Hash)",
            "            obj = dbController.query_datapackage(f'Hash = \"{Hash}\"')",
            "            print(obj)",
            "            # TODO: make this coherent with constants",
            "            currentPath = MainConfig.DataPackageFilePath",
            "            shutil.rmtree(f'{str(currentPath)}/{obj[0].Hash}')",
            "            dbController.remove_datapackage(f'Hash = \"{Hash}\"')",
            "        return '200', 200",
            "",
            "    elif request.method == \"POST\":",
            "        try:",
            "            import string",
            "            import random",
            "            from pathlib import PurePath, Path",
            "            import hashlib",
            "            from zipfile import ZipFile",
            "            from defusedxml import ElementTree as etree",
            "            import uuid",
            "            from lxml.etree import SubElement, Element  # pylint: disable=no-name-in-module",
            "            dp_directory = str(PurePath(Path(MainConfig.DataPackageFilePath)))",
            "            letters = string.ascii_letters",
            "            # uid = ''.join(random.choice(letters) for i in range(4))",
            "            # uid = 'uid-' + str(uid)",
            "            uid = str(uuid.uuid4())",
            "            filename = request.args.get('filename')",
            "            creatorUid = request.args.get('creatorUid')",
            "            file = request.files.getlist('assetfile')[0]",
            "            with ZipFile(file, mode='a') as zip:",
            "                print(zip.infolist())",
            "                if \"MANIFEST/manifest.xml\" not in [member.filename for member in zip.infolist()]:",
            "                    manifestXML = Element(\"MissionPackageManifest\", version=\"2\")",
            "                    config = SubElement(manifestXML, \"Configuration\")",
            "                    SubElement(config, \"Parameter\", name=\"uid\", value=uid)",
            "                    SubElement(config, \"Parameter\", name=\"name\", value=filename)",
            "",
            "                    contents = SubElement(manifestXML, \"Contents\")",
            "                    for fileName in zip.namelist():",
            "                        SubElement(contents, \"Content\", ignore=\"false\", zipEntry=str(fileName))",
            "                    # manifest = zip.open('MANIFEST\\\\manifest.xml', mode=\"w\")",
            "                    zip.writestr('MANIFEST\\\\manifest.xml', etree.tostring(manifestXML))",
            "                    print(zip.namelist())",
            "                    file.seek(0)",
            "                else:",
            "                    pass",
            "",
            "            tempuid = str(uuid.uuid4())",
            "            app.logger.info(f\"Data Package hash = {str(tempuid)}\")",
            "            directory = Path(dp_directory, tempuid)",
            "            if not Path.exists(directory):",
            "                os.mkdir(str(directory))",
            "            file.seek(0)",
            "            filepath = str(PurePath(Path(directory), Path(filename)))",
            "            file.save(filepath)",
            "            openfile = open(str(PurePath(Path(str(directory), filename))), mode='rb')",
            "            file_hash = str(hashlib.sha256(openfile.read()).hexdigest())",
            "            openfile.close()",
            "            newDirectory = str(PurePath(Path(dp_directory), Path(file_hash)))",
            "            os.rename(str(PurePath(Path(directory))), newDirectory)",
            "            fileSize = Path(str(newDirectory), filename).stat().st_size",
            "            if creatorUid == None:",
            "                callsign = str(dbController.query_user(query=f'uid = \"server-uid\"', column=[",
            "                    'callsign']))  # fetchone() gives a tuple, so only grab the first element",
            "                dbController.create_datapackage(uid=uid, Name=filename, Hash=file_hash, SubmissionUser='server',",
            "                                                CreatorUid='server-uid', Size=fileSize)",
            "            else:",
            "                callsign = str(dbController.query_user(query=f'uid = f\"{creatorUid}\"', column=[",
            "                    'callsign']))  # fetchone() gives a tuple, so only grab the first element",
            "                dbController.create_datapackage(uid=uid, Name=filename, Hash=file_hash, SubmissionUser=callsign,",
            "                                                CreatorUid=creatorUid, Size=fileSize)",
            "            return 'successful', 200",
            "        except Exception as e:",
            "            return str(e), 500",
            "",
            "    elif request.method == \"PUT\":",
            "        updatedata = json.loads(request.data)",
            "        DataPackages = updatedata['DataPackages']",
            "        for dp in DataPackages:",
            "            updateDict = {}",
            "            if 'Privacy' in dp:",
            "                updateDict[\"Privacy\"] = int(dp[\"Privacy\"])",
            "            if \"Keywords\" in dp:",
            "                updateDict[\"Keywords\"] = dp[\"Keywords\"]",
            "            if \"Name\" in dp:",
            "                updateDict[\"Name\"] = dp[\"Name\"]",
            "            dbController.update_datapackage(query=f'PrimaryKey = {dp[\"PrimaryKey\"]}', column_value=updateDict)",
            "        return \"success\", 200",
            "",
            "",
            "@app.route(\"/MissionTable\", methods=['GET', 'POST', 'DELETE'])",
            "@auth.login_required()",
            "def mission_table():",
            "    try:",
            "        if request.method == \"GET\":",
            "            import random",
            "",
            "            jsondata = {",
            "                \"version\": \"3\",",
            "                \"type\": \"Mission\",",
            "                \"data\": [],",
            "                \"nodeId\": \"6ff99444fa124679a3943ee90308a44c9d794c02-e5a5-42b5-b4c8-625203ea1287\"",
            "            }",
            "            return json.dumps(jsondata)",
            "        elif request.method == \"POST\":",
            "            return b'', 200",
            "        elif request.method == \"DELETE\":",
            "            return b'', 200",
            "    except Exception as e:",
            "        return e, 500",
            "",
            "",
            "@app.route(\"/ExCheckTable\", methods=[\"GET\", \"POST\", \"DELETE\"])",
            "@auth.login_required()",
            "def excheck_table():",
            "    try:",
            "        from os import listdir",
            "        from pathlib import PurePath, Path",
            "        from datetime import datetime",
            "        from flask import request",
            "        if request.method == \"GET\":",
            "            jsondata = {\"ExCheck\": {'Templates': [], 'Checklists': []}}",
            "            from FreeTAKServer.controllers.ExCheckControllers.templateToJsonSerializer import templateSerializer",
            "            excheckTemplates = DatabaseController().query_ExCheck()",
            "            for template in excheckTemplates:",
            "                templateData = template.data",
            "                templatejson = {",
            "                    \"filename\": templateData.filename,",
            "                    \"name\": templateData.keywords.name,",
            "                    \"submissionTime\": templateData.submissionTime,",
            "                    \"submitter\": str(",
            "                        dbController.query_user(query=f'uid = \"{template.creatorUid}\"', column=['callsign'])),",
            "                    \"uid\": templateData.uid,",
            "                    \"hash\": templateData.hash,",
            "                    \"size\": templateData.size,",
            "                    \"description\": templateData.keywords.description",
            "                }",
            "                jsondata[\"ExCheck\"]['Templates'].append(templatejson)",
            "            excheckChecklists = DatabaseController().query_ExCheckChecklist()",
            "            for checklist in excheckChecklists:",
            "                try:",
            "                    templatename = checklist.template.data.name",
            "                except AttributeError:",
            "                    templatename = \"template removed\"",
            "                checklistjson = {",
            "                    \"filename\": checklist.filename,",
            "                    \"name\": checklist.name,",
            "                    \"startTime\": datetime.strftime(checklist.startTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"),",
            "                    \"submitter\": checklist.callsign,",
            "                    \"uid\": checklist.uid,",
            "                    \"description\": checklist.description,",
            "                    \"template\": templatename",
            "                }",
            "                jsondata[\"ExCheck\"]['Checklists'].append(checklistjson)",
            "            return json.dumps(jsondata), 200",
            "",
            "        elif request.method == \"DELETE\":",
            "            jsondata = request.data",
            "            ExCheckArray = json.loads(jsondata)[\"ExCheck\"]",
            "            for item in ExCheckArray[\"Templates\"]:",
            "                templateitem = DatabaseController().query_ExCheck(f'ExCheckData.uid = \"{item[\"uid\"]}\"', verbose=True)[0]",
            "                os.remove(str(PurePath(Path(MainConfig.ExCheckFilePath), Path(templateitem.data.filename))))",
            "                DatabaseController().remove_ExCheck(f'PrimaryKey = \"{templateitem.PrimaryKey}\"')",
            "            for item in ExCheckArray[\"Checklists\"]:",
            "                checklistitem = DatabaseController().query_ExCheckChecklist(f'uid = \"{item[\"uid\"]}\"')[0]",
            "                os.remove(str(PurePath(Path(MainConfig.ExCheckChecklistFilePath), Path(checklistitem.filename))))",
            "                DatabaseController().remove_ExCheckChecklist(f'uid = \"{item[\"uid\"]}\"')",
            "            return 'success', 200",
            "        elif request.method == \"POST\":",
            "            try:",
            "                import uuid",
            "                from FreeTAKServer.controllers.ExCheckControllers.templateToJsonSerializer import templateSerializer",
            "                xmlstring = f'<?xml version=\"1.0\"?><event version=\"2.0\" uid=\"{uuid.uuid4()}\" type=\"t-x-m-c\" time=\"2020-11-28T17:45:51.000Z\" start=\"2020-11-28T17:45:51.000Z\" stale=\"2020-11-28T17:46:11.000Z\" how=\"h-g-i-g-o\"><point lat=\"0.00000000\" lon=\"0.00000000\" hae=\"0.00000000\" ce=\"9999999\" le=\"9999999\" /><detail><mission type=\"CHANGE\" tool=\"ExCheck\" name=\"exchecktemplates\" authorUid=\"S-1-5-21-2720623347-3037847324-4167270909-1002\"><MissionChanges><MissionChange><contentResource><filename>61b01475-ad44-4300-addc-a9474ebf67b0.xml</filename><hash>018cd5786bd6c2e603beef30d6a59987b72944a60de9e11562297c35ebdb7fd6</hash><keywords>test init</keywords><keywords>dessc init</keywords><keywords>FEATHER</keywords><mimeType>application/xml</mimeType><name>61b01475-ad44-4300-addc-a9474ebf67b0</name><size>1522</size><submissionTime>2020-11-28T17:45:47.980Z</submissionTime><submitter>wintak</submitter><tool>ExCheck</tool><uid>61b01475-ad44-4300-addc-a9474ebf67b0</uid></contentResource><creatorUid>S-1-5-21-2720623347-3037847324-4167270909-1002</creatorUid><missionName>exchecktemplates</missionName><timestamp>2020-11-28T17:45:47.983Z</timestamp><type>ADD_CONTENT</type></MissionChange></MissionChanges></mission></detail></event>'",
            "                # this is where the client will post the xmi of a template",
            "                from datetime import datetime",
            "                from defusedxml import ElementTree as etree",
            "                import hashlib",
            "                # possibly the uid of the client submitting the template",
            "                authoruid = request.args.get('clientUid')",
            "                if not authoruid:",
            "                    authoruid = 'server-uid'",
            "                XMI = request.data.decode()",
            "                serializer = templateSerializer(XMI)",
            "                object = serializer.convert_template_to_object()",
            "                object.timestamp = datetime.strptime(object.timestamp, \"%Y-%m-%dT%H:%M:%S.%fZ\")",
            "                serializer.create_DB_object(object)",
            "                xml = etree.fromstring(XMI)",
            "                path = str(PurePath(Path(MainConfig.ExCheckFilePath), Path(f'{object.data.uid}.xml')))",
            "                with open(path, 'w+') as file:",
            "                    file.write(XMI)",
            "                    file.close()",
            "",
            "                uid = object.data.uid",
            "                temp = etree.fromstring(XMI)",
            "                cot = etree.fromstring(xmlstring)",
            "                cot.find('detail').find('mission').set(\"authorUid\", authoruid)",
            "                resources = cot.find('detail').find('mission').find('MissionChanges').find('MissionChange').find(",
            "                    'contentResource')",
            "                resources.find('filename').text = temp.find('checklistDetails').find('uid').text + '.xml'",
            "                resources.findall('keywords')[0].text = temp.find('checklistDetails').find('name').text",
            "                resources.findall('keywords')[1].text = temp.find('checklistDetails').find('description').text",
            "                resources.findall('keywords')[2].text = temp.find('checklistDetails').find('creatorCallsign').text",
            "                resources.find('uid').text = temp.find('checklistDetails').find('uid').text",
            "                resources.find('name').text = temp.find('checklistDetails').find('uid').text",
            "                resources.find('size').text = str(len(XMI))",
            "                resources.find('hash').text = str(hashlib.sha256(str(XMI).encode()).hexdigest())",
            "                z = etree.tostring(cot)",
            "                from FreeTAKServer.model.testobj import testobj",
            "                object = testobj()",
            "                object.xmlString = z",
            "                APIPipe.put(object)",
            "                return str(uid), 200",
            "            except Exception as e:",
            "                print(str(e))",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route('/checkStatus', methods=[restMethods.GET])",
            "@auth.login_required()",
            "def check_status():",
            "    try:",
            "",
            "        if request.remote_addr in MainConfig.AllowedCLIIPs:",
            "            CommandPipe.put([functionNames.checkStatus])",
            "            FTSServerStatusObject = CommandPipe.get()",
            "            out = ApplyFullJsonController().serialize_model_to_json(FTSServerStatusObject)",
            "            return json.dumps(out), 200",
            "        else:",
            "            return 'endpoint can only be accessed by approved IPs', 401",
            "    except Exception as e:",
            "        return str(e), 500",
            "",
            "",
            "@app.route('/manageAPI/getHelp', methods=[restMethods.GET])",
            "def help():",
            "    try:",
            "        from flask import url_for",
            "        message = {\"APIVersion\": str(MainConfig.APIVersion),",
            "                   \"SupportedEndpoints\": [url_for(i.endpoint, **(i.defaults or {})) for i in app.url_map.iter_rules() if",
            "                                          i.endpoint != 'static']",
            "                   }",
            "        return json.dumps(message)",
            "    except Exception as e:",
            "        return e, 500",
            "",
            "",
            "# @app.route('/changeStatus', methods=[restMethods.POST])",
            "# @auth.login_required()",
            "def changeStatus(jsonmessage):",
            "    # TODO: modify to better support format",
            "    mappings = {\"on\": \"start\", \"off\": \"stop\", \"\": \"\"}",
            "    try:",
            "        import json",
            "        if not jsonmessage:",
            "            jsonmessage = json.loads(request.data)",
            "        FTSObject = FTS()",
            "        json = jsonmessage[\"services\"]",
            "        ip = jsonmessage.get(\"ip\")",
            "        if jsonVars.COTSERVICE in json:",
            "            CoTService = json[jsonVars.COTSERVICE]",
            "            try:",
            "                FTSObject.CoTService.CoTServicePort = int(CoTService.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.CoTService.CoTServicePort = ''",
            "            FTSObject.CoTService.CoTServiceStatus = mappings[CoTService.get(\"status\")]",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.DATAPACKAGESERVICE in json:",
            "",
            "            DPService = json.get(jsonVars.DATAPACKAGESERVICE)",
            "            try:",
            "                FTSObject.TCPDataPackageService.TCPDataPackageServicePort = int(DPService.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.TCPDataPackageService.TCPDataPackageServicePort = ''",
            "            FTSObject.TCPDataPackageService.TCPDataPackageServiceStatus = mappings[DPService.get(\"status\")]",
            "",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.SSLDATAPACKAGESERVICE in json:",
            "",
            "            DPService = json.get(jsonVars.SSLDATAPACKAGESERVICE)",
            "            try:",
            "                FTSObject.SSLDataPackageService.SSLDataPackageServicePort = int(DPService.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.SSLDataPackageService.SSLDataPackageServicePort = ''",
            "            FTSObject.SSLDataPackageService.SSLDataPackageServiceStatus = mappings[DPService.get(\"status\")]",
            "",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.SSLCOTSERVICE in json:",
            "",
            "            SSLCoTservice = json[jsonVars.SSLCOTSERVICE]",
            "            try:",
            "                FTSObject.SSLCoTService.SSLCoTServicePort = int(SSLCoTservice.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.SSLCoTService.SSLCoTServicePort = ''",
            "            FTSObject.SSLCoTService.SSLCoTServiceStatus = mappings[SSLCoTservice.get(\"status\")]",
            "",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.FEDERATIONSERVERSERVICE in json:",
            "",
            "            FederationServerService = json.get(jsonVars.FEDERATIONSERVERSERVICE)",
            "            try:",
            "                FTSObject.FederationServerService.FederationServerServicePort = int(",
            "                    FederationServerService.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.FederationServerService.FederationServerServicePort = ''",
            "            FTSObject.FederationServerService.FederationServerServiceStatus = mappings[",
            "                FederationServerService.get('status')]",
            "",
            "        else:",
            "            pass",
            "",
            "        if jsonVars.RESTAPISERVICE in json:",
            "",
            "            RESTAPISERVICE = json.get(jsonVars.RESTAPISERVICE)",
            "            try:",
            "                FTSObject.RestAPIService.RestAPIServicePort = int(RESTAPISERVICE.get(jsonVars.PORT))",
            "            except:",
            "                FTSObject.RestAPIService.RestAPIServicePort = ''",
            "            FTSObject.RestAPIService.RestAPIServiceStatus = mappings[RESTAPISERVICE.get(\"status\")]",
            "",
            "        else:",
            "            pass",
            "        FTSObject.SSLDataPackageService.SSLDataPackageServiceIP = ip",
            "        FTSObject.TCPDataPackageService.TCPDataPackageServiceIP = ip",
            "        CommandPipe.put([functionNames.Status, FTSObject])",
            "        out = CommandPipe.get()",
            "        return '200', 200",
            "",
            "    except Exception as e:",
            "        return '500', 500",
            "",
            "",
            "def submitData(dataRaw):",
            "    global APIPipe",
            "    print(APIPipe)",
            "    data = RawCoT()",
            "    data.clientInformation = \"SERVER\"",
            "    data.xmlString = dataRaw.encode()",
            "    APIPipe.put([data])",
            "",
            "",
            "def emitUpdates(Updates):",
            "    data = [SimpleClient()]",
            "    data[0].callsign = ''",
            "    data[0].team = ''",
            "    data[0].ip = ''",
            "    returnValue = []",
            "    for client in data:",
            "        returnValue.append(ApplyFullJsonController().serialize_model_to_json(client))",
            "    socketio.emit('up', json.dumps(returnValue), broadcast=True)",
            "    data = Updates",
            "    for client in data:",
            "        returnValue.append(ApplyFullJsonController().serialize_model_to_json(client))",
            "    socketio.emit('up', json.dumps(returnValue), broadcast=True)",
            "    return 1",
            "",
            "",
            "class RestAPI:",
            "    def __init__(self):",
            "        pass",
            "",
            "    def startup(self, APIPipea, CommandPipea, IP, Port, starttime):",
            "        print('running api')",
            "        global APIPipe, CommandPipe, StartTime",
            "        StartTime = starttime",
            "        APIPipe = APIPipea",
            "        CommandPipe = CommandPipea",
            "        socketio.run(app, host=IP, port=Port)",
            "        # try below if something breaks",
            "        # socketio.run(app, host='0.0.0.0', port=10984, debug=True, use_reloader=False)",
            "",
            "    def serializeJsonToModel(self, model, Json):",
            "        for key, value in Json.items():",
            "            if isinstance(value, dict):",
            "                submodel = getattr(model, key)",
            "                out = self.serializeJsonToModel(submodel, value)",
            "                setattr(model, key, out)",
            "            else:",
            "                setattr(model, key, value)",
            "        return model",
            "",
            "",
            "if __name__ == '__main__':",
            "    excheck_table()",
            "    #    app.run(host=\"127.0.0.1\", port=80)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "74": []
        },
        "addLocation": []
    }
}