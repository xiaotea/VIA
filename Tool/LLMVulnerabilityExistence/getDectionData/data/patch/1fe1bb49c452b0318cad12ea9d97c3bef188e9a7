{
    "Tests/test_imagefont.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1038,
                "afterPatchRowNumber": 1038,
                "PatchRowcode": "     assert_image_equal_tofile(im, \"Tests/images/text_mono.gif\")"
            },
            "1": {
                "beforePatchRowNumber": 1039,
                "afterPatchRowNumber": 1039,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 1040,
                "afterPatchRowNumber": 1040,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1041,
                "PatchRowcode": "+def test_too_many_characters(font):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1042,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1043,
                "PatchRowcode": "+        font.getlength(\"A\" * 1000001)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1044,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1045,
                "PatchRowcode": "+        font.getbbox(\"A\" * 1000001)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1046,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1047,
                "PatchRowcode": "+        font.getmask2(\"A\" * 1000001)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1048,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1049,
                "PatchRowcode": "+    transposed_font = ImageFont.TransposedFont(font)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1050,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1051,
                "PatchRowcode": "+        transposed_font.getlength(\"A\" * 1000001)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1052,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1053,
                "PatchRowcode": "+    default_font = ImageFont.load_default()"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1054,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1055,
                "PatchRowcode": "+        default_font.getlength(\"A\" * 1000001)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1056,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1057,
                "PatchRowcode": "+        default_font.getbbox(\"A\" * 1000001)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1058,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1059,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 1041,
                "afterPatchRowNumber": 1060,
                "PatchRowcode": " @pytest.mark.parametrize("
            },
            "23": {
                "beforePatchRowNumber": 1042,
                "afterPatchRowNumber": 1061,
                "PatchRowcode": "     \"test_file\","
            },
            "24": {
                "beforePatchRowNumber": 1043,
                "afterPatchRowNumber": 1062,
                "PatchRowcode": "     ["
            }
        },
        "frontPatchFile": [
            "import copy",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "from io import BytesIO",
            "",
            "import pytest",
            "from packaging.version import parse as parse_version",
            "",
            "from PIL import Image, ImageDraw, ImageFont, features",
            "",
            "from .helper import (",
            "    assert_image_equal,",
            "    assert_image_equal_tofile,",
            "    assert_image_similar_tofile,",
            "    is_win32,",
            "    skip_unless_feature,",
            "    skip_unless_feature_version,",
            ")",
            "",
            "FONT_PATH = \"Tests/fonts/FreeMono.ttf\"",
            "FONT_SIZE = 20",
            "",
            "TEST_TEXT = \"hey you\\nyou are awesome\\nthis looks awkward\"",
            "",
            "",
            "pytestmark = skip_unless_feature(\"freetype2\")",
            "",
            "",
            "def test_sanity():",
            "    assert re.search(r\"\\d+\\.\\d+\\.\\d+$\", features.version_module(\"freetype2\"))",
            "",
            "",
            "@pytest.fixture(",
            "    scope=\"module\",",
            "    params=[",
            "        pytest.param(ImageFont.Layout.BASIC),",
            "        pytest.param(ImageFont.Layout.RAQM, marks=skip_unless_feature(\"raqm\")),",
            "    ],",
            ")",
            "def layout_engine(request):",
            "    return request.param",
            "",
            "",
            "@pytest.fixture(scope=\"module\")",
            "def font(layout_engine):",
            "    return ImageFont.truetype(FONT_PATH, FONT_SIZE, layout_engine=layout_engine)",
            "",
            "",
            "def test_font_properties(font):",
            "    assert font.path == FONT_PATH",
            "    assert font.size == FONT_SIZE",
            "",
            "    font_copy = font.font_variant()",
            "    assert font_copy.path == FONT_PATH",
            "    assert font_copy.size == FONT_SIZE",
            "",
            "    font_copy = font.font_variant(size=FONT_SIZE + 1)",
            "    assert font_copy.size == FONT_SIZE + 1",
            "",
            "    second_font_path = \"Tests/fonts/DejaVuSans/DejaVuSans.ttf\"",
            "    font_copy = font.font_variant(font=second_font_path)",
            "    assert font_copy.path == second_font_path",
            "",
            "",
            "def _render(font, layout_engine):",
            "    txt = \"Hello World!\"",
            "    ttf = ImageFont.truetype(font, FONT_SIZE, layout_engine=layout_engine)",
            "    ttf.getbbox(txt)",
            "",
            "    img = Image.new(\"RGB\", (256, 64), \"white\")",
            "    d = ImageDraw.Draw(img)",
            "    d.text((10, 10), txt, font=ttf, fill=\"black\")",
            "",
            "    return img",
            "",
            "",
            "def test_font_with_name(layout_engine):",
            "    _render(FONT_PATH, layout_engine)",
            "",
            "",
            "def test_font_with_filelike(layout_engine):",
            "    def _font_as_bytes():",
            "        with open(FONT_PATH, \"rb\") as f:",
            "            font_bytes = BytesIO(f.read())",
            "        return font_bytes",
            "",
            "    ttf = ImageFont.truetype(_font_as_bytes(), FONT_SIZE, layout_engine=layout_engine)",
            "    ttf_copy = ttf.font_variant()",
            "    assert ttf_copy.font_bytes == ttf.font_bytes",
            "",
            "    _render(_font_as_bytes(), layout_engine)",
            "    # Usage note:  making two fonts from the same buffer fails.",
            "    # shared_bytes = _font_as_bytes()",
            "    # _render(shared_bytes)",
            "    # with pytest.raises(Exception):",
            "    #   _render(shared_bytes)",
            "",
            "",
            "def test_font_with_open_file(layout_engine):",
            "    with open(FONT_PATH, \"rb\") as f:",
            "        _render(f, layout_engine)",
            "",
            "",
            "def test_render_equal(layout_engine):",
            "    img_path = _render(FONT_PATH, layout_engine)",
            "    with open(FONT_PATH, \"rb\") as f:",
            "        font_filelike = BytesIO(f.read())",
            "    img_filelike = _render(font_filelike, layout_engine)",
            "",
            "    assert_image_equal(img_path, img_filelike)",
            "",
            "",
            "def test_non_ascii_path(tmp_path, layout_engine):",
            "    tempfile = str(tmp_path / (\"temp_\" + chr(128) + \".ttf\"))",
            "    try:",
            "        shutil.copy(FONT_PATH, tempfile)",
            "    except UnicodeEncodeError:",
            "        pytest.skip(\"Non-ASCII path could not be created\")",
            "",
            "    ImageFont.truetype(tempfile, FONT_SIZE, layout_engine=layout_engine)",
            "",
            "",
            "def test_transparent_background(font):",
            "    im = Image.new(mode=\"RGBA\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    txt = \"Hello World!\"",
            "    draw.text((10, 10), txt, font=font)",
            "",
            "    target = \"Tests/images/transparent_background_text.png\"",
            "    assert_image_similar_tofile(im, target, 4.09)",
            "",
            "    target = \"Tests/images/transparent_background_text_L.png\"",
            "    assert_image_similar_tofile(im.convert(\"L\"), target, 0.01)",
            "",
            "",
            "def test_I16(font):",
            "    im = Image.new(mode=\"I;16\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    txt = \"Hello World!\"",
            "    draw.text((10, 10), txt, font=font)",
            "",
            "    target = \"Tests/images/transparent_background_text_L.png\"",
            "    assert_image_similar_tofile(im.convert(\"L\"), target, 0.01)",
            "",
            "",
            "def test_textbbox_equal(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    txt = \"Hello World!\"",
            "    bbox = draw.textbbox((10, 10), txt, font)",
            "    draw.text((10, 10), txt, font=font)",
            "    draw.rectangle(bbox)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/rectangle_surrounding_text.png\", 2.5)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"text, mode, fontname, size, length_basic, length_raqm\",",
            "    (",
            "        # basic test",
            "        (\"text\", \"L\", \"FreeMono.ttf\", 15, 36, 36),",
            "        (\"text\", \"1\", \"FreeMono.ttf\", 15, 36, 36),",
            "        # issue 4177",
            "        (\"rrr\", \"L\", \"DejaVuSans/DejaVuSans.ttf\", 18, 21, 22.21875),",
            "        (\"rrr\", \"1\", \"DejaVuSans/DejaVuSans.ttf\", 18, 24, 22.21875),",
            "        # test 'l' not including extra margin",
            "        # using exact value 2047 / 64 for raqm, checked with debugger",
            "        (\"ill\", \"L\", \"OpenSansCondensed-LightItalic.ttf\", 63, 33, 31.984375),",
            "        (\"ill\", \"1\", \"OpenSansCondensed-LightItalic.ttf\", 63, 33, 31.984375),",
            "    ),",
            ")",
            "def test_getlength(",
            "    text, mode, fontname, size, layout_engine, length_basic, length_raqm",
            "):",
            "    f = ImageFont.truetype(\"Tests/fonts/\" + fontname, size, layout_engine=layout_engine)",
            "",
            "    im = Image.new(mode, (1, 1), 0)",
            "    d = ImageDraw.Draw(im)",
            "",
            "    if layout_engine == ImageFont.Layout.BASIC:",
            "        length = d.textlength(text, f)",
            "        assert length == length_basic",
            "    else:",
            "        # disable kerning, kerning metrics changed",
            "        length = d.textlength(text, f, features=[\"-kern\"])",
            "        assert length == length_raqm",
            "",
            "",
            "def test_float_size():",
            "    lengths = []",
            "    for size in (48, 48.5, 49):",
            "        f = ImageFont.truetype(",
            "            \"Tests/fonts/NotoSans-Regular.ttf\", size, layout_engine=layout_engine",
            "        )",
            "        lengths.append(f.getlength(\"text\"))",
            "    assert lengths[0] != lengths[1] != lengths[2]",
            "",
            "",
            "def test_render_multiline(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "    line_spacing = font.getbbox(\"A\")[3] + 4",
            "    lines = TEST_TEXT.split(\"\\n\")",
            "    y = 0",
            "    for line in lines:",
            "        draw.text((0, y), line, font=font)",
            "        y += line_spacing",
            "",
            "    # some versions of freetype have different horizontal spacing.",
            "    # setting a tight epsilon, I'm showing the original test failure",
            "    # at epsilon = ~38.",
            "    assert_image_similar_tofile(im, \"Tests/images/multiline_text.png\", 6.2)",
            "",
            "",
            "def test_render_multiline_text(font):",
            "    # Test that text() correctly connects to multiline_text()",
            "    # and that align defaults to left",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "    draw.text((0, 0), TEST_TEXT, font=font)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/multiline_text.png\", 0.01)",
            "",
            "    # Test that text() can pass on additional arguments",
            "    # to multiline_text()",
            "    draw.text(",
            "        (0, 0), TEST_TEXT, fill=None, font=font, anchor=None, spacing=4, align=\"left\"",
            "    )",
            "    draw.text((0, 0), TEST_TEXT, None, font, None, 4, \"left\")",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"align, ext\", ((\"left\", \"\"), (\"center\", \"_center\"), (\"right\", \"_right\"))",
            ")",
            "def test_render_multiline_text_align(font, align, ext):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "    draw.multiline_text((0, 0), TEST_TEXT, font=font, align=align)",
            "",
            "    assert_image_similar_tofile(im, f\"Tests/images/multiline_text{ext}.png\", 0.01)",
            "",
            "",
            "def test_unknown_align(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    # Act/Assert",
            "    with pytest.raises(ValueError):",
            "        draw.multiline_text((0, 0), TEST_TEXT, font=font, align=\"unknown\")",
            "",
            "",
            "def test_draw_align(font):",
            "    im = Image.new(\"RGB\", (300, 100), \"white\")",
            "    draw = ImageDraw.Draw(im)",
            "    line = \"some text\"",
            "    draw.text((100, 40), line, (0, 0, 0), font=font, align=\"left\")",
            "",
            "",
            "def test_multiline_bbox(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    # Test that textbbox() correctly connects to multiline_textbbox()",
            "    assert draw.textbbox((0, 0), TEST_TEXT, font=font) == draw.multiline_textbbox(",
            "        (0, 0), TEST_TEXT, font=font",
            "    )",
            "",
            "    # Test that multiline_textbbox corresponds to ImageFont.textbbox()",
            "    # for single line text",
            "    assert font.getbbox(\"A\") == draw.multiline_textbbox((0, 0), \"A\", font=font)",
            "",
            "    # Test that textbbox() can pass on additional arguments",
            "    # to multiline_textbbox()",
            "    draw.textbbox((0, 0), TEST_TEXT, font=font, spacing=4)",
            "",
            "",
            "def test_multiline_width(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    assert (",
            "        draw.textbbox((0, 0), \"longest line\", font=font)[2]",
            "        == draw.multiline_textbbox((0, 0), \"longest line\\nline\", font=font)[2]",
            "    )",
            "",
            "",
            "def test_multiline_spacing(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "    draw.multiline_text((0, 0), TEST_TEXT, font=font, spacing=10)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/multiline_text_spacing.png\", 2.5)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"orientation\", (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270)",
            ")",
            "def test_rotated_transposed_font(font, orientation):",
            "    img_grey = Image.new(\"L\", (100, 100))",
            "    draw = ImageDraw.Draw(img_grey)",
            "    word = \"testing\"",
            "",
            "    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)",
            "",
            "    # Original font",
            "    draw.font = font",
            "    bbox_a = draw.textbbox((10, 10), word)",
            "",
            "    # Rotated font",
            "    draw.font = transposed_font",
            "    bbox_b = draw.textbbox((20, 20), word)",
            "",
            "    # Check (w, h) of box a is (h, w) of box b",
            "    assert (",
            "        bbox_a[2] - bbox_a[0],",
            "        bbox_a[3] - bbox_a[1],",
            "    ) == (",
            "        bbox_b[3] - bbox_b[1],",
            "        bbox_b[2] - bbox_b[0],",
            "    )",
            "",
            "    # Check top left co-ordinates are correct",
            "    assert bbox_b[:2] == (20, 20)",
            "",
            "    # text length is undefined for vertical text",
            "    with pytest.raises(ValueError):",
            "        draw.textlength(word)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"orientation\",",
            "    (",
            "        None,",
            "        Image.Transpose.ROTATE_180,",
            "        Image.Transpose.FLIP_LEFT_RIGHT,",
            "        Image.Transpose.FLIP_TOP_BOTTOM,",
            "    ),",
            ")",
            "def test_unrotated_transposed_font(font, orientation):",
            "    img_grey = Image.new(\"L\", (100, 100))",
            "    draw = ImageDraw.Draw(img_grey)",
            "    word = \"testing\"",
            "",
            "    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)",
            "",
            "    # Original font",
            "    draw.font = font",
            "    bbox_a = draw.textbbox((10, 10), word)",
            "    length_a = draw.textlength(word)",
            "",
            "    # Rotated font",
            "    draw.font = transposed_font",
            "    bbox_b = draw.textbbox((20, 20), word)",
            "    length_b = draw.textlength(word)",
            "",
            "    # Check boxes a and b are same size",
            "    assert (",
            "        bbox_a[2] - bbox_a[0],",
            "        bbox_a[3] - bbox_a[1],",
            "    ) == (",
            "        bbox_b[2] - bbox_b[0],",
            "        bbox_b[3] - bbox_b[1],",
            "    )",
            "",
            "    # Check top left co-ordinates are correct",
            "    assert bbox_b[:2] == (20, 20)",
            "",
            "    assert length_a == length_b",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"orientation\", (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270)",
            ")",
            "def test_rotated_transposed_font_get_mask(font, orientation):",
            "    # Arrange",
            "    text = \"mask this\"",
            "    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)",
            "",
            "    # Act",
            "    mask = transposed_font.getmask(text)",
            "",
            "    # Assert",
            "    assert mask.size == (13, 108)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"orientation\",",
            "    (",
            "        None,",
            "        Image.Transpose.ROTATE_180,",
            "        Image.Transpose.FLIP_LEFT_RIGHT,",
            "        Image.Transpose.FLIP_TOP_BOTTOM,",
            "    ),",
            ")",
            "def test_unrotated_transposed_font_get_mask(font, orientation):",
            "    # Arrange",
            "    text = \"mask this\"",
            "    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)",
            "",
            "    # Act",
            "    mask = transposed_font.getmask(text)",
            "",
            "    # Assert",
            "    assert mask.size == (108, 13)",
            "",
            "",
            "def test_free_type_font_get_name(font):",
            "    assert (\"FreeMono\", \"Regular\") == font.getname()",
            "",
            "",
            "def test_free_type_font_get_metrics(font):",
            "    ascent, descent = font.getmetrics()",
            "",
            "    assert isinstance(ascent, int)",
            "    assert isinstance(descent, int)",
            "    assert (ascent, descent) == (16, 4)",
            "",
            "",
            "def test_free_type_font_get_mask(font):",
            "    # Arrange",
            "    text = \"mask this\"",
            "",
            "    # Act",
            "    mask = font.getmask(text)",
            "",
            "    # Assert",
            "    assert mask.size == (108, 13)",
            "",
            "",
            "def test_load_path_not_found():",
            "    # Arrange",
            "    filename = \"somefilenamethatdoesntexist.ttf\"",
            "",
            "    # Act/Assert",
            "    with pytest.raises(OSError):",
            "        ImageFont.load_path(filename)",
            "    with pytest.raises(OSError):",
            "        ImageFont.truetype(filename)",
            "",
            "",
            "def test_load_non_font_bytes():",
            "    with open(\"Tests/images/hopper.jpg\", \"rb\") as f:",
            "        with pytest.raises(OSError):",
            "            ImageFont.truetype(f)",
            "",
            "",
            "def test_default_font():",
            "    # Arrange",
            "    txt = 'This is a \"better than nothing\" default font.'",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    # Act",
            "    default_font = ImageFont.load_default()",
            "    draw.text((10, 10), txt, font=default_font)",
            "",
            "    # Assert",
            "    assert_image_equal_tofile(im, \"Tests/images/default_font.png\")",
            "",
            "",
            "@pytest.mark.parametrize(\"mode\", (None, \"1\", \"RGBA\"))",
            "def test_getbbox(font, mode):",
            "    assert (0, 4, 12, 16) == font.getbbox(\"A\", mode)",
            "",
            "",
            "def test_getbbox_empty(font):",
            "    # issue #2614, should not crash.",
            "    assert (0, 0, 0, 0) == font.getbbox(\"\")",
            "",
            "",
            "def test_render_empty(font):",
            "    # issue 2666",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    target = im.copy()",
            "    draw = ImageDraw.Draw(im)",
            "    # should not crash here.",
            "    draw.text((10, 10), \"\", font=font)",
            "    assert_image_equal(im, target)",
            "",
            "",
            "def test_unicode_pilfont():",
            "    # should not segfault, should return UnicodeDecodeError",
            "    # issue #2826",
            "    font = ImageFont.load_default()",
            "    with pytest.raises(UnicodeEncodeError):",
            "        font.getbbox(\"\u2019\")",
            "",
            "",
            "def test_unicode_extended(layout_engine):",
            "    # issue #3777",
            "    text = \"A\\u278A\\U0001F12B\"",
            "    target = \"Tests/images/unicode_extended.png\"",
            "",
            "    ttf = ImageFont.truetype(",
            "        \"Tests/fonts/NotoSansSymbols-Regular.ttf\",",
            "        FONT_SIZE,",
            "        layout_engine=layout_engine,",
            "    )",
            "    img = Image.new(\"RGB\", (100, 60))",
            "    d = ImageDraw.Draw(img)",
            "    d.text((10, 10), text, font=ttf)",
            "",
            "    # fails with 14.7",
            "    assert_image_similar_tofile(img, target, 6.2)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"platform, font_directory\",",
            "    ((\"linux\", \"/usr/local/share/fonts\"), (\"darwin\", \"/System/Library/Fonts\")),",
            ")",
            "@pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\")",
            "def test_find_font(monkeypatch, platform, font_directory):",
            "    def _test_fake_loading_font(path_to_fake, fontname):",
            "        # Make a copy of FreeTypeFont so we can patch the original",
            "        free_type_font = copy.deepcopy(ImageFont.FreeTypeFont)",
            "        with monkeypatch.context() as m:",
            "            m.setattr(ImageFont, \"_FreeTypeFont\", free_type_font, raising=False)",
            "",
            "            def loadable_font(filepath, size, index, encoding, *args, **kwargs):",
            "                if filepath == path_to_fake:",
            "                    return ImageFont._FreeTypeFont(",
            "                        FONT_PATH, size, index, encoding, *args, **kwargs",
            "                    )",
            "                return ImageFont._FreeTypeFont(",
            "                    filepath, size, index, encoding, *args, **kwargs",
            "                )",
            "",
            "            m.setattr(ImageFont, \"FreeTypeFont\", loadable_font)",
            "            font = ImageFont.truetype(fontname)",
            "            # Make sure it's loaded",
            "            name = font.getname()",
            "            assert (\"FreeMono\", \"Regular\") == name",
            "",
            "    # A lot of mocking here - this is more for hitting code and",
            "    # catching syntax like errors",
            "    monkeypatch.setattr(sys, \"platform\", platform)",
            "    if platform == \"linux\":",
            "        monkeypatch.setenv(\"XDG_DATA_DIRS\", \"/usr/share/:/usr/local/share/\")",
            "",
            "    def fake_walker(path):",
            "        if path == font_directory:",
            "            return [",
            "                (",
            "                    path,",
            "                    [],",
            "                    [\"Arial.ttf\", \"Single.otf\", \"Duplicate.otf\", \"Duplicate.ttf\"],",
            "                )",
            "            ]",
            "        return [(path, [], [\"some_random_font.ttf\"])]",
            "",
            "    monkeypatch.setattr(os, \"walk\", fake_walker)",
            "",
            "    # Test that the font loads both with and without the extension",
            "    _test_fake_loading_font(font_directory + \"/Arial.ttf\", \"Arial.ttf\")",
            "    _test_fake_loading_font(font_directory + \"/Arial.ttf\", \"Arial\")",
            "",
            "    # Test that non-ttf fonts can be found without the extension",
            "    _test_fake_loading_font(font_directory + \"/Single.otf\", \"Single\")",
            "",
            "    # Test that ttf fonts are preferred if the extension is not specified",
            "    _test_fake_loading_font(font_directory + \"/Duplicate.ttf\", \"Duplicate\")",
            "",
            "",
            "def test_imagefont_getters(font):",
            "    assert font.getmetrics() == (16, 4)",
            "    assert font.font.ascent == 16",
            "    assert font.font.descent == 4",
            "    assert font.font.height == 20",
            "    assert font.font.x_ppem == 20",
            "    assert font.font.y_ppem == 20",
            "    assert font.font.glyphs == 4177",
            "    assert font.getbbox(\"A\") == (0, 4, 12, 16)",
            "    assert font.getbbox(\"AB\") == (0, 4, 24, 16)",
            "    assert font.getbbox(\"M\") == (0, 4, 12, 16)",
            "    assert font.getbbox(\"y\") == (0, 7, 12, 20)",
            "    assert font.getbbox(\"a\") == (0, 7, 12, 16)",
            "    assert font.getlength(\"A\") == 12",
            "    assert font.getlength(\"AB\") == 24",
            "    assert font.getlength(\"M\") == 12",
            "    assert font.getlength(\"y\") == 12",
            "    assert font.getlength(\"a\") == 12",
            "",
            "",
            "@pytest.mark.parametrize(\"stroke_width\", (0, 2))",
            "def test_getsize_stroke(font, stroke_width):",
            "    assert font.getbbox(\"A\", stroke_width=stroke_width) == (",
            "        0 - stroke_width,",
            "        4 - stroke_width,",
            "        12 + stroke_width,",
            "        16 + stroke_width,",
            "    )",
            "",
            "",
            "def test_complex_font_settings():",
            "    t = ImageFont.truetype(FONT_PATH, FONT_SIZE, layout_engine=ImageFont.Layout.BASIC)",
            "    with pytest.raises(KeyError):",
            "        t.getmask(\"\u0430\u0431\u0432\u0433\", direction=\"rtl\")",
            "    with pytest.raises(KeyError):",
            "        t.getmask(\"\u0430\u0431\u0432\u0433\", features=[\"-kern\"])",
            "    with pytest.raises(KeyError):",
            "        t.getmask(\"\u0430\u0431\u0432\u0433\", language=\"sr\")",
            "",
            "",
            "def test_variation_get(font):",
            "    freetype = parse_version(features.version_module(\"freetype2\"))",
            "    if freetype < parse_version(\"2.9.1\"):",
            "        with pytest.raises(NotImplementedError):",
            "            font.get_variation_names()",
            "        with pytest.raises(NotImplementedError):",
            "            font.get_variation_axes()",
            "        return",
            "",
            "    with pytest.raises(OSError):",
            "        font.get_variation_names()",
            "    with pytest.raises(OSError):",
            "        font.get_variation_axes()",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\")",
            "    assert font.get_variation_names(), [",
            "        b\"ExtraLight\",",
            "        b\"Light\",",
            "        b\"Regular\",",
            "        b\"Semibold\",",
            "        b\"Bold\",",
            "        b\"Black\",",
            "        b\"Black Medium Contrast\",",
            "        b\"Black High Contrast\",",
            "        b\"Default\",",
            "    ]",
            "    assert font.get_variation_axes() == [",
            "        {\"name\": b\"Weight\", \"minimum\": 200, \"maximum\": 900, \"default\": 389},",
            "        {\"name\": b\"Contrast\", \"minimum\": 0, \"maximum\": 100, \"default\": 0},",
            "    ]",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\")",
            "    assert font.get_variation_names() == [",
            "        b\"20\",",
            "        b\"40\",",
            "        b\"60\",",
            "        b\"80\",",
            "        b\"100\",",
            "        b\"120\",",
            "        b\"140\",",
            "        b\"160\",",
            "        b\"180\",",
            "        b\"200\",",
            "        b\"220\",",
            "        b\"240\",",
            "        b\"260\",",
            "        b\"280\",",
            "        b\"300\",",
            "        b\"Regular\",",
            "    ]",
            "    assert font.get_variation_axes() == [",
            "        {\"name\": b\"Size\", \"minimum\": 0, \"maximum\": 300, \"default\": 0}",
            "    ]",
            "",
            "",
            "def _check_text(font, path, epsilon):",
            "    im = Image.new(\"RGB\", (100, 75), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.text((10, 10), \"Text\", font=font, fill=\"black\")",
            "",
            "    try:",
            "        assert_image_similar_tofile(im, path, epsilon)",
            "    except AssertionError:",
            "        if \"_adobe\" in path:",
            "            path = path.replace(\"_adobe\", \"_adobe_older_harfbuzz\")",
            "            assert_image_similar_tofile(im, path, epsilon)",
            "        else:",
            "            raise",
            "",
            "",
            "def test_variation_set_by_name(font):",
            "    freetype = parse_version(features.version_module(\"freetype2\"))",
            "    if freetype < parse_version(\"2.9.1\"):",
            "        with pytest.raises(NotImplementedError):",
            "            font.set_variation_by_name(\"Bold\")",
            "        return",
            "",
            "    with pytest.raises(OSError):",
            "        font.set_variation_by_name(\"Bold\")",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\", 36)",
            "    _check_text(font, \"Tests/images/variation_adobe.png\", 11)",
            "    for name in [\"Bold\", b\"Bold\"]:",
            "        font.set_variation_by_name(name)",
            "        assert font.getname()[1] == \"Bold\"",
            "    _check_text(font, \"Tests/images/variation_adobe_name.png\", 16)",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\", 36)",
            "    _check_text(font, \"Tests/images/variation_tiny.png\", 40)",
            "    for name in [\"200\", b\"200\"]:",
            "        font.set_variation_by_name(name)",
            "        assert font.getname()[1] == \"200\"",
            "    _check_text(font, \"Tests/images/variation_tiny_name.png\", 40)",
            "",
            "",
            "def test_variation_set_by_axes(font):",
            "    freetype = parse_version(features.version_module(\"freetype2\"))",
            "    if freetype < parse_version(\"2.9.1\"):",
            "        with pytest.raises(NotImplementedError):",
            "            font.set_variation_by_axes([100])",
            "        return",
            "",
            "    with pytest.raises(OSError):",
            "        font.set_variation_by_axes([500, 50])",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\", 36)",
            "    font.set_variation_by_axes([500, 50])",
            "    _check_text(font, \"Tests/images/variation_adobe_axes.png\", 11.05)",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\", 36)",
            "    font.set_variation_by_axes([100])",
            "    _check_text(font, \"Tests/images/variation_tiny_axes.png\", 32.5)",
            "",
            "",
            "def test_textbbox_non_freetypefont():",
            "    im = Image.new(\"RGB\", (200, 200))",
            "    d = ImageDraw.Draw(im)",
            "    default_font = ImageFont.load_default()",
            "    assert d.textlength(\"test\", font=default_font) == 24",
            "    assert d.textbbox((0, 0), \"test\", font=default_font) == (0, 0, 24, 11)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"anchor, left, top\",",
            "    (",
            "        # test horizontal anchors",
            "        (\"ls\", 0, -36),",
            "        (\"ms\", -64, -36),",
            "        (\"rs\", -128, -36),",
            "        # test vertical anchors",
            "        (\"ma\", -64, 16),",
            "        (\"mt\", -64, 0),",
            "        (\"mm\", -64, -17),",
            "        (\"mb\", -64, -44),",
            "        (\"md\", -64, -51),",
            "    ),",
            "    ids=(\"ls\", \"ms\", \"rs\", \"ma\", \"mt\", \"mm\", \"mb\", \"md\"),",
            ")",
            "def test_anchor(layout_engine, anchor, left, top):",
            "    name, text = \"quick\", \"Quick\"",
            "    path = f\"Tests/images/test_anchor_{name}_{anchor}.png\"",
            "",
            "    if layout_engine == ImageFont.Layout.RAQM:",
            "        width, height = (129, 44)",
            "    else:",
            "        width, height = (128, 44)",
            "",
            "    bbox_expected = (left, top, left + width, top + height)",
            "",
            "    f = ImageFont.truetype(",
            "        \"Tests/fonts/NotoSans-Regular.ttf\", 48, layout_engine=layout_engine",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (200, 200), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.line(((0, 100), (200, 100)), \"gray\")",
            "    d.line(((100, 0), (100, 200)), \"gray\")",
            "    d.text((100, 100), text, fill=\"black\", anchor=anchor, font=f)",
            "",
            "    assert d.textbbox((0, 0), text, f, anchor=anchor) == bbox_expected",
            "",
            "    assert_image_similar_tofile(im, path, 7)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"anchor, align\",",
            "    (",
            "        # test horizontal anchors",
            "        (\"lm\", \"left\"),",
            "        (\"lm\", \"center\"),",
            "        (\"lm\", \"right\"),",
            "        (\"mm\", \"left\"),",
            "        (\"mm\", \"center\"),",
            "        (\"mm\", \"right\"),",
            "        (\"rm\", \"left\"),",
            "        (\"rm\", \"center\"),",
            "        (\"rm\", \"right\"),",
            "        # test vertical anchors",
            "        (\"ma\", \"center\"),",
            "        # (\"mm\", \"center\"),  # duplicate",
            "        (\"md\", \"center\"),",
            "    ),",
            ")",
            "def test_anchor_multiline(layout_engine, anchor, align):",
            "    target = f\"Tests/images/test_anchor_multiline_{anchor}_{align}.png\"",
            "    text = \"a\\nlong\\ntext sample\"",
            "",
            "    f = ImageFont.truetype(",
            "        \"Tests/fonts/NotoSans-Regular.ttf\", 48, layout_engine=layout_engine",
            "    )",
            "",
            "    # test render",
            "    im = Image.new(\"RGB\", (600, 400), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.line(((0, 200), (600, 200)), \"gray\")",
            "    d.line(((300, 0), (300, 400)), \"gray\")",
            "    d.multiline_text((300, 200), text, fill=\"black\", anchor=anchor, font=f, align=align)",
            "",
            "    assert_image_similar_tofile(im, target, 4)",
            "",
            "",
            "def test_anchor_invalid(font):",
            "    im = Image.new(\"RGB\", (100, 100), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.font = font",
            "",
            "    for anchor in [\"\", \"l\", \"a\", \"lax\", \"sa\", \"xa\", \"lx\"]:",
            "        with pytest.raises(ValueError):",
            "            font.getmask2(\"hello\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            font.getbbox(\"hello\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.text((0, 0), \"hello\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.textbbox((0, 0), \"hello\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.multiline_text((0, 0), \"foo\\nbar\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.multiline_textbbox((0, 0), \"foo\\nbar\", anchor=anchor)",
            "    for anchor in [\"lt\", \"lb\"]:",
            "        with pytest.raises(ValueError):",
            "            d.multiline_text((0, 0), \"foo\\nbar\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.multiline_textbbox((0, 0), \"foo\\nbar\", anchor=anchor)",
            "",
            "",
            "@pytest.mark.parametrize(\"bpp\", (1, 2, 4, 8))",
            "def test_bitmap_font(layout_engine, bpp):",
            "    text = \"Bitmap Font\"",
            "    layout_name = [\"basic\", \"raqm\"][layout_engine]",
            "    target = f\"Tests/images/bitmap_font_{bpp}_{layout_name}.png\"",
            "    font = ImageFont.truetype(",
            "        f\"Tests/fonts/DejaVuSans/DejaVuSans-24-{bpp}-stripped.ttf\",",
            "        24,",
            "        layout_engine=layout_engine,",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (160, 35), \"white\")",
            "    draw = ImageDraw.Draw(im)",
            "    draw.text((2, 2), text, \"black\", font)",
            "",
            "    assert_image_equal_tofile(im, target)",
            "",
            "",
            "def test_bitmap_font_stroke(layout_engine):",
            "    text = \"Bitmap Font\"",
            "    layout_name = [\"basic\", \"raqm\"][layout_engine]",
            "    target = f\"Tests/images/bitmap_font_stroke_{layout_name}.png\"",
            "    font = ImageFont.truetype(",
            "        \"Tests/fonts/DejaVuSans/DejaVuSans-24-8-stripped.ttf\",",
            "        24,",
            "        layout_engine=layout_engine,",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (160, 35), \"white\")",
            "    draw = ImageDraw.Draw(im)",
            "    draw.text((2, 2), text, \"black\", font, stroke_width=2, stroke_fill=\"red\")",
            "",
            "    assert_image_similar_tofile(im, target, 0.03)",
            "",
            "",
            "def test_standard_embedded_color(layout_engine):",
            "    txt = \"Hello World!\"",
            "    ttf = ImageFont.truetype(FONT_PATH, 40, layout_engine=layout_engine)",
            "    ttf.getbbox(txt)",
            "",
            "    im = Image.new(\"RGB\", (300, 64), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.text((10, 10), txt, font=ttf, fill=\"#fa6\", embedded_color=True)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/standard_embedded.png\", 3.1)",
            "",
            "",
            "@pytest.mark.parametrize(\"fontmode\", (\"1\", \"L\", \"RGBA\"))",
            "def test_float_coord(layout_engine, fontmode):",
            "    txt = \"Hello World!\"",
            "    ttf = ImageFont.truetype(FONT_PATH, 40, layout_engine=layout_engine)",
            "",
            "    im = Image.new(\"RGB\", (300, 64), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    if fontmode == \"1\":",
            "        d.fontmode = \"1\"",
            "",
            "    embedded_color = fontmode == \"RGBA\"",
            "    d.text((9.5, 9.5), txt, font=ttf, fill=\"#fa6\", embedded_color=embedded_color)",
            "    try:",
            "        assert_image_similar_tofile(im, \"Tests/images/text_float_coord.png\", 3.9)",
            "    except AssertionError:",
            "        if fontmode == \"1\" and layout_engine == ImageFont.Layout.BASIC:",
            "            assert_image_similar_tofile(",
            "                im, \"Tests/images/text_float_coord_1_alt.png\", 1",
            "            )",
            "        else:",
            "            raise",
            "",
            "",
            "def test_cbdt(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/NotoColorEmoji.ttf\", size=109, layout_engine=layout_engine",
            "        )",
            "",
            "        im = Image.new(\"RGB\", (150, 150), \"white\")",
            "        d = ImageDraw.Draw(im)",
            "",
            "        d.text((10, 10), \"\\U0001f469\", font=font, embedded_color=True)",
            "",
            "        assert_image_similar_tofile(im, \"Tests/images/cbdt_notocoloremoji.png\", 6.2)",
            "    except OSError as e:  # pragma: no cover",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"freetype compiled without libpng or CBDT support\")",
            "",
            "",
            "def test_cbdt_mask(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/NotoColorEmoji.ttf\", size=109, layout_engine=layout_engine",
            "        )",
            "",
            "        im = Image.new(\"RGB\", (150, 150), \"white\")",
            "        d = ImageDraw.Draw(im)",
            "",
            "        d.text((10, 10), \"\\U0001f469\", \"black\", font=font)",
            "",
            "        assert_image_similar_tofile(",
            "            im, \"Tests/images/cbdt_notocoloremoji_mask.png\", 6.2",
            "        )",
            "    except OSError as e:  # pragma: no cover",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"freetype compiled without libpng or CBDT support\")",
            "",
            "",
            "def test_sbix(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/chromacheck-sbix.woff\", size=300, layout_engine=layout_engine",
            "        )",
            "",
            "        im = Image.new(\"RGB\", (400, 400), \"white\")",
            "        d = ImageDraw.Draw(im)",
            "",
            "        d.text((50, 50), \"\\uE901\", font=font, embedded_color=True)",
            "",
            "        assert_image_similar_tofile(im, \"Tests/images/chromacheck-sbix.png\", 1)",
            "    except OSError as e:  # pragma: no cover",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"freetype compiled without libpng or SBIX support\")",
            "",
            "",
            "def test_sbix_mask(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/chromacheck-sbix.woff\", size=300, layout_engine=layout_engine",
            "        )",
            "",
            "        im = Image.new(\"RGB\", (400, 400), \"white\")",
            "        d = ImageDraw.Draw(im)",
            "",
            "        d.text((50, 50), \"\\uE901\", (100, 0, 0), font=font)",
            "",
            "        assert_image_similar_tofile(im, \"Tests/images/chromacheck-sbix_mask.png\", 1)",
            "    except OSError as e:  # pragma: no cover",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"freetype compiled without libpng or SBIX support\")",
            "",
            "",
            "@skip_unless_feature_version(\"freetype2\", \"2.10.0\")",
            "def test_colr(layout_engine):",
            "    font = ImageFont.truetype(",
            "        \"Tests/fonts/BungeeColor-Regular_colr_Windows.ttf\",",
            "        size=64,",
            "        layout_engine=layout_engine,",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (300, 75), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "",
            "    d.text((15, 5), \"Bungee\", font=font, embedded_color=True)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/colr_bungee.png\", 21)",
            "",
            "",
            "@skip_unless_feature_version(\"freetype2\", \"2.10.0\")",
            "def test_colr_mask(layout_engine):",
            "    font = ImageFont.truetype(",
            "        \"Tests/fonts/BungeeColor-Regular_colr_Windows.ttf\",",
            "        size=64,",
            "        layout_engine=layout_engine,",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (300, 75), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "",
            "    d.text((15, 5), \"Bungee\", \"black\", font=font)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/colr_bungee_mask.png\", 22)",
            "",
            "",
            "def test_woff2(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/OpenSans.woff2\",",
            "            size=64,",
            "            layout_engine=layout_engine,",
            "        )",
            "    except OSError as e:",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"FreeType compiled without brotli or WOFF2 support\")",
            "",
            "    im = Image.new(\"RGB\", (350, 100), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "",
            "    d.text((15, 5), \"OpenSans\", \"black\", font=font)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/test_woff2.png\", 5)",
            "",
            "",
            "def test_render_mono_size():",
            "    # issue 4177",
            "",
            "    im = Image.new(\"P\", (100, 30), \"white\")",
            "    draw = ImageDraw.Draw(im)",
            "    ttf = ImageFont.truetype(",
            "        \"Tests/fonts/DejaVuSans/DejaVuSans.ttf\",",
            "        18,",
            "        layout_engine=ImageFont.Layout.BASIC,",
            "    )",
            "",
            "    draw.text((10, 10), \"r\" * 10, \"black\", ttf)",
            "    assert_image_equal_tofile(im, \"Tests/images/text_mono.gif\")",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"test_file\",",
            "    [",
            "        \"Tests/fonts/oom-e8e927ba6c0d38274a37c1567560eb33baf74627.ttf\",",
            "        \"Tests/fonts/oom-4da0210eb7081b0bf15bf16cc4c52ce02c1e1bbc.ttf\",",
            "    ],",
            ")",
            "def test_oom(test_file):",
            "    with open(test_file, \"rb\") as f:",
            "        font = ImageFont.truetype(BytesIO(f.read()))",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            font.getmask(\"Test Text\")",
            "",
            "",
            "def test_raqm_missing_warning(monkeypatch):",
            "    monkeypatch.setattr(ImageFont.core, \"HAVE_RAQM\", False)",
            "    with pytest.warns(UserWarning) as record:",
            "        font = ImageFont.truetype(",
            "            FONT_PATH, FONT_SIZE, layout_engine=ImageFont.Layout.RAQM",
            "        )",
            "    assert font.layout_engine == ImageFont.Layout.BASIC",
            "    assert str(record[-1].message) == (",
            "        \"Raqm layout was requested, but Raqm is not available. \"",
            "        \"Falling back to basic layout.\"",
            "    )"
        ],
        "afterPatchFile": [
            "import copy",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "from io import BytesIO",
            "",
            "import pytest",
            "from packaging.version import parse as parse_version",
            "",
            "from PIL import Image, ImageDraw, ImageFont, features",
            "",
            "from .helper import (",
            "    assert_image_equal,",
            "    assert_image_equal_tofile,",
            "    assert_image_similar_tofile,",
            "    is_win32,",
            "    skip_unless_feature,",
            "    skip_unless_feature_version,",
            ")",
            "",
            "FONT_PATH = \"Tests/fonts/FreeMono.ttf\"",
            "FONT_SIZE = 20",
            "",
            "TEST_TEXT = \"hey you\\nyou are awesome\\nthis looks awkward\"",
            "",
            "",
            "pytestmark = skip_unless_feature(\"freetype2\")",
            "",
            "",
            "def test_sanity():",
            "    assert re.search(r\"\\d+\\.\\d+\\.\\d+$\", features.version_module(\"freetype2\"))",
            "",
            "",
            "@pytest.fixture(",
            "    scope=\"module\",",
            "    params=[",
            "        pytest.param(ImageFont.Layout.BASIC),",
            "        pytest.param(ImageFont.Layout.RAQM, marks=skip_unless_feature(\"raqm\")),",
            "    ],",
            ")",
            "def layout_engine(request):",
            "    return request.param",
            "",
            "",
            "@pytest.fixture(scope=\"module\")",
            "def font(layout_engine):",
            "    return ImageFont.truetype(FONT_PATH, FONT_SIZE, layout_engine=layout_engine)",
            "",
            "",
            "def test_font_properties(font):",
            "    assert font.path == FONT_PATH",
            "    assert font.size == FONT_SIZE",
            "",
            "    font_copy = font.font_variant()",
            "    assert font_copy.path == FONT_PATH",
            "    assert font_copy.size == FONT_SIZE",
            "",
            "    font_copy = font.font_variant(size=FONT_SIZE + 1)",
            "    assert font_copy.size == FONT_SIZE + 1",
            "",
            "    second_font_path = \"Tests/fonts/DejaVuSans/DejaVuSans.ttf\"",
            "    font_copy = font.font_variant(font=second_font_path)",
            "    assert font_copy.path == second_font_path",
            "",
            "",
            "def _render(font, layout_engine):",
            "    txt = \"Hello World!\"",
            "    ttf = ImageFont.truetype(font, FONT_SIZE, layout_engine=layout_engine)",
            "    ttf.getbbox(txt)",
            "",
            "    img = Image.new(\"RGB\", (256, 64), \"white\")",
            "    d = ImageDraw.Draw(img)",
            "    d.text((10, 10), txt, font=ttf, fill=\"black\")",
            "",
            "    return img",
            "",
            "",
            "def test_font_with_name(layout_engine):",
            "    _render(FONT_PATH, layout_engine)",
            "",
            "",
            "def test_font_with_filelike(layout_engine):",
            "    def _font_as_bytes():",
            "        with open(FONT_PATH, \"rb\") as f:",
            "            font_bytes = BytesIO(f.read())",
            "        return font_bytes",
            "",
            "    ttf = ImageFont.truetype(_font_as_bytes(), FONT_SIZE, layout_engine=layout_engine)",
            "    ttf_copy = ttf.font_variant()",
            "    assert ttf_copy.font_bytes == ttf.font_bytes",
            "",
            "    _render(_font_as_bytes(), layout_engine)",
            "    # Usage note:  making two fonts from the same buffer fails.",
            "    # shared_bytes = _font_as_bytes()",
            "    # _render(shared_bytes)",
            "    # with pytest.raises(Exception):",
            "    #   _render(shared_bytes)",
            "",
            "",
            "def test_font_with_open_file(layout_engine):",
            "    with open(FONT_PATH, \"rb\") as f:",
            "        _render(f, layout_engine)",
            "",
            "",
            "def test_render_equal(layout_engine):",
            "    img_path = _render(FONT_PATH, layout_engine)",
            "    with open(FONT_PATH, \"rb\") as f:",
            "        font_filelike = BytesIO(f.read())",
            "    img_filelike = _render(font_filelike, layout_engine)",
            "",
            "    assert_image_equal(img_path, img_filelike)",
            "",
            "",
            "def test_non_ascii_path(tmp_path, layout_engine):",
            "    tempfile = str(tmp_path / (\"temp_\" + chr(128) + \".ttf\"))",
            "    try:",
            "        shutil.copy(FONT_PATH, tempfile)",
            "    except UnicodeEncodeError:",
            "        pytest.skip(\"Non-ASCII path could not be created\")",
            "",
            "    ImageFont.truetype(tempfile, FONT_SIZE, layout_engine=layout_engine)",
            "",
            "",
            "def test_transparent_background(font):",
            "    im = Image.new(mode=\"RGBA\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    txt = \"Hello World!\"",
            "    draw.text((10, 10), txt, font=font)",
            "",
            "    target = \"Tests/images/transparent_background_text.png\"",
            "    assert_image_similar_tofile(im, target, 4.09)",
            "",
            "    target = \"Tests/images/transparent_background_text_L.png\"",
            "    assert_image_similar_tofile(im.convert(\"L\"), target, 0.01)",
            "",
            "",
            "def test_I16(font):",
            "    im = Image.new(mode=\"I;16\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    txt = \"Hello World!\"",
            "    draw.text((10, 10), txt, font=font)",
            "",
            "    target = \"Tests/images/transparent_background_text_L.png\"",
            "    assert_image_similar_tofile(im.convert(\"L\"), target, 0.01)",
            "",
            "",
            "def test_textbbox_equal(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    txt = \"Hello World!\"",
            "    bbox = draw.textbbox((10, 10), txt, font)",
            "    draw.text((10, 10), txt, font=font)",
            "    draw.rectangle(bbox)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/rectangle_surrounding_text.png\", 2.5)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"text, mode, fontname, size, length_basic, length_raqm\",",
            "    (",
            "        # basic test",
            "        (\"text\", \"L\", \"FreeMono.ttf\", 15, 36, 36),",
            "        (\"text\", \"1\", \"FreeMono.ttf\", 15, 36, 36),",
            "        # issue 4177",
            "        (\"rrr\", \"L\", \"DejaVuSans/DejaVuSans.ttf\", 18, 21, 22.21875),",
            "        (\"rrr\", \"1\", \"DejaVuSans/DejaVuSans.ttf\", 18, 24, 22.21875),",
            "        # test 'l' not including extra margin",
            "        # using exact value 2047 / 64 for raqm, checked with debugger",
            "        (\"ill\", \"L\", \"OpenSansCondensed-LightItalic.ttf\", 63, 33, 31.984375),",
            "        (\"ill\", \"1\", \"OpenSansCondensed-LightItalic.ttf\", 63, 33, 31.984375),",
            "    ),",
            ")",
            "def test_getlength(",
            "    text, mode, fontname, size, layout_engine, length_basic, length_raqm",
            "):",
            "    f = ImageFont.truetype(\"Tests/fonts/\" + fontname, size, layout_engine=layout_engine)",
            "",
            "    im = Image.new(mode, (1, 1), 0)",
            "    d = ImageDraw.Draw(im)",
            "",
            "    if layout_engine == ImageFont.Layout.BASIC:",
            "        length = d.textlength(text, f)",
            "        assert length == length_basic",
            "    else:",
            "        # disable kerning, kerning metrics changed",
            "        length = d.textlength(text, f, features=[\"-kern\"])",
            "        assert length == length_raqm",
            "",
            "",
            "def test_float_size():",
            "    lengths = []",
            "    for size in (48, 48.5, 49):",
            "        f = ImageFont.truetype(",
            "            \"Tests/fonts/NotoSans-Regular.ttf\", size, layout_engine=layout_engine",
            "        )",
            "        lengths.append(f.getlength(\"text\"))",
            "    assert lengths[0] != lengths[1] != lengths[2]",
            "",
            "",
            "def test_render_multiline(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "    line_spacing = font.getbbox(\"A\")[3] + 4",
            "    lines = TEST_TEXT.split(\"\\n\")",
            "    y = 0",
            "    for line in lines:",
            "        draw.text((0, y), line, font=font)",
            "        y += line_spacing",
            "",
            "    # some versions of freetype have different horizontal spacing.",
            "    # setting a tight epsilon, I'm showing the original test failure",
            "    # at epsilon = ~38.",
            "    assert_image_similar_tofile(im, \"Tests/images/multiline_text.png\", 6.2)",
            "",
            "",
            "def test_render_multiline_text(font):",
            "    # Test that text() correctly connects to multiline_text()",
            "    # and that align defaults to left",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "    draw.text((0, 0), TEST_TEXT, font=font)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/multiline_text.png\", 0.01)",
            "",
            "    # Test that text() can pass on additional arguments",
            "    # to multiline_text()",
            "    draw.text(",
            "        (0, 0), TEST_TEXT, fill=None, font=font, anchor=None, spacing=4, align=\"left\"",
            "    )",
            "    draw.text((0, 0), TEST_TEXT, None, font, None, 4, \"left\")",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"align, ext\", ((\"left\", \"\"), (\"center\", \"_center\"), (\"right\", \"_right\"))",
            ")",
            "def test_render_multiline_text_align(font, align, ext):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "    draw.multiline_text((0, 0), TEST_TEXT, font=font, align=align)",
            "",
            "    assert_image_similar_tofile(im, f\"Tests/images/multiline_text{ext}.png\", 0.01)",
            "",
            "",
            "def test_unknown_align(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    # Act/Assert",
            "    with pytest.raises(ValueError):",
            "        draw.multiline_text((0, 0), TEST_TEXT, font=font, align=\"unknown\")",
            "",
            "",
            "def test_draw_align(font):",
            "    im = Image.new(\"RGB\", (300, 100), \"white\")",
            "    draw = ImageDraw.Draw(im)",
            "    line = \"some text\"",
            "    draw.text((100, 40), line, (0, 0, 0), font=font, align=\"left\")",
            "",
            "",
            "def test_multiline_bbox(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    # Test that textbbox() correctly connects to multiline_textbbox()",
            "    assert draw.textbbox((0, 0), TEST_TEXT, font=font) == draw.multiline_textbbox(",
            "        (0, 0), TEST_TEXT, font=font",
            "    )",
            "",
            "    # Test that multiline_textbbox corresponds to ImageFont.textbbox()",
            "    # for single line text",
            "    assert font.getbbox(\"A\") == draw.multiline_textbbox((0, 0), \"A\", font=font)",
            "",
            "    # Test that textbbox() can pass on additional arguments",
            "    # to multiline_textbbox()",
            "    draw.textbbox((0, 0), TEST_TEXT, font=font, spacing=4)",
            "",
            "",
            "def test_multiline_width(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    assert (",
            "        draw.textbbox((0, 0), \"longest line\", font=font)[2]",
            "        == draw.multiline_textbbox((0, 0), \"longest line\\nline\", font=font)[2]",
            "    )",
            "",
            "",
            "def test_multiline_spacing(font):",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "    draw.multiline_text((0, 0), TEST_TEXT, font=font, spacing=10)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/multiline_text_spacing.png\", 2.5)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"orientation\", (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270)",
            ")",
            "def test_rotated_transposed_font(font, orientation):",
            "    img_grey = Image.new(\"L\", (100, 100))",
            "    draw = ImageDraw.Draw(img_grey)",
            "    word = \"testing\"",
            "",
            "    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)",
            "",
            "    # Original font",
            "    draw.font = font",
            "    bbox_a = draw.textbbox((10, 10), word)",
            "",
            "    # Rotated font",
            "    draw.font = transposed_font",
            "    bbox_b = draw.textbbox((20, 20), word)",
            "",
            "    # Check (w, h) of box a is (h, w) of box b",
            "    assert (",
            "        bbox_a[2] - bbox_a[0],",
            "        bbox_a[3] - bbox_a[1],",
            "    ) == (",
            "        bbox_b[3] - bbox_b[1],",
            "        bbox_b[2] - bbox_b[0],",
            "    )",
            "",
            "    # Check top left co-ordinates are correct",
            "    assert bbox_b[:2] == (20, 20)",
            "",
            "    # text length is undefined for vertical text",
            "    with pytest.raises(ValueError):",
            "        draw.textlength(word)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"orientation\",",
            "    (",
            "        None,",
            "        Image.Transpose.ROTATE_180,",
            "        Image.Transpose.FLIP_LEFT_RIGHT,",
            "        Image.Transpose.FLIP_TOP_BOTTOM,",
            "    ),",
            ")",
            "def test_unrotated_transposed_font(font, orientation):",
            "    img_grey = Image.new(\"L\", (100, 100))",
            "    draw = ImageDraw.Draw(img_grey)",
            "    word = \"testing\"",
            "",
            "    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)",
            "",
            "    # Original font",
            "    draw.font = font",
            "    bbox_a = draw.textbbox((10, 10), word)",
            "    length_a = draw.textlength(word)",
            "",
            "    # Rotated font",
            "    draw.font = transposed_font",
            "    bbox_b = draw.textbbox((20, 20), word)",
            "    length_b = draw.textlength(word)",
            "",
            "    # Check boxes a and b are same size",
            "    assert (",
            "        bbox_a[2] - bbox_a[0],",
            "        bbox_a[3] - bbox_a[1],",
            "    ) == (",
            "        bbox_b[2] - bbox_b[0],",
            "        bbox_b[3] - bbox_b[1],",
            "    )",
            "",
            "    # Check top left co-ordinates are correct",
            "    assert bbox_b[:2] == (20, 20)",
            "",
            "    assert length_a == length_b",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"orientation\", (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270)",
            ")",
            "def test_rotated_transposed_font_get_mask(font, orientation):",
            "    # Arrange",
            "    text = \"mask this\"",
            "    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)",
            "",
            "    # Act",
            "    mask = transposed_font.getmask(text)",
            "",
            "    # Assert",
            "    assert mask.size == (13, 108)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"orientation\",",
            "    (",
            "        None,",
            "        Image.Transpose.ROTATE_180,",
            "        Image.Transpose.FLIP_LEFT_RIGHT,",
            "        Image.Transpose.FLIP_TOP_BOTTOM,",
            "    ),",
            ")",
            "def test_unrotated_transposed_font_get_mask(font, orientation):",
            "    # Arrange",
            "    text = \"mask this\"",
            "    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)",
            "",
            "    # Act",
            "    mask = transposed_font.getmask(text)",
            "",
            "    # Assert",
            "    assert mask.size == (108, 13)",
            "",
            "",
            "def test_free_type_font_get_name(font):",
            "    assert (\"FreeMono\", \"Regular\") == font.getname()",
            "",
            "",
            "def test_free_type_font_get_metrics(font):",
            "    ascent, descent = font.getmetrics()",
            "",
            "    assert isinstance(ascent, int)",
            "    assert isinstance(descent, int)",
            "    assert (ascent, descent) == (16, 4)",
            "",
            "",
            "def test_free_type_font_get_mask(font):",
            "    # Arrange",
            "    text = \"mask this\"",
            "",
            "    # Act",
            "    mask = font.getmask(text)",
            "",
            "    # Assert",
            "    assert mask.size == (108, 13)",
            "",
            "",
            "def test_load_path_not_found():",
            "    # Arrange",
            "    filename = \"somefilenamethatdoesntexist.ttf\"",
            "",
            "    # Act/Assert",
            "    with pytest.raises(OSError):",
            "        ImageFont.load_path(filename)",
            "    with pytest.raises(OSError):",
            "        ImageFont.truetype(filename)",
            "",
            "",
            "def test_load_non_font_bytes():",
            "    with open(\"Tests/images/hopper.jpg\", \"rb\") as f:",
            "        with pytest.raises(OSError):",
            "            ImageFont.truetype(f)",
            "",
            "",
            "def test_default_font():",
            "    # Arrange",
            "    txt = 'This is a \"better than nothing\" default font.'",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    draw = ImageDraw.Draw(im)",
            "",
            "    # Act",
            "    default_font = ImageFont.load_default()",
            "    draw.text((10, 10), txt, font=default_font)",
            "",
            "    # Assert",
            "    assert_image_equal_tofile(im, \"Tests/images/default_font.png\")",
            "",
            "",
            "@pytest.mark.parametrize(\"mode\", (None, \"1\", \"RGBA\"))",
            "def test_getbbox(font, mode):",
            "    assert (0, 4, 12, 16) == font.getbbox(\"A\", mode)",
            "",
            "",
            "def test_getbbox_empty(font):",
            "    # issue #2614, should not crash.",
            "    assert (0, 0, 0, 0) == font.getbbox(\"\")",
            "",
            "",
            "def test_render_empty(font):",
            "    # issue 2666",
            "    im = Image.new(mode=\"RGB\", size=(300, 100))",
            "    target = im.copy()",
            "    draw = ImageDraw.Draw(im)",
            "    # should not crash here.",
            "    draw.text((10, 10), \"\", font=font)",
            "    assert_image_equal(im, target)",
            "",
            "",
            "def test_unicode_pilfont():",
            "    # should not segfault, should return UnicodeDecodeError",
            "    # issue #2826",
            "    font = ImageFont.load_default()",
            "    with pytest.raises(UnicodeEncodeError):",
            "        font.getbbox(\"\u2019\")",
            "",
            "",
            "def test_unicode_extended(layout_engine):",
            "    # issue #3777",
            "    text = \"A\\u278A\\U0001F12B\"",
            "    target = \"Tests/images/unicode_extended.png\"",
            "",
            "    ttf = ImageFont.truetype(",
            "        \"Tests/fonts/NotoSansSymbols-Regular.ttf\",",
            "        FONT_SIZE,",
            "        layout_engine=layout_engine,",
            "    )",
            "    img = Image.new(\"RGB\", (100, 60))",
            "    d = ImageDraw.Draw(img)",
            "    d.text((10, 10), text, font=ttf)",
            "",
            "    # fails with 14.7",
            "    assert_image_similar_tofile(img, target, 6.2)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"platform, font_directory\",",
            "    ((\"linux\", \"/usr/local/share/fonts\"), (\"darwin\", \"/System/Library/Fonts\")),",
            ")",
            "@pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\")",
            "def test_find_font(monkeypatch, platform, font_directory):",
            "    def _test_fake_loading_font(path_to_fake, fontname):",
            "        # Make a copy of FreeTypeFont so we can patch the original",
            "        free_type_font = copy.deepcopy(ImageFont.FreeTypeFont)",
            "        with monkeypatch.context() as m:",
            "            m.setattr(ImageFont, \"_FreeTypeFont\", free_type_font, raising=False)",
            "",
            "            def loadable_font(filepath, size, index, encoding, *args, **kwargs):",
            "                if filepath == path_to_fake:",
            "                    return ImageFont._FreeTypeFont(",
            "                        FONT_PATH, size, index, encoding, *args, **kwargs",
            "                    )",
            "                return ImageFont._FreeTypeFont(",
            "                    filepath, size, index, encoding, *args, **kwargs",
            "                )",
            "",
            "            m.setattr(ImageFont, \"FreeTypeFont\", loadable_font)",
            "            font = ImageFont.truetype(fontname)",
            "            # Make sure it's loaded",
            "            name = font.getname()",
            "            assert (\"FreeMono\", \"Regular\") == name",
            "",
            "    # A lot of mocking here - this is more for hitting code and",
            "    # catching syntax like errors",
            "    monkeypatch.setattr(sys, \"platform\", platform)",
            "    if platform == \"linux\":",
            "        monkeypatch.setenv(\"XDG_DATA_DIRS\", \"/usr/share/:/usr/local/share/\")",
            "",
            "    def fake_walker(path):",
            "        if path == font_directory:",
            "            return [",
            "                (",
            "                    path,",
            "                    [],",
            "                    [\"Arial.ttf\", \"Single.otf\", \"Duplicate.otf\", \"Duplicate.ttf\"],",
            "                )",
            "            ]",
            "        return [(path, [], [\"some_random_font.ttf\"])]",
            "",
            "    monkeypatch.setattr(os, \"walk\", fake_walker)",
            "",
            "    # Test that the font loads both with and without the extension",
            "    _test_fake_loading_font(font_directory + \"/Arial.ttf\", \"Arial.ttf\")",
            "    _test_fake_loading_font(font_directory + \"/Arial.ttf\", \"Arial\")",
            "",
            "    # Test that non-ttf fonts can be found without the extension",
            "    _test_fake_loading_font(font_directory + \"/Single.otf\", \"Single\")",
            "",
            "    # Test that ttf fonts are preferred if the extension is not specified",
            "    _test_fake_loading_font(font_directory + \"/Duplicate.ttf\", \"Duplicate\")",
            "",
            "",
            "def test_imagefont_getters(font):",
            "    assert font.getmetrics() == (16, 4)",
            "    assert font.font.ascent == 16",
            "    assert font.font.descent == 4",
            "    assert font.font.height == 20",
            "    assert font.font.x_ppem == 20",
            "    assert font.font.y_ppem == 20",
            "    assert font.font.glyphs == 4177",
            "    assert font.getbbox(\"A\") == (0, 4, 12, 16)",
            "    assert font.getbbox(\"AB\") == (0, 4, 24, 16)",
            "    assert font.getbbox(\"M\") == (0, 4, 12, 16)",
            "    assert font.getbbox(\"y\") == (0, 7, 12, 20)",
            "    assert font.getbbox(\"a\") == (0, 7, 12, 16)",
            "    assert font.getlength(\"A\") == 12",
            "    assert font.getlength(\"AB\") == 24",
            "    assert font.getlength(\"M\") == 12",
            "    assert font.getlength(\"y\") == 12",
            "    assert font.getlength(\"a\") == 12",
            "",
            "",
            "@pytest.mark.parametrize(\"stroke_width\", (0, 2))",
            "def test_getsize_stroke(font, stroke_width):",
            "    assert font.getbbox(\"A\", stroke_width=stroke_width) == (",
            "        0 - stroke_width,",
            "        4 - stroke_width,",
            "        12 + stroke_width,",
            "        16 + stroke_width,",
            "    )",
            "",
            "",
            "def test_complex_font_settings():",
            "    t = ImageFont.truetype(FONT_PATH, FONT_SIZE, layout_engine=ImageFont.Layout.BASIC)",
            "    with pytest.raises(KeyError):",
            "        t.getmask(\"\u0430\u0431\u0432\u0433\", direction=\"rtl\")",
            "    with pytest.raises(KeyError):",
            "        t.getmask(\"\u0430\u0431\u0432\u0433\", features=[\"-kern\"])",
            "    with pytest.raises(KeyError):",
            "        t.getmask(\"\u0430\u0431\u0432\u0433\", language=\"sr\")",
            "",
            "",
            "def test_variation_get(font):",
            "    freetype = parse_version(features.version_module(\"freetype2\"))",
            "    if freetype < parse_version(\"2.9.1\"):",
            "        with pytest.raises(NotImplementedError):",
            "            font.get_variation_names()",
            "        with pytest.raises(NotImplementedError):",
            "            font.get_variation_axes()",
            "        return",
            "",
            "    with pytest.raises(OSError):",
            "        font.get_variation_names()",
            "    with pytest.raises(OSError):",
            "        font.get_variation_axes()",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\")",
            "    assert font.get_variation_names(), [",
            "        b\"ExtraLight\",",
            "        b\"Light\",",
            "        b\"Regular\",",
            "        b\"Semibold\",",
            "        b\"Bold\",",
            "        b\"Black\",",
            "        b\"Black Medium Contrast\",",
            "        b\"Black High Contrast\",",
            "        b\"Default\",",
            "    ]",
            "    assert font.get_variation_axes() == [",
            "        {\"name\": b\"Weight\", \"minimum\": 200, \"maximum\": 900, \"default\": 389},",
            "        {\"name\": b\"Contrast\", \"minimum\": 0, \"maximum\": 100, \"default\": 0},",
            "    ]",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\")",
            "    assert font.get_variation_names() == [",
            "        b\"20\",",
            "        b\"40\",",
            "        b\"60\",",
            "        b\"80\",",
            "        b\"100\",",
            "        b\"120\",",
            "        b\"140\",",
            "        b\"160\",",
            "        b\"180\",",
            "        b\"200\",",
            "        b\"220\",",
            "        b\"240\",",
            "        b\"260\",",
            "        b\"280\",",
            "        b\"300\",",
            "        b\"Regular\",",
            "    ]",
            "    assert font.get_variation_axes() == [",
            "        {\"name\": b\"Size\", \"minimum\": 0, \"maximum\": 300, \"default\": 0}",
            "    ]",
            "",
            "",
            "def _check_text(font, path, epsilon):",
            "    im = Image.new(\"RGB\", (100, 75), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.text((10, 10), \"Text\", font=font, fill=\"black\")",
            "",
            "    try:",
            "        assert_image_similar_tofile(im, path, epsilon)",
            "    except AssertionError:",
            "        if \"_adobe\" in path:",
            "            path = path.replace(\"_adobe\", \"_adobe_older_harfbuzz\")",
            "            assert_image_similar_tofile(im, path, epsilon)",
            "        else:",
            "            raise",
            "",
            "",
            "def test_variation_set_by_name(font):",
            "    freetype = parse_version(features.version_module(\"freetype2\"))",
            "    if freetype < parse_version(\"2.9.1\"):",
            "        with pytest.raises(NotImplementedError):",
            "            font.set_variation_by_name(\"Bold\")",
            "        return",
            "",
            "    with pytest.raises(OSError):",
            "        font.set_variation_by_name(\"Bold\")",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\", 36)",
            "    _check_text(font, \"Tests/images/variation_adobe.png\", 11)",
            "    for name in [\"Bold\", b\"Bold\"]:",
            "        font.set_variation_by_name(name)",
            "        assert font.getname()[1] == \"Bold\"",
            "    _check_text(font, \"Tests/images/variation_adobe_name.png\", 16)",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\", 36)",
            "    _check_text(font, \"Tests/images/variation_tiny.png\", 40)",
            "    for name in [\"200\", b\"200\"]:",
            "        font.set_variation_by_name(name)",
            "        assert font.getname()[1] == \"200\"",
            "    _check_text(font, \"Tests/images/variation_tiny_name.png\", 40)",
            "",
            "",
            "def test_variation_set_by_axes(font):",
            "    freetype = parse_version(features.version_module(\"freetype2\"))",
            "    if freetype < parse_version(\"2.9.1\"):",
            "        with pytest.raises(NotImplementedError):",
            "            font.set_variation_by_axes([100])",
            "        return",
            "",
            "    with pytest.raises(OSError):",
            "        font.set_variation_by_axes([500, 50])",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\", 36)",
            "    font.set_variation_by_axes([500, 50])",
            "    _check_text(font, \"Tests/images/variation_adobe_axes.png\", 11.05)",
            "",
            "    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\", 36)",
            "    font.set_variation_by_axes([100])",
            "    _check_text(font, \"Tests/images/variation_tiny_axes.png\", 32.5)",
            "",
            "",
            "def test_textbbox_non_freetypefont():",
            "    im = Image.new(\"RGB\", (200, 200))",
            "    d = ImageDraw.Draw(im)",
            "    default_font = ImageFont.load_default()",
            "    assert d.textlength(\"test\", font=default_font) == 24",
            "    assert d.textbbox((0, 0), \"test\", font=default_font) == (0, 0, 24, 11)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"anchor, left, top\",",
            "    (",
            "        # test horizontal anchors",
            "        (\"ls\", 0, -36),",
            "        (\"ms\", -64, -36),",
            "        (\"rs\", -128, -36),",
            "        # test vertical anchors",
            "        (\"ma\", -64, 16),",
            "        (\"mt\", -64, 0),",
            "        (\"mm\", -64, -17),",
            "        (\"mb\", -64, -44),",
            "        (\"md\", -64, -51),",
            "    ),",
            "    ids=(\"ls\", \"ms\", \"rs\", \"ma\", \"mt\", \"mm\", \"mb\", \"md\"),",
            ")",
            "def test_anchor(layout_engine, anchor, left, top):",
            "    name, text = \"quick\", \"Quick\"",
            "    path = f\"Tests/images/test_anchor_{name}_{anchor}.png\"",
            "",
            "    if layout_engine == ImageFont.Layout.RAQM:",
            "        width, height = (129, 44)",
            "    else:",
            "        width, height = (128, 44)",
            "",
            "    bbox_expected = (left, top, left + width, top + height)",
            "",
            "    f = ImageFont.truetype(",
            "        \"Tests/fonts/NotoSans-Regular.ttf\", 48, layout_engine=layout_engine",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (200, 200), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.line(((0, 100), (200, 100)), \"gray\")",
            "    d.line(((100, 0), (100, 200)), \"gray\")",
            "    d.text((100, 100), text, fill=\"black\", anchor=anchor, font=f)",
            "",
            "    assert d.textbbox((0, 0), text, f, anchor=anchor) == bbox_expected",
            "",
            "    assert_image_similar_tofile(im, path, 7)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"anchor, align\",",
            "    (",
            "        # test horizontal anchors",
            "        (\"lm\", \"left\"),",
            "        (\"lm\", \"center\"),",
            "        (\"lm\", \"right\"),",
            "        (\"mm\", \"left\"),",
            "        (\"mm\", \"center\"),",
            "        (\"mm\", \"right\"),",
            "        (\"rm\", \"left\"),",
            "        (\"rm\", \"center\"),",
            "        (\"rm\", \"right\"),",
            "        # test vertical anchors",
            "        (\"ma\", \"center\"),",
            "        # (\"mm\", \"center\"),  # duplicate",
            "        (\"md\", \"center\"),",
            "    ),",
            ")",
            "def test_anchor_multiline(layout_engine, anchor, align):",
            "    target = f\"Tests/images/test_anchor_multiline_{anchor}_{align}.png\"",
            "    text = \"a\\nlong\\ntext sample\"",
            "",
            "    f = ImageFont.truetype(",
            "        \"Tests/fonts/NotoSans-Regular.ttf\", 48, layout_engine=layout_engine",
            "    )",
            "",
            "    # test render",
            "    im = Image.new(\"RGB\", (600, 400), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.line(((0, 200), (600, 200)), \"gray\")",
            "    d.line(((300, 0), (300, 400)), \"gray\")",
            "    d.multiline_text((300, 200), text, fill=\"black\", anchor=anchor, font=f, align=align)",
            "",
            "    assert_image_similar_tofile(im, target, 4)",
            "",
            "",
            "def test_anchor_invalid(font):",
            "    im = Image.new(\"RGB\", (100, 100), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.font = font",
            "",
            "    for anchor in [\"\", \"l\", \"a\", \"lax\", \"sa\", \"xa\", \"lx\"]:",
            "        with pytest.raises(ValueError):",
            "            font.getmask2(\"hello\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            font.getbbox(\"hello\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.text((0, 0), \"hello\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.textbbox((0, 0), \"hello\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.multiline_text((0, 0), \"foo\\nbar\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.multiline_textbbox((0, 0), \"foo\\nbar\", anchor=anchor)",
            "    for anchor in [\"lt\", \"lb\"]:",
            "        with pytest.raises(ValueError):",
            "            d.multiline_text((0, 0), \"foo\\nbar\", anchor=anchor)",
            "        with pytest.raises(ValueError):",
            "            d.multiline_textbbox((0, 0), \"foo\\nbar\", anchor=anchor)",
            "",
            "",
            "@pytest.mark.parametrize(\"bpp\", (1, 2, 4, 8))",
            "def test_bitmap_font(layout_engine, bpp):",
            "    text = \"Bitmap Font\"",
            "    layout_name = [\"basic\", \"raqm\"][layout_engine]",
            "    target = f\"Tests/images/bitmap_font_{bpp}_{layout_name}.png\"",
            "    font = ImageFont.truetype(",
            "        f\"Tests/fonts/DejaVuSans/DejaVuSans-24-{bpp}-stripped.ttf\",",
            "        24,",
            "        layout_engine=layout_engine,",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (160, 35), \"white\")",
            "    draw = ImageDraw.Draw(im)",
            "    draw.text((2, 2), text, \"black\", font)",
            "",
            "    assert_image_equal_tofile(im, target)",
            "",
            "",
            "def test_bitmap_font_stroke(layout_engine):",
            "    text = \"Bitmap Font\"",
            "    layout_name = [\"basic\", \"raqm\"][layout_engine]",
            "    target = f\"Tests/images/bitmap_font_stroke_{layout_name}.png\"",
            "    font = ImageFont.truetype(",
            "        \"Tests/fonts/DejaVuSans/DejaVuSans-24-8-stripped.ttf\",",
            "        24,",
            "        layout_engine=layout_engine,",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (160, 35), \"white\")",
            "    draw = ImageDraw.Draw(im)",
            "    draw.text((2, 2), text, \"black\", font, stroke_width=2, stroke_fill=\"red\")",
            "",
            "    assert_image_similar_tofile(im, target, 0.03)",
            "",
            "",
            "def test_standard_embedded_color(layout_engine):",
            "    txt = \"Hello World!\"",
            "    ttf = ImageFont.truetype(FONT_PATH, 40, layout_engine=layout_engine)",
            "    ttf.getbbox(txt)",
            "",
            "    im = Image.new(\"RGB\", (300, 64), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    d.text((10, 10), txt, font=ttf, fill=\"#fa6\", embedded_color=True)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/standard_embedded.png\", 3.1)",
            "",
            "",
            "@pytest.mark.parametrize(\"fontmode\", (\"1\", \"L\", \"RGBA\"))",
            "def test_float_coord(layout_engine, fontmode):",
            "    txt = \"Hello World!\"",
            "    ttf = ImageFont.truetype(FONT_PATH, 40, layout_engine=layout_engine)",
            "",
            "    im = Image.new(\"RGB\", (300, 64), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "    if fontmode == \"1\":",
            "        d.fontmode = \"1\"",
            "",
            "    embedded_color = fontmode == \"RGBA\"",
            "    d.text((9.5, 9.5), txt, font=ttf, fill=\"#fa6\", embedded_color=embedded_color)",
            "    try:",
            "        assert_image_similar_tofile(im, \"Tests/images/text_float_coord.png\", 3.9)",
            "    except AssertionError:",
            "        if fontmode == \"1\" and layout_engine == ImageFont.Layout.BASIC:",
            "            assert_image_similar_tofile(",
            "                im, \"Tests/images/text_float_coord_1_alt.png\", 1",
            "            )",
            "        else:",
            "            raise",
            "",
            "",
            "def test_cbdt(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/NotoColorEmoji.ttf\", size=109, layout_engine=layout_engine",
            "        )",
            "",
            "        im = Image.new(\"RGB\", (150, 150), \"white\")",
            "        d = ImageDraw.Draw(im)",
            "",
            "        d.text((10, 10), \"\\U0001f469\", font=font, embedded_color=True)",
            "",
            "        assert_image_similar_tofile(im, \"Tests/images/cbdt_notocoloremoji.png\", 6.2)",
            "    except OSError as e:  # pragma: no cover",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"freetype compiled without libpng or CBDT support\")",
            "",
            "",
            "def test_cbdt_mask(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/NotoColorEmoji.ttf\", size=109, layout_engine=layout_engine",
            "        )",
            "",
            "        im = Image.new(\"RGB\", (150, 150), \"white\")",
            "        d = ImageDraw.Draw(im)",
            "",
            "        d.text((10, 10), \"\\U0001f469\", \"black\", font=font)",
            "",
            "        assert_image_similar_tofile(",
            "            im, \"Tests/images/cbdt_notocoloremoji_mask.png\", 6.2",
            "        )",
            "    except OSError as e:  # pragma: no cover",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"freetype compiled without libpng or CBDT support\")",
            "",
            "",
            "def test_sbix(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/chromacheck-sbix.woff\", size=300, layout_engine=layout_engine",
            "        )",
            "",
            "        im = Image.new(\"RGB\", (400, 400), \"white\")",
            "        d = ImageDraw.Draw(im)",
            "",
            "        d.text((50, 50), \"\\uE901\", font=font, embedded_color=True)",
            "",
            "        assert_image_similar_tofile(im, \"Tests/images/chromacheck-sbix.png\", 1)",
            "    except OSError as e:  # pragma: no cover",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"freetype compiled without libpng or SBIX support\")",
            "",
            "",
            "def test_sbix_mask(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/chromacheck-sbix.woff\", size=300, layout_engine=layout_engine",
            "        )",
            "",
            "        im = Image.new(\"RGB\", (400, 400), \"white\")",
            "        d = ImageDraw.Draw(im)",
            "",
            "        d.text((50, 50), \"\\uE901\", (100, 0, 0), font=font)",
            "",
            "        assert_image_similar_tofile(im, \"Tests/images/chromacheck-sbix_mask.png\", 1)",
            "    except OSError as e:  # pragma: no cover",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"freetype compiled without libpng or SBIX support\")",
            "",
            "",
            "@skip_unless_feature_version(\"freetype2\", \"2.10.0\")",
            "def test_colr(layout_engine):",
            "    font = ImageFont.truetype(",
            "        \"Tests/fonts/BungeeColor-Regular_colr_Windows.ttf\",",
            "        size=64,",
            "        layout_engine=layout_engine,",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (300, 75), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "",
            "    d.text((15, 5), \"Bungee\", font=font, embedded_color=True)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/colr_bungee.png\", 21)",
            "",
            "",
            "@skip_unless_feature_version(\"freetype2\", \"2.10.0\")",
            "def test_colr_mask(layout_engine):",
            "    font = ImageFont.truetype(",
            "        \"Tests/fonts/BungeeColor-Regular_colr_Windows.ttf\",",
            "        size=64,",
            "        layout_engine=layout_engine,",
            "    )",
            "",
            "    im = Image.new(\"RGB\", (300, 75), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "",
            "    d.text((15, 5), \"Bungee\", \"black\", font=font)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/colr_bungee_mask.png\", 22)",
            "",
            "",
            "def test_woff2(layout_engine):",
            "    try:",
            "        font = ImageFont.truetype(",
            "            \"Tests/fonts/OpenSans.woff2\",",
            "            size=64,",
            "            layout_engine=layout_engine,",
            "        )",
            "    except OSError as e:",
            "        assert str(e) in (\"unimplemented feature\", \"unknown file format\")",
            "        pytest.skip(\"FreeType compiled without brotli or WOFF2 support\")",
            "",
            "    im = Image.new(\"RGB\", (350, 100), \"white\")",
            "    d = ImageDraw.Draw(im)",
            "",
            "    d.text((15, 5), \"OpenSans\", \"black\", font=font)",
            "",
            "    assert_image_similar_tofile(im, \"Tests/images/test_woff2.png\", 5)",
            "",
            "",
            "def test_render_mono_size():",
            "    # issue 4177",
            "",
            "    im = Image.new(\"P\", (100, 30), \"white\")",
            "    draw = ImageDraw.Draw(im)",
            "    ttf = ImageFont.truetype(",
            "        \"Tests/fonts/DejaVuSans/DejaVuSans.ttf\",",
            "        18,",
            "        layout_engine=ImageFont.Layout.BASIC,",
            "    )",
            "",
            "    draw.text((10, 10), \"r\" * 10, \"black\", ttf)",
            "    assert_image_equal_tofile(im, \"Tests/images/text_mono.gif\")",
            "",
            "",
            "def test_too_many_characters(font):",
            "    with pytest.raises(ValueError):",
            "        font.getlength(\"A\" * 1000001)",
            "    with pytest.raises(ValueError):",
            "        font.getbbox(\"A\" * 1000001)",
            "    with pytest.raises(ValueError):",
            "        font.getmask2(\"A\" * 1000001)",
            "",
            "    transposed_font = ImageFont.TransposedFont(font)",
            "    with pytest.raises(ValueError):",
            "        transposed_font.getlength(\"A\" * 1000001)",
            "",
            "    default_font = ImageFont.load_default()",
            "    with pytest.raises(ValueError):",
            "        default_font.getlength(\"A\" * 1000001)",
            "    with pytest.raises(ValueError):",
            "        default_font.getbbox(\"A\" * 1000001)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"test_file\",",
            "    [",
            "        \"Tests/fonts/oom-e8e927ba6c0d38274a37c1567560eb33baf74627.ttf\",",
            "        \"Tests/fonts/oom-4da0210eb7081b0bf15bf16cc4c52ce02c1e1bbc.ttf\",",
            "    ],",
            ")",
            "def test_oom(test_file):",
            "    with open(test_file, \"rb\") as f:",
            "        font = ImageFont.truetype(BytesIO(f.read()))",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            font.getmask(\"Test Text\")",
            "",
            "",
            "def test_raqm_missing_warning(monkeypatch):",
            "    monkeypatch.setattr(ImageFont.core, \"HAVE_RAQM\", False)",
            "    with pytest.warns(UserWarning) as record:",
            "        font = ImageFont.truetype(",
            "            FONT_PATH, FONT_SIZE, layout_engine=ImageFont.Layout.RAQM",
            "        )",
            "    assert font.layout_engine == ImageFont.Layout.BASIC",
            "    assert str(record[-1].message) == (",
            "        \"Raqm layout was requested, but Raqm is not available. \"",
            "        \"Falling back to basic layout.\"",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "src/PIL/ImageFont.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     RAQM = 1"
            },
            "1": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+MAX_STRING_LENGTH = 1000000"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " try:"
            },
            "7": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     from . import _imagingft as core"
            },
            "8": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " except ImportError as ex:"
            },
            "9": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     core = DeferredError(ex)"
            },
            "10": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+def _string_length_check(text):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    if MAX_STRING_LENGTH is not None and len(text) > MAX_STRING_LENGTH:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        msg = \"too many characters in string\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        raise ValueError(msg)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " # FIXME: add support for pilfont2 format (see FontFile.py)"
            },
            "19": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " # --------------------------------------------------------------------"
            },
            "21": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         :return: ``(left, top, right, bottom)`` bounding box"
            },
            "23": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         \"\"\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        _string_length_check(text)"
            },
            "25": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         width, height = self.font.getsize(text)"
            },
            "26": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         return 0, 0, width, height"
            },
            "27": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         .. versionadded:: 9.2.0"
            },
            "30": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         \"\"\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        _string_length_check(text)"
            },
            "32": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         width, height = self.font.getsize(text)"
            },
            "33": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         return width"
            },
            "34": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 320,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "         :return: Width for horizontal, height for vertical text."
            },
            "37": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 322,
                "PatchRowcode": "         \"\"\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+        _string_length_check(text)"
            },
            "39": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "         return self.font.getlength(text, mode, direction, features, language) / 64"
            },
            "40": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 325,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "     def getbbox("
            },
            "42": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 380,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "         :return: ``(left, top, right, bottom)`` bounding box"
            },
            "44": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "         \"\"\""
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+        _string_length_check(text)"
            },
            "46": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "         size, offset = self.font.getsize("
            },
            "47": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "             text, mode, direction, features, language, anchor"
            },
            "48": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "         )"
            },
            "49": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 559,
                "PatchRowcode": "                  :py:mod:`PIL.Image.core` interface module, and the text offset, the"
            },
            "50": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 560,
                "PatchRowcode": "                  gap between the starting coordinate and the first marking"
            },
            "51": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": 561,
                "PatchRowcode": "         \"\"\""
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 562,
                "PatchRowcode": "+        _string_length_check(text)"
            },
            "53": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": 563,
                "PatchRowcode": "         if start is None:"
            },
            "54": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 564,
                "PatchRowcode": "             start = (0, 0)"
            },
            "55": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 565,
                "PatchRowcode": "         im, size, offset = self.font.render("
            },
            "56": {
                "beforePatchRowNumber": 684,
                "afterPatchRowNumber": 698,
                "PatchRowcode": "         if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):"
            },
            "57": {
                "beforePatchRowNumber": 685,
                "afterPatchRowNumber": 699,
                "PatchRowcode": "             msg = \"text length is undefined for text rotated by 90 or 270 degrees\""
            },
            "58": {
                "beforePatchRowNumber": 686,
                "afterPatchRowNumber": 700,
                "PatchRowcode": "             raise ValueError(msg)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 701,
                "PatchRowcode": "+        _string_length_check(text)"
            },
            "60": {
                "beforePatchRowNumber": 687,
                "afterPatchRowNumber": 702,
                "PatchRowcode": "         return self.font.getlength(text, *args, **kwargs)"
            },
            "61": {
                "beforePatchRowNumber": 688,
                "afterPatchRowNumber": 703,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 689,
                "afterPatchRowNumber": 704,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# PIL raster font management",
            "#",
            "# History:",
            "# 1996-08-07 fl   created (experimental)",
            "# 1997-08-25 fl   minor adjustments to handle fonts from pilfont 0.3",
            "# 1999-02-06 fl   rewrote most font management stuff in C",
            "# 1999-03-17 fl   take pth files into account in load_path (from Richard Jones)",
            "# 2001-02-17 fl   added freetype support",
            "# 2001-05-09 fl   added TransposedFont wrapper class",
            "# 2002-03-04 fl   make sure we have a \"L\" or \"1\" font",
            "# 2002-12-04 fl   skip non-directory entries in the system path",
            "# 2003-04-29 fl   add embedded default font",
            "# 2003-09-27 fl   added support for truetype charmap encodings",
            "#",
            "# Todo:",
            "# Adapt to PILFONT2 format (16-bit fonts, compressed, single file)",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB",
            "# Copyright (c) 1996-2003 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import base64",
            "import os",
            "import sys",
            "import warnings",
            "from enum import IntEnum",
            "from io import BytesIO",
            "",
            "from . import Image",
            "from ._util import is_directory, is_path",
            "",
            "",
            "class Layout(IntEnum):",
            "    BASIC = 0",
            "    RAQM = 1",
            "",
            "",
            "try:",
            "    from . import _imagingft as core",
            "except ImportError as ex:",
            "    from ._util import DeferredError",
            "",
            "    core = DeferredError(ex)",
            "",
            "",
            "# FIXME: add support for pilfont2 format (see FontFile.py)",
            "",
            "# --------------------------------------------------------------------",
            "# Font metrics format:",
            "#       \"PILfont\" LF",
            "#       fontdescriptor LF",
            "#       (optional) key=value... LF",
            "#       \"DATA\" LF",
            "#       binary data: 256*10*2 bytes (dx, dy, dstbox, srcbox)",
            "#",
            "# To place a character, cut out srcbox and paste at dstbox,",
            "# relative to the character position.  Then move the character",
            "# position according to dx, dy.",
            "# --------------------------------------------------------------------",
            "",
            "",
            "class ImageFont:",
            "    \"\"\"PIL font wrapper\"\"\"",
            "",
            "    def _load_pilfont(self, filename):",
            "        with open(filename, \"rb\") as fp:",
            "            image = None",
            "            for ext in (\".png\", \".gif\", \".pbm\"):",
            "                if image:",
            "                    image.close()",
            "                try:",
            "                    fullname = os.path.splitext(filename)[0] + ext",
            "                    image = Image.open(fullname)",
            "                except Exception:",
            "                    pass",
            "                else:",
            "                    if image and image.mode in (\"1\", \"L\"):",
            "                        break",
            "            else:",
            "                if image:",
            "                    image.close()",
            "                msg = \"cannot find glyph data file\"",
            "                raise OSError(msg)",
            "",
            "            self.file = fullname",
            "",
            "            self._load_pilfont_data(fp, image)",
            "            image.close()",
            "",
            "    def _load_pilfont_data(self, file, image):",
            "        # read PILfont header",
            "        if file.readline() != b\"PILfont\\n\":",
            "            msg = \"Not a PILfont file\"",
            "            raise SyntaxError(msg)",
            "        file.readline().split(b\";\")",
            "        self.info = []  # FIXME: should be a dictionary",
            "        while True:",
            "            s = file.readline()",
            "            if not s or s == b\"DATA\\n\":",
            "                break",
            "            self.info.append(s)",
            "",
            "        # read PILfont metrics",
            "        data = file.read(256 * 20)",
            "",
            "        # check image",
            "        if image.mode not in (\"1\", \"L\"):",
            "            msg = \"invalid font image mode\"",
            "            raise TypeError(msg)",
            "",
            "        image.load()",
            "",
            "        self.font = Image.core.font(image.im, data)",
            "",
            "    def getmask(self, text, mode=\"\", *args, **kwargs):",
            "        \"\"\"",
            "        Create a bitmap for the text.",
            "",
            "        If the font uses antialiasing, the bitmap should have mode ``L`` and use a",
            "        maximum value of 255. Otherwise, it should have mode ``1``.",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "                     .. versionadded:: 1.1.5",
            "",
            "        :return: An internal PIL storage memory instance as defined by the",
            "                 :py:mod:`PIL.Image.core` interface module.",
            "        \"\"\"",
            "        return self.font.getmask(text, mode)",
            "",
            "    def getbbox(self, text, *args, **kwargs):",
            "        \"\"\"",
            "        Returns bounding box (in pixels) of given text.",
            "",
            "        .. versionadded:: 9.2.0",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "        :return: ``(left, top, right, bottom)`` bounding box",
            "        \"\"\"",
            "        width, height = self.font.getsize(text)",
            "        return 0, 0, width, height",
            "",
            "    def getlength(self, text, *args, **kwargs):",
            "        \"\"\"",
            "        Returns length (in pixels) of given text.",
            "        This is the amount by which following text should be offset.",
            "",
            "        .. versionadded:: 9.2.0",
            "        \"\"\"",
            "        width, height = self.font.getsize(text)",
            "        return width",
            "",
            "",
            "##",
            "# Wrapper for FreeType fonts.  Application code should use the",
            "# <b>truetype</b> factory function to create font objects.",
            "",
            "",
            "class FreeTypeFont:",
            "    \"\"\"FreeType font wrapper (requires _imagingft service)\"\"\"",
            "",
            "    def __init__(self, font=None, size=10, index=0, encoding=\"\", layout_engine=None):",
            "        # FIXME: use service provider instead",
            "",
            "        self.path = font",
            "        self.size = size",
            "        self.index = index",
            "        self.encoding = encoding",
            "",
            "        if layout_engine not in (Layout.BASIC, Layout.RAQM):",
            "            layout_engine = Layout.BASIC",
            "            if core.HAVE_RAQM:",
            "                layout_engine = Layout.RAQM",
            "        elif layout_engine == Layout.RAQM and not core.HAVE_RAQM:",
            "            warnings.warn(",
            "                \"Raqm layout was requested, but Raqm is not available. \"",
            "                \"Falling back to basic layout.\"",
            "            )",
            "            layout_engine = Layout.BASIC",
            "",
            "        self.layout_engine = layout_engine",
            "",
            "        def load_from_bytes(f):",
            "            self.font_bytes = f.read()",
            "            self.font = core.getfont(",
            "                \"\", size, index, encoding, self.font_bytes, layout_engine",
            "            )",
            "",
            "        if is_path(font):",
            "            if sys.platform == \"win32\":",
            "                font_bytes_path = font if isinstance(font, bytes) else font.encode()",
            "                try:",
            "                    font_bytes_path.decode(\"ascii\")",
            "                except UnicodeDecodeError:",
            "                    # FreeType cannot load fonts with non-ASCII characters on Windows",
            "                    # So load it into memory first",
            "                    with open(font, \"rb\") as f:",
            "                        load_from_bytes(f)",
            "                    return",
            "            self.font = core.getfont(",
            "                font, size, index, encoding, layout_engine=layout_engine",
            "            )",
            "        else:",
            "            load_from_bytes(font)",
            "",
            "    def __getstate__(self):",
            "        return [self.path, self.size, self.index, self.encoding, self.layout_engine]",
            "",
            "    def __setstate__(self, state):",
            "        path, size, index, encoding, layout_engine = state",
            "        self.__init__(path, size, index, encoding, layout_engine)",
            "",
            "    def getname(self):",
            "        \"\"\"",
            "        :return: A tuple of the font family (e.g. Helvetica) and the font style",
            "            (e.g. Bold)",
            "        \"\"\"",
            "        return self.font.family, self.font.style",
            "",
            "    def getmetrics(self):",
            "        \"\"\"",
            "        :return: A tuple of the font ascent (the distance from the baseline to",
            "            the highest outline point) and descent (the distance from the",
            "            baseline to the lowest outline point, a negative value)",
            "        \"\"\"",
            "        return self.font.ascent, self.font.descent",
            "",
            "    def getlength(self, text, mode=\"\", direction=None, features=None, language=None):",
            "        \"\"\"",
            "        Returns length (in pixels with 1/64 precision) of given text when rendered",
            "        in font with provided direction, features, and language.",
            "",
            "        This is the amount by which following text should be offset.",
            "        Text bounding box may extend past the length in some fonts,",
            "        e.g. when using italics or accents.",
            "",
            "        The result is returned as a float; it is a whole number if using basic layout.",
            "",
            "        Note that the sum of two lengths may not equal the length of a concatenated",
            "        string due to kerning. If you need to adjust for kerning, include the following",
            "        character and subtract its length.",
            "",
            "        For example, instead of ::",
            "",
            "          hello = font.getlength(\"Hello\")",
            "          world = font.getlength(\"World\")",
            "          hello_world = hello + world  # not adjusted for kerning",
            "          assert hello_world == font.getlength(\"HelloWorld\")  # may fail",
            "",
            "        use ::",
            "",
            "          hello = font.getlength(\"HelloW\") - font.getlength(\"W\")  # adjusted for kerning",
            "          world = font.getlength(\"World\")",
            "          hello_world = hello + world  # adjusted for kerning",
            "          assert hello_world == font.getlength(\"HelloWorld\")  # True",
            "",
            "        or disable kerning with (requires libraqm) ::",
            "",
            "          hello = draw.textlength(\"Hello\", font, features=[\"-kern\"])",
            "          world = draw.textlength(\"World\", font, features=[\"-kern\"])",
            "          hello_world = hello + world  # kerning is disabled, no need to adjust",
            "          assert hello_world == draw.textlength(\"HelloWorld\", font, features=[\"-kern\"])",
            "",
            "        .. versionadded:: 8.0.0",
            "",
            "        :param text: Text to measure.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "        :param direction: Direction of the text. It can be 'rtl' (right to",
            "                          left), 'ltr' (left to right) or 'ttb' (top to bottom).",
            "                          Requires libraqm.",
            "",
            "        :param features: A list of OpenType font features to be used during text",
            "                         layout. This is usually used to turn on optional",
            "                         font features that are not enabled by default,",
            "                         for example 'dlig' or 'ss01', but can be also",
            "                         used to turn off default font features for",
            "                         example '-liga' to disable ligatures or '-kern'",
            "                         to disable kerning.  To get all supported",
            "                         features, see",
            "                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist",
            "                         Requires libraqm.",
            "",
            "        :param language: Language of the text. Different languages may use",
            "                         different glyph shapes or ligatures. This parameter tells",
            "                         the font which language the text is in, and to apply the",
            "                         correct substitutions as appropriate, if available.",
            "                         It should be a `BCP 47 language code",
            "                         <https://www.w3.org/International/articles/language-tags/>`_",
            "                         Requires libraqm.",
            "",
            "        :return: Width for horizontal, height for vertical text.",
            "        \"\"\"",
            "        return self.font.getlength(text, mode, direction, features, language) / 64",
            "",
            "    def getbbox(",
            "        self,",
            "        text,",
            "        mode=\"\",",
            "        direction=None,",
            "        features=None,",
            "        language=None,",
            "        stroke_width=0,",
            "        anchor=None,",
            "    ):",
            "        \"\"\"",
            "        Returns bounding box (in pixels) of given text relative to given anchor",
            "        when rendered in font with provided direction, features, and language.",
            "",
            "        Use :py:meth:`getlength()` to get the offset of following text with",
            "        1/64 pixel precision. The bounding box includes extra margins for",
            "        some fonts, e.g. italics or accents.",
            "",
            "        .. versionadded:: 8.0.0",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "        :param direction: Direction of the text. It can be 'rtl' (right to",
            "                          left), 'ltr' (left to right) or 'ttb' (top to bottom).",
            "                          Requires libraqm.",
            "",
            "        :param features: A list of OpenType font features to be used during text",
            "                         layout. This is usually used to turn on optional",
            "                         font features that are not enabled by default,",
            "                         for example 'dlig' or 'ss01', but can be also",
            "                         used to turn off default font features for",
            "                         example '-liga' to disable ligatures or '-kern'",
            "                         to disable kerning.  To get all supported",
            "                         features, see",
            "                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist",
            "                         Requires libraqm.",
            "",
            "        :param language: Language of the text. Different languages may use",
            "                         different glyph shapes or ligatures. This parameter tells",
            "                         the font which language the text is in, and to apply the",
            "                         correct substitutions as appropriate, if available.",
            "                         It should be a `BCP 47 language code",
            "                         <https://www.w3.org/International/articles/language-tags/>`_",
            "                         Requires libraqm.",
            "",
            "        :param stroke_width: The width of the text stroke.",
            "",
            "        :param anchor:  The text anchor alignment. Determines the relative location of",
            "                        the anchor to the text. The default alignment is top left.",
            "                        See :ref:`text-anchors` for valid values.",
            "",
            "        :return: ``(left, top, right, bottom)`` bounding box",
            "        \"\"\"",
            "        size, offset = self.font.getsize(",
            "            text, mode, direction, features, language, anchor",
            "        )",
            "        left, top = offset[0] - stroke_width, offset[1] - stroke_width",
            "        width, height = size[0] + 2 * stroke_width, size[1] + 2 * stroke_width",
            "        return left, top, left + width, top + height",
            "",
            "    def getmask(",
            "        self,",
            "        text,",
            "        mode=\"\",",
            "        direction=None,",
            "        features=None,",
            "        language=None,",
            "        stroke_width=0,",
            "        anchor=None,",
            "        ink=0,",
            "        start=None,",
            "    ):",
            "        \"\"\"",
            "        Create a bitmap for the text.",
            "",
            "        If the font uses antialiasing, the bitmap should have mode ``L`` and use a",
            "        maximum value of 255. If the font has embedded color data, the bitmap",
            "        should have mode ``RGBA``. Otherwise, it should have mode ``1``.",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "                     .. versionadded:: 1.1.5",
            "",
            "        :param direction: Direction of the text. It can be 'rtl' (right to",
            "                          left), 'ltr' (left to right) or 'ttb' (top to bottom).",
            "                          Requires libraqm.",
            "",
            "                          .. versionadded:: 4.2.0",
            "",
            "        :param features: A list of OpenType font features to be used during text",
            "                         layout. This is usually used to turn on optional",
            "                         font features that are not enabled by default,",
            "                         for example 'dlig' or 'ss01', but can be also",
            "                         used to turn off default font features for",
            "                         example '-liga' to disable ligatures or '-kern'",
            "                         to disable kerning.  To get all supported",
            "                         features, see",
            "                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist",
            "                         Requires libraqm.",
            "",
            "                         .. versionadded:: 4.2.0",
            "",
            "        :param language: Language of the text. Different languages may use",
            "                         different glyph shapes or ligatures. This parameter tells",
            "                         the font which language the text is in, and to apply the",
            "                         correct substitutions as appropriate, if available.",
            "                         It should be a `BCP 47 language code",
            "                         <https://www.w3.org/International/articles/language-tags/>`_",
            "                         Requires libraqm.",
            "",
            "                         .. versionadded:: 6.0.0",
            "",
            "        :param stroke_width: The width of the text stroke.",
            "",
            "                         .. versionadded:: 6.2.0",
            "",
            "        :param anchor:  The text anchor alignment. Determines the relative location of",
            "                        the anchor to the text. The default alignment is top left.",
            "                        See :ref:`text-anchors` for valid values.",
            "",
            "                         .. versionadded:: 8.0.0",
            "",
            "        :param ink: Foreground ink for rendering in RGBA mode.",
            "",
            "                         .. versionadded:: 8.0.0",
            "",
            "        :param start: Tuple of horizontal and vertical offset, as text may render",
            "                      differently when starting at fractional coordinates.",
            "",
            "                         .. versionadded:: 9.4.0",
            "",
            "        :return: An internal PIL storage memory instance as defined by the",
            "                 :py:mod:`PIL.Image.core` interface module.",
            "        \"\"\"",
            "        return self.getmask2(",
            "            text,",
            "            mode,",
            "            direction=direction,",
            "            features=features,",
            "            language=language,",
            "            stroke_width=stroke_width,",
            "            anchor=anchor,",
            "            ink=ink,",
            "            start=start,",
            "        )[0]",
            "",
            "    def getmask2(",
            "        self,",
            "        text,",
            "        mode=\"\",",
            "        direction=None,",
            "        features=None,",
            "        language=None,",
            "        stroke_width=0,",
            "        anchor=None,",
            "        ink=0,",
            "        start=None,",
            "        *args,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Create a bitmap for the text.",
            "",
            "        If the font uses antialiasing, the bitmap should have mode ``L`` and use a",
            "        maximum value of 255. If the font has embedded color data, the bitmap",
            "        should have mode ``RGBA``. Otherwise, it should have mode ``1``.",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "                     .. versionadded:: 1.1.5",
            "",
            "        :param direction: Direction of the text. It can be 'rtl' (right to",
            "                          left), 'ltr' (left to right) or 'ttb' (top to bottom).",
            "                          Requires libraqm.",
            "",
            "                          .. versionadded:: 4.2.0",
            "",
            "        :param features: A list of OpenType font features to be used during text",
            "                         layout. This is usually used to turn on optional",
            "                         font features that are not enabled by default,",
            "                         for example 'dlig' or 'ss01', but can be also",
            "                         used to turn off default font features for",
            "                         example '-liga' to disable ligatures or '-kern'",
            "                         to disable kerning.  To get all supported",
            "                         features, see",
            "                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist",
            "                         Requires libraqm.",
            "",
            "                         .. versionadded:: 4.2.0",
            "",
            "        :param language: Language of the text. Different languages may use",
            "                         different glyph shapes or ligatures. This parameter tells",
            "                         the font which language the text is in, and to apply the",
            "                         correct substitutions as appropriate, if available.",
            "                         It should be a `BCP 47 language code",
            "                         <https://www.w3.org/International/articles/language-tags/>`_",
            "                         Requires libraqm.",
            "",
            "                         .. versionadded:: 6.0.0",
            "",
            "        :param stroke_width: The width of the text stroke.",
            "",
            "                         .. versionadded:: 6.2.0",
            "",
            "        :param anchor:  The text anchor alignment. Determines the relative location of",
            "                        the anchor to the text. The default alignment is top left.",
            "                        See :ref:`text-anchors` for valid values.",
            "",
            "                         .. versionadded:: 8.0.0",
            "",
            "        :param ink: Foreground ink for rendering in RGBA mode.",
            "",
            "                         .. versionadded:: 8.0.0",
            "",
            "        :param start: Tuple of horizontal and vertical offset, as text may render",
            "                      differently when starting at fractional coordinates.",
            "",
            "                         .. versionadded:: 9.4.0",
            "",
            "        :return: A tuple of an internal PIL storage memory instance as defined by the",
            "                 :py:mod:`PIL.Image.core` interface module, and the text offset, the",
            "                 gap between the starting coordinate and the first marking",
            "        \"\"\"",
            "        if start is None:",
            "            start = (0, 0)",
            "        im, size, offset = self.font.render(",
            "            text,",
            "            Image.core.fill,",
            "            mode,",
            "            direction,",
            "            features,",
            "            language,",
            "            stroke_width,",
            "            anchor,",
            "            ink,",
            "            start[0],",
            "            start[1],",
            "            Image.MAX_IMAGE_PIXELS,",
            "        )",
            "        Image._decompression_bomb_check(size)",
            "        return im, offset",
            "",
            "    def font_variant(",
            "        self, font=None, size=None, index=None, encoding=None, layout_engine=None",
            "    ):",
            "        \"\"\"",
            "        Create a copy of this FreeTypeFont object,",
            "        using any specified arguments to override the settings.",
            "",
            "        Parameters are identical to the parameters used to initialize this",
            "        object.",
            "",
            "        :return: A FreeTypeFont object.",
            "        \"\"\"",
            "        if font is None:",
            "            try:",
            "                font = BytesIO(self.font_bytes)",
            "            except AttributeError:",
            "                font = self.path",
            "        return FreeTypeFont(",
            "            font=font,",
            "            size=self.size if size is None else size,",
            "            index=self.index if index is None else index,",
            "            encoding=self.encoding if encoding is None else encoding,",
            "            layout_engine=layout_engine or self.layout_engine,",
            "        )",
            "",
            "    def get_variation_names(self):",
            "        \"\"\"",
            "        :returns: A list of the named styles in a variation font.",
            "        :exception OSError: If the font is not a variation font.",
            "        \"\"\"",
            "        try:",
            "            names = self.font.getvarnames()",
            "        except AttributeError as e:",
            "            msg = \"FreeType 2.9.1 or greater is required\"",
            "            raise NotImplementedError(msg) from e",
            "        return [name.replace(b\"\\x00\", b\"\") for name in names]",
            "",
            "    def set_variation_by_name(self, name):",
            "        \"\"\"",
            "        :param name: The name of the style.",
            "        :exception OSError: If the font is not a variation font.",
            "        \"\"\"",
            "        names = self.get_variation_names()",
            "        if not isinstance(name, bytes):",
            "            name = name.encode()",
            "        index = names.index(name) + 1",
            "",
            "        if index == getattr(self, \"_last_variation_index\", None):",
            "            # When the same name is set twice in a row,",
            "            # there is an 'unknown freetype error'",
            "            # https://savannah.nongnu.org/bugs/?56186",
            "            return",
            "        self._last_variation_index = index",
            "",
            "        self.font.setvarname(index)",
            "",
            "    def get_variation_axes(self):",
            "        \"\"\"",
            "        :returns: A list of the axes in a variation font.",
            "        :exception OSError: If the font is not a variation font.",
            "        \"\"\"",
            "        try:",
            "            axes = self.font.getvaraxes()",
            "        except AttributeError as e:",
            "            msg = \"FreeType 2.9.1 or greater is required\"",
            "            raise NotImplementedError(msg) from e",
            "        for axis in axes:",
            "            axis[\"name\"] = axis[\"name\"].replace(b\"\\x00\", b\"\")",
            "        return axes",
            "",
            "    def set_variation_by_axes(self, axes):",
            "        \"\"\"",
            "        :param axes: A list of values for each axis.",
            "        :exception OSError: If the font is not a variation font.",
            "        \"\"\"",
            "        try:",
            "            self.font.setvaraxes(axes)",
            "        except AttributeError as e:",
            "            msg = \"FreeType 2.9.1 or greater is required\"",
            "            raise NotImplementedError(msg) from e",
            "",
            "",
            "class TransposedFont:",
            "    \"\"\"Wrapper for writing rotated or mirrored text\"\"\"",
            "",
            "    def __init__(self, font, orientation=None):",
            "        \"\"\"",
            "        Wrapper that creates a transposed font from any existing font",
            "        object.",
            "",
            "        :param font: A font object.",
            "        :param orientation: An optional orientation.  If given, this should",
            "            be one of Image.Transpose.FLIP_LEFT_RIGHT, Image.Transpose.FLIP_TOP_BOTTOM,",
            "            Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_180, or",
            "            Image.Transpose.ROTATE_270.",
            "        \"\"\"",
            "        self.font = font",
            "        self.orientation = orientation  # any 'transpose' argument, or None",
            "",
            "    def getmask(self, text, mode=\"\", *args, **kwargs):",
            "        im = self.font.getmask(text, mode, *args, **kwargs)",
            "        if self.orientation is not None:",
            "            return im.transpose(self.orientation)",
            "        return im",
            "",
            "    def getbbox(self, text, *args, **kwargs):",
            "        # TransposedFont doesn't support getmask2, move top-left point to (0, 0)",
            "        # this has no effect on ImageFont and simulates anchor=\"lt\" for FreeTypeFont",
            "        left, top, right, bottom = self.font.getbbox(text, *args, **kwargs)",
            "        width = right - left",
            "        height = bottom - top",
            "        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):",
            "            return 0, 0, height, width",
            "        return 0, 0, width, height",
            "",
            "    def getlength(self, text, *args, **kwargs):",
            "        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):",
            "            msg = \"text length is undefined for text rotated by 90 or 270 degrees\"",
            "            raise ValueError(msg)",
            "        return self.font.getlength(text, *args, **kwargs)",
            "",
            "",
            "def load(filename):",
            "    \"\"\"",
            "    Load a font file.  This function loads a font object from the given",
            "    bitmap font file, and returns the corresponding font object.",
            "",
            "    :param filename: Name of font file.",
            "    :return: A font object.",
            "    :exception OSError: If the file could not be read.",
            "    \"\"\"",
            "    f = ImageFont()",
            "    f._load_pilfont(filename)",
            "    return f",
            "",
            "",
            "def truetype(font=None, size=10, index=0, encoding=\"\", layout_engine=None):",
            "    \"\"\"",
            "    Load a TrueType or OpenType font from a file or file-like object,",
            "    and create a font object.",
            "    This function loads a font object from the given file or file-like",
            "    object, and creates a font object for a font of the given size.",
            "",
            "    Pillow uses FreeType to open font files. On Windows, be aware that FreeType",
            "    will keep the file open as long as the FreeTypeFont object exists. Windows",
            "    limits the number of files that can be open in C at once to 512, so if many",
            "    fonts are opened simultaneously and that limit is approached, an",
            "    ``OSError`` may be thrown, reporting that FreeType \"cannot open resource\".",
            "    A workaround would be to copy the file(s) into memory, and open that instead.",
            "",
            "    This function requires the _imagingft service.",
            "",
            "    :param font: A filename or file-like object containing a TrueType font.",
            "                 If the file is not found in this filename, the loader may also",
            "                 search in other directories, such as the :file:`fonts/`",
            "                 directory on Windows or :file:`/Library/Fonts/`,",
            "                 :file:`/System/Library/Fonts/` and :file:`~/Library/Fonts/` on",
            "                 macOS.",
            "",
            "    :param size: The requested size, in pixels.",
            "    :param index: Which font face to load (default is first available face).",
            "    :param encoding: Which font encoding to use (default is Unicode). Possible",
            "                     encodings include (see the FreeType documentation for more",
            "                     information):",
            "",
            "                     * \"unic\" (Unicode)",
            "                     * \"symb\" (Microsoft Symbol)",
            "                     * \"ADOB\" (Adobe Standard)",
            "                     * \"ADBE\" (Adobe Expert)",
            "                     * \"ADBC\" (Adobe Custom)",
            "                     * \"armn\" (Apple Roman)",
            "                     * \"sjis\" (Shift JIS)",
            "                     * \"gb  \" (PRC)",
            "                     * \"big5\"",
            "                     * \"wans\" (Extended Wansung)",
            "                     * \"joha\" (Johab)",
            "                     * \"lat1\" (Latin-1)",
            "",
            "                     This specifies the character set to use. It does not alter the",
            "                     encoding of any text provided in subsequent operations.",
            "    :param layout_engine: Which layout engine to use, if available:",
            "                     :data:`.ImageFont.Layout.BASIC` or :data:`.ImageFont.Layout.RAQM`.",
            "                     If it is available, Raqm layout will be used by default.",
            "                     Otherwise, basic layout will be used.",
            "",
            "                     Raqm layout is recommended for all non-English text. If Raqm layout",
            "                     is not required, basic layout will have better performance.",
            "",
            "                     You can check support for Raqm layout using",
            "                     :py:func:`PIL.features.check_feature` with ``feature=\"raqm\"``.",
            "",
            "                     .. versionadded:: 4.2.0",
            "    :return: A font object.",
            "    :exception OSError: If the file could not be read.",
            "    \"\"\"",
            "",
            "    def freetype(font):",
            "        return FreeTypeFont(font, size, index, encoding, layout_engine)",
            "",
            "    try:",
            "        return freetype(font)",
            "    except OSError:",
            "        if not is_path(font):",
            "            raise",
            "        ttf_filename = os.path.basename(font)",
            "",
            "        dirs = []",
            "        if sys.platform == \"win32\":",
            "            # check the windows font repository",
            "            # NOTE: must use uppercase WINDIR, to work around bugs in",
            "            # 1.5.2's os.environ.get()",
            "            windir = os.environ.get(\"WINDIR\")",
            "            if windir:",
            "                dirs.append(os.path.join(windir, \"fonts\"))",
            "        elif sys.platform in (\"linux\", \"linux2\"):",
            "            lindirs = os.environ.get(\"XDG_DATA_DIRS\")",
            "            if not lindirs:",
            "                # According to the freedesktop spec, XDG_DATA_DIRS should",
            "                # default to /usr/share",
            "                lindirs = \"/usr/share\"",
            "            dirs += [os.path.join(lindir, \"fonts\") for lindir in lindirs.split(\":\")]",
            "        elif sys.platform == \"darwin\":",
            "            dirs += [",
            "                \"/Library/Fonts\",",
            "                \"/System/Library/Fonts\",",
            "                os.path.expanduser(\"~/Library/Fonts\"),",
            "            ]",
            "",
            "        ext = os.path.splitext(ttf_filename)[1]",
            "        first_font_with_a_different_extension = None",
            "        for directory in dirs:",
            "            for walkroot, walkdir, walkfilenames in os.walk(directory):",
            "                for walkfilename in walkfilenames:",
            "                    if ext and walkfilename == ttf_filename:",
            "                        return freetype(os.path.join(walkroot, walkfilename))",
            "                    elif not ext and os.path.splitext(walkfilename)[0] == ttf_filename:",
            "                        fontpath = os.path.join(walkroot, walkfilename)",
            "                        if os.path.splitext(fontpath)[1] == \".ttf\":",
            "                            return freetype(fontpath)",
            "                        if not ext and first_font_with_a_different_extension is None:",
            "                            first_font_with_a_different_extension = fontpath",
            "        if first_font_with_a_different_extension:",
            "            return freetype(first_font_with_a_different_extension)",
            "        raise",
            "",
            "",
            "def load_path(filename):",
            "    \"\"\"",
            "    Load font file. Same as :py:func:`~PIL.ImageFont.load`, but searches for a",
            "    bitmap font along the Python path.",
            "",
            "    :param filename: Name of font file.",
            "    :return: A font object.",
            "    :exception OSError: If the file could not be read.",
            "    \"\"\"",
            "    for directory in sys.path:",
            "        if is_directory(directory):",
            "            if not isinstance(filename, str):",
            "                filename = filename.decode(\"utf-8\")",
            "            try:",
            "                return load(os.path.join(directory, filename))",
            "            except OSError:",
            "                pass",
            "    msg = \"cannot find font file\"",
            "    raise OSError(msg)",
            "",
            "",
            "def load_default():",
            "    \"\"\"Load a \"better than nothing\" default font.",
            "",
            "    .. versionadded:: 1.1.4",
            "",
            "    :return: A font object.",
            "    \"\"\"",
            "    f = ImageFont()",
            "    f._load_pilfont_data(",
            "        # courB08",
            "        BytesIO(",
            "            base64.b64decode(",
            "                b\"\"\"",
            "UElMZm9udAo7Ozs7OzsxMDsKREFUQQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAA//8AAQAAAAAAAAABAAEA",
            "BgAAAAH/+gADAAAAAQAAAAMABgAGAAAAAf/6AAT//QADAAAABgADAAYAAAAA//kABQABAAYAAAAL",
            "AAgABgAAAAD/+AAFAAEACwAAABAACQAGAAAAAP/5AAUAAAAQAAAAFQAHAAYAAP////oABQAAABUA",
            "AAAbAAYABgAAAAH/+QAE//wAGwAAAB4AAwAGAAAAAf/5AAQAAQAeAAAAIQAIAAYAAAAB//kABAAB",
            "ACEAAAAkAAgABgAAAAD/+QAE//0AJAAAACgABAAGAAAAAP/6AAX//wAoAAAALQAFAAYAAAAB//8A",
            "BAACAC0AAAAwAAMABgAAAAD//AAF//0AMAAAADUAAQAGAAAAAf//AAMAAAA1AAAANwABAAYAAAAB",
            "//kABQABADcAAAA7AAgABgAAAAD/+QAFAAAAOwAAAEAABwAGAAAAAP/5AAYAAABAAAAARgAHAAYA",
            "AAAA//kABQAAAEYAAABLAAcABgAAAAD/+QAFAAAASwAAAFAABwAGAAAAAP/5AAYAAABQAAAAVgAH",
            "AAYAAAAA//kABQAAAFYAAABbAAcABgAAAAD/+QAFAAAAWwAAAGAABwAGAAAAAP/5AAUAAABgAAAA",
            "ZQAHAAYAAAAA//kABQAAAGUAAABqAAcABgAAAAD/+QAFAAAAagAAAG8ABwAGAAAAAf/8AAMAAABv",
            "AAAAcQAEAAYAAAAA//wAAwACAHEAAAB0AAYABgAAAAD/+gAE//8AdAAAAHgABQAGAAAAAP/7AAT/",
            "/gB4AAAAfAADAAYAAAAB//oABf//AHwAAACAAAUABgAAAAD/+gAFAAAAgAAAAIUABgAGAAAAAP/5",
            "AAYAAQCFAAAAiwAIAAYAAP////oABgAAAIsAAACSAAYABgAA////+gAFAAAAkgAAAJgABgAGAAAA",
            "AP/6AAUAAACYAAAAnQAGAAYAAP////oABQAAAJ0AAACjAAYABgAA////+gAFAAAAowAAAKkABgAG",
            "AAD////6AAUAAACpAAAArwAGAAYAAAAA//oABQAAAK8AAAC0AAYABgAA////+gAGAAAAtAAAALsA",
            "BgAGAAAAAP/6AAQAAAC7AAAAvwAGAAYAAP////oABQAAAL8AAADFAAYABgAA////+gAGAAAAxQAA",
            "AMwABgAGAAD////6AAUAAADMAAAA0gAGAAYAAP////oABQAAANIAAADYAAYABgAA////+gAGAAAA",
            "2AAAAN8ABgAGAAAAAP/6AAUAAADfAAAA5AAGAAYAAP////oABQAAAOQAAADqAAYABgAAAAD/+gAF",
            "AAEA6gAAAO8ABwAGAAD////6AAYAAADvAAAA9gAGAAYAAAAA//oABQAAAPYAAAD7AAYABgAA////",
            "+gAFAAAA+wAAAQEABgAGAAD////6AAYAAAEBAAABCAAGAAYAAP////oABgAAAQgAAAEPAAYABgAA",
            "////+gAGAAABDwAAARYABgAGAAAAAP/6AAYAAAEWAAABHAAGAAYAAP////oABgAAARwAAAEjAAYA",
            "BgAAAAD/+gAFAAABIwAAASgABgAGAAAAAf/5AAQAAQEoAAABKwAIAAYAAAAA//kABAABASsAAAEv",
            "AAgABgAAAAH/+QAEAAEBLwAAATIACAAGAAAAAP/5AAX//AEyAAABNwADAAYAAAAAAAEABgACATcA",
            "AAE9AAEABgAAAAH/+QAE//wBPQAAAUAAAwAGAAAAAP/7AAYAAAFAAAABRgAFAAYAAP////kABQAA",
            "AUYAAAFMAAcABgAAAAD/+wAFAAABTAAAAVEABQAGAAAAAP/5AAYAAAFRAAABVwAHAAYAAAAA//sA",
            "BQAAAVcAAAFcAAUABgAAAAD/+QAFAAABXAAAAWEABwAGAAAAAP/7AAYAAgFhAAABZwAHAAYAAP//",
            "//kABQAAAWcAAAFtAAcABgAAAAD/+QAGAAABbQAAAXMABwAGAAAAAP/5AAQAAgFzAAABdwAJAAYA",
            "AP////kABgAAAXcAAAF+AAcABgAAAAD/+QAGAAABfgAAAYQABwAGAAD////7AAUAAAGEAAABigAF",
            "AAYAAP////sABQAAAYoAAAGQAAUABgAAAAD/+wAFAAABkAAAAZUABQAGAAD////7AAUAAgGVAAAB",
            "mwAHAAYAAAAA//sABgACAZsAAAGhAAcABgAAAAD/+wAGAAABoQAAAacABQAGAAAAAP/7AAYAAAGn",
            "AAABrQAFAAYAAAAA//kABgAAAa0AAAGzAAcABgAA////+wAGAAABswAAAboABQAGAAD////7AAUA",
            "AAG6AAABwAAFAAYAAP////sABgAAAcAAAAHHAAUABgAAAAD/+wAGAAABxwAAAc0ABQAGAAD////7",
            "AAYAAgHNAAAB1AAHAAYAAAAA//sABQAAAdQAAAHZAAUABgAAAAH/+QAFAAEB2QAAAd0ACAAGAAAA",
            "Av/6AAMAAQHdAAAB3gAHAAYAAAAA//kABAABAd4AAAHiAAgABgAAAAD/+wAF//0B4gAAAecAAgAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAB",
            "//sAAwACAecAAAHpAAcABgAAAAD/+QAFAAEB6QAAAe4ACAAGAAAAAP/5AAYAAAHuAAAB9AAHAAYA",
            "AAAA//oABf//AfQAAAH5AAUABgAAAAD/+QAGAAAB+QAAAf8ABwAGAAAAAv/5AAMAAgH/AAACAAAJ",
            "AAYAAAAA//kABQABAgAAAAIFAAgABgAAAAH/+gAE//sCBQAAAggAAQAGAAAAAP/5AAYAAAIIAAAC",
            "DgAHAAYAAAAB//kABf/+Ag4AAAISAAUABgAA////+wAGAAACEgAAAhkABQAGAAAAAP/7AAX//gIZ",
            "AAACHgADAAYAAAAA//wABf/9Ah4AAAIjAAEABgAAAAD/+QAHAAACIwAAAioABwAGAAAAAP/6AAT/",
            "+wIqAAACLgABAAYAAAAA//kABP/8Ai4AAAIyAAMABgAAAAD/+gAFAAACMgAAAjcABgAGAAAAAf/5",
            "AAT//QI3AAACOgAEAAYAAAAB//kABP/9AjoAAAI9AAQABgAAAAL/+QAE//sCPQAAAj8AAgAGAAD/",
            "///7AAYAAgI/AAACRgAHAAYAAAAA//kABgABAkYAAAJMAAgABgAAAAH//AAD//0CTAAAAk4AAQAG",
            "AAAAAf//AAQAAgJOAAACUQADAAYAAAAB//kABP/9AlEAAAJUAAQABgAAAAH/+QAF//4CVAAAAlgA",
            "BQAGAAD////7AAYAAAJYAAACXwAFAAYAAP////kABgAAAl8AAAJmAAcABgAA////+QAGAAACZgAA",
            "Am0ABwAGAAD////5AAYAAAJtAAACdAAHAAYAAAAA//sABQACAnQAAAJ5AAcABgAA////9wAGAAAC",
            "eQAAAoAACQAGAAD////3AAYAAAKAAAAChwAJAAYAAP////cABgAAAocAAAKOAAkABgAA////9wAG",
            "AAACjgAAApUACQAGAAD////4AAYAAAKVAAACnAAIAAYAAP////cABgAAApwAAAKjAAkABgAA////",
            "+gAGAAACowAAAqoABgAGAAAAAP/6AAUAAgKqAAACrwAIAAYAAP////cABQAAAq8AAAK1AAkABgAA",
            "////9wAFAAACtQAAArsACQAGAAD////3AAUAAAK7AAACwQAJAAYAAP////gABQAAAsEAAALHAAgA",
            "BgAAAAD/9wAEAAACxwAAAssACQAGAAAAAP/3AAQAAALLAAACzwAJAAYAAAAA//cABAAAAs8AAALT",
            "AAkABgAAAAD/+AAEAAAC0wAAAtcACAAGAAD////6AAUAAALXAAAC3QAGAAYAAP////cABgAAAt0A",
            "AALkAAkABgAAAAD/9wAFAAAC5AAAAukACQAGAAAAAP/3AAUAAALpAAAC7gAJAAYAAAAA//cABQAA",
            "Au4AAALzAAkABgAAAAD/9wAFAAAC8wAAAvgACQAGAAAAAP/4AAUAAAL4AAAC/QAIAAYAAAAA//oA",
            "Bf//Av0AAAMCAAUABgAA////+gAGAAADAgAAAwkABgAGAAD////3AAYAAAMJAAADEAAJAAYAAP//",
            "//cABgAAAxAAAAMXAAkABgAA////9wAGAAADFwAAAx4ACQAGAAD////4AAYAAAAAAAoABwASAAYA",
            "AP////cABgAAAAcACgAOABMABgAA////+gAFAAAADgAKABQAEAAGAAD////6AAYAAAAUAAoAGwAQ",
            "AAYAAAAA//gABgAAABsACgAhABIABgAAAAD/+AAGAAAAIQAKACcAEgAGAAAAAP/4AAYAAAAnAAoA",
            "LQASAAYAAAAA//gABgAAAC0ACgAzABIABgAAAAD/+QAGAAAAMwAKADkAEQAGAAAAAP/3AAYAAAA5",
            "AAoAPwATAAYAAP////sABQAAAD8ACgBFAA8ABgAAAAD/+wAFAAIARQAKAEoAEQAGAAAAAP/4AAUA",
            "AABKAAoATwASAAYAAAAA//gABQAAAE8ACgBUABIABgAAAAD/+AAFAAAAVAAKAFkAEgAGAAAAAP/5",
            "AAUAAABZAAoAXgARAAYAAAAA//gABgAAAF4ACgBkABIABgAAAAD/+AAGAAAAZAAKAGoAEgAGAAAA",
            "AP/4AAYAAABqAAoAcAASAAYAAAAA//kABgAAAHAACgB2ABEABgAAAAD/+AAFAAAAdgAKAHsAEgAG",
            "AAD////4AAYAAAB7AAoAggASAAYAAAAA//gABQAAAIIACgCHABIABgAAAAD/+AAFAAAAhwAKAIwA",
            "EgAGAAAAAP/4AAUAAACMAAoAkQASAAYAAAAA//gABQAAAJEACgCWABIABgAAAAD/+QAFAAAAlgAK",
            "AJsAEQAGAAAAAP/6AAX//wCbAAoAoAAPAAYAAAAA//oABQABAKAACgClABEABgAA////+AAGAAAA",
            "pQAKAKwAEgAGAAD////4AAYAAACsAAoAswASAAYAAP////gABgAAALMACgC6ABIABgAA////+QAG",
            "AAAAugAKAMEAEQAGAAD////4AAYAAgDBAAoAyAAUAAYAAP////kABQACAMgACgDOABMABgAA////",
            "+QAGAAIAzgAKANUAEw==",
            "\"\"\"",
            "            )",
            "        ),",
            "        Image.open(",
            "            BytesIO(",
            "                base64.b64decode(",
            "                    b\"\"\"",
            "iVBORw0KGgoAAAANSUhEUgAAAx4AAAAUAQAAAAArMtZoAAAEwElEQVR4nABlAJr/AHVE4czCI/4u",
            "Mc4b7vuds/xzjz5/3/7u/n9vMe7vnfH/9++vPn/xyf5zhxzjt8GHw8+2d83u8x27199/nxuQ6Od9",
            "M43/5z2I+9n9ZtmDBwMQECDRQw/eQIQohJXxpBCNVE6QCCAAAAD//wBlAJr/AgALyj1t/wINwq0g",
            "LeNZUworuN1cjTPIzrTX6ofHWeo3v336qPzfEwRmBnHTtf95/fglZK5N0PDgfRTslpGBvz7LFc4F",
            "IUXBWQGjQ5MGCx34EDFPwXiY4YbYxavpnhHFrk14CDAAAAD//wBlAJr/AgKqRooH2gAgPeggvUAA",
            "Bu2WfgPoAwzRAABAAAAAAACQgLz/3Uv4Gv+gX7BJgDeeGP6AAAD1NMDzKHD7ANWr3loYbxsAD791",
            "NAADfcoIDyP44K/jv4Y63/Z+t98Ovt+ub4T48LAAAAD//wBlAJr/AuplMlADJAAAAGuAphWpqhMx",
            "in0A/fRvAYBABPgBwBUgABBQ/sYAyv9g0bCHgOLoGAAAAAAAREAAwI7nr0ArYpow7aX8//9LaP/9",
            "SjdavWA8ePHeBIKB//81/83ndznOaXx379wAAAD//wBlAJr/AqDxW+D3AABAAbUh/QMnbQag/gAY",
            "AYDAAACgtgD/gOqAAAB5IA/8AAAk+n9w0AAA8AAAmFRJuPo27ciC0cD5oeW4E7KA/wD3ECMAn2tt",
            "y8PgwH8AfAxFzC0JzeAMtratAsC/ffwAAAD//wBlAJr/BGKAyCAA4AAAAvgeYTAwHd1kmQF5chkG",
            "ABoMIHcL5xVpTfQbUqzlAAAErwAQBgAAEOClA5D9il08AEh/tUzdCBsXkbgACED+woQg8Si9VeqY",
            "lODCn7lmF6NhnAEYgAAA/NMIAAAAAAD//2JgjLZgVGBg5Pv/Tvpc8hwGBjYGJADjHDrAwPzAjv/H",
            "/Wf3PzCwtzcwHmBgYGcwbZz8wHaCAQMDOwMDQ8MCBgYOC3W7mp+f0w+wHOYxO3OG+e376hsMZjk3",
            "AAAAAP//YmCMY2A4wMAIN5e5gQETPD6AZisDAwMDgzSDAAPjByiHcQMDAwMDg1nOze1lByRu5/47",
            "c4859311AYNZzg0AAAAA//9iYGDBYihOIIMuwIjGL39/fwffA8b//xv/P2BPtzzHwCBjUQAAAAD/",
            "/yLFBrIBAAAA//9i1HhcwdhizX7u8NZNzyLbvT97bfrMf/QHI8evOwcSqGUJAAAA//9iYBB81iSw",
            "pEE170Qrg5MIYydHqwdDQRMrAwcVrQAAAAD//2J4x7j9AAMDn8Q/BgYLBoaiAwwMjPdvMDBYM1Tv",
            "oJodAAAAAP//Yqo/83+dxePWlxl3npsel9lvLfPcqlE9725C+acfVLMEAAAA//9i+s9gwCoaaGMR",
            "evta/58PTEWzr21hufPjA8N+qlnBwAAAAAD//2JiWLci5v1+HmFXDqcnULE/MxgYGBj+f6CaJQAA",
            "AAD//2Ji2FrkY3iYpYC5qDeGgeEMAwPDvwQBBoYvcTwOVLMEAAAA//9isDBgkP///0EOg9z35v//",
            "Gc/eeW7BwPj5+QGZhANUswMAAAD//2JgqGBgYGBgqEMXlvhMPUsAAAAA//8iYDd1AAAAAP//AwDR",
            "w7IkEbzhVQAAAABJRU5ErkJggg==",
            "\"\"\"",
            "                )",
            "            )",
            "        ),",
            "    )",
            "    return f"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# PIL raster font management",
            "#",
            "# History:",
            "# 1996-08-07 fl   created (experimental)",
            "# 1997-08-25 fl   minor adjustments to handle fonts from pilfont 0.3",
            "# 1999-02-06 fl   rewrote most font management stuff in C",
            "# 1999-03-17 fl   take pth files into account in load_path (from Richard Jones)",
            "# 2001-02-17 fl   added freetype support",
            "# 2001-05-09 fl   added TransposedFont wrapper class",
            "# 2002-03-04 fl   make sure we have a \"L\" or \"1\" font",
            "# 2002-12-04 fl   skip non-directory entries in the system path",
            "# 2003-04-29 fl   add embedded default font",
            "# 2003-09-27 fl   added support for truetype charmap encodings",
            "#",
            "# Todo:",
            "# Adapt to PILFONT2 format (16-bit fonts, compressed, single file)",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB",
            "# Copyright (c) 1996-2003 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import base64",
            "import os",
            "import sys",
            "import warnings",
            "from enum import IntEnum",
            "from io import BytesIO",
            "",
            "from . import Image",
            "from ._util import is_directory, is_path",
            "",
            "",
            "class Layout(IntEnum):",
            "    BASIC = 0",
            "    RAQM = 1",
            "",
            "",
            "MAX_STRING_LENGTH = 1000000",
            "",
            "",
            "try:",
            "    from . import _imagingft as core",
            "except ImportError as ex:",
            "    from ._util import DeferredError",
            "",
            "    core = DeferredError(ex)",
            "",
            "",
            "def _string_length_check(text):",
            "    if MAX_STRING_LENGTH is not None and len(text) > MAX_STRING_LENGTH:",
            "        msg = \"too many characters in string\"",
            "        raise ValueError(msg)",
            "",
            "",
            "# FIXME: add support for pilfont2 format (see FontFile.py)",
            "",
            "# --------------------------------------------------------------------",
            "# Font metrics format:",
            "#       \"PILfont\" LF",
            "#       fontdescriptor LF",
            "#       (optional) key=value... LF",
            "#       \"DATA\" LF",
            "#       binary data: 256*10*2 bytes (dx, dy, dstbox, srcbox)",
            "#",
            "# To place a character, cut out srcbox and paste at dstbox,",
            "# relative to the character position.  Then move the character",
            "# position according to dx, dy.",
            "# --------------------------------------------------------------------",
            "",
            "",
            "class ImageFont:",
            "    \"\"\"PIL font wrapper\"\"\"",
            "",
            "    def _load_pilfont(self, filename):",
            "        with open(filename, \"rb\") as fp:",
            "            image = None",
            "            for ext in (\".png\", \".gif\", \".pbm\"):",
            "                if image:",
            "                    image.close()",
            "                try:",
            "                    fullname = os.path.splitext(filename)[0] + ext",
            "                    image = Image.open(fullname)",
            "                except Exception:",
            "                    pass",
            "                else:",
            "                    if image and image.mode in (\"1\", \"L\"):",
            "                        break",
            "            else:",
            "                if image:",
            "                    image.close()",
            "                msg = \"cannot find glyph data file\"",
            "                raise OSError(msg)",
            "",
            "            self.file = fullname",
            "",
            "            self._load_pilfont_data(fp, image)",
            "            image.close()",
            "",
            "    def _load_pilfont_data(self, file, image):",
            "        # read PILfont header",
            "        if file.readline() != b\"PILfont\\n\":",
            "            msg = \"Not a PILfont file\"",
            "            raise SyntaxError(msg)",
            "        file.readline().split(b\";\")",
            "        self.info = []  # FIXME: should be a dictionary",
            "        while True:",
            "            s = file.readline()",
            "            if not s or s == b\"DATA\\n\":",
            "                break",
            "            self.info.append(s)",
            "",
            "        # read PILfont metrics",
            "        data = file.read(256 * 20)",
            "",
            "        # check image",
            "        if image.mode not in (\"1\", \"L\"):",
            "            msg = \"invalid font image mode\"",
            "            raise TypeError(msg)",
            "",
            "        image.load()",
            "",
            "        self.font = Image.core.font(image.im, data)",
            "",
            "    def getmask(self, text, mode=\"\", *args, **kwargs):",
            "        \"\"\"",
            "        Create a bitmap for the text.",
            "",
            "        If the font uses antialiasing, the bitmap should have mode ``L`` and use a",
            "        maximum value of 255. Otherwise, it should have mode ``1``.",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "                     .. versionadded:: 1.1.5",
            "",
            "        :return: An internal PIL storage memory instance as defined by the",
            "                 :py:mod:`PIL.Image.core` interface module.",
            "        \"\"\"",
            "        return self.font.getmask(text, mode)",
            "",
            "    def getbbox(self, text, *args, **kwargs):",
            "        \"\"\"",
            "        Returns bounding box (in pixels) of given text.",
            "",
            "        .. versionadded:: 9.2.0",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "        :return: ``(left, top, right, bottom)`` bounding box",
            "        \"\"\"",
            "        _string_length_check(text)",
            "        width, height = self.font.getsize(text)",
            "        return 0, 0, width, height",
            "",
            "    def getlength(self, text, *args, **kwargs):",
            "        \"\"\"",
            "        Returns length (in pixels) of given text.",
            "        This is the amount by which following text should be offset.",
            "",
            "        .. versionadded:: 9.2.0",
            "        \"\"\"",
            "        _string_length_check(text)",
            "        width, height = self.font.getsize(text)",
            "        return width",
            "",
            "",
            "##",
            "# Wrapper for FreeType fonts.  Application code should use the",
            "# <b>truetype</b> factory function to create font objects.",
            "",
            "",
            "class FreeTypeFont:",
            "    \"\"\"FreeType font wrapper (requires _imagingft service)\"\"\"",
            "",
            "    def __init__(self, font=None, size=10, index=0, encoding=\"\", layout_engine=None):",
            "        # FIXME: use service provider instead",
            "",
            "        self.path = font",
            "        self.size = size",
            "        self.index = index",
            "        self.encoding = encoding",
            "",
            "        if layout_engine not in (Layout.BASIC, Layout.RAQM):",
            "            layout_engine = Layout.BASIC",
            "            if core.HAVE_RAQM:",
            "                layout_engine = Layout.RAQM",
            "        elif layout_engine == Layout.RAQM and not core.HAVE_RAQM:",
            "            warnings.warn(",
            "                \"Raqm layout was requested, but Raqm is not available. \"",
            "                \"Falling back to basic layout.\"",
            "            )",
            "            layout_engine = Layout.BASIC",
            "",
            "        self.layout_engine = layout_engine",
            "",
            "        def load_from_bytes(f):",
            "            self.font_bytes = f.read()",
            "            self.font = core.getfont(",
            "                \"\", size, index, encoding, self.font_bytes, layout_engine",
            "            )",
            "",
            "        if is_path(font):",
            "            if sys.platform == \"win32\":",
            "                font_bytes_path = font if isinstance(font, bytes) else font.encode()",
            "                try:",
            "                    font_bytes_path.decode(\"ascii\")",
            "                except UnicodeDecodeError:",
            "                    # FreeType cannot load fonts with non-ASCII characters on Windows",
            "                    # So load it into memory first",
            "                    with open(font, \"rb\") as f:",
            "                        load_from_bytes(f)",
            "                    return",
            "            self.font = core.getfont(",
            "                font, size, index, encoding, layout_engine=layout_engine",
            "            )",
            "        else:",
            "            load_from_bytes(font)",
            "",
            "    def __getstate__(self):",
            "        return [self.path, self.size, self.index, self.encoding, self.layout_engine]",
            "",
            "    def __setstate__(self, state):",
            "        path, size, index, encoding, layout_engine = state",
            "        self.__init__(path, size, index, encoding, layout_engine)",
            "",
            "    def getname(self):",
            "        \"\"\"",
            "        :return: A tuple of the font family (e.g. Helvetica) and the font style",
            "            (e.g. Bold)",
            "        \"\"\"",
            "        return self.font.family, self.font.style",
            "",
            "    def getmetrics(self):",
            "        \"\"\"",
            "        :return: A tuple of the font ascent (the distance from the baseline to",
            "            the highest outline point) and descent (the distance from the",
            "            baseline to the lowest outline point, a negative value)",
            "        \"\"\"",
            "        return self.font.ascent, self.font.descent",
            "",
            "    def getlength(self, text, mode=\"\", direction=None, features=None, language=None):",
            "        \"\"\"",
            "        Returns length (in pixels with 1/64 precision) of given text when rendered",
            "        in font with provided direction, features, and language.",
            "",
            "        This is the amount by which following text should be offset.",
            "        Text bounding box may extend past the length in some fonts,",
            "        e.g. when using italics or accents.",
            "",
            "        The result is returned as a float; it is a whole number if using basic layout.",
            "",
            "        Note that the sum of two lengths may not equal the length of a concatenated",
            "        string due to kerning. If you need to adjust for kerning, include the following",
            "        character and subtract its length.",
            "",
            "        For example, instead of ::",
            "",
            "          hello = font.getlength(\"Hello\")",
            "          world = font.getlength(\"World\")",
            "          hello_world = hello + world  # not adjusted for kerning",
            "          assert hello_world == font.getlength(\"HelloWorld\")  # may fail",
            "",
            "        use ::",
            "",
            "          hello = font.getlength(\"HelloW\") - font.getlength(\"W\")  # adjusted for kerning",
            "          world = font.getlength(\"World\")",
            "          hello_world = hello + world  # adjusted for kerning",
            "          assert hello_world == font.getlength(\"HelloWorld\")  # True",
            "",
            "        or disable kerning with (requires libraqm) ::",
            "",
            "          hello = draw.textlength(\"Hello\", font, features=[\"-kern\"])",
            "          world = draw.textlength(\"World\", font, features=[\"-kern\"])",
            "          hello_world = hello + world  # kerning is disabled, no need to adjust",
            "          assert hello_world == draw.textlength(\"HelloWorld\", font, features=[\"-kern\"])",
            "",
            "        .. versionadded:: 8.0.0",
            "",
            "        :param text: Text to measure.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "        :param direction: Direction of the text. It can be 'rtl' (right to",
            "                          left), 'ltr' (left to right) or 'ttb' (top to bottom).",
            "                          Requires libraqm.",
            "",
            "        :param features: A list of OpenType font features to be used during text",
            "                         layout. This is usually used to turn on optional",
            "                         font features that are not enabled by default,",
            "                         for example 'dlig' or 'ss01', but can be also",
            "                         used to turn off default font features for",
            "                         example '-liga' to disable ligatures or '-kern'",
            "                         to disable kerning.  To get all supported",
            "                         features, see",
            "                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist",
            "                         Requires libraqm.",
            "",
            "        :param language: Language of the text. Different languages may use",
            "                         different glyph shapes or ligatures. This parameter tells",
            "                         the font which language the text is in, and to apply the",
            "                         correct substitutions as appropriate, if available.",
            "                         It should be a `BCP 47 language code",
            "                         <https://www.w3.org/International/articles/language-tags/>`_",
            "                         Requires libraqm.",
            "",
            "        :return: Width for horizontal, height for vertical text.",
            "        \"\"\"",
            "        _string_length_check(text)",
            "        return self.font.getlength(text, mode, direction, features, language) / 64",
            "",
            "    def getbbox(",
            "        self,",
            "        text,",
            "        mode=\"\",",
            "        direction=None,",
            "        features=None,",
            "        language=None,",
            "        stroke_width=0,",
            "        anchor=None,",
            "    ):",
            "        \"\"\"",
            "        Returns bounding box (in pixels) of given text relative to given anchor",
            "        when rendered in font with provided direction, features, and language.",
            "",
            "        Use :py:meth:`getlength()` to get the offset of following text with",
            "        1/64 pixel precision. The bounding box includes extra margins for",
            "        some fonts, e.g. italics or accents.",
            "",
            "        .. versionadded:: 8.0.0",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "        :param direction: Direction of the text. It can be 'rtl' (right to",
            "                          left), 'ltr' (left to right) or 'ttb' (top to bottom).",
            "                          Requires libraqm.",
            "",
            "        :param features: A list of OpenType font features to be used during text",
            "                         layout. This is usually used to turn on optional",
            "                         font features that are not enabled by default,",
            "                         for example 'dlig' or 'ss01', but can be also",
            "                         used to turn off default font features for",
            "                         example '-liga' to disable ligatures or '-kern'",
            "                         to disable kerning.  To get all supported",
            "                         features, see",
            "                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist",
            "                         Requires libraqm.",
            "",
            "        :param language: Language of the text. Different languages may use",
            "                         different glyph shapes or ligatures. This parameter tells",
            "                         the font which language the text is in, and to apply the",
            "                         correct substitutions as appropriate, if available.",
            "                         It should be a `BCP 47 language code",
            "                         <https://www.w3.org/International/articles/language-tags/>`_",
            "                         Requires libraqm.",
            "",
            "        :param stroke_width: The width of the text stroke.",
            "",
            "        :param anchor:  The text anchor alignment. Determines the relative location of",
            "                        the anchor to the text. The default alignment is top left.",
            "                        See :ref:`text-anchors` for valid values.",
            "",
            "        :return: ``(left, top, right, bottom)`` bounding box",
            "        \"\"\"",
            "        _string_length_check(text)",
            "        size, offset = self.font.getsize(",
            "            text, mode, direction, features, language, anchor",
            "        )",
            "        left, top = offset[0] - stroke_width, offset[1] - stroke_width",
            "        width, height = size[0] + 2 * stroke_width, size[1] + 2 * stroke_width",
            "        return left, top, left + width, top + height",
            "",
            "    def getmask(",
            "        self,",
            "        text,",
            "        mode=\"\",",
            "        direction=None,",
            "        features=None,",
            "        language=None,",
            "        stroke_width=0,",
            "        anchor=None,",
            "        ink=0,",
            "        start=None,",
            "    ):",
            "        \"\"\"",
            "        Create a bitmap for the text.",
            "",
            "        If the font uses antialiasing, the bitmap should have mode ``L`` and use a",
            "        maximum value of 255. If the font has embedded color data, the bitmap",
            "        should have mode ``RGBA``. Otherwise, it should have mode ``1``.",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "                     .. versionadded:: 1.1.5",
            "",
            "        :param direction: Direction of the text. It can be 'rtl' (right to",
            "                          left), 'ltr' (left to right) or 'ttb' (top to bottom).",
            "                          Requires libraqm.",
            "",
            "                          .. versionadded:: 4.2.0",
            "",
            "        :param features: A list of OpenType font features to be used during text",
            "                         layout. This is usually used to turn on optional",
            "                         font features that are not enabled by default,",
            "                         for example 'dlig' or 'ss01', but can be also",
            "                         used to turn off default font features for",
            "                         example '-liga' to disable ligatures or '-kern'",
            "                         to disable kerning.  To get all supported",
            "                         features, see",
            "                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist",
            "                         Requires libraqm.",
            "",
            "                         .. versionadded:: 4.2.0",
            "",
            "        :param language: Language of the text. Different languages may use",
            "                         different glyph shapes or ligatures. This parameter tells",
            "                         the font which language the text is in, and to apply the",
            "                         correct substitutions as appropriate, if available.",
            "                         It should be a `BCP 47 language code",
            "                         <https://www.w3.org/International/articles/language-tags/>`_",
            "                         Requires libraqm.",
            "",
            "                         .. versionadded:: 6.0.0",
            "",
            "        :param stroke_width: The width of the text stroke.",
            "",
            "                         .. versionadded:: 6.2.0",
            "",
            "        :param anchor:  The text anchor alignment. Determines the relative location of",
            "                        the anchor to the text. The default alignment is top left.",
            "                        See :ref:`text-anchors` for valid values.",
            "",
            "                         .. versionadded:: 8.0.0",
            "",
            "        :param ink: Foreground ink for rendering in RGBA mode.",
            "",
            "                         .. versionadded:: 8.0.0",
            "",
            "        :param start: Tuple of horizontal and vertical offset, as text may render",
            "                      differently when starting at fractional coordinates.",
            "",
            "                         .. versionadded:: 9.4.0",
            "",
            "        :return: An internal PIL storage memory instance as defined by the",
            "                 :py:mod:`PIL.Image.core` interface module.",
            "        \"\"\"",
            "        return self.getmask2(",
            "            text,",
            "            mode,",
            "            direction=direction,",
            "            features=features,",
            "            language=language,",
            "            stroke_width=stroke_width,",
            "            anchor=anchor,",
            "            ink=ink,",
            "            start=start,",
            "        )[0]",
            "",
            "    def getmask2(",
            "        self,",
            "        text,",
            "        mode=\"\",",
            "        direction=None,",
            "        features=None,",
            "        language=None,",
            "        stroke_width=0,",
            "        anchor=None,",
            "        ink=0,",
            "        start=None,",
            "        *args,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Create a bitmap for the text.",
            "",
            "        If the font uses antialiasing, the bitmap should have mode ``L`` and use a",
            "        maximum value of 255. If the font has embedded color data, the bitmap",
            "        should have mode ``RGBA``. Otherwise, it should have mode ``1``.",
            "",
            "        :param text: Text to render.",
            "        :param mode: Used by some graphics drivers to indicate what mode the",
            "                     driver prefers; if empty, the renderer may return either",
            "                     mode. Note that the mode is always a string, to simplify",
            "                     C-level implementations.",
            "",
            "                     .. versionadded:: 1.1.5",
            "",
            "        :param direction: Direction of the text. It can be 'rtl' (right to",
            "                          left), 'ltr' (left to right) or 'ttb' (top to bottom).",
            "                          Requires libraqm.",
            "",
            "                          .. versionadded:: 4.2.0",
            "",
            "        :param features: A list of OpenType font features to be used during text",
            "                         layout. This is usually used to turn on optional",
            "                         font features that are not enabled by default,",
            "                         for example 'dlig' or 'ss01', but can be also",
            "                         used to turn off default font features for",
            "                         example '-liga' to disable ligatures or '-kern'",
            "                         to disable kerning.  To get all supported",
            "                         features, see",
            "                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist",
            "                         Requires libraqm.",
            "",
            "                         .. versionadded:: 4.2.0",
            "",
            "        :param language: Language of the text. Different languages may use",
            "                         different glyph shapes or ligatures. This parameter tells",
            "                         the font which language the text is in, and to apply the",
            "                         correct substitutions as appropriate, if available.",
            "                         It should be a `BCP 47 language code",
            "                         <https://www.w3.org/International/articles/language-tags/>`_",
            "                         Requires libraqm.",
            "",
            "                         .. versionadded:: 6.0.0",
            "",
            "        :param stroke_width: The width of the text stroke.",
            "",
            "                         .. versionadded:: 6.2.0",
            "",
            "        :param anchor:  The text anchor alignment. Determines the relative location of",
            "                        the anchor to the text. The default alignment is top left.",
            "                        See :ref:`text-anchors` for valid values.",
            "",
            "                         .. versionadded:: 8.0.0",
            "",
            "        :param ink: Foreground ink for rendering in RGBA mode.",
            "",
            "                         .. versionadded:: 8.0.0",
            "",
            "        :param start: Tuple of horizontal and vertical offset, as text may render",
            "                      differently when starting at fractional coordinates.",
            "",
            "                         .. versionadded:: 9.4.0",
            "",
            "        :return: A tuple of an internal PIL storage memory instance as defined by the",
            "                 :py:mod:`PIL.Image.core` interface module, and the text offset, the",
            "                 gap between the starting coordinate and the first marking",
            "        \"\"\"",
            "        _string_length_check(text)",
            "        if start is None:",
            "            start = (0, 0)",
            "        im, size, offset = self.font.render(",
            "            text,",
            "            Image.core.fill,",
            "            mode,",
            "            direction,",
            "            features,",
            "            language,",
            "            stroke_width,",
            "            anchor,",
            "            ink,",
            "            start[0],",
            "            start[1],",
            "            Image.MAX_IMAGE_PIXELS,",
            "        )",
            "        Image._decompression_bomb_check(size)",
            "        return im, offset",
            "",
            "    def font_variant(",
            "        self, font=None, size=None, index=None, encoding=None, layout_engine=None",
            "    ):",
            "        \"\"\"",
            "        Create a copy of this FreeTypeFont object,",
            "        using any specified arguments to override the settings.",
            "",
            "        Parameters are identical to the parameters used to initialize this",
            "        object.",
            "",
            "        :return: A FreeTypeFont object.",
            "        \"\"\"",
            "        if font is None:",
            "            try:",
            "                font = BytesIO(self.font_bytes)",
            "            except AttributeError:",
            "                font = self.path",
            "        return FreeTypeFont(",
            "            font=font,",
            "            size=self.size if size is None else size,",
            "            index=self.index if index is None else index,",
            "            encoding=self.encoding if encoding is None else encoding,",
            "            layout_engine=layout_engine or self.layout_engine,",
            "        )",
            "",
            "    def get_variation_names(self):",
            "        \"\"\"",
            "        :returns: A list of the named styles in a variation font.",
            "        :exception OSError: If the font is not a variation font.",
            "        \"\"\"",
            "        try:",
            "            names = self.font.getvarnames()",
            "        except AttributeError as e:",
            "            msg = \"FreeType 2.9.1 or greater is required\"",
            "            raise NotImplementedError(msg) from e",
            "        return [name.replace(b\"\\x00\", b\"\") for name in names]",
            "",
            "    def set_variation_by_name(self, name):",
            "        \"\"\"",
            "        :param name: The name of the style.",
            "        :exception OSError: If the font is not a variation font.",
            "        \"\"\"",
            "        names = self.get_variation_names()",
            "        if not isinstance(name, bytes):",
            "            name = name.encode()",
            "        index = names.index(name) + 1",
            "",
            "        if index == getattr(self, \"_last_variation_index\", None):",
            "            # When the same name is set twice in a row,",
            "            # there is an 'unknown freetype error'",
            "            # https://savannah.nongnu.org/bugs/?56186",
            "            return",
            "        self._last_variation_index = index",
            "",
            "        self.font.setvarname(index)",
            "",
            "    def get_variation_axes(self):",
            "        \"\"\"",
            "        :returns: A list of the axes in a variation font.",
            "        :exception OSError: If the font is not a variation font.",
            "        \"\"\"",
            "        try:",
            "            axes = self.font.getvaraxes()",
            "        except AttributeError as e:",
            "            msg = \"FreeType 2.9.1 or greater is required\"",
            "            raise NotImplementedError(msg) from e",
            "        for axis in axes:",
            "            axis[\"name\"] = axis[\"name\"].replace(b\"\\x00\", b\"\")",
            "        return axes",
            "",
            "    def set_variation_by_axes(self, axes):",
            "        \"\"\"",
            "        :param axes: A list of values for each axis.",
            "        :exception OSError: If the font is not a variation font.",
            "        \"\"\"",
            "        try:",
            "            self.font.setvaraxes(axes)",
            "        except AttributeError as e:",
            "            msg = \"FreeType 2.9.1 or greater is required\"",
            "            raise NotImplementedError(msg) from e",
            "",
            "",
            "class TransposedFont:",
            "    \"\"\"Wrapper for writing rotated or mirrored text\"\"\"",
            "",
            "    def __init__(self, font, orientation=None):",
            "        \"\"\"",
            "        Wrapper that creates a transposed font from any existing font",
            "        object.",
            "",
            "        :param font: A font object.",
            "        :param orientation: An optional orientation.  If given, this should",
            "            be one of Image.Transpose.FLIP_LEFT_RIGHT, Image.Transpose.FLIP_TOP_BOTTOM,",
            "            Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_180, or",
            "            Image.Transpose.ROTATE_270.",
            "        \"\"\"",
            "        self.font = font",
            "        self.orientation = orientation  # any 'transpose' argument, or None",
            "",
            "    def getmask(self, text, mode=\"\", *args, **kwargs):",
            "        im = self.font.getmask(text, mode, *args, **kwargs)",
            "        if self.orientation is not None:",
            "            return im.transpose(self.orientation)",
            "        return im",
            "",
            "    def getbbox(self, text, *args, **kwargs):",
            "        # TransposedFont doesn't support getmask2, move top-left point to (0, 0)",
            "        # this has no effect on ImageFont and simulates anchor=\"lt\" for FreeTypeFont",
            "        left, top, right, bottom = self.font.getbbox(text, *args, **kwargs)",
            "        width = right - left",
            "        height = bottom - top",
            "        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):",
            "            return 0, 0, height, width",
            "        return 0, 0, width, height",
            "",
            "    def getlength(self, text, *args, **kwargs):",
            "        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):",
            "            msg = \"text length is undefined for text rotated by 90 or 270 degrees\"",
            "            raise ValueError(msg)",
            "        _string_length_check(text)",
            "        return self.font.getlength(text, *args, **kwargs)",
            "",
            "",
            "def load(filename):",
            "    \"\"\"",
            "    Load a font file.  This function loads a font object from the given",
            "    bitmap font file, and returns the corresponding font object.",
            "",
            "    :param filename: Name of font file.",
            "    :return: A font object.",
            "    :exception OSError: If the file could not be read.",
            "    \"\"\"",
            "    f = ImageFont()",
            "    f._load_pilfont(filename)",
            "    return f",
            "",
            "",
            "def truetype(font=None, size=10, index=0, encoding=\"\", layout_engine=None):",
            "    \"\"\"",
            "    Load a TrueType or OpenType font from a file or file-like object,",
            "    and create a font object.",
            "    This function loads a font object from the given file or file-like",
            "    object, and creates a font object for a font of the given size.",
            "",
            "    Pillow uses FreeType to open font files. On Windows, be aware that FreeType",
            "    will keep the file open as long as the FreeTypeFont object exists. Windows",
            "    limits the number of files that can be open in C at once to 512, so if many",
            "    fonts are opened simultaneously and that limit is approached, an",
            "    ``OSError`` may be thrown, reporting that FreeType \"cannot open resource\".",
            "    A workaround would be to copy the file(s) into memory, and open that instead.",
            "",
            "    This function requires the _imagingft service.",
            "",
            "    :param font: A filename or file-like object containing a TrueType font.",
            "                 If the file is not found in this filename, the loader may also",
            "                 search in other directories, such as the :file:`fonts/`",
            "                 directory on Windows or :file:`/Library/Fonts/`,",
            "                 :file:`/System/Library/Fonts/` and :file:`~/Library/Fonts/` on",
            "                 macOS.",
            "",
            "    :param size: The requested size, in pixels.",
            "    :param index: Which font face to load (default is first available face).",
            "    :param encoding: Which font encoding to use (default is Unicode). Possible",
            "                     encodings include (see the FreeType documentation for more",
            "                     information):",
            "",
            "                     * \"unic\" (Unicode)",
            "                     * \"symb\" (Microsoft Symbol)",
            "                     * \"ADOB\" (Adobe Standard)",
            "                     * \"ADBE\" (Adobe Expert)",
            "                     * \"ADBC\" (Adobe Custom)",
            "                     * \"armn\" (Apple Roman)",
            "                     * \"sjis\" (Shift JIS)",
            "                     * \"gb  \" (PRC)",
            "                     * \"big5\"",
            "                     * \"wans\" (Extended Wansung)",
            "                     * \"joha\" (Johab)",
            "                     * \"lat1\" (Latin-1)",
            "",
            "                     This specifies the character set to use. It does not alter the",
            "                     encoding of any text provided in subsequent operations.",
            "    :param layout_engine: Which layout engine to use, if available:",
            "                     :data:`.ImageFont.Layout.BASIC` or :data:`.ImageFont.Layout.RAQM`.",
            "                     If it is available, Raqm layout will be used by default.",
            "                     Otherwise, basic layout will be used.",
            "",
            "                     Raqm layout is recommended for all non-English text. If Raqm layout",
            "                     is not required, basic layout will have better performance.",
            "",
            "                     You can check support for Raqm layout using",
            "                     :py:func:`PIL.features.check_feature` with ``feature=\"raqm\"``.",
            "",
            "                     .. versionadded:: 4.2.0",
            "    :return: A font object.",
            "    :exception OSError: If the file could not be read.",
            "    \"\"\"",
            "",
            "    def freetype(font):",
            "        return FreeTypeFont(font, size, index, encoding, layout_engine)",
            "",
            "    try:",
            "        return freetype(font)",
            "    except OSError:",
            "        if not is_path(font):",
            "            raise",
            "        ttf_filename = os.path.basename(font)",
            "",
            "        dirs = []",
            "        if sys.platform == \"win32\":",
            "            # check the windows font repository",
            "            # NOTE: must use uppercase WINDIR, to work around bugs in",
            "            # 1.5.2's os.environ.get()",
            "            windir = os.environ.get(\"WINDIR\")",
            "            if windir:",
            "                dirs.append(os.path.join(windir, \"fonts\"))",
            "        elif sys.platform in (\"linux\", \"linux2\"):",
            "            lindirs = os.environ.get(\"XDG_DATA_DIRS\")",
            "            if not lindirs:",
            "                # According to the freedesktop spec, XDG_DATA_DIRS should",
            "                # default to /usr/share",
            "                lindirs = \"/usr/share\"",
            "            dirs += [os.path.join(lindir, \"fonts\") for lindir in lindirs.split(\":\")]",
            "        elif sys.platform == \"darwin\":",
            "            dirs += [",
            "                \"/Library/Fonts\",",
            "                \"/System/Library/Fonts\",",
            "                os.path.expanduser(\"~/Library/Fonts\"),",
            "            ]",
            "",
            "        ext = os.path.splitext(ttf_filename)[1]",
            "        first_font_with_a_different_extension = None",
            "        for directory in dirs:",
            "            for walkroot, walkdir, walkfilenames in os.walk(directory):",
            "                for walkfilename in walkfilenames:",
            "                    if ext and walkfilename == ttf_filename:",
            "                        return freetype(os.path.join(walkroot, walkfilename))",
            "                    elif not ext and os.path.splitext(walkfilename)[0] == ttf_filename:",
            "                        fontpath = os.path.join(walkroot, walkfilename)",
            "                        if os.path.splitext(fontpath)[1] == \".ttf\":",
            "                            return freetype(fontpath)",
            "                        if not ext and first_font_with_a_different_extension is None:",
            "                            first_font_with_a_different_extension = fontpath",
            "        if first_font_with_a_different_extension:",
            "            return freetype(first_font_with_a_different_extension)",
            "        raise",
            "",
            "",
            "def load_path(filename):",
            "    \"\"\"",
            "    Load font file. Same as :py:func:`~PIL.ImageFont.load`, but searches for a",
            "    bitmap font along the Python path.",
            "",
            "    :param filename: Name of font file.",
            "    :return: A font object.",
            "    :exception OSError: If the file could not be read.",
            "    \"\"\"",
            "    for directory in sys.path:",
            "        if is_directory(directory):",
            "            if not isinstance(filename, str):",
            "                filename = filename.decode(\"utf-8\")",
            "            try:",
            "                return load(os.path.join(directory, filename))",
            "            except OSError:",
            "                pass",
            "    msg = \"cannot find font file\"",
            "    raise OSError(msg)",
            "",
            "",
            "def load_default():",
            "    \"\"\"Load a \"better than nothing\" default font.",
            "",
            "    .. versionadded:: 1.1.4",
            "",
            "    :return: A font object.",
            "    \"\"\"",
            "    f = ImageFont()",
            "    f._load_pilfont_data(",
            "        # courB08",
            "        BytesIO(",
            "            base64.b64decode(",
            "                b\"\"\"",
            "UElMZm9udAo7Ozs7OzsxMDsKREFUQQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAA//8AAQAAAAAAAAABAAEA",
            "BgAAAAH/+gADAAAAAQAAAAMABgAGAAAAAf/6AAT//QADAAAABgADAAYAAAAA//kABQABAAYAAAAL",
            "AAgABgAAAAD/+AAFAAEACwAAABAACQAGAAAAAP/5AAUAAAAQAAAAFQAHAAYAAP////oABQAAABUA",
            "AAAbAAYABgAAAAH/+QAE//wAGwAAAB4AAwAGAAAAAf/5AAQAAQAeAAAAIQAIAAYAAAAB//kABAAB",
            "ACEAAAAkAAgABgAAAAD/+QAE//0AJAAAACgABAAGAAAAAP/6AAX//wAoAAAALQAFAAYAAAAB//8A",
            "BAACAC0AAAAwAAMABgAAAAD//AAF//0AMAAAADUAAQAGAAAAAf//AAMAAAA1AAAANwABAAYAAAAB",
            "//kABQABADcAAAA7AAgABgAAAAD/+QAFAAAAOwAAAEAABwAGAAAAAP/5AAYAAABAAAAARgAHAAYA",
            "AAAA//kABQAAAEYAAABLAAcABgAAAAD/+QAFAAAASwAAAFAABwAGAAAAAP/5AAYAAABQAAAAVgAH",
            "AAYAAAAA//kABQAAAFYAAABbAAcABgAAAAD/+QAFAAAAWwAAAGAABwAGAAAAAP/5AAUAAABgAAAA",
            "ZQAHAAYAAAAA//kABQAAAGUAAABqAAcABgAAAAD/+QAFAAAAagAAAG8ABwAGAAAAAf/8AAMAAABv",
            "AAAAcQAEAAYAAAAA//wAAwACAHEAAAB0AAYABgAAAAD/+gAE//8AdAAAAHgABQAGAAAAAP/7AAT/",
            "/gB4AAAAfAADAAYAAAAB//oABf//AHwAAACAAAUABgAAAAD/+gAFAAAAgAAAAIUABgAGAAAAAP/5",
            "AAYAAQCFAAAAiwAIAAYAAP////oABgAAAIsAAACSAAYABgAA////+gAFAAAAkgAAAJgABgAGAAAA",
            "AP/6AAUAAACYAAAAnQAGAAYAAP////oABQAAAJ0AAACjAAYABgAA////+gAFAAAAowAAAKkABgAG",
            "AAD////6AAUAAACpAAAArwAGAAYAAAAA//oABQAAAK8AAAC0AAYABgAA////+gAGAAAAtAAAALsA",
            "BgAGAAAAAP/6AAQAAAC7AAAAvwAGAAYAAP////oABQAAAL8AAADFAAYABgAA////+gAGAAAAxQAA",
            "AMwABgAGAAD////6AAUAAADMAAAA0gAGAAYAAP////oABQAAANIAAADYAAYABgAA////+gAGAAAA",
            "2AAAAN8ABgAGAAAAAP/6AAUAAADfAAAA5AAGAAYAAP////oABQAAAOQAAADqAAYABgAAAAD/+gAF",
            "AAEA6gAAAO8ABwAGAAD////6AAYAAADvAAAA9gAGAAYAAAAA//oABQAAAPYAAAD7AAYABgAA////",
            "+gAFAAAA+wAAAQEABgAGAAD////6AAYAAAEBAAABCAAGAAYAAP////oABgAAAQgAAAEPAAYABgAA",
            "////+gAGAAABDwAAARYABgAGAAAAAP/6AAYAAAEWAAABHAAGAAYAAP////oABgAAARwAAAEjAAYA",
            "BgAAAAD/+gAFAAABIwAAASgABgAGAAAAAf/5AAQAAQEoAAABKwAIAAYAAAAA//kABAABASsAAAEv",
            "AAgABgAAAAH/+QAEAAEBLwAAATIACAAGAAAAAP/5AAX//AEyAAABNwADAAYAAAAAAAEABgACATcA",
            "AAE9AAEABgAAAAH/+QAE//wBPQAAAUAAAwAGAAAAAP/7AAYAAAFAAAABRgAFAAYAAP////kABQAA",
            "AUYAAAFMAAcABgAAAAD/+wAFAAABTAAAAVEABQAGAAAAAP/5AAYAAAFRAAABVwAHAAYAAAAA//sA",
            "BQAAAVcAAAFcAAUABgAAAAD/+QAFAAABXAAAAWEABwAGAAAAAP/7AAYAAgFhAAABZwAHAAYAAP//",
            "//kABQAAAWcAAAFtAAcABgAAAAD/+QAGAAABbQAAAXMABwAGAAAAAP/5AAQAAgFzAAABdwAJAAYA",
            "AP////kABgAAAXcAAAF+AAcABgAAAAD/+QAGAAABfgAAAYQABwAGAAD////7AAUAAAGEAAABigAF",
            "AAYAAP////sABQAAAYoAAAGQAAUABgAAAAD/+wAFAAABkAAAAZUABQAGAAD////7AAUAAgGVAAAB",
            "mwAHAAYAAAAA//sABgACAZsAAAGhAAcABgAAAAD/+wAGAAABoQAAAacABQAGAAAAAP/7AAYAAAGn",
            "AAABrQAFAAYAAAAA//kABgAAAa0AAAGzAAcABgAA////+wAGAAABswAAAboABQAGAAD////7AAUA",
            "AAG6AAABwAAFAAYAAP////sABgAAAcAAAAHHAAUABgAAAAD/+wAGAAABxwAAAc0ABQAGAAD////7",
            "AAYAAgHNAAAB1AAHAAYAAAAA//sABQAAAdQAAAHZAAUABgAAAAH/+QAFAAEB2QAAAd0ACAAGAAAA",
            "Av/6AAMAAQHdAAAB3gAHAAYAAAAA//kABAABAd4AAAHiAAgABgAAAAD/+wAF//0B4gAAAecAAgAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAB",
            "//sAAwACAecAAAHpAAcABgAAAAD/+QAFAAEB6QAAAe4ACAAGAAAAAP/5AAYAAAHuAAAB9AAHAAYA",
            "AAAA//oABf//AfQAAAH5AAUABgAAAAD/+QAGAAAB+QAAAf8ABwAGAAAAAv/5AAMAAgH/AAACAAAJ",
            "AAYAAAAA//kABQABAgAAAAIFAAgABgAAAAH/+gAE//sCBQAAAggAAQAGAAAAAP/5AAYAAAIIAAAC",
            "DgAHAAYAAAAB//kABf/+Ag4AAAISAAUABgAA////+wAGAAACEgAAAhkABQAGAAAAAP/7AAX//gIZ",
            "AAACHgADAAYAAAAA//wABf/9Ah4AAAIjAAEABgAAAAD/+QAHAAACIwAAAioABwAGAAAAAP/6AAT/",
            "+wIqAAACLgABAAYAAAAA//kABP/8Ai4AAAIyAAMABgAAAAD/+gAFAAACMgAAAjcABgAGAAAAAf/5",
            "AAT//QI3AAACOgAEAAYAAAAB//kABP/9AjoAAAI9AAQABgAAAAL/+QAE//sCPQAAAj8AAgAGAAD/",
            "///7AAYAAgI/AAACRgAHAAYAAAAA//kABgABAkYAAAJMAAgABgAAAAH//AAD//0CTAAAAk4AAQAG",
            "AAAAAf//AAQAAgJOAAACUQADAAYAAAAB//kABP/9AlEAAAJUAAQABgAAAAH/+QAF//4CVAAAAlgA",
            "BQAGAAD////7AAYAAAJYAAACXwAFAAYAAP////kABgAAAl8AAAJmAAcABgAA////+QAGAAACZgAA",
            "Am0ABwAGAAD////5AAYAAAJtAAACdAAHAAYAAAAA//sABQACAnQAAAJ5AAcABgAA////9wAGAAAC",
            "eQAAAoAACQAGAAD////3AAYAAAKAAAAChwAJAAYAAP////cABgAAAocAAAKOAAkABgAA////9wAG",
            "AAACjgAAApUACQAGAAD////4AAYAAAKVAAACnAAIAAYAAP////cABgAAApwAAAKjAAkABgAA////",
            "+gAGAAACowAAAqoABgAGAAAAAP/6AAUAAgKqAAACrwAIAAYAAP////cABQAAAq8AAAK1AAkABgAA",
            "////9wAFAAACtQAAArsACQAGAAD////3AAUAAAK7AAACwQAJAAYAAP////gABQAAAsEAAALHAAgA",
            "BgAAAAD/9wAEAAACxwAAAssACQAGAAAAAP/3AAQAAALLAAACzwAJAAYAAAAA//cABAAAAs8AAALT",
            "AAkABgAAAAD/+AAEAAAC0wAAAtcACAAGAAD////6AAUAAALXAAAC3QAGAAYAAP////cABgAAAt0A",
            "AALkAAkABgAAAAD/9wAFAAAC5AAAAukACQAGAAAAAP/3AAUAAALpAAAC7gAJAAYAAAAA//cABQAA",
            "Au4AAALzAAkABgAAAAD/9wAFAAAC8wAAAvgACQAGAAAAAP/4AAUAAAL4AAAC/QAIAAYAAAAA//oA",
            "Bf//Av0AAAMCAAUABgAA////+gAGAAADAgAAAwkABgAGAAD////3AAYAAAMJAAADEAAJAAYAAP//",
            "//cABgAAAxAAAAMXAAkABgAA////9wAGAAADFwAAAx4ACQAGAAD////4AAYAAAAAAAoABwASAAYA",
            "AP////cABgAAAAcACgAOABMABgAA////+gAFAAAADgAKABQAEAAGAAD////6AAYAAAAUAAoAGwAQ",
            "AAYAAAAA//gABgAAABsACgAhABIABgAAAAD/+AAGAAAAIQAKACcAEgAGAAAAAP/4AAYAAAAnAAoA",
            "LQASAAYAAAAA//gABgAAAC0ACgAzABIABgAAAAD/+QAGAAAAMwAKADkAEQAGAAAAAP/3AAYAAAA5",
            "AAoAPwATAAYAAP////sABQAAAD8ACgBFAA8ABgAAAAD/+wAFAAIARQAKAEoAEQAGAAAAAP/4AAUA",
            "AABKAAoATwASAAYAAAAA//gABQAAAE8ACgBUABIABgAAAAD/+AAFAAAAVAAKAFkAEgAGAAAAAP/5",
            "AAUAAABZAAoAXgARAAYAAAAA//gABgAAAF4ACgBkABIABgAAAAD/+AAGAAAAZAAKAGoAEgAGAAAA",
            "AP/4AAYAAABqAAoAcAASAAYAAAAA//kABgAAAHAACgB2ABEABgAAAAD/+AAFAAAAdgAKAHsAEgAG",
            "AAD////4AAYAAAB7AAoAggASAAYAAAAA//gABQAAAIIACgCHABIABgAAAAD/+AAFAAAAhwAKAIwA",
            "EgAGAAAAAP/4AAUAAACMAAoAkQASAAYAAAAA//gABQAAAJEACgCWABIABgAAAAD/+QAFAAAAlgAK",
            "AJsAEQAGAAAAAP/6AAX//wCbAAoAoAAPAAYAAAAA//oABQABAKAACgClABEABgAA////+AAGAAAA",
            "pQAKAKwAEgAGAAD////4AAYAAACsAAoAswASAAYAAP////gABgAAALMACgC6ABIABgAA////+QAG",
            "AAAAugAKAMEAEQAGAAD////4AAYAAgDBAAoAyAAUAAYAAP////kABQACAMgACgDOABMABgAA////",
            "+QAGAAIAzgAKANUAEw==",
            "\"\"\"",
            "            )",
            "        ),",
            "        Image.open(",
            "            BytesIO(",
            "                base64.b64decode(",
            "                    b\"\"\"",
            "iVBORw0KGgoAAAANSUhEUgAAAx4AAAAUAQAAAAArMtZoAAAEwElEQVR4nABlAJr/AHVE4czCI/4u",
            "Mc4b7vuds/xzjz5/3/7u/n9vMe7vnfH/9++vPn/xyf5zhxzjt8GHw8+2d83u8x27199/nxuQ6Od9",
            "M43/5z2I+9n9ZtmDBwMQECDRQw/eQIQohJXxpBCNVE6QCCAAAAD//wBlAJr/AgALyj1t/wINwq0g",
            "LeNZUworuN1cjTPIzrTX6ofHWeo3v336qPzfEwRmBnHTtf95/fglZK5N0PDgfRTslpGBvz7LFc4F",
            "IUXBWQGjQ5MGCx34EDFPwXiY4YbYxavpnhHFrk14CDAAAAD//wBlAJr/AgKqRooH2gAgPeggvUAA",
            "Bu2WfgPoAwzRAABAAAAAAACQgLz/3Uv4Gv+gX7BJgDeeGP6AAAD1NMDzKHD7ANWr3loYbxsAD791",
            "NAADfcoIDyP44K/jv4Y63/Z+t98Ovt+ub4T48LAAAAD//wBlAJr/AuplMlADJAAAAGuAphWpqhMx",
            "in0A/fRvAYBABPgBwBUgABBQ/sYAyv9g0bCHgOLoGAAAAAAAREAAwI7nr0ArYpow7aX8//9LaP/9",
            "SjdavWA8ePHeBIKB//81/83ndznOaXx379wAAAD//wBlAJr/AqDxW+D3AABAAbUh/QMnbQag/gAY",
            "AYDAAACgtgD/gOqAAAB5IA/8AAAk+n9w0AAA8AAAmFRJuPo27ciC0cD5oeW4E7KA/wD3ECMAn2tt",
            "y8PgwH8AfAxFzC0JzeAMtratAsC/ffwAAAD//wBlAJr/BGKAyCAA4AAAAvgeYTAwHd1kmQF5chkG",
            "ABoMIHcL5xVpTfQbUqzlAAAErwAQBgAAEOClA5D9il08AEh/tUzdCBsXkbgACED+woQg8Si9VeqY",
            "lODCn7lmF6NhnAEYgAAA/NMIAAAAAAD//2JgjLZgVGBg5Pv/Tvpc8hwGBjYGJADjHDrAwPzAjv/H",
            "/Wf3PzCwtzcwHmBgYGcwbZz8wHaCAQMDOwMDQ8MCBgYOC3W7mp+f0w+wHOYxO3OG+e376hsMZjk3",
            "AAAAAP//YmCMY2A4wMAIN5e5gQETPD6AZisDAwMDgzSDAAPjByiHcQMDAwMDg1nOze1lByRu5/47",
            "c4859311AYNZzg0AAAAA//9iYGDBYihOIIMuwIjGL39/fwffA8b//xv/P2BPtzzHwCBjUQAAAAD/",
            "/yLFBrIBAAAA//9i1HhcwdhizX7u8NZNzyLbvT97bfrMf/QHI8evOwcSqGUJAAAA//9iYBB81iSw",
            "pEE170Qrg5MIYydHqwdDQRMrAwcVrQAAAAD//2J4x7j9AAMDn8Q/BgYLBoaiAwwMjPdvMDBYM1Tv",
            "oJodAAAAAP//Yqo/83+dxePWlxl3npsel9lvLfPcqlE9725C+acfVLMEAAAA//9i+s9gwCoaaGMR",
            "evta/58PTEWzr21hufPjA8N+qlnBwAAAAAD//2JiWLci5v1+HmFXDqcnULE/MxgYGBj+f6CaJQAA",
            "AAD//2Ji2FrkY3iYpYC5qDeGgeEMAwPDvwQBBoYvcTwOVLMEAAAA//9isDBgkP///0EOg9z35v//",
            "Gc/eeW7BwPj5+QGZhANUswMAAAD//2JgqGBgYGBgqEMXlvhMPUsAAAAA//8iYDd1AAAAAP//AwDR",
            "w7IkEbzhVQAAAABJRU5ErkJggg==",
            "\"\"\"",
            "                )",
            "            )",
            "        ),",
            "    )",
            "    return f"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.PIL.ImageFont.FreeTypeFont.getmask",
            "src.PIL.ImageFont.TransposedFont.getlength",
            "src.PIL.ImageFont.ImageFont.getbbox",
            "src.PIL.ImageFont.FreeTypeFont.getbbox",
            "src.PIL.ImageFont.FreeTypeFont.getmask2",
            "src.PIL.ImageFont.ImageFont.getlength",
            "src.borg.helpers.parseformat",
            "src.PIL.ImageFont.FreeTypeFont.getlength"
        ]
    }
}