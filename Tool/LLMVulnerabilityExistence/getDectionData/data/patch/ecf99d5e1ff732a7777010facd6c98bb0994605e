{
    "lib/ansible/plugins/action/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         '''"
            },
            "1": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 277,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "         become_unprivileged = self._is_become_unprivileged()"
            },
            "3": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "4": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            remote_tmp = self._connection._shell.get_option('remote_tmp')"
            },
            "5": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except AnsibleError:"
            },
            "6": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            remote_tmp = '~/.ansible/tmp'"
            },
            "7": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 279,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         # deal with tmpdir creation"
            },
            "9": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "         basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))"
            },
            "10": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "         if getattr(self._connection, '_remote_is_local', False):"
            },
            "11": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "             tmpdir = C.DEFAULT_LOCAL_TMP"
            },
            "12": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         else:"
            },
            "13": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            tmpdir = self._remote_expand_user(remote_tmp, sudoable=False)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+            # NOTE: shell plugins should populate this setting anyways, but they dont do remote expansion, which"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+            # we need for 'non posix' systems like cloud-init and solaris"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+            try:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+                tmpdir = self._connection._shell.get_option('remote_tmp')"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+            except AnsibleError:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+                tmpdir = '~/.ansible/tmp'"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+            tmpdir = self._remote_expand_user(tmpdir, sudoable=False)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+        basefile = self._connection._shell._generate_temp_dir_name()"
            },
            "23": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         cmd = self._connection._shell.mkdtemp(basefile=basefile, system=become_unprivileged, tmpdir=tmpdir)"
            },
            "24": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "         result = self._low_level_execute_command(cmd, sudoable=False)"
            },
            "25": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 299,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "             elif u'No space left on device' in result['stderr']:"
            },
            "27": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "                 output = result['stderr']"
            },
            "28": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "             else:"
            },
            "29": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                output = ('Authentication or permission failure. '"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+                output = ('Failed to create temporary directory.'"
            },
            "31": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "                           'In some cases, you may have been able to authenticate and did not have permissions on the target directory. '"
            },
            "32": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                          'Consider changing the remote tmp path in ansible.cfg to a path rooted in \"/tmp\". '"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+                          'Consider changing the remote tmp path in ansible.cfg to a path rooted in \"/tmp\", for more error information use -vvv. '"
            },
            "34": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "                           'Failed command was: %s, exited with result %d' % (cmd, result['rc']))"
            },
            "35": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 319,
                "PatchRowcode": "             if 'stdout' in result and result['stdout'] != u'':"
            },
            "36": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "                 output = output + u\", stdout output: %s\" % result['stdout']"
            }
        },
        "frontPatchFile": [
            "# coding: utf-8",
            "# Copyright: (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright: (c) 2018, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import base64",
            "import json",
            "import os",
            "import random",
            "import re",
            "import stat",
            "import tempfile",
            "import time",
            "from abc import ABCMeta, abstractmethod",
            "",
            "from ansible import constants as C",
            "from ansible.errors import AnsibleError, AnsibleConnectionFailure, AnsibleActionSkip, AnsibleActionFail",
            "from ansible.executor.module_common import modify_module",
            "from ansible.module_utils.json_utils import _filter_non_json_lines",
            "from ansible.module_utils.six import binary_type, string_types, text_type, iteritems, with_metaclass",
            "from ansible.module_utils.six.moves import shlex_quote",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.parsing.utils.jsonify import jsonify",
            "from ansible.release import __version__",
            "from ansible.utils.unsafe_proxy import wrap_var",
            "from ansible.vars.clean import remove_internal_keys",
            "",
            "",
            "try:",
            "    from __main__ import display",
            "except ImportError:",
            "    from ansible.utils.display import Display",
            "    display = Display()",
            "",
            "",
            "class ActionBase(with_metaclass(ABCMeta, object)):",
            "",
            "    '''",
            "    This class is the base class for all action plugins, and defines",
            "    code common to all actions. The base class handles the connection",
            "    by putting/getting files and executing commands based on the current",
            "    action in use.",
            "    '''",
            "",
            "    # A set of valid arguments",
            "    _VALID_ARGS = frozenset([])",
            "",
            "    def __init__(self, task, connection, play_context, loader, templar, shared_loader_obj):",
            "        self._task = task",
            "        self._connection = connection",
            "        self._play_context = play_context",
            "        self._loader = loader",
            "        self._templar = templar",
            "        self._shared_loader_obj = shared_loader_obj",
            "        self._cleanup_remote_tmp = False",
            "",
            "        self._supports_check_mode = True",
            "        self._supports_async = False",
            "",
            "        # Backwards compat: self._display isn't really needed, just import the global display and use that.",
            "        self._display = display",
            "",
            "        self._used_interpreter = None",
            "",
            "    @abstractmethod",
            "    def run(self, tmp=None, task_vars=None):",
            "        \"\"\" Action Plugins should implement this method to perform their",
            "        tasks.  Everything else in this base class is a helper method for the",
            "        action plugin to do that.",
            "",
            "        :kwarg tmp: Deprecated parameter.  This is no longer used.  An action plugin that calls",
            "            another one and wants to use the same remote tmp for both should set",
            "            self._connection._shell.tmpdir rather than this parameter.",
            "        :kwarg task_vars: The variables (host vars, group vars, config vars,",
            "            etc) associated with this task.",
            "        :returns: dictionary of results from the module",
            "",
            "        Implementors of action modules may find the following variables especially useful:",
            "",
            "        * Module parameters.  These are stored in self._task.args",
            "        \"\"\"",
            "",
            "        result = {}",
            "",
            "        if tmp is not None:",
            "            result['warning'] = ['ActionModule.run() no longer honors the tmp parameter. Action'",
            "                                 ' plugins should set self._connection._shell.tmpdir to share'",
            "                                 ' the tmpdir']",
            "        del tmp",
            "",
            "        if self._task.async_val and not self._supports_async:",
            "            raise AnsibleActionFail('async is not supported for this task.')",
            "        elif self._play_context.check_mode and not self._supports_check_mode:",
            "            raise AnsibleActionSkip('check mode is not supported for this task.')",
            "        elif self._task.async_val and self._play_context.check_mode:",
            "            raise AnsibleActionFail('check mode and async cannot be used on same task.')",
            "",
            "        # Error if invalid argument is passed",
            "        if self._VALID_ARGS:",
            "            task_opts = frozenset(self._task.args.keys())",
            "            bad_opts = task_opts.difference(self._VALID_ARGS)",
            "            if bad_opts:",
            "                raise AnsibleActionFail('Invalid options for %s: %s' % (self._task.action, ','.join(list(bad_opts))))",
            "",
            "        if self._connection._shell.tmpdir is None and self._early_needs_tmp_path():",
            "            self._make_tmp_path()",
            "",
            "        return result",
            "",
            "    def _remote_file_exists(self, path):",
            "        cmd = self._connection._shell.exists(path)",
            "        result = self._low_level_execute_command(cmd=cmd, sudoable=True)",
            "        if result['rc'] == 0:",
            "            return True",
            "        return False",
            "",
            "    def _configure_module(self, module_name, module_args, task_vars=None):",
            "        '''",
            "        Handles the loading and templating of the module code through the",
            "        modify_module() function.",
            "        '''",
            "        if task_vars is None:",
            "            task_vars = dict()",
            "",
            "        # Search module path(s) for named module.",
            "        for mod_type in self._connection.module_implementation_preferences:",
            "            # Check to determine if PowerShell modules are supported, and apply",
            "            # some fixes (hacks) to module name + args.",
            "            if mod_type == '.ps1':",
            "                # win_stat, win_file, and win_copy are not just like their",
            "                # python counterparts but they are compatible enough for our",
            "                # internal usage",
            "                if module_name in ('stat', 'file', 'copy') and self._task.action != module_name:",
            "                    module_name = 'win_%s' % module_name",
            "",
            "                # Remove extra quotes surrounding path parameters before sending to module.",
            "                if module_name in ('win_stat', 'win_file', 'win_copy', 'slurp') and module_args and hasattr(self._connection._shell, '_unquote'):",
            "                    for key in ('src', 'dest', 'path'):",
            "                        if key in module_args:",
            "                            module_args[key] = self._connection._shell._unquote(module_args[key])",
            "",
            "            module_path = self._shared_loader_obj.module_loader.find_plugin(module_name, mod_type)",
            "            if module_path:",
            "                break",
            "        else:  # This is a for-else: http://bit.ly/1ElPkyg",
            "            # Use Windows version of ping module to check module paths when",
            "            # using a connection that supports .ps1 suffixes. We check specifically",
            "            # for win_ping here, otherwise the code would look for ping.ps1",
            "            if '.ps1' in self._connection.module_implementation_preferences:",
            "                ping_module = 'win_ping'",
            "            else:",
            "                ping_module = 'ping'",
            "            module_path2 = self._shared_loader_obj.module_loader.find_plugin(ping_module, self._connection.module_implementation_preferences)",
            "            if module_path2 is not None:",
            "                raise AnsibleError(\"The module %s was not found in configured module paths\" % (module_name))",
            "            else:",
            "                raise AnsibleError(\"The module %s was not found in configured module paths. \"",
            "                                   \"Additionally, core modules are missing. If this is a checkout, \"",
            "                                   \"run 'git pull --rebase' to correct this problem.\" % (module_name))",
            "",
            "        # insert shared code and arguments into the module",
            "        final_environment = dict()",
            "        self._compute_environment_string(final_environment)",
            "",
            "        (module_data, module_style, module_shebang) = modify_module(module_name, module_path, module_args, self._templar,",
            "                                                                    task_vars=task_vars,",
            "                                                                    module_compression=self._play_context.module_compression,",
            "                                                                    async_timeout=self._task.async_val,",
            "                                                                    become=self._play_context.become,",
            "                                                                    become_method=self._play_context.become_method,",
            "                                                                    become_user=self._play_context.become_user,",
            "                                                                    become_password=self._play_context.become_pass,",
            "                                                                    become_flags=self._play_context.become_flags,",
            "                                                                    environment=final_environment)",
            "",
            "        return (module_style, module_shebang, module_data, module_path)",
            "",
            "    def _compute_environment_string(self, raw_environment_out=None):",
            "        '''",
            "        Builds the environment string to be used when executing the remote task.",
            "        '''",
            "",
            "        final_environment = dict()",
            "        if self._task.environment is not None:",
            "            environments = self._task.environment",
            "            if not isinstance(environments, list):",
            "                environments = [environments]",
            "",
            "            # The order of environments matters to make sure we merge",
            "            # in the parent's values first so those in the block then",
            "            # task 'win' in precedence",
            "            for environment in environments:",
            "                if environment is None or len(environment) == 0:",
            "                    continue",
            "                temp_environment = self._templar.template(environment)",
            "                if not isinstance(temp_environment, dict):",
            "                    raise AnsibleError(\"environment must be a dictionary, received %s (%s)\" % (temp_environment, type(temp_environment)))",
            "                # very deliberately using update here instead of combine_vars, as",
            "                # these environment settings should not need to merge sub-dicts",
            "                final_environment.update(temp_environment)",
            "",
            "        if len(final_environment) > 0:",
            "            final_environment = self._templar.template(final_environment)",
            "",
            "        if isinstance(raw_environment_out, dict):",
            "            raw_environment_out.clear()",
            "            raw_environment_out.update(final_environment)",
            "",
            "        return self._connection._shell.env_prefix(**final_environment)",
            "",
            "    def _early_needs_tmp_path(self):",
            "        '''",
            "        Determines if a tmp path should be created before the action is executed.",
            "        '''",
            "",
            "        return getattr(self, 'TRANSFERS_FILES', False)",
            "",
            "    def _is_pipelining_enabled(self, module_style, wrap_async=False):",
            "        '''",
            "        Determines if we are required and can do pipelining",
            "        '''",
            "",
            "        # any of these require a true",
            "        for condition in [",
            "            self._connection.has_pipelining,",
            "            self._play_context.pipelining or self._connection.always_pipeline_modules,  # pipelining enabled for play or connection requires it (eg winrm)",
            "            module_style == \"new\",                     # old style modules do not support pipelining",
            "            not C.DEFAULT_KEEP_REMOTE_FILES,           # user wants remote files",
            "            not wrap_async or self._connection.always_pipeline_modules,  # async does not normally support pipelining unless it does (eg winrm)",
            "            self._play_context.become_method != 'su',  # su does not work with pipelining,",
            "            # FIXME: we might need to make become_method exclusion a configurable list",
            "        ]:",
            "            if not condition:",
            "                return False",
            "",
            "        return True",
            "",
            "    def _get_admin_users(self):",
            "        '''",
            "        Returns a list of admin users that are configured for the current shell",
            "        plugin",
            "        '''",
            "        try:",
            "            admin_users = self._connection._shell.get_option('admin_users')",
            "        except AnsibleError:",
            "            # fallback for old custom plugins w/o get_option",
            "            admin_users = ['root']",
            "        return admin_users",
            "",
            "    def _is_become_unprivileged(self):",
            "        '''",
            "        The user is not the same as the connection user and is not part of the",
            "        shell configured admin users",
            "        '''",
            "        # if we don't use become then we know we aren't switching to a",
            "        # different unprivileged user",
            "        if not self._play_context.become:",
            "            return False",
            "",
            "        # if we use become and the user is not an admin (or same user) then",
            "        # we need to return become_unprivileged as True",
            "        admin_users = self._get_admin_users()",
            "        try:",
            "            remote_user = self._connection.get_option('remote_user')",
            "        except AnsibleError:",
            "            remote_user = self._play_context.remote_user",
            "        return bool(self._play_context.become_user not in admin_users + [remote_user])",
            "",
            "    def _make_tmp_path(self, remote_user=None):",
            "        '''",
            "        Create and return a temporary path on a remote box.",
            "        '''",
            "",
            "        become_unprivileged = self._is_become_unprivileged()",
            "        try:",
            "            remote_tmp = self._connection._shell.get_option('remote_tmp')",
            "        except AnsibleError:",
            "            remote_tmp = '~/.ansible/tmp'",
            "",
            "        # deal with tmpdir creation",
            "        basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))",
            "        # Network connection plugins (network_cli, netconf, etc.) execute on the controller, rather than the remote host.",
            "        # As such, we want to avoid using remote_user for paths  as remote_user may not line up with the local user",
            "        # This is a hack and should be solved by more intelligent handling of remote_tmp in 2.7",
            "        if getattr(self._connection, '_remote_is_local', False):",
            "            tmpdir = C.DEFAULT_LOCAL_TMP",
            "        else:",
            "            tmpdir = self._remote_expand_user(remote_tmp, sudoable=False)",
            "        cmd = self._connection._shell.mkdtemp(basefile=basefile, system=become_unprivileged, tmpdir=tmpdir)",
            "        result = self._low_level_execute_command(cmd, sudoable=False)",
            "",
            "        # error handling on this seems a little aggressive?",
            "        if result['rc'] != 0:",
            "            if result['rc'] == 5:",
            "                output = 'Authentication failure.'",
            "            elif result['rc'] == 255 and self._connection.transport in ('ssh',):",
            "",
            "                if self._play_context.verbosity > 3:",
            "                    output = u'SSH encountered an unknown error. The output was:\\n%s%s' % (result['stdout'], result['stderr'])",
            "                else:",
            "                    output = (u'SSH encountered an unknown error during the connection. '",
            "                              'We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue')",
            "",
            "            elif u'No space left on device' in result['stderr']:",
            "                output = result['stderr']",
            "            else:",
            "                output = ('Authentication or permission failure. '",
            "                          'In some cases, you may have been able to authenticate and did not have permissions on the target directory. '",
            "                          'Consider changing the remote tmp path in ansible.cfg to a path rooted in \"/tmp\". '",
            "                          'Failed command was: %s, exited with result %d' % (cmd, result['rc']))",
            "            if 'stdout' in result and result['stdout'] != u'':",
            "                output = output + u\", stdout output: %s\" % result['stdout']",
            "            if self._play_context.verbosity > 3 and 'stderr' in result and result['stderr'] != u'':",
            "                output += u\", stderr output: %s\" % result['stderr']",
            "            raise AnsibleConnectionFailure(output)",
            "        else:",
            "            self._cleanup_remote_tmp = True",
            "",
            "        try:",
            "            stdout_parts = result['stdout'].strip().split('%s=' % basefile, 1)",
            "            rc = self._connection._shell.join_path(stdout_parts[-1], u'').splitlines()[-1]",
            "        except IndexError:",
            "            # stdout was empty or just space, set to / to trigger error in next if",
            "            rc = '/'",
            "",
            "        # Catch failure conditions, files should never be",
            "        # written to locations in /.",
            "        if rc == '/':",
            "            raise AnsibleError('failed to resolve remote temporary directory from %s: `%s` returned empty string' % (basefile, cmd))",
            "",
            "        self._connection._shell.tmpdir = rc",
            "",
            "        return rc",
            "",
            "    def _should_remove_tmp_path(self, tmp_path):",
            "        '''Determine if temporary path should be deleted or kept by user request/config'''",
            "        return tmp_path and self._cleanup_remote_tmp and not C.DEFAULT_KEEP_REMOTE_FILES and \"-tmp-\" in tmp_path",
            "",
            "    def _remove_tmp_path(self, tmp_path):",
            "        '''Remove a temporary path we created. '''",
            "",
            "        if tmp_path is None and self._connection._shell.tmpdir:",
            "            tmp_path = self._connection._shell.tmpdir",
            "",
            "        if self._should_remove_tmp_path(tmp_path):",
            "            cmd = self._connection._shell.remove(tmp_path, recurse=True)",
            "            # If we have gotten here we have a working ssh configuration.",
            "            # If ssh breaks we could leave tmp directories out on the remote system.",
            "            tmp_rm_res = self._low_level_execute_command(cmd, sudoable=False)",
            "",
            "            if tmp_rm_res.get('rc', 0) != 0:",
            "                display.warning('Error deleting remote temporary files (rc: %s, stderr: %s})'",
            "                                % (tmp_rm_res.get('rc'), tmp_rm_res.get('stderr', 'No error string available.')))",
            "            else:",
            "                self._connection._shell.tmpdir = None",
            "",
            "    def _transfer_file(self, local_path, remote_path):",
            "        \"\"\"",
            "        Copy a file from the controller to a remote path",
            "",
            "        :arg local_path: Path on controller to transfer",
            "        :arg remote_path: Path on the remote system to transfer into",
            "",
            "        .. warning::",
            "            * When you use this function you likely want to use use fixup_perms2() on the",
            "              remote_path to make sure that the remote file is readable when the user becomes",
            "              a non-privileged user.",
            "            * If you use fixup_perms2() on the file and copy or move the file into place, you will",
            "              need to then remove filesystem acls on the file once it has been copied into place by",
            "              the module.  See how the copy module implements this for help.",
            "        \"\"\"",
            "        self._connection.put_file(local_path, remote_path)",
            "        return remote_path",
            "",
            "    def _transfer_data(self, remote_path, data):",
            "        '''",
            "        Copies the module data out to the temporary module path.",
            "        '''",
            "",
            "        if isinstance(data, dict):",
            "            data = jsonify(data)",
            "",
            "        afd, afile = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)",
            "        afo = os.fdopen(afd, 'wb')",
            "        try:",
            "            data = to_bytes(data, errors='surrogate_or_strict')",
            "            afo.write(data)",
            "        except Exception as e:",
            "            raise AnsibleError(\"failure writing module data to temporary file for transfer: %s\" % to_native(e))",
            "",
            "        afo.flush()",
            "        afo.close()",
            "",
            "        try:",
            "            self._transfer_file(afile, remote_path)",
            "        finally:",
            "            os.unlink(afile)",
            "",
            "        return remote_path",
            "",
            "    def _fixup_perms2(self, remote_paths, remote_user=None, execute=True):",
            "        \"\"\"",
            "        We need the files we upload to be readable (and sometimes executable)",
            "        by the user being sudo'd to but we want to limit other people's access",
            "        (because the files could contain passwords or other private",
            "        information.  We achieve this in one of these ways:",
            "",
            "        * If no sudo is performed or the remote_user is sudo'ing to",
            "          themselves, we don't have to change permissions.",
            "        * If the remote_user sudo's to a privileged user (for instance, root),",
            "          we don't have to change permissions",
            "        * If the remote_user sudo's to an unprivileged user then we attempt to",
            "          grant the unprivileged user access via file system acls.",
            "        * If granting file system acls fails we try to change the owner of the",
            "          file with chown which only works in case the remote_user is",
            "          privileged or the remote systems allows chown calls by unprivileged",
            "          users (e.g. HP-UX)",
            "        * If the chown fails we can set the file to be world readable so that",
            "          the second unprivileged user can read the file.",
            "          Since this could allow other users to get access to private",
            "          information we only do this if ansible is configured with",
            "          \"allow_world_readable_tmpfiles\" in the ansible.cfg",
            "        \"\"\"",
            "        if remote_user is None:",
            "            remote_user = self._play_context.remote_user",
            "",
            "        if self._connection._shell.SHELL_FAMILY == 'powershell':",
            "            # This won't work on Powershell as-is, so we'll just completely skip until",
            "            # we have a need for it, at which point we'll have to do something different.",
            "            return remote_paths",
            "",
            "        if self._is_become_unprivileged():",
            "            # Unprivileged user that's different than the ssh user.  Let's get",
            "            # to work!",
            "",
            "            # Try to use file system acls to make the files readable for sudo'd",
            "            # user",
            "            if execute:",
            "                chmod_mode = 'rx'",
            "                setfacl_mode = 'r-x'",
            "            else:",
            "                chmod_mode = 'rX'",
            "                # NOTE: this form fails silently on freebsd.  We currently",
            "                # never call _fixup_perms2() with execute=False but if we",
            "                # start to we'll have to fix this.",
            "                setfacl_mode = 'r-X'",
            "",
            "            res = self._remote_set_user_facl(remote_paths, self._play_context.become_user, setfacl_mode)",
            "            if res['rc'] != 0:",
            "                # File system acls failed; let's try to use chown next",
            "                # Set executable bit first as on some systems an",
            "                # unprivileged user can use chown",
            "                if execute:",
            "                    res = self._remote_chmod(remote_paths, 'u+x')",
            "                    if res['rc'] != 0:",
            "                        raise AnsibleError('Failed to set file mode on remote temporary files (rc: {0}, err: {1})'.format(res['rc'], to_native(res['stderr'])))",
            "",
            "                res = self._remote_chown(remote_paths, self._play_context.become_user)",
            "                if res['rc'] != 0 and remote_user in self._get_admin_users():",
            "                    # chown failed even if remote_user is administrator/root",
            "                    raise AnsibleError('Failed to change ownership of the temporary files Ansible needs to create despite connecting as a privileged user. '",
            "                                       'Unprivileged become user would be unable to read the file.')",
            "                elif res['rc'] != 0:",
            "                    if C.ALLOW_WORLD_READABLE_TMPFILES:",
            "                        # chown and fs acls failed -- do things this insecure",
            "                        # way only if the user opted in in the config file",
            "                        display.warning('Using world-readable permissions for temporary files Ansible needs to create when becoming an unprivileged user. '",
            "                                        'This may be insecure. For information on securing this, see '",
            "                                        'https://docs.ansible.com/ansible/become.html#becoming-an-unprivileged-user')",
            "                        res = self._remote_chmod(remote_paths, 'a+%s' % chmod_mode)",
            "                        if res['rc'] != 0:",
            "                            raise AnsibleError('Failed to set file mode on remote files (rc: {0}, err: {1})'.format(res['rc'], to_native(res['stderr'])))",
            "                    else:",
            "                        raise AnsibleError('Failed to set permissions on the temporary files Ansible needs to create when becoming an unprivileged user '",
            "                                           '(rc: %s, err: %s}). For information on working around this, see '",
            "                                           'https://docs.ansible.com/ansible/become.html#becoming-an-unprivileged-user'",
            "                                           % (res['rc'], to_native(res['stderr'])))",
            "        elif execute:",
            "            # Can't depend on the file being transferred with execute permissions.",
            "            # Only need user perms because no become was used here",
            "            res = self._remote_chmod(remote_paths, 'u+x')",
            "            if res['rc'] != 0:",
            "                raise AnsibleError('Failed to set execute bit on remote files (rc: {0}, err: {1})'.format(res['rc'], to_native(res['stderr'])))",
            "",
            "        return remote_paths",
            "",
            "    def _remote_chmod(self, paths, mode, sudoable=False):",
            "        '''",
            "        Issue a remote chmod command",
            "        '''",
            "        cmd = self._connection._shell.chmod(paths, mode)",
            "        res = self._low_level_execute_command(cmd, sudoable=sudoable)",
            "        return res",
            "",
            "    def _remote_chown(self, paths, user, sudoable=False):",
            "        '''",
            "        Issue a remote chown command",
            "        '''",
            "        cmd = self._connection._shell.chown(paths, user)",
            "        res = self._low_level_execute_command(cmd, sudoable=sudoable)",
            "        return res",
            "",
            "    def _remote_set_user_facl(self, paths, user, mode, sudoable=False):",
            "        '''",
            "        Issue a remote call to setfacl",
            "        '''",
            "        cmd = self._connection._shell.set_user_facl(paths, user, mode)",
            "        res = self._low_level_execute_command(cmd, sudoable=sudoable)",
            "        return res",
            "",
            "    def _execute_remote_stat(self, path, all_vars, follow, tmp=None, checksum=True):",
            "        '''",
            "        Get information from remote file.",
            "        '''",
            "        if tmp is not None:",
            "            display.warning('_execute_remote_stat no longer honors the tmp parameter. Action'",
            "                            ' plugins should set self._connection._shell.tmpdir to share'",
            "                            ' the tmpdir')",
            "        del tmp  # No longer used",
            "",
            "        module_args = dict(",
            "            path=path,",
            "            follow=follow,",
            "            get_checksum=checksum,",
            "            checksum_algo='sha1',",
            "        )",
            "        mystat = self._execute_module(module_name='stat', module_args=module_args, task_vars=all_vars,",
            "                                      wrap_async=False)",
            "",
            "        if mystat.get('failed'):",
            "            msg = mystat.get('module_stderr')",
            "            if not msg:",
            "                msg = mystat.get('module_stdout')",
            "            if not msg:",
            "                msg = mystat.get('msg')",
            "            raise AnsibleError('Failed to get information on remote file (%s): %s' % (path, msg))",
            "",
            "        if not mystat['stat']['exists']:",
            "            # empty might be matched, 1 should never match, also backwards compatible",
            "            mystat['stat']['checksum'] = '1'",
            "",
            "        # happens sometimes when it is a dir and not on bsd",
            "        if 'checksum' not in mystat['stat']:",
            "            mystat['stat']['checksum'] = ''",
            "        elif not isinstance(mystat['stat']['checksum'], string_types):",
            "            raise AnsibleError(\"Invalid checksum returned by stat: expected a string type but got %s\" % type(mystat['stat']['checksum']))",
            "",
            "        return mystat['stat']",
            "",
            "    def _remote_checksum(self, path, all_vars, follow=False):",
            "        '''",
            "        Produces a remote checksum given a path,",
            "        Returns a number 0-4 for specific errors instead of checksum, also ensures it is different",
            "        0 = unknown error",
            "        1 = file does not exist, this might not be an error",
            "        2 = permissions issue",
            "        3 = its a directory, not a file",
            "        4 = stat module failed, likely due to not finding python",
            "        5 = appropriate json module not found",
            "        '''",
            "        x = \"0\"  # unknown error has occurred",
            "        try:",
            "            remote_stat = self._execute_remote_stat(path, all_vars, follow=follow)",
            "            if remote_stat['exists'] and remote_stat['isdir']:",
            "                x = \"3\"  # its a directory not a file",
            "            else:",
            "                x = remote_stat['checksum']  # if 1, file is missing",
            "        except AnsibleError as e:",
            "            errormsg = to_text(e)",
            "            if errormsg.endswith(u'Permission denied'):",
            "                x = \"2\"  # cannot read file",
            "            elif errormsg.endswith(u'MODULE FAILURE'):",
            "                x = \"4\"  # python not found or module uncaught exception",
            "            elif 'json' in errormsg:",
            "                x = \"5\"  # json module needed",
            "        finally:",
            "            return x  # pylint: disable=lost-exception",
            "",
            "    def _remote_expand_user(self, path, sudoable=True, pathsep=None):",
            "        ''' takes a remote path and performs tilde/$HOME expansion on the remote host '''",
            "",
            "        # We only expand ~/path and ~username/path",
            "        if not path.startswith('~'):",
            "            return path",
            "",
            "        # Per Jborean, we don't have to worry about Windows as we don't have a notion of user's home",
            "        # dir there.",
            "        split_path = path.split(os.path.sep, 1)",
            "        expand_path = split_path[0]",
            "",
            "        if expand_path == '~':",
            "            # Network connection plugins (network_cli, netconf, etc.) execute on the controller, rather than the remote host.",
            "            # As such, we want to avoid using remote_user for paths  as remote_user may not line up with the local user",
            "            # This is a hack and should be solved by more intelligent handling of remote_tmp in 2.7",
            "            if getattr(self._connection, '_remote_is_local', False):",
            "                pass",
            "            elif sudoable and self._play_context.become and self._play_context.become_user:",
            "                expand_path = '~%s' % self._play_context.become_user",
            "            else:",
            "                # use remote user instead, if none set default to current user",
            "                expand_path = '~%s' % (self._play_context.remote_user or self._connection.default_user or '')",
            "",
            "        # use shell to construct appropriate command and execute",
            "        cmd = self._connection._shell.expand_user(expand_path)",
            "        data = self._low_level_execute_command(cmd, sudoable=False)",
            "",
            "        try:",
            "            initial_fragment = data['stdout'].strip().splitlines()[-1]",
            "        except IndexError:",
            "            initial_fragment = None",
            "",
            "        if not initial_fragment:",
            "            # Something went wrong trying to expand the path remotely. Try using pwd, if not, return",
            "            # the original string",
            "            cmd = self._connection._shell.pwd()",
            "            pwd = self._low_level_execute_command(cmd, sudoable=False).get('stdout', '').strip()",
            "            if pwd:",
            "                expanded = pwd",
            "            else:",
            "                expanded = path",
            "",
            "        elif len(split_path) > 1:",
            "            expanded = self._connection._shell.join_path(initial_fragment, *split_path[1:])",
            "        else:",
            "            expanded = initial_fragment",
            "",
            "        if '..' in os.path.dirname(expanded).split('/'):",
            "            raise AnsibleError(\"'%s' returned an invalid relative home directory path containing '..'\" % self._play_context.remote_addr)",
            "",
            "        return expanded",
            "",
            "    def _strip_success_message(self, data):",
            "        '''",
            "        Removes the BECOME-SUCCESS message from the data.",
            "        '''",
            "        if data.strip().startswith('BECOME-SUCCESS-'):",
            "            data = re.sub(r'^((\\r)?\\n)?BECOME-SUCCESS.*(\\r)?\\n', '', data)",
            "        return data",
            "",
            "    def _update_module_args(self, module_name, module_args, task_vars):",
            "",
            "        # set check mode in the module arguments, if required",
            "        if self._play_context.check_mode:",
            "            if not self._supports_check_mode:",
            "                raise AnsibleError(\"check mode is not supported for this operation\")",
            "            module_args['_ansible_check_mode'] = True",
            "        else:",
            "            module_args['_ansible_check_mode'] = False",
            "",
            "        # set no log in the module arguments, if required",
            "        module_args['_ansible_no_log'] = self._play_context.no_log or C.DEFAULT_NO_TARGET_SYSLOG",
            "",
            "        # set debug in the module arguments, if required",
            "        module_args['_ansible_debug'] = C.DEFAULT_DEBUG",
            "",
            "        # let module know we are in diff mode",
            "        module_args['_ansible_diff'] = self._play_context.diff",
            "",
            "        # let module know our verbosity",
            "        module_args['_ansible_verbosity'] = display.verbosity",
            "",
            "        # give the module information about the ansible version",
            "        module_args['_ansible_version'] = __version__",
            "",
            "        # give the module information about its name",
            "        module_args['_ansible_module_name'] = module_name",
            "",
            "        # set the syslog facility to be used in the module",
            "        module_args['_ansible_syslog_facility'] = task_vars.get('ansible_syslog_facility', C.DEFAULT_SYSLOG_FACILITY)",
            "",
            "        # let module know about filesystems that selinux treats specially",
            "        module_args['_ansible_selinux_special_fs'] = C.DEFAULT_SELINUX_SPECIAL_FS",
            "",
            "        # give the module the socket for persistent connections",
            "        module_args['_ansible_socket'] = getattr(self._connection, 'socket_path')",
            "        if not module_args['_ansible_socket']:",
            "            module_args['_ansible_socket'] = task_vars.get('ansible_socket')",
            "",
            "        # make sure all commands use the designated shell executable",
            "        module_args['_ansible_shell_executable'] = self._play_context.executable",
            "",
            "        # make sure modules are aware if they need to keep the remote files",
            "        module_args['_ansible_keep_remote_files'] = C.DEFAULT_KEEP_REMOTE_FILES",
            "",
            "        # make sure all commands use the designated temporary directory if created",
            "        if self._is_become_unprivileged():  # force fallback on remote_tmp as user cannot normally write to dir",
            "            module_args['_ansible_tmpdir'] = None",
            "        else:",
            "            module_args['_ansible_tmpdir'] = self._connection._shell.tmpdir",
            "",
            "        # make sure the remote_tmp value is sent through in case modules needs to create their own",
            "        try:",
            "            module_args['_ansible_remote_tmp'] = self._connection._shell.get_option('remote_tmp')",
            "        except KeyError:",
            "            # here for 3rd party shell plugin compatibility in case they do not define the remote_tmp option",
            "            module_args['_ansible_remote_tmp'] = '~/.ansible/tmp'",
            "",
            "    def _update_connection_options(self, options, variables=None):",
            "        ''' ensures connections have the appropriate information '''",
            "        update = {}",
            "",
            "        if getattr(self.connection, 'glob_option_vars', False):",
            "            # if the connection allows for it, pass any variables matching it.",
            "            if variables is not None:",
            "                for varname in variables:",
            "                    if varname.match('ansible_%s_' % self.connection._load_name):",
            "                        update[varname] = variables[varname]",
            "",
            "        # always override existing with options",
            "        update.update(options)",
            "        self.connection.set_options(update)",
            "",
            "    def _execute_module(self, module_name=None, module_args=None, tmp=None, task_vars=None, persist_files=False, delete_remote_tmp=None, wrap_async=False):",
            "        '''",
            "        Transfer and run a module along with its arguments.",
            "        '''",
            "        if tmp is not None:",
            "            display.warning('_execute_module no longer honors the tmp parameter. Action plugins'",
            "                            ' should set self._connection._shell.tmpdir to share the tmpdir')",
            "        del tmp  # No longer used",
            "        if delete_remote_tmp is not None:",
            "            display.warning('_execute_module no longer honors the delete_remote_tmp parameter.'",
            "                            ' Action plugins should check self._connection._shell.tmpdir to'",
            "                            ' see if a tmpdir existed before they were called to determine'",
            "                            ' if they are responsible for removing it.')",
            "        del delete_remote_tmp  # No longer used",
            "",
            "        tmpdir = self._connection._shell.tmpdir",
            "",
            "        # We set the module_style to new here so the remote_tmp is created",
            "        # before the module args are built if remote_tmp is needed (async).",
            "        # If the module_style turns out to not be new and we didn't create the",
            "        # remote tmp here, it will still be created. This must be done before",
            "        # calling self._update_module_args() so the module wrapper has the",
            "        # correct remote_tmp value set",
            "        if not self._is_pipelining_enabled(\"new\", wrap_async) and tmpdir is None:",
            "            self._make_tmp_path()",
            "            tmpdir = self._connection._shell.tmpdir",
            "",
            "        if task_vars is None:",
            "            task_vars = dict()",
            "",
            "        # if a module name was not specified for this execution, use the action from the task",
            "        if module_name is None:",
            "            module_name = self._task.action",
            "        if module_args is None:",
            "            module_args = self._task.args",
            "",
            "        self._update_module_args(module_name, module_args, task_vars)",
            "",
            "        # FUTURE: refactor this along with module build process to better encapsulate \"smart wrapper\" functionality",
            "        (module_style, shebang, module_data, module_path) = self._configure_module(module_name=module_name, module_args=module_args, task_vars=task_vars)",
            "        display.vvv(\"Using module file %s\" % module_path)",
            "        if not shebang and module_style != 'binary':",
            "            raise AnsibleError(\"module (%s) is missing interpreter line\" % module_name)",
            "",
            "        self._used_interpreter = shebang",
            "        remote_module_path = None",
            "",
            "        if not self._is_pipelining_enabled(module_style, wrap_async):",
            "            # we might need remote tmp dir",
            "            if tmpdir is None:",
            "                self._make_tmp_path()",
            "                tmpdir = self._connection._shell.tmpdir",
            "",
            "            remote_module_filename = self._connection._shell.get_remote_filename(module_path)",
            "            remote_module_path = self._connection._shell.join_path(tmpdir, 'AnsiballZ_%s' % remote_module_filename)",
            "",
            "        args_file_path = None",
            "        if module_style in ('old', 'non_native_want_json', 'binary'):",
            "            # we'll also need a tmp file to hold our module arguments",
            "            args_file_path = self._connection._shell.join_path(tmpdir, 'args')",
            "",
            "        if remote_module_path or module_style != 'new':",
            "            display.debug(\"transferring module to remote %s\" % remote_module_path)",
            "            if module_style == 'binary':",
            "                self._transfer_file(module_path, remote_module_path)",
            "            else:",
            "                self._transfer_data(remote_module_path, module_data)",
            "            if module_style == 'old':",
            "                # we need to dump the module args to a k=v string in a file on",
            "                # the remote system, which can be read and parsed by the module",
            "                args_data = \"\"",
            "                for k, v in iteritems(module_args):",
            "                    args_data += '%s=%s ' % (k, shlex_quote(text_type(v)))",
            "                self._transfer_data(args_file_path, args_data)",
            "            elif module_style in ('non_native_want_json', 'binary'):",
            "                self._transfer_data(args_file_path, json.dumps(module_args))",
            "            display.debug(\"done transferring module to remote\")",
            "",
            "        environment_string = self._compute_environment_string()",
            "",
            "        remote_files = []",
            "        if tmpdir and remote_module_path:",
            "            remote_files = [tmpdir, remote_module_path]",
            "",
            "        if args_file_path:",
            "            remote_files.append(args_file_path)",
            "",
            "        sudoable = True",
            "        in_data = None",
            "        cmd = \"\"",
            "",
            "        if wrap_async and not self._connection.always_pipeline_modules:",
            "            # configure, upload, and chmod the async_wrapper module",
            "            (async_module_style, shebang, async_module_data, async_module_path) = self._configure_module(module_name='async_wrapper', module_args=dict(),",
            "                                                                                                         task_vars=task_vars)",
            "            async_module_remote_filename = self._connection._shell.get_remote_filename(async_module_path)",
            "            remote_async_module_path = self._connection._shell.join_path(tmpdir, async_module_remote_filename)",
            "            self._transfer_data(remote_async_module_path, async_module_data)",
            "            remote_files.append(remote_async_module_path)",
            "",
            "            async_limit = self._task.async_val",
            "            async_jid = str(random.randint(0, 999999999999))",
            "",
            "            # call the interpreter for async_wrapper directly",
            "            # this permits use of a script for an interpreter on non-Linux platforms",
            "            # TODO: re-implement async_wrapper as a regular module to avoid this special case",
            "            interpreter = shebang.replace('#!', '').strip()",
            "            async_cmd = [interpreter, remote_async_module_path, async_jid, async_limit, remote_module_path]",
            "",
            "            if environment_string:",
            "                async_cmd.insert(0, environment_string)",
            "",
            "            if args_file_path:",
            "                async_cmd.append(args_file_path)",
            "            else:",
            "                # maintain a fixed number of positional parameters for async_wrapper",
            "                async_cmd.append('_')",
            "",
            "            if not self._should_remove_tmp_path(tmpdir):",
            "                async_cmd.append(\"-preserve_tmp\")",
            "",
            "            cmd = \" \".join(to_text(x) for x in async_cmd)",
            "",
            "        else:",
            "",
            "            if self._is_pipelining_enabled(module_style):",
            "                in_data = module_data",
            "            else:",
            "                cmd = remote_module_path",
            "",
            "            cmd = self._connection._shell.build_module_command(environment_string, shebang, cmd, arg_path=args_file_path).strip()",
            "",
            "        # Fix permissions of the tmpdir path and tmpdir files. This should be called after all",
            "        # files have been transferred.",
            "        if remote_files:",
            "            # remove none/empty",
            "            remote_files = [x for x in remote_files if x]",
            "            self._fixup_perms2(remote_files, self._play_context.remote_user)",
            "",
            "        # actually execute",
            "        res = self._low_level_execute_command(cmd, sudoable=sudoable, in_data=in_data)",
            "",
            "        # parse the main result",
            "        data = self._parse_returned_data(res)",
            "",
            "        # NOTE: INTERNAL KEYS ONLY ACCESSIBLE HERE",
            "        # get internal info before cleaning",
            "        if data.pop(\"_ansible_suppress_tmpdir_delete\", False):",
            "            self._cleanup_remote_tmp = False",
            "",
            "        # remove internal keys",
            "        remove_internal_keys(data)",
            "",
            "        if wrap_async:",
            "            # async_wrapper will clean up its tmpdir on its own so we want the controller side to",
            "            # forget about it now",
            "            self._connection._shell.tmpdir = None",
            "",
            "            # FIXME: for backwards compat, figure out if still makes sense",
            "            data['changed'] = True",
            "",
            "        # pre-split stdout/stderr into lines if needed",
            "        if 'stdout' in data and 'stdout_lines' not in data:",
            "            # if the value is 'False', a default won't catch it.",
            "            txt = data.get('stdout', None) or u''",
            "            data['stdout_lines'] = txt.splitlines()",
            "        if 'stderr' in data and 'stderr_lines' not in data:",
            "            # if the value is 'False', a default won't catch it.",
            "            txt = data.get('stderr', None) or u''",
            "            data['stderr_lines'] = txt.splitlines()",
            "",
            "        display.debug(\"done with _execute_module (%s, %s)\" % (module_name, module_args))",
            "        return data",
            "",
            "    def _parse_returned_data(self, res):",
            "        try:",
            "            filtered_output, warnings = _filter_non_json_lines(res.get('stdout', u''))",
            "            for w in warnings:",
            "                display.warning(w)",
            "",
            "            data = json.loads(filtered_output)",
            "",
            "            if 'ansible_facts' in data and isinstance(data['ansible_facts'], dict):",
            "                data['ansible_facts'] = wrap_var(data['ansible_facts'])",
            "            data['_ansible_parsed'] = True",
            "        except ValueError:",
            "            # not valid json, lets try to capture error",
            "            data = dict(failed=True, _ansible_parsed=False)",
            "            data['module_stdout'] = res.get('stdout', u'')",
            "            if 'stderr' in res:",
            "                data['module_stderr'] = res['stderr']",
            "                if res['stderr'].startswith(u'Traceback'):",
            "                    data['exception'] = res['stderr']",
            "",
            "            # The default",
            "            data['msg'] = \"MODULE FAILURE\"",
            "",
            "            # try to figure out if we are missing interpreter",
            "            if self._used_interpreter is not None:",
            "                match = re.compile('%s: (?:No such file or directory|not found)' % self._used_interpreter.lstrip('!#'))",
            "                if match.search(data['module_stderr']) or match.search(data['module_stdout']):",
            "                    data['msg'] = \"The module failed to execute correctly, you probably need to set the interpreter.\"",
            "",
            "            # always append hint",
            "            data['msg'] += '\\nSee stdout/stderr for the exact error'",
            "",
            "            if 'rc' in res:",
            "                data['rc'] = res['rc']",
            "        return data",
            "",
            "    def _low_level_execute_command(self, cmd, sudoable=True, in_data=None, executable=None, encoding_errors='surrogate_then_replace', chdir=None):",
            "        '''",
            "        This is the function which executes the low level shell command, which",
            "        may be commands to create/remove directories for temporary files, or to",
            "        run the module code or python directly when pipelining.",
            "",
            "        :kwarg encoding_errors: If the value returned by the command isn't",
            "            utf-8 then we have to figure out how to transform it to unicode.",
            "            If the value is just going to be displayed to the user (or",
            "            discarded) then the default of 'replace' is fine.  If the data is",
            "            used as a key or is going to be written back out to a file",
            "            verbatim, then this won't work.  May have to use some sort of",
            "            replacement strategy (python3 could use surrogateescape)",
            "        :kwarg chdir: cd into this directory before executing the command.",
            "        '''",
            "",
            "        display.debug(\"_low_level_execute_command(): starting\")",
            "#        if not cmd:",
            "#            # this can happen with powershell modules when there is no analog to a Windows command (like chmod)",
            "#            display.debug(\"_low_level_execute_command(): no command, exiting\")",
            "#           return dict(stdout='', stderr='', rc=254)",
            "",
            "        if chdir:",
            "            display.debug(\"_low_level_execute_command(): changing cwd to %s for this command\" % chdir)",
            "            cmd = self._connection._shell.append_command('cd %s' % chdir, cmd)",
            "",
            "        allow_same_user = C.BECOME_ALLOW_SAME_USER",
            "        same_user = self._play_context.become_user == self._play_context.remote_user",
            "        if sudoable and self._play_context.become and (allow_same_user or not same_user):",
            "            display.debug(\"_low_level_execute_command(): using become for this command\")",
            "            if self._connection.transport != 'network_cli' and self._play_context.become_method != 'enable':",
            "                cmd = self._play_context.make_become_cmd(cmd, executable=executable)",
            "",
            "        if self._connection.allow_executable:",
            "            if executable is None:",
            "                executable = self._play_context.executable",
            "                # mitigation for SSH race which can drop stdout (https://github.com/ansible/ansible/issues/13876)",
            "                # only applied for the default executable to avoid interfering with the raw action",
            "                cmd = self._connection._shell.append_command(cmd, 'sleep 0')",
            "            if executable:",
            "                cmd = executable + ' -c ' + shlex_quote(cmd)",
            "",
            "        display.debug(\"_low_level_execute_command(): executing: %s\" % (cmd,))",
            "",
            "        # Change directory to basedir of task for command execution when connection is local",
            "        if self._connection.transport == 'local':",
            "            cwd = os.getcwd()",
            "            os.chdir(self._loader.get_basedir())",
            "        try:",
            "            rc, stdout, stderr = self._connection.exec_command(cmd, in_data=in_data, sudoable=sudoable)",
            "        finally:",
            "            if self._connection.transport == 'local':",
            "                os.chdir(cwd)",
            "",
            "        # stdout and stderr may be either a file-like or a bytes object.",
            "        # Convert either one to a text type",
            "        if isinstance(stdout, binary_type):",
            "            out = to_text(stdout, errors=encoding_errors)",
            "        elif not isinstance(stdout, text_type):",
            "            out = to_text(b''.join(stdout.readlines()), errors=encoding_errors)",
            "        else:",
            "            out = stdout",
            "",
            "        if isinstance(stderr, binary_type):",
            "            err = to_text(stderr, errors=encoding_errors)",
            "        elif not isinstance(stderr, text_type):",
            "            err = to_text(b''.join(stderr.readlines()), errors=encoding_errors)",
            "        else:",
            "            err = stderr",
            "",
            "        if rc is None:",
            "            rc = 0",
            "",
            "        # be sure to remove the BECOME-SUCCESS message now",
            "        out = self._strip_success_message(out)",
            "",
            "        display.debug(u\"_low_level_execute_command() done: rc=%d, stdout=%s, stderr=%s\" % (rc, out, err))",
            "        return dict(rc=rc, stdout=out, stdout_lines=out.splitlines(), stderr=err, stderr_lines=err.splitlines())",
            "",
            "    def _get_diff_data(self, destination, source, task_vars, source_file=True):",
            "",
            "        # Note: Since we do not diff the source and destination before we transform from bytes into",
            "        # text the diff between source and destination may not be accurate.  To fix this, we'd need",
            "        # to move the diffing from the callback plugins into here.",
            "        #",
            "        # Example of data which would cause trouble is src_content == b'\\xff' and dest_content ==",
            "        # b'\\xfe'.  Neither of those are valid utf-8 so both get turned into the replacement",
            "        # character: diff['before'] = u'\ufffd' ; diff['after'] = u'\ufffd'  When the callback plugin later",
            "        # diffs before and after it shows an empty diff.",
            "",
            "        diff = {}",
            "        display.debug(\"Going to peek to see if file has changed permissions\")",
            "        peek_result = self._execute_module(module_name='file', module_args=dict(path=destination, _diff_peek=True), task_vars=task_vars, persist_files=True)",
            "",
            "        if not peek_result.get('failed', False) or peek_result.get('rc', 0) == 0:",
            "",
            "            if peek_result.get('state') == 'absent':",
            "                diff['before'] = u''",
            "            elif peek_result.get('appears_binary'):",
            "                diff['dst_binary'] = 1",
            "            elif peek_result.get('size') and C.MAX_FILE_SIZE_FOR_DIFF > 0 and peek_result['size'] > C.MAX_FILE_SIZE_FOR_DIFF:",
            "                diff['dst_larger'] = C.MAX_FILE_SIZE_FOR_DIFF",
            "            else:",
            "                display.debug(u\"Slurping the file %s\" % source)",
            "                dest_result = self._execute_module(module_name='slurp', module_args=dict(path=destination), task_vars=task_vars, persist_files=True)",
            "                if 'content' in dest_result:",
            "                    dest_contents = dest_result['content']",
            "                    if dest_result['encoding'] == u'base64':",
            "                        dest_contents = base64.b64decode(dest_contents)",
            "                    else:",
            "                        raise AnsibleError(\"unknown encoding in content option, failed: %s\" % to_native(dest_result))",
            "                    diff['before_header'] = destination",
            "                    diff['before'] = to_text(dest_contents)",
            "",
            "            if source_file:",
            "                st = os.stat(source)",
            "                if C.MAX_FILE_SIZE_FOR_DIFF > 0 and st[stat.ST_SIZE] > C.MAX_FILE_SIZE_FOR_DIFF:",
            "                    diff['src_larger'] = C.MAX_FILE_SIZE_FOR_DIFF",
            "                else:",
            "                    display.debug(\"Reading local copy of the file %s\" % source)",
            "                    try:",
            "                        with open(source, 'rb') as src:",
            "                            src_contents = src.read()",
            "                    except Exception as e:",
            "                        raise AnsibleError(\"Unexpected error while reading source (%s) for diff: %s \" % (source, str(e)))",
            "",
            "                    if b\"\\x00\" in src_contents:",
            "                        diff['src_binary'] = 1",
            "                    else:",
            "                        diff['after_header'] = source",
            "                        diff['after'] = to_text(src_contents)",
            "            else:",
            "                display.debug(u\"source of file passed in\")",
            "                diff['after_header'] = u'dynamically generated'",
            "                diff['after'] = source",
            "",
            "        if self._play_context.no_log:",
            "            if 'before' in diff:",
            "                diff[\"before\"] = u\"\"",
            "            if 'after' in diff:",
            "                diff[\"after\"] = u\" [[ Diff output has been hidden because 'no_log: true' was specified for this result ]]\\n\"",
            "",
            "        return diff",
            "",
            "    def _find_needle(self, dirname, needle):",
            "        '''",
            "            find a needle in haystack of paths, optionally using 'dirname' as a subdir.",
            "            This will build the ordered list of paths to search and pass them to dwim",
            "            to get back the first existing file found.",
            "        '''",
            "",
            "        # dwim already deals with playbook basedirs",
            "        path_stack = self._task.get_search_path()",
            "",
            "        # if missing it will return a file not found exception",
            "        return self._loader.path_dwim_relative_stack(path_stack, dirname, needle)"
        ],
        "afterPatchFile": [
            "# coding: utf-8",
            "# Copyright: (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright: (c) 2018, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import base64",
            "import json",
            "import os",
            "import random",
            "import re",
            "import stat",
            "import tempfile",
            "import time",
            "from abc import ABCMeta, abstractmethod",
            "",
            "from ansible import constants as C",
            "from ansible.errors import AnsibleError, AnsibleConnectionFailure, AnsibleActionSkip, AnsibleActionFail",
            "from ansible.executor.module_common import modify_module",
            "from ansible.module_utils.json_utils import _filter_non_json_lines",
            "from ansible.module_utils.six import binary_type, string_types, text_type, iteritems, with_metaclass",
            "from ansible.module_utils.six.moves import shlex_quote",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.parsing.utils.jsonify import jsonify",
            "from ansible.release import __version__",
            "from ansible.utils.unsafe_proxy import wrap_var",
            "from ansible.vars.clean import remove_internal_keys",
            "",
            "",
            "try:",
            "    from __main__ import display",
            "except ImportError:",
            "    from ansible.utils.display import Display",
            "    display = Display()",
            "",
            "",
            "class ActionBase(with_metaclass(ABCMeta, object)):",
            "",
            "    '''",
            "    This class is the base class for all action plugins, and defines",
            "    code common to all actions. The base class handles the connection",
            "    by putting/getting files and executing commands based on the current",
            "    action in use.",
            "    '''",
            "",
            "    # A set of valid arguments",
            "    _VALID_ARGS = frozenset([])",
            "",
            "    def __init__(self, task, connection, play_context, loader, templar, shared_loader_obj):",
            "        self._task = task",
            "        self._connection = connection",
            "        self._play_context = play_context",
            "        self._loader = loader",
            "        self._templar = templar",
            "        self._shared_loader_obj = shared_loader_obj",
            "        self._cleanup_remote_tmp = False",
            "",
            "        self._supports_check_mode = True",
            "        self._supports_async = False",
            "",
            "        # Backwards compat: self._display isn't really needed, just import the global display and use that.",
            "        self._display = display",
            "",
            "        self._used_interpreter = None",
            "",
            "    @abstractmethod",
            "    def run(self, tmp=None, task_vars=None):",
            "        \"\"\" Action Plugins should implement this method to perform their",
            "        tasks.  Everything else in this base class is a helper method for the",
            "        action plugin to do that.",
            "",
            "        :kwarg tmp: Deprecated parameter.  This is no longer used.  An action plugin that calls",
            "            another one and wants to use the same remote tmp for both should set",
            "            self._connection._shell.tmpdir rather than this parameter.",
            "        :kwarg task_vars: The variables (host vars, group vars, config vars,",
            "            etc) associated with this task.",
            "        :returns: dictionary of results from the module",
            "",
            "        Implementors of action modules may find the following variables especially useful:",
            "",
            "        * Module parameters.  These are stored in self._task.args",
            "        \"\"\"",
            "",
            "        result = {}",
            "",
            "        if tmp is not None:",
            "            result['warning'] = ['ActionModule.run() no longer honors the tmp parameter. Action'",
            "                                 ' plugins should set self._connection._shell.tmpdir to share'",
            "                                 ' the tmpdir']",
            "        del tmp",
            "",
            "        if self._task.async_val and not self._supports_async:",
            "            raise AnsibleActionFail('async is not supported for this task.')",
            "        elif self._play_context.check_mode and not self._supports_check_mode:",
            "            raise AnsibleActionSkip('check mode is not supported for this task.')",
            "        elif self._task.async_val and self._play_context.check_mode:",
            "            raise AnsibleActionFail('check mode and async cannot be used on same task.')",
            "",
            "        # Error if invalid argument is passed",
            "        if self._VALID_ARGS:",
            "            task_opts = frozenset(self._task.args.keys())",
            "            bad_opts = task_opts.difference(self._VALID_ARGS)",
            "            if bad_opts:",
            "                raise AnsibleActionFail('Invalid options for %s: %s' % (self._task.action, ','.join(list(bad_opts))))",
            "",
            "        if self._connection._shell.tmpdir is None and self._early_needs_tmp_path():",
            "            self._make_tmp_path()",
            "",
            "        return result",
            "",
            "    def _remote_file_exists(self, path):",
            "        cmd = self._connection._shell.exists(path)",
            "        result = self._low_level_execute_command(cmd=cmd, sudoable=True)",
            "        if result['rc'] == 0:",
            "            return True",
            "        return False",
            "",
            "    def _configure_module(self, module_name, module_args, task_vars=None):",
            "        '''",
            "        Handles the loading and templating of the module code through the",
            "        modify_module() function.",
            "        '''",
            "        if task_vars is None:",
            "            task_vars = dict()",
            "",
            "        # Search module path(s) for named module.",
            "        for mod_type in self._connection.module_implementation_preferences:",
            "            # Check to determine if PowerShell modules are supported, and apply",
            "            # some fixes (hacks) to module name + args.",
            "            if mod_type == '.ps1':",
            "                # win_stat, win_file, and win_copy are not just like their",
            "                # python counterparts but they are compatible enough for our",
            "                # internal usage",
            "                if module_name in ('stat', 'file', 'copy') and self._task.action != module_name:",
            "                    module_name = 'win_%s' % module_name",
            "",
            "                # Remove extra quotes surrounding path parameters before sending to module.",
            "                if module_name in ('win_stat', 'win_file', 'win_copy', 'slurp') and module_args and hasattr(self._connection._shell, '_unquote'):",
            "                    for key in ('src', 'dest', 'path'):",
            "                        if key in module_args:",
            "                            module_args[key] = self._connection._shell._unquote(module_args[key])",
            "",
            "            module_path = self._shared_loader_obj.module_loader.find_plugin(module_name, mod_type)",
            "            if module_path:",
            "                break",
            "        else:  # This is a for-else: http://bit.ly/1ElPkyg",
            "            # Use Windows version of ping module to check module paths when",
            "            # using a connection that supports .ps1 suffixes. We check specifically",
            "            # for win_ping here, otherwise the code would look for ping.ps1",
            "            if '.ps1' in self._connection.module_implementation_preferences:",
            "                ping_module = 'win_ping'",
            "            else:",
            "                ping_module = 'ping'",
            "            module_path2 = self._shared_loader_obj.module_loader.find_plugin(ping_module, self._connection.module_implementation_preferences)",
            "            if module_path2 is not None:",
            "                raise AnsibleError(\"The module %s was not found in configured module paths\" % (module_name))",
            "            else:",
            "                raise AnsibleError(\"The module %s was not found in configured module paths. \"",
            "                                   \"Additionally, core modules are missing. If this is a checkout, \"",
            "                                   \"run 'git pull --rebase' to correct this problem.\" % (module_name))",
            "",
            "        # insert shared code and arguments into the module",
            "        final_environment = dict()",
            "        self._compute_environment_string(final_environment)",
            "",
            "        (module_data, module_style, module_shebang) = modify_module(module_name, module_path, module_args, self._templar,",
            "                                                                    task_vars=task_vars,",
            "                                                                    module_compression=self._play_context.module_compression,",
            "                                                                    async_timeout=self._task.async_val,",
            "                                                                    become=self._play_context.become,",
            "                                                                    become_method=self._play_context.become_method,",
            "                                                                    become_user=self._play_context.become_user,",
            "                                                                    become_password=self._play_context.become_pass,",
            "                                                                    become_flags=self._play_context.become_flags,",
            "                                                                    environment=final_environment)",
            "",
            "        return (module_style, module_shebang, module_data, module_path)",
            "",
            "    def _compute_environment_string(self, raw_environment_out=None):",
            "        '''",
            "        Builds the environment string to be used when executing the remote task.",
            "        '''",
            "",
            "        final_environment = dict()",
            "        if self._task.environment is not None:",
            "            environments = self._task.environment",
            "            if not isinstance(environments, list):",
            "                environments = [environments]",
            "",
            "            # The order of environments matters to make sure we merge",
            "            # in the parent's values first so those in the block then",
            "            # task 'win' in precedence",
            "            for environment in environments:",
            "                if environment is None or len(environment) == 0:",
            "                    continue",
            "                temp_environment = self._templar.template(environment)",
            "                if not isinstance(temp_environment, dict):",
            "                    raise AnsibleError(\"environment must be a dictionary, received %s (%s)\" % (temp_environment, type(temp_environment)))",
            "                # very deliberately using update here instead of combine_vars, as",
            "                # these environment settings should not need to merge sub-dicts",
            "                final_environment.update(temp_environment)",
            "",
            "        if len(final_environment) > 0:",
            "            final_environment = self._templar.template(final_environment)",
            "",
            "        if isinstance(raw_environment_out, dict):",
            "            raw_environment_out.clear()",
            "            raw_environment_out.update(final_environment)",
            "",
            "        return self._connection._shell.env_prefix(**final_environment)",
            "",
            "    def _early_needs_tmp_path(self):",
            "        '''",
            "        Determines if a tmp path should be created before the action is executed.",
            "        '''",
            "",
            "        return getattr(self, 'TRANSFERS_FILES', False)",
            "",
            "    def _is_pipelining_enabled(self, module_style, wrap_async=False):",
            "        '''",
            "        Determines if we are required and can do pipelining",
            "        '''",
            "",
            "        # any of these require a true",
            "        for condition in [",
            "            self._connection.has_pipelining,",
            "            self._play_context.pipelining or self._connection.always_pipeline_modules,  # pipelining enabled for play or connection requires it (eg winrm)",
            "            module_style == \"new\",                     # old style modules do not support pipelining",
            "            not C.DEFAULT_KEEP_REMOTE_FILES,           # user wants remote files",
            "            not wrap_async or self._connection.always_pipeline_modules,  # async does not normally support pipelining unless it does (eg winrm)",
            "            self._play_context.become_method != 'su',  # su does not work with pipelining,",
            "            # FIXME: we might need to make become_method exclusion a configurable list",
            "        ]:",
            "            if not condition:",
            "                return False",
            "",
            "        return True",
            "",
            "    def _get_admin_users(self):",
            "        '''",
            "        Returns a list of admin users that are configured for the current shell",
            "        plugin",
            "        '''",
            "        try:",
            "            admin_users = self._connection._shell.get_option('admin_users')",
            "        except AnsibleError:",
            "            # fallback for old custom plugins w/o get_option",
            "            admin_users = ['root']",
            "        return admin_users",
            "",
            "    def _is_become_unprivileged(self):",
            "        '''",
            "        The user is not the same as the connection user and is not part of the",
            "        shell configured admin users",
            "        '''",
            "        # if we don't use become then we know we aren't switching to a",
            "        # different unprivileged user",
            "        if not self._play_context.become:",
            "            return False",
            "",
            "        # if we use become and the user is not an admin (or same user) then",
            "        # we need to return become_unprivileged as True",
            "        admin_users = self._get_admin_users()",
            "        try:",
            "            remote_user = self._connection.get_option('remote_user')",
            "        except AnsibleError:",
            "            remote_user = self._play_context.remote_user",
            "        return bool(self._play_context.become_user not in admin_users + [remote_user])",
            "",
            "    def _make_tmp_path(self, remote_user=None):",
            "        '''",
            "        Create and return a temporary path on a remote box.",
            "        '''",
            "",
            "        become_unprivileged = self._is_become_unprivileged()",
            "",
            "        # deal with tmpdir creation",
            "        basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))",
            "        # Network connection plugins (network_cli, netconf, etc.) execute on the controller, rather than the remote host.",
            "        # As such, we want to avoid using remote_user for paths  as remote_user may not line up with the local user",
            "        # This is a hack and should be solved by more intelligent handling of remote_tmp in 2.7",
            "        if getattr(self._connection, '_remote_is_local', False):",
            "            tmpdir = C.DEFAULT_LOCAL_TMP",
            "        else:",
            "            # NOTE: shell plugins should populate this setting anyways, but they dont do remote expansion, which",
            "            # we need for 'non posix' systems like cloud-init and solaris",
            "            try:",
            "                tmpdir = self._connection._shell.get_option('remote_tmp')",
            "            except AnsibleError:",
            "                tmpdir = '~/.ansible/tmp'",
            "            tmpdir = self._remote_expand_user(tmpdir, sudoable=False)",
            "",
            "        basefile = self._connection._shell._generate_temp_dir_name()",
            "        cmd = self._connection._shell.mkdtemp(basefile=basefile, system=become_unprivileged, tmpdir=tmpdir)",
            "        result = self._low_level_execute_command(cmd, sudoable=False)",
            "",
            "        # error handling on this seems a little aggressive?",
            "        if result['rc'] != 0:",
            "            if result['rc'] == 5:",
            "                output = 'Authentication failure.'",
            "            elif result['rc'] == 255 and self._connection.transport in ('ssh',):",
            "",
            "                if self._play_context.verbosity > 3:",
            "                    output = u'SSH encountered an unknown error. The output was:\\n%s%s' % (result['stdout'], result['stderr'])",
            "                else:",
            "                    output = (u'SSH encountered an unknown error during the connection. '",
            "                              'We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue')",
            "",
            "            elif u'No space left on device' in result['stderr']:",
            "                output = result['stderr']",
            "            else:",
            "                output = ('Failed to create temporary directory.'",
            "                          'In some cases, you may have been able to authenticate and did not have permissions on the target directory. '",
            "                          'Consider changing the remote tmp path in ansible.cfg to a path rooted in \"/tmp\", for more error information use -vvv. '",
            "                          'Failed command was: %s, exited with result %d' % (cmd, result['rc']))",
            "            if 'stdout' in result and result['stdout'] != u'':",
            "                output = output + u\", stdout output: %s\" % result['stdout']",
            "            if self._play_context.verbosity > 3 and 'stderr' in result and result['stderr'] != u'':",
            "                output += u\", stderr output: %s\" % result['stderr']",
            "            raise AnsibleConnectionFailure(output)",
            "        else:",
            "            self._cleanup_remote_tmp = True",
            "",
            "        try:",
            "            stdout_parts = result['stdout'].strip().split('%s=' % basefile, 1)",
            "            rc = self._connection._shell.join_path(stdout_parts[-1], u'').splitlines()[-1]",
            "        except IndexError:",
            "            # stdout was empty or just space, set to / to trigger error in next if",
            "            rc = '/'",
            "",
            "        # Catch failure conditions, files should never be",
            "        # written to locations in /.",
            "        if rc == '/':",
            "            raise AnsibleError('failed to resolve remote temporary directory from %s: `%s` returned empty string' % (basefile, cmd))",
            "",
            "        self._connection._shell.tmpdir = rc",
            "",
            "        return rc",
            "",
            "    def _should_remove_tmp_path(self, tmp_path):",
            "        '''Determine if temporary path should be deleted or kept by user request/config'''",
            "        return tmp_path and self._cleanup_remote_tmp and not C.DEFAULT_KEEP_REMOTE_FILES and \"-tmp-\" in tmp_path",
            "",
            "    def _remove_tmp_path(self, tmp_path):",
            "        '''Remove a temporary path we created. '''",
            "",
            "        if tmp_path is None and self._connection._shell.tmpdir:",
            "            tmp_path = self._connection._shell.tmpdir",
            "",
            "        if self._should_remove_tmp_path(tmp_path):",
            "            cmd = self._connection._shell.remove(tmp_path, recurse=True)",
            "            # If we have gotten here we have a working ssh configuration.",
            "            # If ssh breaks we could leave tmp directories out on the remote system.",
            "            tmp_rm_res = self._low_level_execute_command(cmd, sudoable=False)",
            "",
            "            if tmp_rm_res.get('rc', 0) != 0:",
            "                display.warning('Error deleting remote temporary files (rc: %s, stderr: %s})'",
            "                                % (tmp_rm_res.get('rc'), tmp_rm_res.get('stderr', 'No error string available.')))",
            "            else:",
            "                self._connection._shell.tmpdir = None",
            "",
            "    def _transfer_file(self, local_path, remote_path):",
            "        \"\"\"",
            "        Copy a file from the controller to a remote path",
            "",
            "        :arg local_path: Path on controller to transfer",
            "        :arg remote_path: Path on the remote system to transfer into",
            "",
            "        .. warning::",
            "            * When you use this function you likely want to use use fixup_perms2() on the",
            "              remote_path to make sure that the remote file is readable when the user becomes",
            "              a non-privileged user.",
            "            * If you use fixup_perms2() on the file and copy or move the file into place, you will",
            "              need to then remove filesystem acls on the file once it has been copied into place by",
            "              the module.  See how the copy module implements this for help.",
            "        \"\"\"",
            "        self._connection.put_file(local_path, remote_path)",
            "        return remote_path",
            "",
            "    def _transfer_data(self, remote_path, data):",
            "        '''",
            "        Copies the module data out to the temporary module path.",
            "        '''",
            "",
            "        if isinstance(data, dict):",
            "            data = jsonify(data)",
            "",
            "        afd, afile = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)",
            "        afo = os.fdopen(afd, 'wb')",
            "        try:",
            "            data = to_bytes(data, errors='surrogate_or_strict')",
            "            afo.write(data)",
            "        except Exception as e:",
            "            raise AnsibleError(\"failure writing module data to temporary file for transfer: %s\" % to_native(e))",
            "",
            "        afo.flush()",
            "        afo.close()",
            "",
            "        try:",
            "            self._transfer_file(afile, remote_path)",
            "        finally:",
            "            os.unlink(afile)",
            "",
            "        return remote_path",
            "",
            "    def _fixup_perms2(self, remote_paths, remote_user=None, execute=True):",
            "        \"\"\"",
            "        We need the files we upload to be readable (and sometimes executable)",
            "        by the user being sudo'd to but we want to limit other people's access",
            "        (because the files could contain passwords or other private",
            "        information.  We achieve this in one of these ways:",
            "",
            "        * If no sudo is performed or the remote_user is sudo'ing to",
            "          themselves, we don't have to change permissions.",
            "        * If the remote_user sudo's to a privileged user (for instance, root),",
            "          we don't have to change permissions",
            "        * If the remote_user sudo's to an unprivileged user then we attempt to",
            "          grant the unprivileged user access via file system acls.",
            "        * If granting file system acls fails we try to change the owner of the",
            "          file with chown which only works in case the remote_user is",
            "          privileged or the remote systems allows chown calls by unprivileged",
            "          users (e.g. HP-UX)",
            "        * If the chown fails we can set the file to be world readable so that",
            "          the second unprivileged user can read the file.",
            "          Since this could allow other users to get access to private",
            "          information we only do this if ansible is configured with",
            "          \"allow_world_readable_tmpfiles\" in the ansible.cfg",
            "        \"\"\"",
            "        if remote_user is None:",
            "            remote_user = self._play_context.remote_user",
            "",
            "        if self._connection._shell.SHELL_FAMILY == 'powershell':",
            "            # This won't work on Powershell as-is, so we'll just completely skip until",
            "            # we have a need for it, at which point we'll have to do something different.",
            "            return remote_paths",
            "",
            "        if self._is_become_unprivileged():",
            "            # Unprivileged user that's different than the ssh user.  Let's get",
            "            # to work!",
            "",
            "            # Try to use file system acls to make the files readable for sudo'd",
            "            # user",
            "            if execute:",
            "                chmod_mode = 'rx'",
            "                setfacl_mode = 'r-x'",
            "            else:",
            "                chmod_mode = 'rX'",
            "                # NOTE: this form fails silently on freebsd.  We currently",
            "                # never call _fixup_perms2() with execute=False but if we",
            "                # start to we'll have to fix this.",
            "                setfacl_mode = 'r-X'",
            "",
            "            res = self._remote_set_user_facl(remote_paths, self._play_context.become_user, setfacl_mode)",
            "            if res['rc'] != 0:",
            "                # File system acls failed; let's try to use chown next",
            "                # Set executable bit first as on some systems an",
            "                # unprivileged user can use chown",
            "                if execute:",
            "                    res = self._remote_chmod(remote_paths, 'u+x')",
            "                    if res['rc'] != 0:",
            "                        raise AnsibleError('Failed to set file mode on remote temporary files (rc: {0}, err: {1})'.format(res['rc'], to_native(res['stderr'])))",
            "",
            "                res = self._remote_chown(remote_paths, self._play_context.become_user)",
            "                if res['rc'] != 0 and remote_user in self._get_admin_users():",
            "                    # chown failed even if remote_user is administrator/root",
            "                    raise AnsibleError('Failed to change ownership of the temporary files Ansible needs to create despite connecting as a privileged user. '",
            "                                       'Unprivileged become user would be unable to read the file.')",
            "                elif res['rc'] != 0:",
            "                    if C.ALLOW_WORLD_READABLE_TMPFILES:",
            "                        # chown and fs acls failed -- do things this insecure",
            "                        # way only if the user opted in in the config file",
            "                        display.warning('Using world-readable permissions for temporary files Ansible needs to create when becoming an unprivileged user. '",
            "                                        'This may be insecure. For information on securing this, see '",
            "                                        'https://docs.ansible.com/ansible/become.html#becoming-an-unprivileged-user')",
            "                        res = self._remote_chmod(remote_paths, 'a+%s' % chmod_mode)",
            "                        if res['rc'] != 0:",
            "                            raise AnsibleError('Failed to set file mode on remote files (rc: {0}, err: {1})'.format(res['rc'], to_native(res['stderr'])))",
            "                    else:",
            "                        raise AnsibleError('Failed to set permissions on the temporary files Ansible needs to create when becoming an unprivileged user '",
            "                                           '(rc: %s, err: %s}). For information on working around this, see '",
            "                                           'https://docs.ansible.com/ansible/become.html#becoming-an-unprivileged-user'",
            "                                           % (res['rc'], to_native(res['stderr'])))",
            "        elif execute:",
            "            # Can't depend on the file being transferred with execute permissions.",
            "            # Only need user perms because no become was used here",
            "            res = self._remote_chmod(remote_paths, 'u+x')",
            "            if res['rc'] != 0:",
            "                raise AnsibleError('Failed to set execute bit on remote files (rc: {0}, err: {1})'.format(res['rc'], to_native(res['stderr'])))",
            "",
            "        return remote_paths",
            "",
            "    def _remote_chmod(self, paths, mode, sudoable=False):",
            "        '''",
            "        Issue a remote chmod command",
            "        '''",
            "        cmd = self._connection._shell.chmod(paths, mode)",
            "        res = self._low_level_execute_command(cmd, sudoable=sudoable)",
            "        return res",
            "",
            "    def _remote_chown(self, paths, user, sudoable=False):",
            "        '''",
            "        Issue a remote chown command",
            "        '''",
            "        cmd = self._connection._shell.chown(paths, user)",
            "        res = self._low_level_execute_command(cmd, sudoable=sudoable)",
            "        return res",
            "",
            "    def _remote_set_user_facl(self, paths, user, mode, sudoable=False):",
            "        '''",
            "        Issue a remote call to setfacl",
            "        '''",
            "        cmd = self._connection._shell.set_user_facl(paths, user, mode)",
            "        res = self._low_level_execute_command(cmd, sudoable=sudoable)",
            "        return res",
            "",
            "    def _execute_remote_stat(self, path, all_vars, follow, tmp=None, checksum=True):",
            "        '''",
            "        Get information from remote file.",
            "        '''",
            "        if tmp is not None:",
            "            display.warning('_execute_remote_stat no longer honors the tmp parameter. Action'",
            "                            ' plugins should set self._connection._shell.tmpdir to share'",
            "                            ' the tmpdir')",
            "        del tmp  # No longer used",
            "",
            "        module_args = dict(",
            "            path=path,",
            "            follow=follow,",
            "            get_checksum=checksum,",
            "            checksum_algo='sha1',",
            "        )",
            "        mystat = self._execute_module(module_name='stat', module_args=module_args, task_vars=all_vars,",
            "                                      wrap_async=False)",
            "",
            "        if mystat.get('failed'):",
            "            msg = mystat.get('module_stderr')",
            "            if not msg:",
            "                msg = mystat.get('module_stdout')",
            "            if not msg:",
            "                msg = mystat.get('msg')",
            "            raise AnsibleError('Failed to get information on remote file (%s): %s' % (path, msg))",
            "",
            "        if not mystat['stat']['exists']:",
            "            # empty might be matched, 1 should never match, also backwards compatible",
            "            mystat['stat']['checksum'] = '1'",
            "",
            "        # happens sometimes when it is a dir and not on bsd",
            "        if 'checksum' not in mystat['stat']:",
            "            mystat['stat']['checksum'] = ''",
            "        elif not isinstance(mystat['stat']['checksum'], string_types):",
            "            raise AnsibleError(\"Invalid checksum returned by stat: expected a string type but got %s\" % type(mystat['stat']['checksum']))",
            "",
            "        return mystat['stat']",
            "",
            "    def _remote_checksum(self, path, all_vars, follow=False):",
            "        '''",
            "        Produces a remote checksum given a path,",
            "        Returns a number 0-4 for specific errors instead of checksum, also ensures it is different",
            "        0 = unknown error",
            "        1 = file does not exist, this might not be an error",
            "        2 = permissions issue",
            "        3 = its a directory, not a file",
            "        4 = stat module failed, likely due to not finding python",
            "        5 = appropriate json module not found",
            "        '''",
            "        x = \"0\"  # unknown error has occurred",
            "        try:",
            "            remote_stat = self._execute_remote_stat(path, all_vars, follow=follow)",
            "            if remote_stat['exists'] and remote_stat['isdir']:",
            "                x = \"3\"  # its a directory not a file",
            "            else:",
            "                x = remote_stat['checksum']  # if 1, file is missing",
            "        except AnsibleError as e:",
            "            errormsg = to_text(e)",
            "            if errormsg.endswith(u'Permission denied'):",
            "                x = \"2\"  # cannot read file",
            "            elif errormsg.endswith(u'MODULE FAILURE'):",
            "                x = \"4\"  # python not found or module uncaught exception",
            "            elif 'json' in errormsg:",
            "                x = \"5\"  # json module needed",
            "        finally:",
            "            return x  # pylint: disable=lost-exception",
            "",
            "    def _remote_expand_user(self, path, sudoable=True, pathsep=None):",
            "        ''' takes a remote path and performs tilde/$HOME expansion on the remote host '''",
            "",
            "        # We only expand ~/path and ~username/path",
            "        if not path.startswith('~'):",
            "            return path",
            "",
            "        # Per Jborean, we don't have to worry about Windows as we don't have a notion of user's home",
            "        # dir there.",
            "        split_path = path.split(os.path.sep, 1)",
            "        expand_path = split_path[0]",
            "",
            "        if expand_path == '~':",
            "            # Network connection plugins (network_cli, netconf, etc.) execute on the controller, rather than the remote host.",
            "            # As such, we want to avoid using remote_user for paths  as remote_user may not line up with the local user",
            "            # This is a hack and should be solved by more intelligent handling of remote_tmp in 2.7",
            "            if getattr(self._connection, '_remote_is_local', False):",
            "                pass",
            "            elif sudoable and self._play_context.become and self._play_context.become_user:",
            "                expand_path = '~%s' % self._play_context.become_user",
            "            else:",
            "                # use remote user instead, if none set default to current user",
            "                expand_path = '~%s' % (self._play_context.remote_user or self._connection.default_user or '')",
            "",
            "        # use shell to construct appropriate command and execute",
            "        cmd = self._connection._shell.expand_user(expand_path)",
            "        data = self._low_level_execute_command(cmd, sudoable=False)",
            "",
            "        try:",
            "            initial_fragment = data['stdout'].strip().splitlines()[-1]",
            "        except IndexError:",
            "            initial_fragment = None",
            "",
            "        if not initial_fragment:",
            "            # Something went wrong trying to expand the path remotely. Try using pwd, if not, return",
            "            # the original string",
            "            cmd = self._connection._shell.pwd()",
            "            pwd = self._low_level_execute_command(cmd, sudoable=False).get('stdout', '').strip()",
            "            if pwd:",
            "                expanded = pwd",
            "            else:",
            "                expanded = path",
            "",
            "        elif len(split_path) > 1:",
            "            expanded = self._connection._shell.join_path(initial_fragment, *split_path[1:])",
            "        else:",
            "            expanded = initial_fragment",
            "",
            "        if '..' in os.path.dirname(expanded).split('/'):",
            "            raise AnsibleError(\"'%s' returned an invalid relative home directory path containing '..'\" % self._play_context.remote_addr)",
            "",
            "        return expanded",
            "",
            "    def _strip_success_message(self, data):",
            "        '''",
            "        Removes the BECOME-SUCCESS message from the data.",
            "        '''",
            "        if data.strip().startswith('BECOME-SUCCESS-'):",
            "            data = re.sub(r'^((\\r)?\\n)?BECOME-SUCCESS.*(\\r)?\\n', '', data)",
            "        return data",
            "",
            "    def _update_module_args(self, module_name, module_args, task_vars):",
            "",
            "        # set check mode in the module arguments, if required",
            "        if self._play_context.check_mode:",
            "            if not self._supports_check_mode:",
            "                raise AnsibleError(\"check mode is not supported for this operation\")",
            "            module_args['_ansible_check_mode'] = True",
            "        else:",
            "            module_args['_ansible_check_mode'] = False",
            "",
            "        # set no log in the module arguments, if required",
            "        module_args['_ansible_no_log'] = self._play_context.no_log or C.DEFAULT_NO_TARGET_SYSLOG",
            "",
            "        # set debug in the module arguments, if required",
            "        module_args['_ansible_debug'] = C.DEFAULT_DEBUG",
            "",
            "        # let module know we are in diff mode",
            "        module_args['_ansible_diff'] = self._play_context.diff",
            "",
            "        # let module know our verbosity",
            "        module_args['_ansible_verbosity'] = display.verbosity",
            "",
            "        # give the module information about the ansible version",
            "        module_args['_ansible_version'] = __version__",
            "",
            "        # give the module information about its name",
            "        module_args['_ansible_module_name'] = module_name",
            "",
            "        # set the syslog facility to be used in the module",
            "        module_args['_ansible_syslog_facility'] = task_vars.get('ansible_syslog_facility', C.DEFAULT_SYSLOG_FACILITY)",
            "",
            "        # let module know about filesystems that selinux treats specially",
            "        module_args['_ansible_selinux_special_fs'] = C.DEFAULT_SELINUX_SPECIAL_FS",
            "",
            "        # give the module the socket for persistent connections",
            "        module_args['_ansible_socket'] = getattr(self._connection, 'socket_path')",
            "        if not module_args['_ansible_socket']:",
            "            module_args['_ansible_socket'] = task_vars.get('ansible_socket')",
            "",
            "        # make sure all commands use the designated shell executable",
            "        module_args['_ansible_shell_executable'] = self._play_context.executable",
            "",
            "        # make sure modules are aware if they need to keep the remote files",
            "        module_args['_ansible_keep_remote_files'] = C.DEFAULT_KEEP_REMOTE_FILES",
            "",
            "        # make sure all commands use the designated temporary directory if created",
            "        if self._is_become_unprivileged():  # force fallback on remote_tmp as user cannot normally write to dir",
            "            module_args['_ansible_tmpdir'] = None",
            "        else:",
            "            module_args['_ansible_tmpdir'] = self._connection._shell.tmpdir",
            "",
            "        # make sure the remote_tmp value is sent through in case modules needs to create their own",
            "        try:",
            "            module_args['_ansible_remote_tmp'] = self._connection._shell.get_option('remote_tmp')",
            "        except KeyError:",
            "            # here for 3rd party shell plugin compatibility in case they do not define the remote_tmp option",
            "            module_args['_ansible_remote_tmp'] = '~/.ansible/tmp'",
            "",
            "    def _update_connection_options(self, options, variables=None):",
            "        ''' ensures connections have the appropriate information '''",
            "        update = {}",
            "",
            "        if getattr(self.connection, 'glob_option_vars', False):",
            "            # if the connection allows for it, pass any variables matching it.",
            "            if variables is not None:",
            "                for varname in variables:",
            "                    if varname.match('ansible_%s_' % self.connection._load_name):",
            "                        update[varname] = variables[varname]",
            "",
            "        # always override existing with options",
            "        update.update(options)",
            "        self.connection.set_options(update)",
            "",
            "    def _execute_module(self, module_name=None, module_args=None, tmp=None, task_vars=None, persist_files=False, delete_remote_tmp=None, wrap_async=False):",
            "        '''",
            "        Transfer and run a module along with its arguments.",
            "        '''",
            "        if tmp is not None:",
            "            display.warning('_execute_module no longer honors the tmp parameter. Action plugins'",
            "                            ' should set self._connection._shell.tmpdir to share the tmpdir')",
            "        del tmp  # No longer used",
            "        if delete_remote_tmp is not None:",
            "            display.warning('_execute_module no longer honors the delete_remote_tmp parameter.'",
            "                            ' Action plugins should check self._connection._shell.tmpdir to'",
            "                            ' see if a tmpdir existed before they were called to determine'",
            "                            ' if they are responsible for removing it.')",
            "        del delete_remote_tmp  # No longer used",
            "",
            "        tmpdir = self._connection._shell.tmpdir",
            "",
            "        # We set the module_style to new here so the remote_tmp is created",
            "        # before the module args are built if remote_tmp is needed (async).",
            "        # If the module_style turns out to not be new and we didn't create the",
            "        # remote tmp here, it will still be created. This must be done before",
            "        # calling self._update_module_args() so the module wrapper has the",
            "        # correct remote_tmp value set",
            "        if not self._is_pipelining_enabled(\"new\", wrap_async) and tmpdir is None:",
            "            self._make_tmp_path()",
            "            tmpdir = self._connection._shell.tmpdir",
            "",
            "        if task_vars is None:",
            "            task_vars = dict()",
            "",
            "        # if a module name was not specified for this execution, use the action from the task",
            "        if module_name is None:",
            "            module_name = self._task.action",
            "        if module_args is None:",
            "            module_args = self._task.args",
            "",
            "        self._update_module_args(module_name, module_args, task_vars)",
            "",
            "        # FUTURE: refactor this along with module build process to better encapsulate \"smart wrapper\" functionality",
            "        (module_style, shebang, module_data, module_path) = self._configure_module(module_name=module_name, module_args=module_args, task_vars=task_vars)",
            "        display.vvv(\"Using module file %s\" % module_path)",
            "        if not shebang and module_style != 'binary':",
            "            raise AnsibleError(\"module (%s) is missing interpreter line\" % module_name)",
            "",
            "        self._used_interpreter = shebang",
            "        remote_module_path = None",
            "",
            "        if not self._is_pipelining_enabled(module_style, wrap_async):",
            "            # we might need remote tmp dir",
            "            if tmpdir is None:",
            "                self._make_tmp_path()",
            "                tmpdir = self._connection._shell.tmpdir",
            "",
            "            remote_module_filename = self._connection._shell.get_remote_filename(module_path)",
            "            remote_module_path = self._connection._shell.join_path(tmpdir, 'AnsiballZ_%s' % remote_module_filename)",
            "",
            "        args_file_path = None",
            "        if module_style in ('old', 'non_native_want_json', 'binary'):",
            "            # we'll also need a tmp file to hold our module arguments",
            "            args_file_path = self._connection._shell.join_path(tmpdir, 'args')",
            "",
            "        if remote_module_path or module_style != 'new':",
            "            display.debug(\"transferring module to remote %s\" % remote_module_path)",
            "            if module_style == 'binary':",
            "                self._transfer_file(module_path, remote_module_path)",
            "            else:",
            "                self._transfer_data(remote_module_path, module_data)",
            "            if module_style == 'old':",
            "                # we need to dump the module args to a k=v string in a file on",
            "                # the remote system, which can be read and parsed by the module",
            "                args_data = \"\"",
            "                for k, v in iteritems(module_args):",
            "                    args_data += '%s=%s ' % (k, shlex_quote(text_type(v)))",
            "                self._transfer_data(args_file_path, args_data)",
            "            elif module_style in ('non_native_want_json', 'binary'):",
            "                self._transfer_data(args_file_path, json.dumps(module_args))",
            "            display.debug(\"done transferring module to remote\")",
            "",
            "        environment_string = self._compute_environment_string()",
            "",
            "        remote_files = []",
            "        if tmpdir and remote_module_path:",
            "            remote_files = [tmpdir, remote_module_path]",
            "",
            "        if args_file_path:",
            "            remote_files.append(args_file_path)",
            "",
            "        sudoable = True",
            "        in_data = None",
            "        cmd = \"\"",
            "",
            "        if wrap_async and not self._connection.always_pipeline_modules:",
            "            # configure, upload, and chmod the async_wrapper module",
            "            (async_module_style, shebang, async_module_data, async_module_path) = self._configure_module(module_name='async_wrapper', module_args=dict(),",
            "                                                                                                         task_vars=task_vars)",
            "            async_module_remote_filename = self._connection._shell.get_remote_filename(async_module_path)",
            "            remote_async_module_path = self._connection._shell.join_path(tmpdir, async_module_remote_filename)",
            "            self._transfer_data(remote_async_module_path, async_module_data)",
            "            remote_files.append(remote_async_module_path)",
            "",
            "            async_limit = self._task.async_val",
            "            async_jid = str(random.randint(0, 999999999999))",
            "",
            "            # call the interpreter for async_wrapper directly",
            "            # this permits use of a script for an interpreter on non-Linux platforms",
            "            # TODO: re-implement async_wrapper as a regular module to avoid this special case",
            "            interpreter = shebang.replace('#!', '').strip()",
            "            async_cmd = [interpreter, remote_async_module_path, async_jid, async_limit, remote_module_path]",
            "",
            "            if environment_string:",
            "                async_cmd.insert(0, environment_string)",
            "",
            "            if args_file_path:",
            "                async_cmd.append(args_file_path)",
            "            else:",
            "                # maintain a fixed number of positional parameters for async_wrapper",
            "                async_cmd.append('_')",
            "",
            "            if not self._should_remove_tmp_path(tmpdir):",
            "                async_cmd.append(\"-preserve_tmp\")",
            "",
            "            cmd = \" \".join(to_text(x) for x in async_cmd)",
            "",
            "        else:",
            "",
            "            if self._is_pipelining_enabled(module_style):",
            "                in_data = module_data",
            "            else:",
            "                cmd = remote_module_path",
            "",
            "            cmd = self._connection._shell.build_module_command(environment_string, shebang, cmd, arg_path=args_file_path).strip()",
            "",
            "        # Fix permissions of the tmpdir path and tmpdir files. This should be called after all",
            "        # files have been transferred.",
            "        if remote_files:",
            "            # remove none/empty",
            "            remote_files = [x for x in remote_files if x]",
            "            self._fixup_perms2(remote_files, self._play_context.remote_user)",
            "",
            "        # actually execute",
            "        res = self._low_level_execute_command(cmd, sudoable=sudoable, in_data=in_data)",
            "",
            "        # parse the main result",
            "        data = self._parse_returned_data(res)",
            "",
            "        # NOTE: INTERNAL KEYS ONLY ACCESSIBLE HERE",
            "        # get internal info before cleaning",
            "        if data.pop(\"_ansible_suppress_tmpdir_delete\", False):",
            "            self._cleanup_remote_tmp = False",
            "",
            "        # remove internal keys",
            "        remove_internal_keys(data)",
            "",
            "        if wrap_async:",
            "            # async_wrapper will clean up its tmpdir on its own so we want the controller side to",
            "            # forget about it now",
            "            self._connection._shell.tmpdir = None",
            "",
            "            # FIXME: for backwards compat, figure out if still makes sense",
            "            data['changed'] = True",
            "",
            "        # pre-split stdout/stderr into lines if needed",
            "        if 'stdout' in data and 'stdout_lines' not in data:",
            "            # if the value is 'False', a default won't catch it.",
            "            txt = data.get('stdout', None) or u''",
            "            data['stdout_lines'] = txt.splitlines()",
            "        if 'stderr' in data and 'stderr_lines' not in data:",
            "            # if the value is 'False', a default won't catch it.",
            "            txt = data.get('stderr', None) or u''",
            "            data['stderr_lines'] = txt.splitlines()",
            "",
            "        display.debug(\"done with _execute_module (%s, %s)\" % (module_name, module_args))",
            "        return data",
            "",
            "    def _parse_returned_data(self, res):",
            "        try:",
            "            filtered_output, warnings = _filter_non_json_lines(res.get('stdout', u''))",
            "            for w in warnings:",
            "                display.warning(w)",
            "",
            "            data = json.loads(filtered_output)",
            "",
            "            if 'ansible_facts' in data and isinstance(data['ansible_facts'], dict):",
            "                data['ansible_facts'] = wrap_var(data['ansible_facts'])",
            "            data['_ansible_parsed'] = True",
            "        except ValueError:",
            "            # not valid json, lets try to capture error",
            "            data = dict(failed=True, _ansible_parsed=False)",
            "            data['module_stdout'] = res.get('stdout', u'')",
            "            if 'stderr' in res:",
            "                data['module_stderr'] = res['stderr']",
            "                if res['stderr'].startswith(u'Traceback'):",
            "                    data['exception'] = res['stderr']",
            "",
            "            # The default",
            "            data['msg'] = \"MODULE FAILURE\"",
            "",
            "            # try to figure out if we are missing interpreter",
            "            if self._used_interpreter is not None:",
            "                match = re.compile('%s: (?:No such file or directory|not found)' % self._used_interpreter.lstrip('!#'))",
            "                if match.search(data['module_stderr']) or match.search(data['module_stdout']):",
            "                    data['msg'] = \"The module failed to execute correctly, you probably need to set the interpreter.\"",
            "",
            "            # always append hint",
            "            data['msg'] += '\\nSee stdout/stderr for the exact error'",
            "",
            "            if 'rc' in res:",
            "                data['rc'] = res['rc']",
            "        return data",
            "",
            "    def _low_level_execute_command(self, cmd, sudoable=True, in_data=None, executable=None, encoding_errors='surrogate_then_replace', chdir=None):",
            "        '''",
            "        This is the function which executes the low level shell command, which",
            "        may be commands to create/remove directories for temporary files, or to",
            "        run the module code or python directly when pipelining.",
            "",
            "        :kwarg encoding_errors: If the value returned by the command isn't",
            "            utf-8 then we have to figure out how to transform it to unicode.",
            "            If the value is just going to be displayed to the user (or",
            "            discarded) then the default of 'replace' is fine.  If the data is",
            "            used as a key or is going to be written back out to a file",
            "            verbatim, then this won't work.  May have to use some sort of",
            "            replacement strategy (python3 could use surrogateescape)",
            "        :kwarg chdir: cd into this directory before executing the command.",
            "        '''",
            "",
            "        display.debug(\"_low_level_execute_command(): starting\")",
            "#        if not cmd:",
            "#            # this can happen with powershell modules when there is no analog to a Windows command (like chmod)",
            "#            display.debug(\"_low_level_execute_command(): no command, exiting\")",
            "#           return dict(stdout='', stderr='', rc=254)",
            "",
            "        if chdir:",
            "            display.debug(\"_low_level_execute_command(): changing cwd to %s for this command\" % chdir)",
            "            cmd = self._connection._shell.append_command('cd %s' % chdir, cmd)",
            "",
            "        allow_same_user = C.BECOME_ALLOW_SAME_USER",
            "        same_user = self._play_context.become_user == self._play_context.remote_user",
            "        if sudoable and self._play_context.become and (allow_same_user or not same_user):",
            "            display.debug(\"_low_level_execute_command(): using become for this command\")",
            "            if self._connection.transport != 'network_cli' and self._play_context.become_method != 'enable':",
            "                cmd = self._play_context.make_become_cmd(cmd, executable=executable)",
            "",
            "        if self._connection.allow_executable:",
            "            if executable is None:",
            "                executable = self._play_context.executable",
            "                # mitigation for SSH race which can drop stdout (https://github.com/ansible/ansible/issues/13876)",
            "                # only applied for the default executable to avoid interfering with the raw action",
            "                cmd = self._connection._shell.append_command(cmd, 'sleep 0')",
            "            if executable:",
            "                cmd = executable + ' -c ' + shlex_quote(cmd)",
            "",
            "        display.debug(\"_low_level_execute_command(): executing: %s\" % (cmd,))",
            "",
            "        # Change directory to basedir of task for command execution when connection is local",
            "        if self._connection.transport == 'local':",
            "            cwd = os.getcwd()",
            "            os.chdir(self._loader.get_basedir())",
            "        try:",
            "            rc, stdout, stderr = self._connection.exec_command(cmd, in_data=in_data, sudoable=sudoable)",
            "        finally:",
            "            if self._connection.transport == 'local':",
            "                os.chdir(cwd)",
            "",
            "        # stdout and stderr may be either a file-like or a bytes object.",
            "        # Convert either one to a text type",
            "        if isinstance(stdout, binary_type):",
            "            out = to_text(stdout, errors=encoding_errors)",
            "        elif not isinstance(stdout, text_type):",
            "            out = to_text(b''.join(stdout.readlines()), errors=encoding_errors)",
            "        else:",
            "            out = stdout",
            "",
            "        if isinstance(stderr, binary_type):",
            "            err = to_text(stderr, errors=encoding_errors)",
            "        elif not isinstance(stderr, text_type):",
            "            err = to_text(b''.join(stderr.readlines()), errors=encoding_errors)",
            "        else:",
            "            err = stderr",
            "",
            "        if rc is None:",
            "            rc = 0",
            "",
            "        # be sure to remove the BECOME-SUCCESS message now",
            "        out = self._strip_success_message(out)",
            "",
            "        display.debug(u\"_low_level_execute_command() done: rc=%d, stdout=%s, stderr=%s\" % (rc, out, err))",
            "        return dict(rc=rc, stdout=out, stdout_lines=out.splitlines(), stderr=err, stderr_lines=err.splitlines())",
            "",
            "    def _get_diff_data(self, destination, source, task_vars, source_file=True):",
            "",
            "        # Note: Since we do not diff the source and destination before we transform from bytes into",
            "        # text the diff between source and destination may not be accurate.  To fix this, we'd need",
            "        # to move the diffing from the callback plugins into here.",
            "        #",
            "        # Example of data which would cause trouble is src_content == b'\\xff' and dest_content ==",
            "        # b'\\xfe'.  Neither of those are valid utf-8 so both get turned into the replacement",
            "        # character: diff['before'] = u'\ufffd' ; diff['after'] = u'\ufffd'  When the callback plugin later",
            "        # diffs before and after it shows an empty diff.",
            "",
            "        diff = {}",
            "        display.debug(\"Going to peek to see if file has changed permissions\")",
            "        peek_result = self._execute_module(module_name='file', module_args=dict(path=destination, _diff_peek=True), task_vars=task_vars, persist_files=True)",
            "",
            "        if not peek_result.get('failed', False) or peek_result.get('rc', 0) == 0:",
            "",
            "            if peek_result.get('state') == 'absent':",
            "                diff['before'] = u''",
            "            elif peek_result.get('appears_binary'):",
            "                diff['dst_binary'] = 1",
            "            elif peek_result.get('size') and C.MAX_FILE_SIZE_FOR_DIFF > 0 and peek_result['size'] > C.MAX_FILE_SIZE_FOR_DIFF:",
            "                diff['dst_larger'] = C.MAX_FILE_SIZE_FOR_DIFF",
            "            else:",
            "                display.debug(u\"Slurping the file %s\" % source)",
            "                dest_result = self._execute_module(module_name='slurp', module_args=dict(path=destination), task_vars=task_vars, persist_files=True)",
            "                if 'content' in dest_result:",
            "                    dest_contents = dest_result['content']",
            "                    if dest_result['encoding'] == u'base64':",
            "                        dest_contents = base64.b64decode(dest_contents)",
            "                    else:",
            "                        raise AnsibleError(\"unknown encoding in content option, failed: %s\" % to_native(dest_result))",
            "                    diff['before_header'] = destination",
            "                    diff['before'] = to_text(dest_contents)",
            "",
            "            if source_file:",
            "                st = os.stat(source)",
            "                if C.MAX_FILE_SIZE_FOR_DIFF > 0 and st[stat.ST_SIZE] > C.MAX_FILE_SIZE_FOR_DIFF:",
            "                    diff['src_larger'] = C.MAX_FILE_SIZE_FOR_DIFF",
            "                else:",
            "                    display.debug(\"Reading local copy of the file %s\" % source)",
            "                    try:",
            "                        with open(source, 'rb') as src:",
            "                            src_contents = src.read()",
            "                    except Exception as e:",
            "                        raise AnsibleError(\"Unexpected error while reading source (%s) for diff: %s \" % (source, str(e)))",
            "",
            "                    if b\"\\x00\" in src_contents:",
            "                        diff['src_binary'] = 1",
            "                    else:",
            "                        diff['after_header'] = source",
            "                        diff['after'] = to_text(src_contents)",
            "            else:",
            "                display.debug(u\"source of file passed in\")",
            "                diff['after_header'] = u'dynamically generated'",
            "                diff['after'] = source",
            "",
            "        if self._play_context.no_log:",
            "            if 'before' in diff:",
            "                diff[\"before\"] = u\"\"",
            "            if 'after' in diff:",
            "                diff[\"after\"] = u\" [[ Diff output has been hidden because 'no_log: true' was specified for this result ]]\\n\"",
            "",
            "        return diff",
            "",
            "    def _find_needle(self, dirname, needle):",
            "        '''",
            "            find a needle in haystack of paths, optionally using 'dirname' as a subdir.",
            "            This will build the ordered list of paths to search and pass them to dwim",
            "            to get back the first existing file found.",
            "        '''",
            "",
            "        # dwim already deals with playbook basedirs",
            "        path_stack = self._task.get_search_path()",
            "",
            "        # if missing it will return a file not found exception",
            "        return self._loader.path_dwim_relative_stack(path_stack, dirname, needle)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "279": [
                "ActionBase",
                "_make_tmp_path"
            ],
            "280": [
                "ActionBase",
                "_make_tmp_path"
            ],
            "281": [
                "ActionBase",
                "_make_tmp_path"
            ],
            "282": [
                "ActionBase",
                "_make_tmp_path"
            ],
            "292": [
                "ActionBase",
                "_make_tmp_path"
            ],
            "311": [
                "ActionBase",
                "_make_tmp_path"
            ],
            "313": [
                "ActionBase",
                "_make_tmp_path"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/plugins/shell/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import re"
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " import time"
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import ansible.constants as C"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+from ansible import constants as C"
            },
            "5": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from ansible.errors import AnsibleError"
            },
            "6": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from ansible.module_utils.six import text_type"
            },
            "7": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from ansible.module_utils.six.moves import shlex_quote"
            },
            "8": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         except AnsibleError:"
            },
            "9": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "             pass"
            },
            "10": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    @staticmethod"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+    def _generate_temp_dir_name():"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        return 'ansible-tmp-%s-%s-%s' % (time.time(), os.getpid(), random.randint(0, 2**48))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     def env_prefix(self, **kwargs):"
            },
            "16": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         return ' '.join(['%s=%s' % (k, shlex_quote(text_type(v))) for k, v in kwargs.items()])"
            },
            "17": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "     def mkdtemp(self, basefile=None, system=False, mode=0o700, tmpdir=None):"
            },
            "20": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         if not basefile:"
            },
            "21": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+            basefile = self.__class__._generate_temp_dir_name()"
            },
            "23": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         # When system is specified we have to create this in a directory where"
            },
            "25": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         # other users can read and access the tmp directory."
            },
            "26": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         # passed in tmpdir if it is valid or the first one from the setting if not."
            },
            "27": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         if system:"
            },
            "29": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            tmpdir = tmpdir.rstrip('/')"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            if tmpdir:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+                tmpdir = tmpdir.rstrip('/')"
            },
            "32": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             if tmpdir in self.get_option('system_tmpdirs'):"
            },
            "34": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "                 basetmpdir = tmpdir"
            },
            "35": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         basetmp = self.join_path(basetmpdir, basefile)"
            },
            "37": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cmd = 'mkdir -p %s echo %s %s' % (self._SHELL_SUB_LEFT, basetmp, self._SHELL_SUB_RIGHT)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        # use mkdir -p to ensure parents exist, but mkdir fullpath to ensure last one is created by us"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        cmd = 'mkdir -p %s echo %s %s' % (self._SHELL_SUB_LEFT, basetmpdir, self._SHELL_SUB_RIGHT)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        cmd += '%s mkdir %s' % (self._SHELL_AND, basetmp)"
            },
            "42": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         cmd += ' %s echo %s=%s echo %s %s' % (self._SHELL_AND, basefile, self._SHELL_SUB_LEFT, basetmp, self._SHELL_SUB_RIGHT)"
            },
            "43": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         # change the umask in a subshell to achieve the desired mode"
            }
        },
        "frontPatchFile": [
            "# (c) 2016 RedHat",
            "#",
            "# This file is part of Ansible.",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import os.path",
            "import random",
            "import re",
            "import time",
            "",
            "import ansible.constants as C",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils.six import text_type",
            "from ansible.module_utils.six.moves import shlex_quote",
            "from ansible.module_utils._text import to_native",
            "from ansible.plugins import AnsiblePlugin",
            "",
            "_USER_HOME_PATH_RE = re.compile(r'^~[_.A-Za-z0-9][-_.A-Za-z0-9]*$')",
            "",
            "",
            "class ShellBase(AnsiblePlugin):",
            "    def __init__(self):",
            "",
            "        super(ShellBase, self).__init__()",
            "",
            "        self.env = {}",
            "        if C.DEFAULT_MODULE_SET_LOCALE:",
            "            module_locale = C.DEFAULT_MODULE_LANG",
            "            self.env = {'LANG': module_locale,",
            "                        'LC_ALL': module_locale,",
            "                        'LC_MESSAGES': module_locale}",
            "",
            "        self.tmpdir = None",
            "",
            "    def _normalize_system_tmpdirs(self):",
            "        # Normalize the tmp directory strings. We don't use expanduser/expandvars because those",
            "        # can vary between remote user and become user.  Therefore the safest practice will be for",
            "        # this to always be specified as full paths)",
            "        normalized_paths = [d.rstrip('/') for d in self.get_option('system_tmpdirs')]",
            "",
            "        # Make sure all system_tmpdirs are absolute otherwise they'd be relative to the login dir",
            "        # which is almost certainly going to fail in a cornercase.",
            "        if not all(os.path.isabs(d) for d in normalized_paths):",
            "            raise AnsibleError('The configured system_tmpdirs contains a relative path: {0}. All'",
            "                               ' system_tmpdirs must be absolute'.format(to_native(normalized_paths)))",
            "",
            "        self.set_option('system_tmpdirs', normalized_paths)",
            "",
            "    def set_options(self, task_keys=None, var_options=None, direct=None):",
            "",
            "        super(ShellBase, self).set_options(task_keys=task_keys, var_options=var_options, direct=direct)",
            "",
            "        # set env",
            "        self.env.update(self.get_option('environment'))",
            "",
            "        # We can remove the try: except in the future when we make ShellBase a proper subset of",
            "        # *all* shells.  Right now powershell and third party shells which do not use the",
            "        # shell_common documentation fragment (and so do not have system_tmpdirs) will fail",
            "        try:",
            "            self._normalize_system_tmpdirs()",
            "        except AnsibleError:",
            "            pass",
            "",
            "    def env_prefix(self, **kwargs):",
            "        return ' '.join(['%s=%s' % (k, shlex_quote(text_type(v))) for k, v in kwargs.items()])",
            "",
            "    def join_path(self, *args):",
            "        return os.path.join(*args)",
            "",
            "    # some shells (eg, powershell) are snooty about filenames/extensions, this lets the shell plugin have a say",
            "    def get_remote_filename(self, pathname):",
            "        base_name = os.path.basename(pathname.strip())",
            "        return base_name.strip()",
            "",
            "    def path_has_trailing_slash(self, path):",
            "        return path.endswith('/')",
            "",
            "    def chmod(self, paths, mode):",
            "        cmd = ['chmod', mode]",
            "        cmd.extend(paths)",
            "        cmd = [shlex_quote(c) for c in cmd]",
            "",
            "        return ' '.join(cmd)",
            "",
            "    def chown(self, paths, user):",
            "        cmd = ['chown', user]",
            "        cmd.extend(paths)",
            "        cmd = [shlex_quote(c) for c in cmd]",
            "",
            "        return ' '.join(cmd)",
            "",
            "    def set_user_facl(self, paths, user, mode):",
            "        \"\"\"Only sets acls for users as that's really all we need\"\"\"",
            "        cmd = ['setfacl', '-m', 'u:%s:%s' % (user, mode)]",
            "        cmd.extend(paths)",
            "        cmd = [shlex_quote(c) for c in cmd]",
            "",
            "        return ' '.join(cmd)",
            "",
            "    def remove(self, path, recurse=False):",
            "        path = shlex_quote(path)",
            "        cmd = 'rm -f '",
            "        if recurse:",
            "            cmd += '-r '",
            "        return cmd + \"%s %s\" % (path, self._SHELL_REDIRECT_ALLNULL)",
            "",
            "    def exists(self, path):",
            "        cmd = ['test', '-e', shlex_quote(path)]",
            "        return ' '.join(cmd)",
            "",
            "    def mkdtemp(self, basefile=None, system=False, mode=0o700, tmpdir=None):",
            "        if not basefile:",
            "            basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))",
            "",
            "        # When system is specified we have to create this in a directory where",
            "        # other users can read and access the tmp directory.",
            "        # This is because we use system to create tmp dirs for unprivileged users who are",
            "        # sudo'ing to a second unprivileged user.",
            "        # The 'system_tmpdirs' setting defines dirctories we can use for this purpose",
            "        # the default are, /tmp and /var/tmp.",
            "        # So we only allow one of those locations if system=True, using the",
            "        # passed in tmpdir if it is valid or the first one from the setting if not.",
            "",
            "        if system:",
            "            tmpdir = tmpdir.rstrip('/')",
            "",
            "            if tmpdir in self.get_option('system_tmpdirs'):",
            "                basetmpdir = tmpdir",
            "            else:",
            "                basetmpdir = self.get_option('system_tmpdirs')[0]",
            "        else:",
            "            if tmpdir is None:",
            "                basetmpdir = self.get_option('remote_tmp')",
            "            else:",
            "                basetmpdir = tmpdir",
            "",
            "        basetmp = self.join_path(basetmpdir, basefile)",
            "",
            "        cmd = 'mkdir -p %s echo %s %s' % (self._SHELL_SUB_LEFT, basetmp, self._SHELL_SUB_RIGHT)",
            "        cmd += ' %s echo %s=%s echo %s %s' % (self._SHELL_AND, basefile, self._SHELL_SUB_LEFT, basetmp, self._SHELL_SUB_RIGHT)",
            "",
            "        # change the umask in a subshell to achieve the desired mode",
            "        # also for directories created with `mkdir -p`",
            "        if mode:",
            "            tmp_umask = 0o777 & ~mode",
            "            cmd = '%s umask %o %s %s %s' % (self._SHELL_GROUP_LEFT, tmp_umask, self._SHELL_AND, cmd, self._SHELL_GROUP_RIGHT)",
            "",
            "        return cmd",
            "",
            "    def expand_user(self, user_home_path, username=''):",
            "        ''' Return a command to expand tildes in a path",
            "",
            "        It can be either \"~\" or \"~username\". We just ignore $HOME",
            "        We use the POSIX definition of a username:",
            "            http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_426",
            "            http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_276",
            "",
            "            Falls back to 'current workind directory' as we assume 'home is where the remote user ends up'",
            "        '''",
            "",
            "        # Check that the user_path to expand is safe",
            "        if user_home_path != '~':",
            "            if not _USER_HOME_PATH_RE.match(user_home_path):",
            "                # shlex_quote will make the shell return the string verbatim",
            "                user_home_path = shlex_quote(user_home_path)",
            "        elif username:",
            "            # if present the user name is appended to resolve \"that user's home\"",
            "            user_home_path += username",
            "",
            "        return 'echo %s' % user_home_path",
            "",
            "    def pwd(self):",
            "        \"\"\"Return the working directory after connecting\"\"\"",
            "        return 'echo %spwd%s' % (self._SHELL_SUB_LEFT, self._SHELL_SUB_RIGHT)",
            "",
            "    def build_module_command(self, env_string, shebang, cmd, arg_path=None):",
            "        # don't quote the cmd if it's an empty string, because this will break pipelining mode",
            "        if cmd.strip() != '':",
            "            cmd = shlex_quote(cmd)",
            "",
            "        cmd_parts = []",
            "        if shebang:",
            "            shebang = shebang.replace(\"#!\", \"\").strip()",
            "        else:",
            "            shebang = \"\"",
            "        cmd_parts.extend([env_string.strip(), shebang, cmd])",
            "        if arg_path is not None:",
            "            cmd_parts.append(arg_path)",
            "        new_cmd = \" \".join(cmd_parts)",
            "        return new_cmd",
            "",
            "    def append_command(self, cmd, cmd_to_append):",
            "        \"\"\"Append an additional command if supported by the shell\"\"\"",
            "",
            "        if self._SHELL_AND:",
            "            cmd += ' %s %s' % (self._SHELL_AND, cmd_to_append)",
            "",
            "        return cmd",
            "",
            "    def wrap_for_exec(self, cmd):",
            "        \"\"\"wrap script execution with any necessary decoration (eg '&' for quoted powershell script paths)\"\"\"",
            "        return cmd"
        ],
        "afterPatchFile": [
            "# (c) 2016 RedHat",
            "#",
            "# This file is part of Ansible.",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import os.path",
            "import random",
            "import re",
            "import time",
            "",
            "from ansible import constants as C",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils.six import text_type",
            "from ansible.module_utils.six.moves import shlex_quote",
            "from ansible.module_utils._text import to_native",
            "from ansible.plugins import AnsiblePlugin",
            "",
            "_USER_HOME_PATH_RE = re.compile(r'^~[_.A-Za-z0-9][-_.A-Za-z0-9]*$')",
            "",
            "",
            "class ShellBase(AnsiblePlugin):",
            "    def __init__(self):",
            "",
            "        super(ShellBase, self).__init__()",
            "",
            "        self.env = {}",
            "        if C.DEFAULT_MODULE_SET_LOCALE:",
            "            module_locale = C.DEFAULT_MODULE_LANG",
            "            self.env = {'LANG': module_locale,",
            "                        'LC_ALL': module_locale,",
            "                        'LC_MESSAGES': module_locale}",
            "",
            "        self.tmpdir = None",
            "",
            "    def _normalize_system_tmpdirs(self):",
            "        # Normalize the tmp directory strings. We don't use expanduser/expandvars because those",
            "        # can vary between remote user and become user.  Therefore the safest practice will be for",
            "        # this to always be specified as full paths)",
            "        normalized_paths = [d.rstrip('/') for d in self.get_option('system_tmpdirs')]",
            "",
            "        # Make sure all system_tmpdirs are absolute otherwise they'd be relative to the login dir",
            "        # which is almost certainly going to fail in a cornercase.",
            "        if not all(os.path.isabs(d) for d in normalized_paths):",
            "            raise AnsibleError('The configured system_tmpdirs contains a relative path: {0}. All'",
            "                               ' system_tmpdirs must be absolute'.format(to_native(normalized_paths)))",
            "",
            "        self.set_option('system_tmpdirs', normalized_paths)",
            "",
            "    def set_options(self, task_keys=None, var_options=None, direct=None):",
            "",
            "        super(ShellBase, self).set_options(task_keys=task_keys, var_options=var_options, direct=direct)",
            "",
            "        # set env",
            "        self.env.update(self.get_option('environment'))",
            "",
            "        # We can remove the try: except in the future when we make ShellBase a proper subset of",
            "        # *all* shells.  Right now powershell and third party shells which do not use the",
            "        # shell_common documentation fragment (and so do not have system_tmpdirs) will fail",
            "        try:",
            "            self._normalize_system_tmpdirs()",
            "        except AnsibleError:",
            "            pass",
            "",
            "    @staticmethod",
            "    def _generate_temp_dir_name():",
            "        return 'ansible-tmp-%s-%s-%s' % (time.time(), os.getpid(), random.randint(0, 2**48))",
            "",
            "    def env_prefix(self, **kwargs):",
            "        return ' '.join(['%s=%s' % (k, shlex_quote(text_type(v))) for k, v in kwargs.items()])",
            "",
            "    def join_path(self, *args):",
            "        return os.path.join(*args)",
            "",
            "    # some shells (eg, powershell) are snooty about filenames/extensions, this lets the shell plugin have a say",
            "    def get_remote_filename(self, pathname):",
            "        base_name = os.path.basename(pathname.strip())",
            "        return base_name.strip()",
            "",
            "    def path_has_trailing_slash(self, path):",
            "        return path.endswith('/')",
            "",
            "    def chmod(self, paths, mode):",
            "        cmd = ['chmod', mode]",
            "        cmd.extend(paths)",
            "        cmd = [shlex_quote(c) for c in cmd]",
            "",
            "        return ' '.join(cmd)",
            "",
            "    def chown(self, paths, user):",
            "        cmd = ['chown', user]",
            "        cmd.extend(paths)",
            "        cmd = [shlex_quote(c) for c in cmd]",
            "",
            "        return ' '.join(cmd)",
            "",
            "    def set_user_facl(self, paths, user, mode):",
            "        \"\"\"Only sets acls for users as that's really all we need\"\"\"",
            "        cmd = ['setfacl', '-m', 'u:%s:%s' % (user, mode)]",
            "        cmd.extend(paths)",
            "        cmd = [shlex_quote(c) for c in cmd]",
            "",
            "        return ' '.join(cmd)",
            "",
            "    def remove(self, path, recurse=False):",
            "        path = shlex_quote(path)",
            "        cmd = 'rm -f '",
            "        if recurse:",
            "            cmd += '-r '",
            "        return cmd + \"%s %s\" % (path, self._SHELL_REDIRECT_ALLNULL)",
            "",
            "    def exists(self, path):",
            "        cmd = ['test', '-e', shlex_quote(path)]",
            "        return ' '.join(cmd)",
            "",
            "    def mkdtemp(self, basefile=None, system=False, mode=0o700, tmpdir=None):",
            "        if not basefile:",
            "            basefile = self.__class__._generate_temp_dir_name()",
            "",
            "        # When system is specified we have to create this in a directory where",
            "        # other users can read and access the tmp directory.",
            "        # This is because we use system to create tmp dirs for unprivileged users who are",
            "        # sudo'ing to a second unprivileged user.",
            "        # The 'system_tmpdirs' setting defines dirctories we can use for this purpose",
            "        # the default are, /tmp and /var/tmp.",
            "        # So we only allow one of those locations if system=True, using the",
            "        # passed in tmpdir if it is valid or the first one from the setting if not.",
            "",
            "        if system:",
            "            if tmpdir:",
            "                tmpdir = tmpdir.rstrip('/')",
            "",
            "            if tmpdir in self.get_option('system_tmpdirs'):",
            "                basetmpdir = tmpdir",
            "            else:",
            "                basetmpdir = self.get_option('system_tmpdirs')[0]",
            "        else:",
            "            if tmpdir is None:",
            "                basetmpdir = self.get_option('remote_tmp')",
            "            else:",
            "                basetmpdir = tmpdir",
            "",
            "        basetmp = self.join_path(basetmpdir, basefile)",
            "",
            "        # use mkdir -p to ensure parents exist, but mkdir fullpath to ensure last one is created by us",
            "        cmd = 'mkdir -p %s echo %s %s' % (self._SHELL_SUB_LEFT, basetmpdir, self._SHELL_SUB_RIGHT)",
            "        cmd += '%s mkdir %s' % (self._SHELL_AND, basetmp)",
            "        cmd += ' %s echo %s=%s echo %s %s' % (self._SHELL_AND, basefile, self._SHELL_SUB_LEFT, basetmp, self._SHELL_SUB_RIGHT)",
            "",
            "        # change the umask in a subshell to achieve the desired mode",
            "        # also for directories created with `mkdir -p`",
            "        if mode:",
            "            tmp_umask = 0o777 & ~mode",
            "            cmd = '%s umask %o %s %s %s' % (self._SHELL_GROUP_LEFT, tmp_umask, self._SHELL_AND, cmd, self._SHELL_GROUP_RIGHT)",
            "",
            "        return cmd",
            "",
            "    def expand_user(self, user_home_path, username=''):",
            "        ''' Return a command to expand tildes in a path",
            "",
            "        It can be either \"~\" or \"~username\". We just ignore $HOME",
            "        We use the POSIX definition of a username:",
            "            http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_426",
            "            http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_276",
            "",
            "            Falls back to 'current workind directory' as we assume 'home is where the remote user ends up'",
            "        '''",
            "",
            "        # Check that the user_path to expand is safe",
            "        if user_home_path != '~':",
            "            if not _USER_HOME_PATH_RE.match(user_home_path):",
            "                # shlex_quote will make the shell return the string verbatim",
            "                user_home_path = shlex_quote(user_home_path)",
            "        elif username:",
            "            # if present the user name is appended to resolve \"that user's home\"",
            "            user_home_path += username",
            "",
            "        return 'echo %s' % user_home_path",
            "",
            "    def pwd(self):",
            "        \"\"\"Return the working directory after connecting\"\"\"",
            "        return 'echo %spwd%s' % (self._SHELL_SUB_LEFT, self._SHELL_SUB_RIGHT)",
            "",
            "    def build_module_command(self, env_string, shebang, cmd, arg_path=None):",
            "        # don't quote the cmd if it's an empty string, because this will break pipelining mode",
            "        if cmd.strip() != '':",
            "            cmd = shlex_quote(cmd)",
            "",
            "        cmd_parts = []",
            "        if shebang:",
            "            shebang = shebang.replace(\"#!\", \"\").strip()",
            "        else:",
            "            shebang = \"\"",
            "        cmd_parts.extend([env_string.strip(), shebang, cmd])",
            "        if arg_path is not None:",
            "            cmd_parts.append(arg_path)",
            "        new_cmd = \" \".join(cmd_parts)",
            "        return new_cmd",
            "",
            "    def append_command(self, cmd, cmd_to_append):",
            "        \"\"\"Append an additional command if supported by the shell\"\"\"",
            "",
            "        if self._SHELL_AND:",
            "            cmd += ' %s %s' % (self._SHELL_AND, cmd_to_append)",
            "",
            "        return cmd",
            "",
            "    def wrap_for_exec(self, cmd):",
            "        \"\"\"wrap script execution with any necessary decoration (eg '&' for quoted powershell script paths)\"\"\"",
            "        return cmd"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [],
            "128": [
                "ShellBase",
                "mkdtemp"
            ],
            "140": [
                "ShellBase",
                "mkdtemp"
            ],
            "154": [
                "ShellBase",
                "mkdtemp"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/plugins/shell/powershell.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1574,
                "afterPatchRowNumber": 1574,
                "PatchRowcode": "     def mkdtemp(self, basefile=None, system=False, mode=None, tmpdir=None):"
            },
            "1": {
                "beforePatchRowNumber": 1575,
                "afterPatchRowNumber": 1575,
                "PatchRowcode": "         # Windows does not have an equivalent for the system temp files, so"
            },
            "2": {
                "beforePatchRowNumber": 1576,
                "afterPatchRowNumber": 1576,
                "PatchRowcode": "         # the param is ignored"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1577,
                "PatchRowcode": "+        if not basefile:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1578,
                "PatchRowcode": "+            basefile = self.__class__._generate_temp_dir_name()"
            },
            "5": {
                "beforePatchRowNumber": 1577,
                "afterPatchRowNumber": 1579,
                "PatchRowcode": "         basefile = self._escape(self._unquote(basefile))"
            },
            "6": {
                "beforePatchRowNumber": 1578,
                "afterPatchRowNumber": 1580,
                "PatchRowcode": "         basetmpdir = tmpdir if tmpdir else self.get_option('remote_tmp')"
            },
            "7": {
                "beforePatchRowNumber": 1579,
                "afterPatchRowNumber": 1581,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2014, Chris Church <chris@ninemoreminutes.com>",
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = '''",
            "    name: powershell",
            "    plugin_type: shell",
            "    version_added: \"\"",
            "    short_description: Windows Powershell",
            "    description:",
            "      - The only option when using 'winrm' as a connection plugin",
            "    options:",
            "      remote_tmp:",
            "        description:",
            "        - Temporary directory to use on targets when copying files to the host.",
            "        default: '%TEMP%'",
            "        ini:",
            "        - section: powershell",
            "          key: remote_tmp",
            "        vars:",
            "        - name: ansible_remote_tmp",
            "      set_module_language:",
            "        description:",
            "        - Controls if we set the locale for moduels when executing on the",
            "          target.",
            "        - Windows only supports C(no) as an option.",
            "        type: bool",
            "        default: 'no'",
            "        choices:",
            "        - 'no'",
            "      environment:",
            "        description:",
            "        - Dictionary of environment variables and their values to use when",
            "          executing commands.",
            "        type: dict",
            "        default: {}",
            "'''",
            "# FIXME: admin_users and set_module_language don't belong here but must be set",
            "# so they don't failk when someone get_option('admin_users') on this plugin",
            "",
            "import base64",
            "import os",
            "import re",
            "import shlex",
            "import pkgutil",
            "",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_text",
            "from ansible.plugins.shell import ShellBase",
            "",
            "",
            "_common_args = ['PowerShell', '-NoProfile', '-NonInteractive', '-ExecutionPolicy', 'Unrestricted']",
            "",
            "# Primarily for testing, allow explicitly specifying PowerShell version via",
            "# an environment variable.",
            "_powershell_version = os.environ.get('POWERSHELL_VERSION', None)",
            "if _powershell_version:",
            "    _common_args = ['PowerShell', '-Version', _powershell_version] + _common_args[1:]",
            "",
            "exec_wrapper = br'''",
            "begin {",
            "    $DebugPreference = \"Continue\"",
            "    $ErrorActionPreference = \"Stop\"",
            "    Set-StrictMode -Version 2",
            "",
            "    function ConvertTo-HashtableFromPsCustomObject ($myPsObject){",
            "        $output = @{};",
            "        $myPsObject | Get-Member -MemberType *Property | % {",
            "            $val = $myPsObject.($_.name);",
            "            If ($val -is [psobject]) {",
            "                $val = ConvertTo-HashtableFromPsCustomObject $val",
            "            }",
            "            $output.($_.name) = $val",
            "        }",
            "        return $output;",
            "    }",
            "    # stream JSON including become_pw, ps_module_payload, bin_module_payload, become_payload, write_payload_path, preserve directives",
            "    # exec runspace, capture output, cleanup, return module output",
            "",
            "    # only init and stream in $json_raw if it wasn't set by the enclosing scope",
            "    if (-not $(Get-Variable \"json_raw\" -ErrorAction SilentlyContinue)) {",
            "        $json_raw = ''",
            "    }",
            "}",
            "process {",
            "    $input_as_string = [string]$input",
            "",
            "    $json_raw += $input_as_string",
            "}",
            "end {",
            "    If (-not $json_raw) {",
            "        Write-Error \"no input given\" -Category InvalidArgument",
            "    }",
            "    $payload = ConvertTo-HashtableFromPsCustomObject (ConvertFrom-Json $json_raw)",
            "",
            "    # TODO: handle binary modules",
            "    # TODO: handle persistence",
            "",
            "    $min_os_version = [version]$payload.min_os_version",
            "    if ($min_os_version -ne $null) {",
            "        $actual_os_version = [System.Environment]::OSVersion.Version",
            "        if ($actual_os_version -lt $min_os_version) {",
            "            $msg = \"This module cannot run on this OS as it requires a minimum version of $min_os_version, actual was $actual_os_version\"",
            "            Write-Output (ConvertTo-Json @{failed=$true;msg=$msg})",
            "            exit 1",
            "        }",
            "    }",
            "",
            "    $min_ps_version = [version]$payload.min_ps_version",
            "    if ($min_ps_version -ne $null) {",
            "        $actual_ps_version = $PSVersionTable.PSVersion",
            "        if ($actual_ps_version -lt $min_ps_version) {",
            "            $msg = \"This module cannot run as it requires a minimum PowerShell version of $min_ps_version, actual was $actual_ps_version\"",
            "            Write-Output (ConvertTo-Json @{failed=$true;msg=$msg})",
            "            exit 1",
            "        }",
            "    }",
            "",
            "    $actions = $payload.actions",
            "",
            "    # pop 0th action as entrypoint",
            "    $entrypoint = $payload.($actions[0])",
            "    $payload.actions = $payload.actions[1..99]",
            "",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    # load the current action entrypoint as a module custom object with a Run method",
            "    $entrypoint = New-Module -ScriptBlock ([scriptblock]::Create($entrypoint)) -AsCustomObject",
            "",
            "    Set-Variable -Scope global -Name complex_args -Value $payload[\"module_args\"] | Out-Null",
            "",
            "    # dynamically create/load modules",
            "    ForEach ($mod in $payload.powershell_modules.GetEnumerator()) {",
            "        $decoded_module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($mod.Value))",
            "        New-Module -ScriptBlock ([scriptblock]::Create($decoded_module)) -Name $mod.Key | Import-Module -WarningAction SilentlyContinue | Out-Null",
            "    }",
            "",
            "    $output = $entrypoint.Run($payload)",
            "",
            "    Write-Output $output",
            "}",
            "",
            "'''  # end exec_wrapper",
            "",
            "leaf_exec = br'''",
            "Function Run($payload) {",
            "    $entrypoint = $payload.module_entry",
            "",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    $ps = [powershell]::Create()",
            "",
            "    $ps.AddStatement().AddCommand(\"Set-Variable\").AddParameters(@{Scope=\"global\";Name=\"complex_args\";Value=$payload.module_args}) | Out-Null",
            "    $ps.AddCommand(\"Out-Null\") | Out-Null",
            "",
            "    # redefine Write-Host to dump to output instead of failing- lots of scripts use it",
            "    $ps.AddStatement().AddScript(\"Function Write-Host(`$msg){ Write-Output `$msg }\") | Out-Null",
            "",
            "    ForEach ($env_kv in $payload.environment.GetEnumerator()) {",
            "        # need to escape ' in both the key and value",
            "        $env_key = $env_kv.Key.ToString().Replace(\"'\", \"''\")",
            "        $env_value = $env_kv.Value.ToString().Replace(\"'\", \"''\")",
            "        $escaped_env_set = \"[System.Environment]::SetEnvironmentVariable('{0}', '{1}')\" -f $env_key, $env_value",
            "        $ps.AddStatement().AddScript($escaped_env_set) | Out-Null",
            "    }",
            "",
            "    # dynamically create/load modules",
            "    ForEach ($mod in $payload.powershell_modules.GetEnumerator()) {",
            "        $decoded_module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($mod.Value))",
            "        $ps.AddStatement().AddCommand(\"New-Module\").AddParameters(@{ScriptBlock=([scriptblock]::Create($decoded_module));Name=$mod.Key}) | Out-Null",
            "        $ps.AddCommand(\"Import-Module\").AddParameters(@{WarningAction=\"SilentlyContinue\"}) | Out-Null",
            "        $ps.AddCommand(\"Out-Null\") | Out-Null",
            "    }",
            "",
            "    # force input encoding to preamble-free UTF8 so PS sub-processes (eg,",
            "    # Start-Job) don't blow up. This is only required for WinRM, a PSRP",
            "    # runspace doesn't have a host console and this will bomb out",
            "    if ($host.Name -eq \"ConsoleHost\") {",
            "        $ps.AddStatement().AddScript(\"[Console]::InputEncoding = New-Object Text.UTF8Encoding `$false\") | Out-Null",
            "    }",
            "",
            "    $ps.AddStatement().AddScript($entrypoint) | Out-Null",
            "",
            "    $output = $ps.Invoke()",
            "",
            "    $output",
            "",
            "    # PS3 doesn't properly set HadErrors in many cases, inspect the error stream as a fallback",
            "    If ($ps.HadErrors -or ($PSVersionTable.PSVersion.Major -lt 4 -and $ps.Streams.Error.Count -gt 0)) {",
            "        $host.UI.WriteErrorLine($($ps.Streams.Error | Out-String))",
            "        $exit_code = $ps.Runspace.SessionStateProxy.GetVariable(\"LASTEXITCODE\")",
            "        If(-not $exit_code) {",
            "            $exit_code = 1",
            "        }",
            "        # need to use this instead of Exit keyword to prevent runspace from crashing with dynamic modules",
            "        $host.SetShouldExit($exit_code)",
            "    }",
            "}",
            "'''  # end leaf_exec",
            "",
            "become_wrapper = br'''",
            "Set-StrictMode -Version 2",
            "$ErrorActionPreference = \"Stop\"",
            "",
            "$helper_def = @\"",
            "using Microsoft.Win32.SafeHandles;",
            "using System;",
            "using System.Collections.Generic;",
            "using System.Diagnostics;",
            "using System.IO;",
            "using System.Linq;",
            "using System.Runtime.ConstrainedExecution;",
            "using System.Runtime.InteropServices;",
            "using System.Security.AccessControl;",
            "using System.Security.Principal;",
            "using System.Text;",
            "using System.Threading;",
            "",
            "namespace AnsibleBecome",
            "{",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public class SECURITY_ATTRIBUTES",
            "    {",
            "        public int nLength;",
            "        public IntPtr lpSecurityDescriptor;",
            "        public bool bInheritHandle = false;",
            "        public SECURITY_ATTRIBUTES()",
            "        {",
            "            nLength = Marshal.SizeOf(this);",
            "        }",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public class STARTUPINFO",
            "    {",
            "        public Int32 cb;",
            "        public IntPtr lpReserved;",
            "        public IntPtr lpDesktop;",
            "        public IntPtr lpTitle;",
            "        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 28)]",
            "        public byte[] _data1;",
            "        public Int32 dwFlags;",
            "        public Int16 wShowWindow;",
            "        public Int16 cbReserved2;",
            "        public IntPtr lpReserved2;",
            "        public SafeFileHandle hStdInput;",
            "        public SafeFileHandle hStdOutput;",
            "        public SafeFileHandle hStdError;",
            "        public STARTUPINFO()",
            "        {",
            "            cb = Marshal.SizeOf(this);",
            "        }",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public class STARTUPINFOEX",
            "    {",
            "        public STARTUPINFO startupInfo;",
            "        public IntPtr lpAttributeList;",
            "        public STARTUPINFOEX()",
            "        {",
            "            startupInfo = new STARTUPINFO();",
            "            startupInfo.cb = Marshal.SizeOf(this);",
            "        }",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct LUID",
            "    {",
            "        public UInt32 LowPart;",
            "        public Int32 HighPart;",
            "",
            "        public static explicit operator UInt64(LUID l)",
            "        {",
            "            return (UInt64)((UInt64)l.HighPart << 32) | (UInt64)l.LowPart;",
            "        }",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct LUID_AND_ATTRIBUTES",
            "    {",
            "        public LUID Luid;",
            "        public UInt32 Attributes;",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct PROCESS_INFORMATION",
            "    {",
            "        public IntPtr hProcess;",
            "        public IntPtr hThread;",
            "        public int dwProcessId;",
            "        public int dwThreadId;",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct SID_AND_ATTRIBUTES",
            "    {",
            "        public IntPtr Sid;",
            "        public int Attributes;",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct TOKEN_PRIVILEGES",
            "    {",
            "        public UInt32 PrivilegeCount;",
            "        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]",
            "        public LUID_AND_ATTRIBUTES[] Privileges;",
            "    }",
            "",
            "    public struct TOKEN_USER",
            "    {",
            "        public SID_AND_ATTRIBUTES User;",
            "    }",
            "",
            "    [Flags]",
            "    public enum StartupInfoFlags : uint",
            "    {",
            "        USESTDHANDLES = 0x00000100",
            "    }",
            "",
            "    [Flags]",
            "    public enum CreationFlags : uint",
            "    {",
            "        CREATE_BREAKAWAY_FROM_JOB = 0x01000000,",
            "        CREATE_DEFAULT_ERROR_MODE = 0x04000000,",
            "        CREATE_NEW_CONSOLE = 0x00000010,",
            "        CREATE_SUSPENDED = 0x00000004,",
            "        CREATE_UNICODE_ENVIRONMENT = 0x00000400,",
            "        EXTENDED_STARTUPINFO_PRESENT = 0x00080000",
            "    }",
            "",
            "    public enum HandleFlags : uint",
            "    {",
            "        None = 0,",
            "        INHERIT = 1",
            "    }",
            "",
            "    [Flags]",
            "    public enum LogonFlags",
            "    {",
            "        LOGON_WITH_PROFILE = 0x00000001,",
            "        LOGON_NETCREDENTIALS_ONLY = 0x00000002",
            "    }",
            "",
            "    public enum LogonType",
            "    {",
            "        LOGON32_LOGON_INTERACTIVE = 2,",
            "        LOGON32_LOGON_NETWORK = 3,",
            "        LOGON32_LOGON_BATCH = 4,",
            "        LOGON32_LOGON_SERVICE = 5,",
            "        LOGON32_LOGON_UNLOCK = 7,",
            "        LOGON32_LOGON_NETWORK_CLEARTEXT = 8,",
            "        LOGON32_LOGON_NEW_CREDENTIALS = 9",
            "    }",
            "",
            "    public enum LogonProvider",
            "    {",
            "        LOGON32_PROVIDER_DEFAULT = 0,",
            "    }",
            "",
            "    public enum TokenInformationClass",
            "    {",
            "        TokenUser = 1,",
            "        TokenPrivileges = 3,",
            "        TokenType = 8,",
            "        TokenImpersonationLevel = 9,",
            "        TokenElevationType = 18,",
            "        TokenLinkedToken = 19,",
            "    }",
            "",
            "    public enum TokenElevationType",
            "    {",
            "        TokenElevationTypeDefault = 1,",
            "        TokenElevationTypeFull,",
            "        TokenElevationTypeLimited",
            "    }",
            "",
            "    [Flags]",
            "    public enum ProcessAccessFlags : uint",
            "    {",
            "        PROCESS_QUERY_INFORMATION = 0x00000400,",
            "    }",
            "",
            "    public enum SECURITY_IMPERSONATION_LEVEL",
            "    {",
            "        SecurityImpersonation,",
            "    }",
            "",
            "    public enum TOKEN_TYPE",
            "    {",
            "        TokenPrimary = 1,",
            "        TokenImpersonation",
            "    }",
            "",
            "    class NativeWaitHandle : WaitHandle",
            "    {",
            "        public NativeWaitHandle(IntPtr handle)",
            "        {",
            "            this.SafeWaitHandle = new SafeWaitHandle(handle, false);",
            "        }",
            "    }",
            "",
            "    class SafeMemoryBuffer : SafeHandleZeroOrMinusOneIsInvalid",
            "    {",
            "        public SafeMemoryBuffer() : base(true) { }",
            "        public SafeMemoryBuffer(int cb) : base(true)",
            "        {",
            "            base.SetHandle(Marshal.AllocHGlobal(cb));",
            "        }",
            "        public SafeMemoryBuffer(IntPtr handle) : base(true)",
            "        {",
            "            base.SetHandle(handle);",
            "        }",
            "",
            "        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]",
            "        protected override bool ReleaseHandle()",
            "        {",
            "            Marshal.FreeHGlobal(handle);",
            "            return true;",
            "        }",
            "    }",
            "",
            "    public class Win32Exception : System.ComponentModel.Win32Exception",
            "    {",
            "        private string _msg;",
            "        public Win32Exception(string message) : this(Marshal.GetLastWin32Error(), message) { }",
            "        public Win32Exception(int errorCode, string message) : base(errorCode)",
            "        {",
            "            _msg = String.Format(\"{0} ({1}, Win32ErrorCode {2})\", message, base.Message, errorCode);",
            "        }",
            "        public override string Message { get { return _msg; } }",
            "        public static explicit operator Win32Exception(string message) { return new Win32Exception(message); }",
            "    }",
            "",
            "    public class CommandResult",
            "    {",
            "        public string StandardOut { get; internal set; }",
            "        public string StandardError { get; internal set; }",
            "        public uint ExitCode { get; internal set; }",
            "    }",
            "",
            "    public class BecomeUtil",
            "    {",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool LogonUser(",
            "            string lpszUsername,",
            "            string lpszDomain,",
            "            string lpszPassword,",
            "            LogonType dwLogonType,",
            "            LogonProvider dwLogonProvider,",
            "            out IntPtr phToken);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]",
            "        private static extern bool CreateProcessWithTokenW(",
            "            IntPtr hToken,",
            "            LogonFlags dwLogonFlags,",
            "            [MarshalAs(UnmanagedType.LPTStr)]",
            "            string lpApplicationName,",
            "            StringBuilder lpCommandLine,",
            "            CreationFlags dwCreationFlags,",
            "            IntPtr lpEnvironment,",
            "            [MarshalAs(UnmanagedType.LPTStr)]",
            "            string lpCurrentDirectory,",
            "            STARTUPINFOEX lpStartupInfo,",
            "            out PROCESS_INFORMATION lpProcessInformation);",
            "",
            "        [DllImport(\"kernel32.dll\")]",
            "        private static extern bool CreatePipe(",
            "            out SafeFileHandle hReadPipe,",
            "            out SafeFileHandle hWritePipe,",
            "            SECURITY_ATTRIBUTES lpPipeAttributes,",
            "            uint nSize);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern bool SetHandleInformation(",
            "            SafeFileHandle hObject,",
            "            HandleFlags dwMask,",
            "            int dwFlags);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern bool GetExitCodeProcess(",
            "            IntPtr hProcess,",
            "            out uint lpExitCode);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern bool CloseHandle(",
            "            IntPtr hObject);",
            "",
            "        [DllImport(\"user32.dll\", SetLastError = true)]",
            "        private static extern IntPtr GetProcessWindowStation();",
            "",
            "        [DllImport(\"user32.dll\", SetLastError = true)]",
            "        private static extern IntPtr GetThreadDesktop(",
            "            int dwThreadId);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern int GetCurrentThreadId();",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool GetTokenInformation(",
            "            IntPtr TokenHandle,",
            "            TokenInformationClass TokenInformationClass,",
            "            SafeMemoryBuffer TokenInformation,",
            "            uint TokenInformationLength,",
            "            out uint ReturnLength);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]",
            "        public static extern bool LookupPrivilegeNameW(",
            "            string lpSystemName,",
            "            ref LUID lpLuid,",
            "            StringBuilder lpName,",
            "            ref UInt32 cchName);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern IntPtr OpenProcess(",
            "            ProcessAccessFlags processAccess,",
            "            bool bInheritHandle,",
            "            UInt32 processId);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool OpenProcessToken(",
            "            IntPtr ProcessHandle,",
            "            TokenAccessLevels DesiredAccess,",
            "            out IntPtr TokenHandle);",
            "",
            "        [DllImport(\"advapi32\", SetLastError = true)]",
            "        private static extern bool DuplicateTokenEx(",
            "            IntPtr hExistingToken,",
            "            TokenAccessLevels dwDesiredAccess,",
            "            IntPtr lpTokenAttributes,",
            "            SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,",
            "            TOKEN_TYPE TokenType,",
            "            out IntPtr phNewToken);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool ImpersonateLoggedOnUser(",
            "            IntPtr hToken);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool RevertToSelf();",
            "",
            "        public static CommandResult RunAsUser(string username, string password, string lpCommandLine,",
            "            string lpCurrentDirectory, string stdinInput, LogonFlags logonFlags, LogonType logonType)",
            "        {",
            "            SecurityIdentifier account = null;",
            "            if (logonType != LogonType.LOGON32_LOGON_NEW_CREDENTIALS)",
            "            {",
            "                account = GetBecomeSid(username);",
            "            }",
            "",
            "            STARTUPINFOEX si = new STARTUPINFOEX();",
            "            si.startupInfo.dwFlags = (int)StartupInfoFlags.USESTDHANDLES;",
            "",
            "            SECURITY_ATTRIBUTES pipesec = new SECURITY_ATTRIBUTES();",
            "            pipesec.bInheritHandle = true;",
            "",
            "            // Create the stdout, stderr and stdin pipes used in the process and add to the startupInfo",
            "            SafeFileHandle stdout_read, stdout_write, stderr_read, stderr_write, stdin_read, stdin_write;",
            "            if (!CreatePipe(out stdout_read, out stdout_write, pipesec, 0))",
            "                throw new Win32Exception(\"STDOUT pipe setup failed\");",
            "            if (!SetHandleInformation(stdout_read, HandleFlags.INHERIT, 0))",
            "                throw new Win32Exception(\"STDOUT pipe handle setup failed\");",
            "",
            "            if (!CreatePipe(out stderr_read, out stderr_write, pipesec, 0))",
            "                throw new Win32Exception(\"STDERR pipe setup failed\");",
            "            if (!SetHandleInformation(stderr_read, HandleFlags.INHERIT, 0))",
            "                throw new Win32Exception(\"STDERR pipe handle setup failed\");",
            "",
            "            if (!CreatePipe(out stdin_read, out stdin_write, pipesec, 0))",
            "                throw new Win32Exception(\"STDIN pipe setup failed\");",
            "            if (!SetHandleInformation(stdin_write, HandleFlags.INHERIT, 0))",
            "                throw new Win32Exception(\"STDIN pipe handle setup failed\");",
            "",
            "            si.startupInfo.hStdOutput = stdout_write;",
            "            si.startupInfo.hStdError = stderr_write;",
            "            si.startupInfo.hStdInput = stdin_read;",
            "",
            "            // Setup the stdin buffer",
            "            UTF8Encoding utf8_encoding = new UTF8Encoding(false);",
            "            FileStream stdin_fs = new FileStream(stdin_write, FileAccess.Write, 32768);",
            "            StreamWriter stdin = new StreamWriter(stdin_fs, utf8_encoding, 32768);",
            "",
            "            // Create the environment block if set",
            "            IntPtr lpEnvironment = IntPtr.Zero;",
            "",
            "            CreationFlags startup_flags = CreationFlags.CREATE_UNICODE_ENVIRONMENT;",
            "",
            "            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();",
            "",
            "            // Get the user tokens to try running processes with",
            "            List<IntPtr> tokens = GetUserTokens(account, username, password, logonType);",
            "",
            "            bool launch_success = false;",
            "            foreach (IntPtr token in tokens)",
            "            {",
            "                if (CreateProcessWithTokenW(",
            "                    token,",
            "                    logonFlags,",
            "                    null,",
            "                    new StringBuilder(lpCommandLine),",
            "                    startup_flags,",
            "                    lpEnvironment,",
            "                    lpCurrentDirectory,",
            "                    si,",
            "                    out pi))",
            "                {",
            "                    launch_success = true;",
            "                    break;",
            "                }",
            "            }",
            "",
            "            if (!launch_success)",
            "                throw new Win32Exception(\"Failed to start become process\");",
            "",
            "            CommandResult result = new CommandResult();",
            "            // Setup the output buffers and get stdout/stderr",
            "            FileStream stdout_fs = new FileStream(stdout_read, FileAccess.Read, 4096);",
            "            StreamReader stdout = new StreamReader(stdout_fs, utf8_encoding, true, 4096);",
            "            stdout_write.Close();",
            "",
            "            FileStream stderr_fs = new FileStream(stderr_read, FileAccess.Read, 4096);",
            "            StreamReader stderr = new StreamReader(stderr_fs, utf8_encoding, true, 4096);",
            "            stderr_write.Close();",
            "",
            "            stdin.WriteLine(stdinInput);",
            "            stdin.Close();",
            "",
            "            string stdout_str, stderr_str = null;",
            "            GetProcessOutput(stdout, stderr, out stdout_str, out stderr_str);",
            "            UInt32 rc = GetProcessExitCode(pi.hProcess);",
            "",
            "            result.StandardOut = stdout_str;",
            "            result.StandardError = stderr_str;",
            "            result.ExitCode = rc;",
            "",
            "            return result;",
            "        }",
            "",
            "        private static SecurityIdentifier GetBecomeSid(string username)",
            "        {",
            "            NTAccount account = new NTAccount(username);",
            "            try",
            "            {",
            "                SecurityIdentifier security_identifier = (SecurityIdentifier)account.Translate(typeof(SecurityIdentifier));",
            "                return security_identifier;",
            "            }",
            "            catch (IdentityNotMappedException ex)",
            "            {",
            "                throw new Exception(String.Format(\"Unable to find become user {0}: {1}\", username, ex.Message));",
            "            }",
            "        }",
            "",
            "        private static List<IntPtr> GetUserTokens(SecurityIdentifier account, string username, string password, LogonType logonType)",
            "        {",
            "            List<IntPtr> tokens = new List<IntPtr>();",
            "            List<String> service_sids = new List<String>()",
            "            {",
            "                \"S-1-5-18\", // NT AUTHORITY\\SYSTEM",
            "                \"S-1-5-19\", // NT AUTHORITY\\LocalService",
            "                \"S-1-5-20\"  // NT AUTHORITY\\NetworkService",
            "            };",
            "",
            "            IntPtr hSystemToken = IntPtr.Zero;",
            "            string account_sid = \"\";",
            "            if (logonType != LogonType.LOGON32_LOGON_NEW_CREDENTIALS)",
            "            {",
            "                GrantAccessToWindowStationAndDesktop(account);",
            "                // Try to get SYSTEM token handle so we can impersonate to get full admin token",
            "                hSystemToken = GetSystemUserHandle();",
            "                account_sid = account.ToString();",
            "            }",
            "            bool impersonated = false;",
            "",
            "            try",
            "            {",
            "                if (hSystemToken == IntPtr.Zero && service_sids.Contains(account_sid))",
            "                {",
            "                    // We need the SYSTEM token if we want to become one of those accounts, fail here",
            "                    throw new Win32Exception(\"Failed to get token for NT AUTHORITY\\\\SYSTEM\");",
            "                }",
            "                else if (hSystemToken != IntPtr.Zero)",
            "                {",
            "                    // If SYSTEM impersonation failed but we're trying to become a regular user, just proceed;",
            "                    // might get a limited token in UAC-enabled cases, but better than nothing...",
            "                    if (ImpersonateLoggedOnUser(hSystemToken))",
            "                        impersonated = true;",
            "                    else if (service_sids.Contains(account_sid))",
            "                        throw new Win32Exception(\"Failed to impersonate as SYSTEM account\");",
            "",
            "                }",
            "",
            "                string domain = null;",
            "",
            "                if (service_sids.Contains(account_sid))",
            "                {",
            "                    // We're using a well-known service account, do a service logon instead of the actual flag set",
            "                    logonType = LogonType.LOGON32_LOGON_SERVICE;",
            "                    domain = \"NT AUTHORITY\";",
            "                    password = null;",
            "                    switch (account_sid)",
            "                    {",
            "                        case \"S-1-5-18\":",
            "                            tokens.Add(hSystemToken);",
            "                            return tokens;",
            "                        case \"S-1-5-19\":",
            "                            username = \"LocalService\";",
            "                            break;",
            "                        case \"S-1-5-20\":",
            "                            username = \"NetworkService\";",
            "                            break;",
            "                    }",
            "                }",
            "                else",
            "                {",
            "                    // We are trying to become a local or domain account",
            "                    if (username.Contains(@\"\\\"))",
            "                    {",
            "                        var user_split = username.Split(Convert.ToChar(@\"\\\"));",
            "                        domain = user_split[0];",
            "                        username = user_split[1];",
            "                    }",
            "                    else if (username.Contains(\"@\"))",
            "                        domain = null;",
            "                    else",
            "                        domain = \".\";",
            "                }",
            "",
            "                IntPtr hToken = IntPtr.Zero;",
            "                if (!LogonUser(",
            "                    username,",
            "                    domain,",
            "                    password,",
            "                    logonType,",
            "                    LogonProvider.LOGON32_PROVIDER_DEFAULT,",
            "                    out hToken))",
            "                {",
            "                    throw new Win32Exception(\"LogonUser failed\");",
            "                }",
            "",
            "                if (!service_sids.Contains(account_sid))",
            "                {",
            "                    // Try and get the elevated token for local/domain account",
            "                    IntPtr hTokenElevated = GetElevatedToken(hToken);",
            "                    tokens.Add(hTokenElevated);",
            "                }",
            "",
            "                // add the original token as a fallback",
            "                tokens.Add(hToken);",
            "            }",
            "            finally",
            "            {",
            "                if (impersonated)",
            "                    RevertToSelf();",
            "            }",
            "",
            "            return tokens;",
            "        }",
            "",
            "        private static IntPtr GetSystemUserHandle()",
            "        {",
            "            // According to CreateProcessWithTokenW we require a token with",
            "            //  TOKEN_QUERY, TOKEN_DUPLICATE and TOKEN_ASSIGN_PRIMARY",
            "            // Also add in TOKEN_IMPERSONATE so we can get an impersontated token",
            "            TokenAccessLevels desired_access = TokenAccessLevels.Query |",
            "                TokenAccessLevels.Duplicate |",
            "                TokenAccessLevels.AssignPrimary |",
            "                TokenAccessLevels.Impersonate;",
            "",
            "            foreach (System.Diagnostics.Process process in System.Diagnostics.Process.GetProcesses())",
            "            {",
            "                using (process)",
            "                {",
            "                    IntPtr hProcess = OpenProcess(ProcessAccessFlags.PROCESS_QUERY_INFORMATION, false, (UInt32)process.Id);",
            "                    if (hProcess == IntPtr.Zero)",
            "                        continue;",
            "",
            "                    try",
            "                    {",
            "                        IntPtr hToken = IntPtr.Zero;",
            "                        if (!OpenProcessToken(hProcess, desired_access, out hToken))",
            "                            continue;",
            "",
            "                        try",
            "                        {",
            "                            string sid = GetTokenUserSID(hToken);",
            "                            if (sid != \"S-1-5-18\")",
            "                                continue;",
            "",
            "                            // Make sure the SYSTEM token we are checking contains the SeTcbPrivilege required for",
            "                            // escalation. Some SYSTEM tokens have this privilege stripped out.",
            "                            List<string> actualPrivileges = GetTokenPrivileges(hToken);",
            "                            if (!actualPrivileges.Contains(\"SeTcbPrivilege\"))",
            "                                continue;",
            "",
            "                            IntPtr dupToken = IntPtr.Zero;",
            "                            if (!DuplicateTokenEx(hToken, TokenAccessLevels.MaximumAllowed, IntPtr.Zero,",
            "                                SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation, TOKEN_TYPE.TokenPrimary,",
            "                                out dupToken))",
            "                            {",
            "                                continue;",
            "                            }",
            "                            return dupToken;",
            "                        }",
            "                        finally",
            "                        {",
            "                            CloseHandle(hToken);",
            "                        }",
            "                    }",
            "                    finally",
            "                    {",
            "                        CloseHandle(hProcess);",
            "                    }",
            "                }",
            "            }",
            "",
            "            return IntPtr.Zero;",
            "        }",
            "",
            "        private static string GetTokenUserSID(IntPtr hToken)",
            "        {",
            "            using (SafeMemoryBuffer tokenInfo = GetTokenInformation(hToken, TokenInformationClass.TokenUser))",
            "            {",
            "                TOKEN_USER tokenUser = (TOKEN_USER)Marshal.PtrToStructure(tokenInfo.DangerousGetHandle(),",
            "                    typeof(TOKEN_USER));",
            "                return new SecurityIdentifier(tokenUser.User.Sid).Value;",
            "            }",
            "        }",
            "",
            "        private static void GetProcessOutput(StreamReader stdoutStream, StreamReader stderrStream, out string stdout, out string stderr)",
            "        {",
            "            var sowait = new EventWaitHandle(false, EventResetMode.ManualReset);",
            "            var sewait = new EventWaitHandle(false, EventResetMode.ManualReset);",
            "            string so = null, se = null;",
            "            ThreadPool.QueueUserWorkItem((s) =>",
            "            {",
            "                so = stdoutStream.ReadToEnd();",
            "                sowait.Set();",
            "            });",
            "            ThreadPool.QueueUserWorkItem((s) =>",
            "            {",
            "                se = stderrStream.ReadToEnd();",
            "                sewait.Set();",
            "            });",
            "            foreach (var wh in new WaitHandle[] { sowait, sewait })",
            "                wh.WaitOne();",
            "            stdout = so;",
            "            stderr = se;",
            "        }",
            "",
            "        private static uint GetProcessExitCode(IntPtr processHandle)",
            "        {",
            "            new NativeWaitHandle(processHandle).WaitOne();",
            "            uint exitCode;",
            "            if (!GetExitCodeProcess(processHandle, out exitCode))",
            "                throw new Win32Exception(\"Error getting process exit code\");",
            "            return exitCode;",
            "        }",
            "",
            "        private static IntPtr GetElevatedToken(IntPtr hToken)",
            "        {",
            "            // First determine if the current token is a limited token",
            "            using (SafeMemoryBuffer tokenInfo = GetTokenInformation(hToken, TokenInformationClass.TokenElevationType))",
            "            {",
            "                TokenElevationType tet = (TokenElevationType)Marshal.ReadInt32(tokenInfo.DangerousGetHandle());",
            "                // We already have the best token we can get, just use it",
            "                if (tet != TokenElevationType.TokenElevationTypeLimited)",
            "                    return hToken;",
            "            }",
            "",
            "            // We have a limited token, get the linked elevated token",
            "            using (SafeMemoryBuffer tokenInfo = GetTokenInformation(hToken, TokenInformationClass.TokenLinkedToken))",
            "                return Marshal.ReadIntPtr(tokenInfo.DangerousGetHandle());",
            "        }",
            "",
            "        private static List<string> GetTokenPrivileges(IntPtr hToken)",
            "        {",
            "            using (SafeMemoryBuffer tokenInfo = GetTokenInformation(hToken, TokenInformationClass.TokenPrivileges))",
            "            {",
            "                TOKEN_PRIVILEGES tokenPrivileges = (TOKEN_PRIVILEGES)Marshal.PtrToStructure(",
            "                    tokenInfo.DangerousGetHandle(), typeof(TOKEN_PRIVILEGES));",
            "",
            "                LUID_AND_ATTRIBUTES[] luidAndAttributes = new LUID_AND_ATTRIBUTES[tokenPrivileges.PrivilegeCount];",
            "                PtrToStructureArray(luidAndAttributes, IntPtr.Add(tokenInfo.DangerousGetHandle(), Marshal.SizeOf(tokenPrivileges.PrivilegeCount)));",
            "",
            "                return luidAndAttributes.Select(x => GetPrivilegeName(x.Luid)).ToList();",
            "            }",
            "        }",
            "",
            "        private static SafeMemoryBuffer GetTokenInformation(IntPtr hToken, TokenInformationClass tokenClass)",
            "        {",
            "            UInt32 tokenLength;",
            "            bool res = GetTokenInformation(hToken, tokenClass, new SafeMemoryBuffer(IntPtr.Zero), 0, out tokenLength);",
            "            if (!res && tokenLength == 0)  // res will be false due to insufficient buffer size, we ignore if we got the buffer length",
            "                throw new Win32Exception(String.Format(\"GetTokenInformation({0}) failed to get buffer length\", tokenClass.ToString()));",
            "",
            "            SafeMemoryBuffer tokenInfo = new SafeMemoryBuffer((int)tokenLength);",
            "            if (!GetTokenInformation(hToken, tokenClass, tokenInfo, tokenLength, out tokenLength))",
            "                throw new Win32Exception(String.Format(\"GetTokenInformation({0}) failed\", tokenClass.ToString()));",
            "",
            "            return tokenInfo;",
            "        }",
            "",
            "        private static string GetPrivilegeName(LUID luid)",
            "        {",
            "            UInt32 nameLen = 0;",
            "            LookupPrivilegeNameW(null, ref luid, null, ref nameLen);",
            "",
            "            StringBuilder name = new StringBuilder((int)(nameLen + 1));",
            "            if (!LookupPrivilegeNameW(null, ref luid, name, ref nameLen))",
            "                throw new Win32Exception(\"LookupPrivilegeNameW() failed\");",
            "",
            "            return name.ToString();",
            "        }",
            "",
            "        private static void PtrToStructureArray<T>(T[] array, IntPtr ptr)",
            "        {",
            "            IntPtr ptrOffset = ptr;",
            "            for (int i = 0; i < array.Length; i++, ptrOffset = IntPtr.Add(ptrOffset, Marshal.SizeOf(typeof(T))))",
            "                array[i] = (T)Marshal.PtrToStructure(ptrOffset, typeof(T));",
            "        }",
            "",
            "        private static void GrantAccessToWindowStationAndDesktop(SecurityIdentifier account)",
            "        {",
            "            const int WindowStationAllAccess = 0x000f037f;",
            "            GrantAccess(account, GetProcessWindowStation(), WindowStationAllAccess);",
            "            const int DesktopRightsAllAccess = 0x000f01ff;",
            "            GrantAccess(account, GetThreadDesktop(GetCurrentThreadId()), DesktopRightsAllAccess);",
            "        }",
            "",
            "        private static void GrantAccess(SecurityIdentifier account, IntPtr handle, int accessMask)",
            "        {",
            "            SafeHandle safeHandle = new NoopSafeHandle(handle);",
            "            GenericSecurity security =",
            "                new GenericSecurity(false, ResourceType.WindowObject, safeHandle, AccessControlSections.Access);",
            "            security.AddAccessRule(",
            "                new GenericAccessRule(account, accessMask, AccessControlType.Allow));",
            "            security.Persist(safeHandle, AccessControlSections.Access);",
            "        }",
            "",
            "        private class GenericSecurity : NativeObjectSecurity",
            "        {",
            "            public GenericSecurity(bool isContainer, ResourceType resType, SafeHandle objectHandle, AccessControlSections sectionsRequested)",
            "                : base(isContainer, resType, objectHandle, sectionsRequested) { }",
            "            public new void Persist(SafeHandle handle, AccessControlSections includeSections) { base.Persist(handle, includeSections); }",
            "            public new void AddAccessRule(AccessRule rule) { base.AddAccessRule(rule); }",
            "            public override Type AccessRightType { get { throw new NotImplementedException(); } }",
            "            public override AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited,",
            "                InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)",
            "            { throw new NotImplementedException(); }",
            "            public override Type AccessRuleType { get { return typeof(AccessRule); } }",
            "            public override AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited,",
            "                InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)",
            "            { throw new NotImplementedException(); }",
            "            public override Type AuditRuleType { get { return typeof(AuditRule); } }",
            "        }",
            "",
            "        private class NoopSafeHandle : SafeHandle",
            "        {",
            "            public NoopSafeHandle(IntPtr handle) : base(handle, false) { }",
            "            public override bool IsInvalid { get { return false; } }",
            "            protected override bool ReleaseHandle() { return true; }",
            "        }",
            "",
            "        private class GenericAccessRule : AccessRule",
            "        {",
            "            public GenericAccessRule(IdentityReference identity, int accessMask, AccessControlType type) :",
            "                base(identity, accessMask, false, InheritanceFlags.None, PropagationFlags.None, type)",
            "            { }",
            "        }",
            "    }",
            "}",
            "\"@",
            "",
            "# due to the command line size limitations of CreateProcessWithTokenW, we",
            "# execute a simple PS script that executes our full exec_wrapper so no files",
            "# touch the disk",
            "$become_exec_wrapper = {",
            "    chcp.com 65001 > $null",
            "    $ProgressPreference = \"SilentlyContinue\"",
            "    $raw = [System.Console]::In.ReadToEnd()",
            "    $split_parts = $raw.Split(@(\"`0`0`0`0\"), 0)",
            "    If (-not $split_parts.Length -eq 2) { throw \"invalid payload\" }",
            "    $json_raw = $split_parts[1]",
            "    &([ScriptBlock]::Create($split_parts[0]))",
            "}",
            "",
            "$exec_wrapper = {",
            "    &chcp.com 65001 > $null",
            "    Set-StrictMode -Version 2",
            "    $DebugPreference = \"Continue\"",
            "    $ErrorActionPreference = \"Stop\"",
            "",
            "    Function ConvertTo-HashtableFromPsCustomObject($myPsObject) {",
            "        $output = @{}",
            "        $myPsObject | Get-Member -MemberType *Property | % {",
            "            $val = $myPsObject.($_.name)",
            "            if ($val -is [psobject]) {",
            "                $val = ConvertTo-HashtableFromPsCustomObject -myPsObject $val",
            "            }",
            "            $output.($_.name) = $val",
            "        }",
            "        return $output",
            "    }",
            "",
            "    # stream JSON including become_pw, ps_module_payload, bin_module_payload, become_payload, write_payload_path, preserve directives",
            "    # exec runspace, capture output, cleanup, return module output. Do not change this as it is set become before being passed to the",
            "    # become process.",
            "",
            "    if (-not $(Get-Variable \"json_raw\" -ErrorAction SilentlyContinue)) {",
            "        Write-Error \"no payload supplied\" -Category InvalidArgument",
            "    }",
            "",
            "    $payload = ConvertTo-HashtableFromPsCustomObject -myPsObject (ConvertFrom-Json $json_raw)",
            "",
            "    # TODO: handle binary modules",
            "    # TODO: handle persistence",
            "",
            "    $actions = $payload.actions",
            "",
            "    # pop 0th action as entrypoint",
            "    $entrypoint = $payload.($actions[0])",
            "    $payload.actions = $payload.actions[1..99]",
            "",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    # load the current action entrypoint as a module custom object with a Run method",
            "    $entrypoint = New-Module -ScriptBlock ([scriptblock]::Create($entrypoint)) -AsCustomObject",
            "",
            "    Set-Variable -Scope global -Name complex_args -Value $payload[\"module_args\"] | Out-Null",
            "",
            "    # dynamically create/load modules",
            "    ForEach ($mod in $payload.powershell_modules.GetEnumerator()) {",
            "        $decoded_module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($mod.Value))",
            "        New-Module -ScriptBlock ([scriptblock]::Create($decoded_module)) -Name $mod.Key | Import-Module -WarningAction SilentlyContinue | Out-Null",
            "    }",
            "",
            "    $output = $entrypoint.Run($payload)",
            "    # base64 encode the output so the non-ascii characters are preserved",
            "    Write-Output ([System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((Write-Output $output))))",
            "} # end exec_wrapper",
            "",
            "Function Dump-Error ($excep, $msg=$null) {",
            "    $eo = @{failed=$true}",
            "",
            "    $exception_message = $excep.Exception.Message",
            "    if ($null -ne $msg) {",
            "        $exception_message = \"$($msg): $exception_message\"",
            "    }",
            "    $eo.msg = $exception_message",
            "    $eo.exception = $excep | Out-String",
            "    $host.SetShouldExit(1)",
            "",
            "    $eo | ConvertTo-Json -Depth 10 -Compress",
            "}",
            "",
            "Function Parse-EnumValue($enum, $flag_type, $value, $prefix) {",
            "    $raw_enum_value = \"$prefix$($value.ToUpper())\"",
            "    try {",
            "        $enum_value = [Enum]::Parse($enum, $raw_enum_value)",
            "    } catch [System.ArgumentException] {",
            "        $valid_options = [Enum]::GetNames($enum) | ForEach-Object { $_.Substring($prefix.Length).ToLower() }",
            "        throw \"become_flags $flag_type value '$value' is not valid, valid values are: $($valid_options -join \", \")\"",
            "    }",
            "    return $enum_value",
            "}",
            "",
            "Function Parse-BecomeFlags($flags) {",
            "    $logon_type = [AnsibleBecome.LogonType]::LOGON32_LOGON_INTERACTIVE",
            "    $logon_flags = [AnsibleBecome.LogonFlags]::LOGON_WITH_PROFILE",
            "",
            "    if ($flags -eq $null -or $flags -eq \"\") {",
            "        $flag_split = @()",
            "    } elseif ($flags -is [string]) {",
            "        $flag_split = $flags.Split(\" \")",
            "    } else {",
            "        throw \"become_flags must be a string, was $($flags.GetType())\"",
            "    }",
            "",
            "    foreach ($flag in $flag_split) {",
            "        $split = $flag.Split(\"=\")",
            "        if ($split.Count -ne 2) {",
            "            throw \"become_flags entry '$flag' is in an invalid format, must be a key=value pair\"",
            "        }",
            "        $flag_key = $split[0]",
            "        $flag_value = $split[1]",
            "        if ($flag_key -eq \"logon_type\") {",
            "            $enum_details = @{",
            "                enum = [AnsibleBecome.LogonType]",
            "                flag_type = $flag_key",
            "                value = $flag_value",
            "                prefix = \"LOGON32_LOGON_\"",
            "            }",
            "            $logon_type = Parse-EnumValue @enum_details",
            "        } elseif ($flag_key -eq \"logon_flags\") {",
            "            $logon_flag_values = $flag_value.Split(\",\")",
            "            $logon_flags = 0 -as [AnsibleBecome.LogonFlags]",
            "            foreach ($logon_flag_value in $logon_flag_values) {",
            "                if ($logon_flag_value -eq \"\") {",
            "                    continue",
            "                }",
            "                $enum_details = @{",
            "                    enum = [AnsibleBecome.LogonFlags]",
            "                    flag_type = $flag_key",
            "                    value = $logon_flag_value",
            "                    prefix = \"LOGON_\"",
            "                }",
            "                $logon_flag = Parse-EnumValue @enum_details",
            "                $logon_flags = $logon_flags -bor $logon_flag",
            "            }",
            "        } else {",
            "            throw \"become_flags key '$flag_key' is not a valid runas flag, must be 'logon_type' or 'logon_flags'\"",
            "        }",
            "    }",
            "",
            "    return $logon_type, [AnsibleBecome.LogonFlags]$logon_flags",
            "}",
            "",
            "Function Run($payload) {",
            "    # NB: action popping handled inside subprocess wrapper",
            "",
            "    $original_tmp = $env:TMP",
            "    $remote_tmp = $payload[\"module_args\"][\"_ansible_remote_tmp\"]",
            "    $remote_tmp = [System.Environment]::ExpandEnvironmentVariables($remote_tmp)",
            "    if ($null -eq $remote_tmp) {",
            "        $remote_tmp = $original_tmp",
            "    }",
            "",
            "    # become process is run under a different console to the WinRM one so we",
            "    # need to set the UTF-8 codepage again",
            "    $env:TMP = $remote_tmp",
            "    Add-Type -TypeDefinition $helper_def -Debug:$false",
            "    $env:TMP = $original_tmp",
            "",
            "    $username = $payload.become_user",
            "    $password = $payload.become_password",
            "    try {",
            "        $logon_type, $logon_flags = Parse-BecomeFlags -flags $payload.become_flags",
            "    } catch {",
            "        Dump-Error -excep $_ -msg \"Failed to parse become_flags '$($payload.become_flags)'\"",
            "        return $null",
            "    }",
            "",
            "    # NB: CreateProcessWithTokenW commandline maxes out at 1024 chars, must bootstrap via small",
            "    # wrapper which calls our read wrapper passed through stdin. Cannot use 'powershell -' as",
            "    # the $ErrorActionPreference is always set to Stop and cannot be changed",
            "    $payload_string = $payload | ConvertTo-Json -Depth 99 -Compress",
            "    $exec_wrapper = $exec_wrapper.ToString() + \"`0`0`0`0\" + $payload_string",
            "    $rc = 0",
            "",
            "    $exec_command = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($become_exec_wrapper.ToString()))",
            "    $lp_command_line = New-Object System.Text.StringBuilder @(\"powershell.exe -NonInteractive -NoProfile -ExecutionPolicy Bypass -EncodedCommand $exec_command\")",
            "    $lp_current_directory = \"$env:SystemRoot\"",
            "",
            "    Try {",
            "        $result = [AnsibleBecome.BecomeUtil]::RunAsUser($username, $password, $lp_command_line, $lp_current_directory, $exec_wrapper, $logon_flags, $logon_type)",
            "        $stdout = $result.StandardOut",
            "        $stdout = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($stdout.Trim()))",
            "        $stderr = $result.StandardError",
            "        $rc = $result.ExitCode",
            "",
            "        $host.UI.WriteLine($stdout)",
            "        $host.UI.WriteErrorLine($stderr.Trim())",
            "    } Catch {",
            "        $excep = $_",
            "        Dump-Error -excep $excep -msg \"Failed to become user $username\"",
            "    }",
            "    $host.SetShouldExit($rc)",
            "}",
            "'''",
            "",
            "async_wrapper = br'''",
            "Set-StrictMode -Version 2",
            "$ErrorActionPreference = \"Stop\"",
            "",
            "# build exec_wrapper encoded command",
            "# start powershell with breakaway running exec_wrapper encodedcommand",
            "# stream payload to powershell with normal exec, but normal exec writes results to resultfile instead of stdout/stderr",
            "# return asyncresult to controller",
            "",
            "$exec_wrapper = {",
            "    # help to debug any errors in the exec_wrapper or async_watchdog by generating",
            "    # an error log in case of a terminating error",
            "    trap {",
            "        $log_path = \"$($env:TEMP)\\async-exec-wrapper-$(Get-Date -Format \"yyyy-MM-ddTHH-mm-ss.ffffZ\")-error.txt\"",
            "        $error_msg = \"Error while running the async exec wrapper`r`n$_`r`n$($_.ScriptStackTrace)\"",
            "        Set-Content -Path $log_path -Value $error_msg",
            "        throw $_",
            "    }",
            "",
            "    &chcp.com 65001 > $null",
            "    $DebugPreference = \"Continue\"",
            "    $ErrorActionPreference = \"Stop\"",
            "    Set-StrictMode -Version 2",
            "",
            "    function ConvertTo-HashtableFromPsCustomObject ($myPsObject){",
            "        $output = @{};",
            "        $myPsObject | Get-Member -MemberType *Property | % {",
            "            $val = $myPsObject.($_.name);",
            "            If ($val -is [psobject]) {",
            "                $val = ConvertTo-HashtableFromPsCustomObject $val",
            "            }",
            "            $output.($_.name) = $val",
            "        }",
            "        return $output;",
            "    }",
            "",
            "    # store the pipe name and no. of bytes to read, these are populated by the",
            "    # Run function before being run - do not remove or change",
            "    $pipe_name = \"\"",
            "    $bytes_length = 0",
            "",
            "    # stream JSON including become_pw, ps_module_payload, bin_module_payload, become_payload, write_payload_path, preserve directives",
            "    # exec runspace, capture output, cleanup, return module output",
            "    $input_bytes = New-Object -TypeName byte[] -ArgumentList $bytes_length",
            "    $pipe = New-Object -TypeName System.IO.Pipes.NamedPipeClientStream -ArgumentList @(",
            "        \".\",  # localhost",
            "        $pipe_name,",
            "        [System.IO.Pipes.PipeDirection]::In,",
            "        [System.IO.Pipes.PipeOptions]::None,",
            "        [System.Security.Principal.TokenImpersonationLevel]::Anonymous",
            "    )",
            "    try {",
            "        $pipe.Connect()",
            "        $pipe.Read($input_bytes, 0, $bytes_length) > $null",
            "    } finally {",
            "        $pipe.Close()",
            "    }",
            "    $json_raw = [System.Text.Encoding]::UTF8.GetString($input_bytes)",
            "",
            "    If (-not $json_raw) {",
            "        Write-Error \"no input given\" -Category InvalidArgument",
            "    }",
            "",
            "    $payload = ConvertTo-HashtableFromPsCustomObject (ConvertFrom-Json $json_raw)",
            "",
            "    # TODO: handle binary modules",
            "    # TODO: handle persistence",
            "",
            "    $actions = $payload.actions",
            "",
            "    # pop 0th action as entrypoint",
            "    $entrypoint = $payload.($actions[0])",
            "    $payload.actions = $payload.actions[1..99]",
            "",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    # load the current action entrypoint as a module custom object with a Run method",
            "    $entrypoint = New-Module -ScriptBlock ([scriptblock]::Create($entrypoint)) -AsCustomObject",
            "",
            "    Set-Variable -Scope global -Name complex_args -Value $payload[\"module_args\"] | Out-Null",
            "",
            "    # dynamically create/load modules",
            "    ForEach ($mod in $payload.powershell_modules.GetEnumerator()) {",
            "        $decoded_module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($mod.Value))",
            "        New-Module -ScriptBlock ([scriptblock]::Create($decoded_module)) -Name $mod.Key | Import-Module -WarningAction SilentlyContinue | Out-Null",
            "    }",
            "",
            "    $output = $entrypoint.Run($payload)",
            "",
            "    Write-Output $output",
            "} # end exec_wrapper",
            "",
            "",
            "Function Run($payload) {",
            "    $remote_tmp = $payload[\"module_args\"][\"_ansible_remote_tmp\"]",
            "    $remote_tmp = [System.Environment]::ExpandEnvironmentVariables($remote_tmp)",
            "",
            "    # calculate the result path so we can include it in the worker payload",
            "    $jid = $payload.async_jid",
            "    $local_jid = $jid + \".\" + $pid",
            "",
            "    $results_path = [System.IO.Path]::Combine($remote_tmp, \".ansible_async\", $local_jid)",
            "",
            "    $payload.async_results_path = $results_path",
            "",
            "    [System.IO.Directory]::CreateDirectory([System.IO.Path]::GetDirectoryName($results_path)) | Out-Null",
            "",
            "    # can't use anonymous pipes as the spawned process will not be a child due to",
            "    # the way WMI works, use a named pipe with a random name instead and set to",
            "    # only allow current user to read from the pipe",
            "    $pipe_name = \"ansible-async-$jid-$([guid]::NewGuid())\"",
            "    $current_user = ([Security.Principal.WindowsIdentity]::GetCurrent()).User",
            "    $payload_string = $payload | ConvertTo-Json -Depth 99 -Compress",
            "    $payload_bytes = [System.Text.Encoding]::UTF8.GetBytes($payload_string)",
            "",
            "    $pipe_sec = New-Object -TypeName System.IO.Pipes.PipeSecurity",
            "    $pipe_ar = New-Object -TypeName System.IO.Pipes.PipeAccessRule -ArgumentList @(",
            "        $current_user,",
            "        [System.IO.Pipes.PipeAccessRights]::Read,",
            "        [System.Security.AccessControl.AccessControlType]::Allow",
            "    )",
            "    $pipe_sec.AddAccessRule($pipe_ar)",
            "    $pipe = New-Object -TypeName System.IO.Pipes.NamedPipeServerStream -ArgumentList @(",
            "        $pipe_name,",
            "        [System.IO.Pipes.PipeDirection]::Out,",
            "        1,",
            "        [System.IO.Pipes.PipeTransmissionMode]::Byte,",
            "        [System.IO.Pipes.PipeOptions]::Asynchronous,",
            "        0,",
            "        0,",
            "        $pipe_sec",
            "    )",
            "",
            "    try {",
            "        $exec_wrapper_str = $exec_wrapper.ToString()",
            "        $exec_wrapper_str = $exec_wrapper_str.Replace('$pipe_name = \"\"', \"`$pipe_name = `\"$pipe_name`\"\")",
            "        $exec_wrapper_str = $exec_wrapper_str.Replace('$bytes_length = 0', \"`$bytes_length = $($payload_bytes.Count)\")",
            "",
            "        $encoded_command = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($exec_wrapper_str))",
            "        $exec_args = \"powershell.exe -NonInteractive -NoProfile -ExecutionPolicy Bypass -EncodedCommand $encoded_command\"",
            "",
            "        # not all connection plugins support breakaway from job that is required",
            "        # for async, Win32_Process.Create() is still able to escape so we use",
            "        # that here",
            "        $process = Invoke-CimMethod -ClassName Win32_Process -Name Create -Arguments @{CommandLine=$exec_args}",
            "        $rc = $process.ReturnValue",
            "        if ($rc -ne 0) {",
            "            $error_msg = switch($rc) {",
            "                2 { \"Access denied\" }",
            "                3 { \"Insufficient privilege\" }",
            "                8 { \"Unknown failure\" }",
            "                9 { \"Path not found\" }",
            "                21 { \"Invalid parameter\" }",
            "                default { \"Other\" }",
            "            }",
            "            throw \"Failed to start async process: $rc ($error_msg)\"",
            "        }",
            "        $watchdog_pid = $process.ProcessId",
            "",
            "        # populate initial results before we send the async data to avoid result race",
            "        $result = @{",
            "            started = 1;",
            "            finished = 0;",
            "            results_file = $results_path;",
            "            ansible_job_id = $local_jid;",
            "            _ansible_suppress_tmpdir_delete = $true;",
            "            ansible_async_watchdog_pid = $watchdog_pid",
            "        }",
            "",
            "        $result_json = ConvertTo-Json $result",
            "        Set-Content $results_path -Value $result_json",
            "",
            "        # wait until the client connects, throw an error if the timeout is reached",
            "        $wait_async = $pipe.BeginWaitForConnection($null, $null)",
            "        $wait_async.AsyncWaitHandle.WaitOne(5000) > $null",
            "        if (-not $wait_async.IsCompleted) {",
            "            throw \"timeout while waiting for child process to connect to named pipe\"",
            "        }",
            "        $pipe.EndWaitForConnection($wait_async)",
            "",
            "        # write the exec manifest to the child process",
            "        $pipe.Write($payload_bytes, 0, $payload_bytes.Count)",
            "        $pipe.Flush()",
            "        $pipe.WaitForPipeDrain()",
            "    } finally {",
            "        $pipe.Close()",
            "    }",
            "",
            "    return $result_json",
            "}",
            "",
            "'''  # end async_wrapper",
            "",
            "async_watchdog = br'''",
            "Set-StrictMode -Version 2",
            "$ErrorActionPreference = \"Stop\"",
            "",
            "Add-Type -AssemblyName System.Web.Extensions",
            "",
            "Function Log {",
            "    Param(",
            "        [string]$msg",
            "    )",
            "",
            "    If(Get-Variable -Name log_path -ErrorAction SilentlyContinue) {",
            "        Add-Content $log_path $msg",
            "    }",
            "}",
            "",
            "Function Deserialize-Json {",
            "    Param(",
            "        [Parameter(ValueFromPipeline=$true)]",
            "        [string]$json",
            "    )",
            "",
            "    # FUTURE: move this into module_utils/powershell.ps1 and use for everything (sidestep PSCustomObject issues)",
            "    # FUTURE: won't work w/ Nano Server/.NET Core- fallback to DataContractJsonSerializer (which can't handle dicts on .NET 4.0)",
            "",
            "    Log \"Deserializing:`n$json\"",
            "",
            "    $jss = New-Object System.Web.Script.Serialization.JavaScriptSerializer",
            "    return $jss.DeserializeObject($json)",
            "}",
            "",
            "Function Write-Result {",
            "    Param(",
            "        [hashtable]$result,",
            "        [string]$resultfile_path",
            "    )",
            "",
            "    $result | ConvertTo-Json | Set-Content -Path $resultfile_path",
            "}",
            "",
            "Function Run($payload) {",
            "    $actions = $payload.actions",
            "",
            "    # pop 0th action as entrypoint",
            "    $entrypoint = $payload.($actions[0])",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    $payload.actions = $payload.actions[1..99]",
            "",
            "    $resultfile_path = $payload.async_results_path",
            "    $max_exec_time_sec = $payload.async_timeout_sec",
            "",
            "    Log \"deserializing existing resultfile args\"",
            "    # read in existing resultsfile to merge w/ module output (it should be written by the time we're unsuspended and running)",
            "    $result = Get-Content $resultfile_path -Raw | Deserialize-Json",
            "",
            "    Log \"deserialized result is $($result | Out-String)\"",
            "",
            "    Log \"creating runspace\"",
            "",
            "    $rs = [runspacefactory]::CreateRunspace()",
            "    $rs.Open()",
            "",
            "    Log \"creating Powershell object\"",
            "",
            "    $job = [powershell]::Create()",
            "    $job.Runspace = $rs",
            "",
            "    $job.AddScript($entrypoint) | Out-Null",
            "    $job.AddStatement().AddCommand(\"Run\").AddArgument($payload) | Out-Null",
            "",
            "    Log \"job BeginInvoke()\"",
            "",
            "    $job_asyncresult = $job.BeginInvoke()",
            "",
            "    Log \"waiting $max_exec_time_sec seconds for job to complete\"",
            "",
            "    $signaled = $job_asyncresult.AsyncWaitHandle.WaitOne($max_exec_time_sec * 1000)",
            "",
            "    $result[\"finished\"] = 1",
            "",
            "    If($job_asyncresult.IsCompleted) {",
            "        Log \"job completed, calling EndInvoke()\"",
            "",
            "        $job_output = $job.EndInvoke($job_asyncresult)",
            "        $job_error = $job.Streams.Error",
            "",
            "        Log \"raw module stdout: \\r\\n$job_output\"",
            "        If($job_error) {",
            "            Log \"raw module stderr: \\r\\n$job_error\"",
            "        }",
            "",
            "        # write success/output/error to result object",
            "",
            "        # TODO: cleanse leading/trailing junk",
            "        Try {",
            "            $module_result = Deserialize-Json $job_output",
            "            # TODO: check for conflicting keys",
            "            $result = $result + $module_result",
            "        }",
            "        Catch {",
            "            $excep = $_",
            "",
            "            $result.failed = $true",
            "            $result.msg = \"failed to parse module output: $excep\"",
            "            # return the output back to Ansible to help with debugging errors",
            "            $result.stdout = $job_output | Out-String",
            "            $result.stderr = $job_error | Out-String",
            "        }",
            "",
            "        # TODO: determine success/fail, or always include stderr if nonempty?",
            "        Write-Result $result $resultfile_path",
            "",
            "        Log \"wrote output to $resultfile_path\"",
            "    }",
            "    Else {",
            "        $job.BeginStop($null, $null) | Out-Null # best effort stop",
            "        # write timeout to result object",
            "        $result.failed = $true",
            "        $result.msg = \"timed out waiting for module completion\"",
            "        Write-Result $result $resultfile_path",
            "",
            "        Log \"wrote timeout to $resultfile_path\"",
            "    }",
            "",
            "    # in the case of a hung pipeline, this will cause the process to stay alive until it's un-hung...",
            "    #$rs.Close() | Out-Null",
            "}",
            "",
            "'''  # end async_watchdog",
            "",
            "from ansible.plugins import AnsiblePlugin",
            "",
            "",
            "class ShellModule(ShellBase):",
            "",
            "    # Common shell filenames that this plugin handles",
            "    # Powershell is handled differently.  It's selected when winrm is the",
            "    # connection",
            "    COMPATIBLE_SHELLS = frozenset()",
            "    # Family of shells this has.  Must match the filename without extension",
            "    SHELL_FAMILY = 'powershell'",
            "",
            "    env = dict()",
            "",
            "    # We're being overly cautious about which keys to accept (more so than",
            "    # the Windows environment is capable of doing), since the powershell",
            "    # env provider's limitations don't appear to be documented.",
            "    safe_envkey = re.compile(r'^[\\d\\w_]{1,255}$')",
            "",
            "    # TODO: add binary module support",
            "",
            "    def assert_safe_env_key(self, key):",
            "        if not self.safe_envkey.match(key):",
            "            raise AnsibleError(\"Invalid PowerShell environment key: %s\" % key)",
            "        return key",
            "",
            "    def safe_env_value(self, key, value):",
            "        if len(value) > 32767:",
            "            raise AnsibleError(\"PowerShell environment value for key '%s' exceeds 32767 characters in length\" % key)",
            "        # powershell single quoted literals need single-quote doubling as their only escaping",
            "        value = value.replace(\"'\", \"''\")",
            "        return to_text(value, errors='surrogate_or_strict')",
            "",
            "    def env_prefix(self, **kwargs):",
            "        # powershell/winrm env handling is handled in the exec wrapper",
            "        return \"\"",
            "",
            "    def join_path(self, *args):",
            "        parts = []",
            "        for arg in args:",
            "            arg = self._unquote(arg).replace('/', '\\\\')",
            "            parts.extend([a for a in arg.split('\\\\') if a])",
            "        path = '\\\\'.join(parts)",
            "        if path.startswith('~'):",
            "            return path",
            "        return path",
            "",
            "    def get_remote_filename(self, pathname):",
            "        # powershell requires that script files end with .ps1",
            "        base_name = os.path.basename(pathname.strip())",
            "        name, ext = os.path.splitext(base_name.strip())",
            "        if ext.lower() not in ['.ps1', '.exe']:",
            "            return name + '.ps1'",
            "",
            "        return base_name.strip()",
            "",
            "    def path_has_trailing_slash(self, path):",
            "        # Allow Windows paths to be specified using either slash.",
            "        path = self._unquote(path)",
            "        return path.endswith('/') or path.endswith('\\\\')",
            "",
            "    def chmod(self, paths, mode):",
            "        raise NotImplementedError('chmod is not implemented for Powershell')",
            "",
            "    def chown(self, paths, user):",
            "        raise NotImplementedError('chown is not implemented for Powershell')",
            "",
            "    def set_user_facl(self, paths, user, mode):",
            "        raise NotImplementedError('set_user_facl is not implemented for Powershell')",
            "",
            "    def remove(self, path, recurse=False):",
            "        path = self._escape(self._unquote(path))",
            "        if recurse:",
            "            return self._encode_script('''Remove-Item \"%s\" -Force -Recurse;''' % path)",
            "        else:",
            "            return self._encode_script('''Remove-Item \"%s\" -Force;''' % path)",
            "",
            "    def mkdtemp(self, basefile=None, system=False, mode=None, tmpdir=None):",
            "        # Windows does not have an equivalent for the system temp files, so",
            "        # the param is ignored",
            "        basefile = self._escape(self._unquote(basefile))",
            "        basetmpdir = tmpdir if tmpdir else self.get_option('remote_tmp')",
            "",
            "        script = '''",
            "        $tmp_path = [System.Environment]::ExpandEnvironmentVariables('%s')",
            "        $tmp = New-Item -Type Directory -Path $tmp_path -Name '%s'",
            "        Write-Output -InputObject $tmp.FullName",
            "        ''' % (basetmpdir, basefile)",
            "        return self._encode_script(script.strip())",
            "",
            "    def expand_user(self, user_home_path, username=''):",
            "        # PowerShell only supports \"~\" (not \"~username\").  Resolve-Path ~ does",
            "        # not seem to work remotely, though by default we are always starting",
            "        # in the user's home directory.",
            "        user_home_path = self._unquote(user_home_path)",
            "        if user_home_path == '~':",
            "            script = 'Write-Output (Get-Location).Path'",
            "        elif user_home_path.startswith('~\\\\'):",
            "            script = 'Write-Output ((Get-Location).Path + \"%s\")' % self._escape(user_home_path[1:])",
            "        else:",
            "            script = 'Write-Output \"%s\"' % self._escape(user_home_path)",
            "        return self._encode_script(script)",
            "",
            "    def exists(self, path):",
            "        path = self._escape(self._unquote(path))",
            "        script = '''",
            "            If (Test-Path \"%s\")",
            "            {",
            "                $res = 0;",
            "            }",
            "            Else",
            "            {",
            "                $res = 1;",
            "            }",
            "            Write-Output \"$res\";",
            "            Exit $res;",
            "         ''' % path",
            "        return self._encode_script(script)",
            "",
            "    def checksum(self, path, *args, **kwargs):",
            "        path = self._escape(self._unquote(path))",
            "        script = '''",
            "            If (Test-Path -PathType Leaf \"%(path)s\")",
            "            {",
            "                $sp = new-object -TypeName System.Security.Cryptography.SHA1CryptoServiceProvider;",
            "                $fp = [System.IO.File]::Open(\"%(path)s\", [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read);",
            "                [System.BitConverter]::ToString($sp.ComputeHash($fp)).Replace(\"-\", \"\").ToLower();",
            "                $fp.Dispose();",
            "            }",
            "            ElseIf (Test-Path -PathType Container \"%(path)s\")",
            "            {",
            "                Write-Output \"3\";",
            "            }",
            "            Else",
            "            {",
            "                Write-Output \"1\";",
            "            }",
            "        ''' % dict(path=path)",
            "        return self._encode_script(script)",
            "",
            "    def build_module_command(self, env_string, shebang, cmd, arg_path=None):",
            "        bootstrap_wrapper = pkgutil.get_data(\"ansible.executor.powershell\", \"bootstrap_wrapper.ps1\")",
            "",
            "        # pipelining bypass",
            "        if cmd == '':",
            "            return self._encode_script(script=bootstrap_wrapper, strict_mode=False, preserve_rc=False)",
            "",
            "        # non-pipelining",
            "",
            "        cmd_parts = shlex.split(cmd, posix=False)",
            "        cmd_parts = list(map(to_text, cmd_parts))",
            "        if shebang and shebang.lower() == '#!powershell':",
            "            if not self._unquote(cmd_parts[0]).lower().endswith('.ps1'):",
            "                # we're running a module via the bootstrap wrapper",
            "                cmd_parts[0] = '\"%s.ps1\"' % self._unquote(cmd_parts[0])",
            "            wrapper_cmd = \"type \" + cmd_parts[0] + \" | \" + self._encode_script(script=bootstrap_wrapper,",
            "                                                                               strict_mode=False, preserve_rc=False)",
            "            return wrapper_cmd",
            "        elif shebang and shebang.startswith('#!'):",
            "            cmd_parts.insert(0, shebang[2:])",
            "        elif not shebang:",
            "            # The module is assumed to be a binary",
            "            cmd_parts[0] = self._unquote(cmd_parts[0])",
            "            cmd_parts.append(arg_path)",
            "        script = '''",
            "            Try",
            "            {",
            "                %s",
            "                %s",
            "            }",
            "            Catch",
            "            {",
            "                $_obj = @{ failed = $true }",
            "                If ($_.Exception.GetType)",
            "                {",
            "                    $_obj.Add('msg', $_.Exception.Message)",
            "                }",
            "                Else",
            "                {",
            "                    $_obj.Add('msg', $_.ToString())",
            "                }",
            "                If ($_.InvocationInfo.PositionMessage)",
            "                {",
            "                    $_obj.Add('exception', $_.InvocationInfo.PositionMessage)",
            "                }",
            "                ElseIf ($_.ScriptStackTrace)",
            "                {",
            "                    $_obj.Add('exception', $_.ScriptStackTrace)",
            "                }",
            "                Try",
            "                {",
            "                    $_obj.Add('error_record', ($_ | ConvertTo-Json | ConvertFrom-Json))",
            "                }",
            "                Catch",
            "                {",
            "                }",
            "                Echo $_obj | ConvertTo-Json -Compress -Depth 99",
            "                Exit 1",
            "            }",
            "        ''' % (env_string, ' '.join(cmd_parts))",
            "        return self._encode_script(script, preserve_rc=False)",
            "",
            "    def wrap_for_exec(self, cmd):",
            "        return '& %s; exit $LASTEXITCODE' % cmd",
            "",
            "    def _unquote(self, value):",
            "        '''Remove any matching quotes that wrap the given value.'''",
            "        value = to_text(value or '')",
            "        m = re.match(r'^\\s*?\\'(.*?)\\'\\s*?$', value)",
            "        if m:",
            "            return m.group(1)",
            "        m = re.match(r'^\\s*?\"(.*?)\"\\s*?$', value)",
            "        if m:",
            "            return m.group(1)",
            "        return value",
            "",
            "    def _escape(self, value, include_vars=False):",
            "        '''Return value escaped for use in PowerShell command.'''",
            "        # http://www.techotopia.com/index.php/Windows_PowerShell_1.0_String_Quoting_and_Escape_Sequences",
            "        # http://stackoverflow.com/questions/764360/a-list-of-string-replacements-in-python",
            "        subs = [('\\n', '`n'), ('\\r', '`r'), ('\\t', '`t'), ('\\a', '`a'),",
            "                ('\\b', '`b'), ('\\f', '`f'), ('\\v', '`v'), ('\"', '`\"'),",
            "                ('\\'', '`\\''), ('`', '``'), ('\\x00', '`0')]",
            "        if include_vars:",
            "            subs.append(('$', '`$'))",
            "        pattern = '|'.join('(%s)' % re.escape(p) for p, s in subs)",
            "        substs = [s for p, s in subs]",
            "",
            "        def replace(m):",
            "            return substs[m.lastindex - 1]",
            "",
            "        return re.sub(pattern, replace, value)",
            "",
            "    def _encode_script(self, script, as_list=False, strict_mode=True, preserve_rc=True):",
            "        '''Convert a PowerShell script to a single base64-encoded command.'''",
            "        script = to_text(script)",
            "",
            "        if script == u'-':",
            "            cmd_parts = _common_args + ['-']",
            "",
            "        else:",
            "            if strict_mode:",
            "                script = u'Set-StrictMode -Version Latest\\r\\n%s' % script",
            "            # try to propagate exit code if present- won't work with begin/process/end-style scripts (ala put_file)",
            "            # NB: the exit code returned may be incorrect in the case of a successful command followed by an invalid command",
            "            if preserve_rc:",
            "                script = u'%s\\r\\nIf (-not $?) { If (Get-Variable LASTEXITCODE -ErrorAction SilentlyContinue) { exit $LASTEXITCODE } Else { exit 1 } }\\r\\n'\\",
            "                    % script",
            "            script = '\\n'.join([x.strip() for x in script.splitlines() if x.strip()])",
            "            encoded_script = to_text(base64.b64encode(script.encode('utf-16-le')), 'utf-8')",
            "            cmd_parts = _common_args + ['-EncodedCommand', encoded_script]",
            "",
            "        if as_list:",
            "            return cmd_parts",
            "        return ' '.join(cmd_parts)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2014, Chris Church <chris@ninemoreminutes.com>",
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = '''",
            "    name: powershell",
            "    plugin_type: shell",
            "    version_added: \"\"",
            "    short_description: Windows Powershell",
            "    description:",
            "      - The only option when using 'winrm' as a connection plugin",
            "    options:",
            "      remote_tmp:",
            "        description:",
            "        - Temporary directory to use on targets when copying files to the host.",
            "        default: '%TEMP%'",
            "        ini:",
            "        - section: powershell",
            "          key: remote_tmp",
            "        vars:",
            "        - name: ansible_remote_tmp",
            "      set_module_language:",
            "        description:",
            "        - Controls if we set the locale for moduels when executing on the",
            "          target.",
            "        - Windows only supports C(no) as an option.",
            "        type: bool",
            "        default: 'no'",
            "        choices:",
            "        - 'no'",
            "      environment:",
            "        description:",
            "        - Dictionary of environment variables and their values to use when",
            "          executing commands.",
            "        type: dict",
            "        default: {}",
            "'''",
            "# FIXME: admin_users and set_module_language don't belong here but must be set",
            "# so they don't failk when someone get_option('admin_users') on this plugin",
            "",
            "import base64",
            "import os",
            "import re",
            "import shlex",
            "import pkgutil",
            "",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_text",
            "from ansible.plugins.shell import ShellBase",
            "",
            "",
            "_common_args = ['PowerShell', '-NoProfile', '-NonInteractive', '-ExecutionPolicy', 'Unrestricted']",
            "",
            "# Primarily for testing, allow explicitly specifying PowerShell version via",
            "# an environment variable.",
            "_powershell_version = os.environ.get('POWERSHELL_VERSION', None)",
            "if _powershell_version:",
            "    _common_args = ['PowerShell', '-Version', _powershell_version] + _common_args[1:]",
            "",
            "exec_wrapper = br'''",
            "begin {",
            "    $DebugPreference = \"Continue\"",
            "    $ErrorActionPreference = \"Stop\"",
            "    Set-StrictMode -Version 2",
            "",
            "    function ConvertTo-HashtableFromPsCustomObject ($myPsObject){",
            "        $output = @{};",
            "        $myPsObject | Get-Member -MemberType *Property | % {",
            "            $val = $myPsObject.($_.name);",
            "            If ($val -is [psobject]) {",
            "                $val = ConvertTo-HashtableFromPsCustomObject $val",
            "            }",
            "            $output.($_.name) = $val",
            "        }",
            "        return $output;",
            "    }",
            "    # stream JSON including become_pw, ps_module_payload, bin_module_payload, become_payload, write_payload_path, preserve directives",
            "    # exec runspace, capture output, cleanup, return module output",
            "",
            "    # only init and stream in $json_raw if it wasn't set by the enclosing scope",
            "    if (-not $(Get-Variable \"json_raw\" -ErrorAction SilentlyContinue)) {",
            "        $json_raw = ''",
            "    }",
            "}",
            "process {",
            "    $input_as_string = [string]$input",
            "",
            "    $json_raw += $input_as_string",
            "}",
            "end {",
            "    If (-not $json_raw) {",
            "        Write-Error \"no input given\" -Category InvalidArgument",
            "    }",
            "    $payload = ConvertTo-HashtableFromPsCustomObject (ConvertFrom-Json $json_raw)",
            "",
            "    # TODO: handle binary modules",
            "    # TODO: handle persistence",
            "",
            "    $min_os_version = [version]$payload.min_os_version",
            "    if ($min_os_version -ne $null) {",
            "        $actual_os_version = [System.Environment]::OSVersion.Version",
            "        if ($actual_os_version -lt $min_os_version) {",
            "            $msg = \"This module cannot run on this OS as it requires a minimum version of $min_os_version, actual was $actual_os_version\"",
            "            Write-Output (ConvertTo-Json @{failed=$true;msg=$msg})",
            "            exit 1",
            "        }",
            "    }",
            "",
            "    $min_ps_version = [version]$payload.min_ps_version",
            "    if ($min_ps_version -ne $null) {",
            "        $actual_ps_version = $PSVersionTable.PSVersion",
            "        if ($actual_ps_version -lt $min_ps_version) {",
            "            $msg = \"This module cannot run as it requires a minimum PowerShell version of $min_ps_version, actual was $actual_ps_version\"",
            "            Write-Output (ConvertTo-Json @{failed=$true;msg=$msg})",
            "            exit 1",
            "        }",
            "    }",
            "",
            "    $actions = $payload.actions",
            "",
            "    # pop 0th action as entrypoint",
            "    $entrypoint = $payload.($actions[0])",
            "    $payload.actions = $payload.actions[1..99]",
            "",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    # load the current action entrypoint as a module custom object with a Run method",
            "    $entrypoint = New-Module -ScriptBlock ([scriptblock]::Create($entrypoint)) -AsCustomObject",
            "",
            "    Set-Variable -Scope global -Name complex_args -Value $payload[\"module_args\"] | Out-Null",
            "",
            "    # dynamically create/load modules",
            "    ForEach ($mod in $payload.powershell_modules.GetEnumerator()) {",
            "        $decoded_module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($mod.Value))",
            "        New-Module -ScriptBlock ([scriptblock]::Create($decoded_module)) -Name $mod.Key | Import-Module -WarningAction SilentlyContinue | Out-Null",
            "    }",
            "",
            "    $output = $entrypoint.Run($payload)",
            "",
            "    Write-Output $output",
            "}",
            "",
            "'''  # end exec_wrapper",
            "",
            "leaf_exec = br'''",
            "Function Run($payload) {",
            "    $entrypoint = $payload.module_entry",
            "",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    $ps = [powershell]::Create()",
            "",
            "    $ps.AddStatement().AddCommand(\"Set-Variable\").AddParameters(@{Scope=\"global\";Name=\"complex_args\";Value=$payload.module_args}) | Out-Null",
            "    $ps.AddCommand(\"Out-Null\") | Out-Null",
            "",
            "    # redefine Write-Host to dump to output instead of failing- lots of scripts use it",
            "    $ps.AddStatement().AddScript(\"Function Write-Host(`$msg){ Write-Output `$msg }\") | Out-Null",
            "",
            "    ForEach ($env_kv in $payload.environment.GetEnumerator()) {",
            "        # need to escape ' in both the key and value",
            "        $env_key = $env_kv.Key.ToString().Replace(\"'\", \"''\")",
            "        $env_value = $env_kv.Value.ToString().Replace(\"'\", \"''\")",
            "        $escaped_env_set = \"[System.Environment]::SetEnvironmentVariable('{0}', '{1}')\" -f $env_key, $env_value",
            "        $ps.AddStatement().AddScript($escaped_env_set) | Out-Null",
            "    }",
            "",
            "    # dynamically create/load modules",
            "    ForEach ($mod in $payload.powershell_modules.GetEnumerator()) {",
            "        $decoded_module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($mod.Value))",
            "        $ps.AddStatement().AddCommand(\"New-Module\").AddParameters(@{ScriptBlock=([scriptblock]::Create($decoded_module));Name=$mod.Key}) | Out-Null",
            "        $ps.AddCommand(\"Import-Module\").AddParameters(@{WarningAction=\"SilentlyContinue\"}) | Out-Null",
            "        $ps.AddCommand(\"Out-Null\") | Out-Null",
            "    }",
            "",
            "    # force input encoding to preamble-free UTF8 so PS sub-processes (eg,",
            "    # Start-Job) don't blow up. This is only required for WinRM, a PSRP",
            "    # runspace doesn't have a host console and this will bomb out",
            "    if ($host.Name -eq \"ConsoleHost\") {",
            "        $ps.AddStatement().AddScript(\"[Console]::InputEncoding = New-Object Text.UTF8Encoding `$false\") | Out-Null",
            "    }",
            "",
            "    $ps.AddStatement().AddScript($entrypoint) | Out-Null",
            "",
            "    $output = $ps.Invoke()",
            "",
            "    $output",
            "",
            "    # PS3 doesn't properly set HadErrors in many cases, inspect the error stream as a fallback",
            "    If ($ps.HadErrors -or ($PSVersionTable.PSVersion.Major -lt 4 -and $ps.Streams.Error.Count -gt 0)) {",
            "        $host.UI.WriteErrorLine($($ps.Streams.Error | Out-String))",
            "        $exit_code = $ps.Runspace.SessionStateProxy.GetVariable(\"LASTEXITCODE\")",
            "        If(-not $exit_code) {",
            "            $exit_code = 1",
            "        }",
            "        # need to use this instead of Exit keyword to prevent runspace from crashing with dynamic modules",
            "        $host.SetShouldExit($exit_code)",
            "    }",
            "}",
            "'''  # end leaf_exec",
            "",
            "become_wrapper = br'''",
            "Set-StrictMode -Version 2",
            "$ErrorActionPreference = \"Stop\"",
            "",
            "$helper_def = @\"",
            "using Microsoft.Win32.SafeHandles;",
            "using System;",
            "using System.Collections.Generic;",
            "using System.Diagnostics;",
            "using System.IO;",
            "using System.Linq;",
            "using System.Runtime.ConstrainedExecution;",
            "using System.Runtime.InteropServices;",
            "using System.Security.AccessControl;",
            "using System.Security.Principal;",
            "using System.Text;",
            "using System.Threading;",
            "",
            "namespace AnsibleBecome",
            "{",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public class SECURITY_ATTRIBUTES",
            "    {",
            "        public int nLength;",
            "        public IntPtr lpSecurityDescriptor;",
            "        public bool bInheritHandle = false;",
            "        public SECURITY_ATTRIBUTES()",
            "        {",
            "            nLength = Marshal.SizeOf(this);",
            "        }",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public class STARTUPINFO",
            "    {",
            "        public Int32 cb;",
            "        public IntPtr lpReserved;",
            "        public IntPtr lpDesktop;",
            "        public IntPtr lpTitle;",
            "        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 28)]",
            "        public byte[] _data1;",
            "        public Int32 dwFlags;",
            "        public Int16 wShowWindow;",
            "        public Int16 cbReserved2;",
            "        public IntPtr lpReserved2;",
            "        public SafeFileHandle hStdInput;",
            "        public SafeFileHandle hStdOutput;",
            "        public SafeFileHandle hStdError;",
            "        public STARTUPINFO()",
            "        {",
            "            cb = Marshal.SizeOf(this);",
            "        }",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public class STARTUPINFOEX",
            "    {",
            "        public STARTUPINFO startupInfo;",
            "        public IntPtr lpAttributeList;",
            "        public STARTUPINFOEX()",
            "        {",
            "            startupInfo = new STARTUPINFO();",
            "            startupInfo.cb = Marshal.SizeOf(this);",
            "        }",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct LUID",
            "    {",
            "        public UInt32 LowPart;",
            "        public Int32 HighPart;",
            "",
            "        public static explicit operator UInt64(LUID l)",
            "        {",
            "            return (UInt64)((UInt64)l.HighPart << 32) | (UInt64)l.LowPart;",
            "        }",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct LUID_AND_ATTRIBUTES",
            "    {",
            "        public LUID Luid;",
            "        public UInt32 Attributes;",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct PROCESS_INFORMATION",
            "    {",
            "        public IntPtr hProcess;",
            "        public IntPtr hThread;",
            "        public int dwProcessId;",
            "        public int dwThreadId;",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct SID_AND_ATTRIBUTES",
            "    {",
            "        public IntPtr Sid;",
            "        public int Attributes;",
            "    }",
            "",
            "    [StructLayout(LayoutKind.Sequential)]",
            "    public struct TOKEN_PRIVILEGES",
            "    {",
            "        public UInt32 PrivilegeCount;",
            "        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]",
            "        public LUID_AND_ATTRIBUTES[] Privileges;",
            "    }",
            "",
            "    public struct TOKEN_USER",
            "    {",
            "        public SID_AND_ATTRIBUTES User;",
            "    }",
            "",
            "    [Flags]",
            "    public enum StartupInfoFlags : uint",
            "    {",
            "        USESTDHANDLES = 0x00000100",
            "    }",
            "",
            "    [Flags]",
            "    public enum CreationFlags : uint",
            "    {",
            "        CREATE_BREAKAWAY_FROM_JOB = 0x01000000,",
            "        CREATE_DEFAULT_ERROR_MODE = 0x04000000,",
            "        CREATE_NEW_CONSOLE = 0x00000010,",
            "        CREATE_SUSPENDED = 0x00000004,",
            "        CREATE_UNICODE_ENVIRONMENT = 0x00000400,",
            "        EXTENDED_STARTUPINFO_PRESENT = 0x00080000",
            "    }",
            "",
            "    public enum HandleFlags : uint",
            "    {",
            "        None = 0,",
            "        INHERIT = 1",
            "    }",
            "",
            "    [Flags]",
            "    public enum LogonFlags",
            "    {",
            "        LOGON_WITH_PROFILE = 0x00000001,",
            "        LOGON_NETCREDENTIALS_ONLY = 0x00000002",
            "    }",
            "",
            "    public enum LogonType",
            "    {",
            "        LOGON32_LOGON_INTERACTIVE = 2,",
            "        LOGON32_LOGON_NETWORK = 3,",
            "        LOGON32_LOGON_BATCH = 4,",
            "        LOGON32_LOGON_SERVICE = 5,",
            "        LOGON32_LOGON_UNLOCK = 7,",
            "        LOGON32_LOGON_NETWORK_CLEARTEXT = 8,",
            "        LOGON32_LOGON_NEW_CREDENTIALS = 9",
            "    }",
            "",
            "    public enum LogonProvider",
            "    {",
            "        LOGON32_PROVIDER_DEFAULT = 0,",
            "    }",
            "",
            "    public enum TokenInformationClass",
            "    {",
            "        TokenUser = 1,",
            "        TokenPrivileges = 3,",
            "        TokenType = 8,",
            "        TokenImpersonationLevel = 9,",
            "        TokenElevationType = 18,",
            "        TokenLinkedToken = 19,",
            "    }",
            "",
            "    public enum TokenElevationType",
            "    {",
            "        TokenElevationTypeDefault = 1,",
            "        TokenElevationTypeFull,",
            "        TokenElevationTypeLimited",
            "    }",
            "",
            "    [Flags]",
            "    public enum ProcessAccessFlags : uint",
            "    {",
            "        PROCESS_QUERY_INFORMATION = 0x00000400,",
            "    }",
            "",
            "    public enum SECURITY_IMPERSONATION_LEVEL",
            "    {",
            "        SecurityImpersonation,",
            "    }",
            "",
            "    public enum TOKEN_TYPE",
            "    {",
            "        TokenPrimary = 1,",
            "        TokenImpersonation",
            "    }",
            "",
            "    class NativeWaitHandle : WaitHandle",
            "    {",
            "        public NativeWaitHandle(IntPtr handle)",
            "        {",
            "            this.SafeWaitHandle = new SafeWaitHandle(handle, false);",
            "        }",
            "    }",
            "",
            "    class SafeMemoryBuffer : SafeHandleZeroOrMinusOneIsInvalid",
            "    {",
            "        public SafeMemoryBuffer() : base(true) { }",
            "        public SafeMemoryBuffer(int cb) : base(true)",
            "        {",
            "            base.SetHandle(Marshal.AllocHGlobal(cb));",
            "        }",
            "        public SafeMemoryBuffer(IntPtr handle) : base(true)",
            "        {",
            "            base.SetHandle(handle);",
            "        }",
            "",
            "        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]",
            "        protected override bool ReleaseHandle()",
            "        {",
            "            Marshal.FreeHGlobal(handle);",
            "            return true;",
            "        }",
            "    }",
            "",
            "    public class Win32Exception : System.ComponentModel.Win32Exception",
            "    {",
            "        private string _msg;",
            "        public Win32Exception(string message) : this(Marshal.GetLastWin32Error(), message) { }",
            "        public Win32Exception(int errorCode, string message) : base(errorCode)",
            "        {",
            "            _msg = String.Format(\"{0} ({1}, Win32ErrorCode {2})\", message, base.Message, errorCode);",
            "        }",
            "        public override string Message { get { return _msg; } }",
            "        public static explicit operator Win32Exception(string message) { return new Win32Exception(message); }",
            "    }",
            "",
            "    public class CommandResult",
            "    {",
            "        public string StandardOut { get; internal set; }",
            "        public string StandardError { get; internal set; }",
            "        public uint ExitCode { get; internal set; }",
            "    }",
            "",
            "    public class BecomeUtil",
            "    {",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool LogonUser(",
            "            string lpszUsername,",
            "            string lpszDomain,",
            "            string lpszPassword,",
            "            LogonType dwLogonType,",
            "            LogonProvider dwLogonProvider,",
            "            out IntPtr phToken);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]",
            "        private static extern bool CreateProcessWithTokenW(",
            "            IntPtr hToken,",
            "            LogonFlags dwLogonFlags,",
            "            [MarshalAs(UnmanagedType.LPTStr)]",
            "            string lpApplicationName,",
            "            StringBuilder lpCommandLine,",
            "            CreationFlags dwCreationFlags,",
            "            IntPtr lpEnvironment,",
            "            [MarshalAs(UnmanagedType.LPTStr)]",
            "            string lpCurrentDirectory,",
            "            STARTUPINFOEX lpStartupInfo,",
            "            out PROCESS_INFORMATION lpProcessInformation);",
            "",
            "        [DllImport(\"kernel32.dll\")]",
            "        private static extern bool CreatePipe(",
            "            out SafeFileHandle hReadPipe,",
            "            out SafeFileHandle hWritePipe,",
            "            SECURITY_ATTRIBUTES lpPipeAttributes,",
            "            uint nSize);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern bool SetHandleInformation(",
            "            SafeFileHandle hObject,",
            "            HandleFlags dwMask,",
            "            int dwFlags);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern bool GetExitCodeProcess(",
            "            IntPtr hProcess,",
            "            out uint lpExitCode);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern bool CloseHandle(",
            "            IntPtr hObject);",
            "",
            "        [DllImport(\"user32.dll\", SetLastError = true)]",
            "        private static extern IntPtr GetProcessWindowStation();",
            "",
            "        [DllImport(\"user32.dll\", SetLastError = true)]",
            "        private static extern IntPtr GetThreadDesktop(",
            "            int dwThreadId);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern int GetCurrentThreadId();",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool GetTokenInformation(",
            "            IntPtr TokenHandle,",
            "            TokenInformationClass TokenInformationClass,",
            "            SafeMemoryBuffer TokenInformation,",
            "            uint TokenInformationLength,",
            "            out uint ReturnLength);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]",
            "        public static extern bool LookupPrivilegeNameW(",
            "            string lpSystemName,",
            "            ref LUID lpLuid,",
            "            StringBuilder lpName,",
            "            ref UInt32 cchName);",
            "",
            "        [DllImport(\"kernel32.dll\", SetLastError = true)]",
            "        private static extern IntPtr OpenProcess(",
            "            ProcessAccessFlags processAccess,",
            "            bool bInheritHandle,",
            "            UInt32 processId);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool OpenProcessToken(",
            "            IntPtr ProcessHandle,",
            "            TokenAccessLevels DesiredAccess,",
            "            out IntPtr TokenHandle);",
            "",
            "        [DllImport(\"advapi32\", SetLastError = true)]",
            "        private static extern bool DuplicateTokenEx(",
            "            IntPtr hExistingToken,",
            "            TokenAccessLevels dwDesiredAccess,",
            "            IntPtr lpTokenAttributes,",
            "            SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,",
            "            TOKEN_TYPE TokenType,",
            "            out IntPtr phNewToken);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool ImpersonateLoggedOnUser(",
            "            IntPtr hToken);",
            "",
            "        [DllImport(\"advapi32.dll\", SetLastError = true)]",
            "        private static extern bool RevertToSelf();",
            "",
            "        public static CommandResult RunAsUser(string username, string password, string lpCommandLine,",
            "            string lpCurrentDirectory, string stdinInput, LogonFlags logonFlags, LogonType logonType)",
            "        {",
            "            SecurityIdentifier account = null;",
            "            if (logonType != LogonType.LOGON32_LOGON_NEW_CREDENTIALS)",
            "            {",
            "                account = GetBecomeSid(username);",
            "            }",
            "",
            "            STARTUPINFOEX si = new STARTUPINFOEX();",
            "            si.startupInfo.dwFlags = (int)StartupInfoFlags.USESTDHANDLES;",
            "",
            "            SECURITY_ATTRIBUTES pipesec = new SECURITY_ATTRIBUTES();",
            "            pipesec.bInheritHandle = true;",
            "",
            "            // Create the stdout, stderr and stdin pipes used in the process and add to the startupInfo",
            "            SafeFileHandle stdout_read, stdout_write, stderr_read, stderr_write, stdin_read, stdin_write;",
            "            if (!CreatePipe(out stdout_read, out stdout_write, pipesec, 0))",
            "                throw new Win32Exception(\"STDOUT pipe setup failed\");",
            "            if (!SetHandleInformation(stdout_read, HandleFlags.INHERIT, 0))",
            "                throw new Win32Exception(\"STDOUT pipe handle setup failed\");",
            "",
            "            if (!CreatePipe(out stderr_read, out stderr_write, pipesec, 0))",
            "                throw new Win32Exception(\"STDERR pipe setup failed\");",
            "            if (!SetHandleInformation(stderr_read, HandleFlags.INHERIT, 0))",
            "                throw new Win32Exception(\"STDERR pipe handle setup failed\");",
            "",
            "            if (!CreatePipe(out stdin_read, out stdin_write, pipesec, 0))",
            "                throw new Win32Exception(\"STDIN pipe setup failed\");",
            "            if (!SetHandleInformation(stdin_write, HandleFlags.INHERIT, 0))",
            "                throw new Win32Exception(\"STDIN pipe handle setup failed\");",
            "",
            "            si.startupInfo.hStdOutput = stdout_write;",
            "            si.startupInfo.hStdError = stderr_write;",
            "            si.startupInfo.hStdInput = stdin_read;",
            "",
            "            // Setup the stdin buffer",
            "            UTF8Encoding utf8_encoding = new UTF8Encoding(false);",
            "            FileStream stdin_fs = new FileStream(stdin_write, FileAccess.Write, 32768);",
            "            StreamWriter stdin = new StreamWriter(stdin_fs, utf8_encoding, 32768);",
            "",
            "            // Create the environment block if set",
            "            IntPtr lpEnvironment = IntPtr.Zero;",
            "",
            "            CreationFlags startup_flags = CreationFlags.CREATE_UNICODE_ENVIRONMENT;",
            "",
            "            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();",
            "",
            "            // Get the user tokens to try running processes with",
            "            List<IntPtr> tokens = GetUserTokens(account, username, password, logonType);",
            "",
            "            bool launch_success = false;",
            "            foreach (IntPtr token in tokens)",
            "            {",
            "                if (CreateProcessWithTokenW(",
            "                    token,",
            "                    logonFlags,",
            "                    null,",
            "                    new StringBuilder(lpCommandLine),",
            "                    startup_flags,",
            "                    lpEnvironment,",
            "                    lpCurrentDirectory,",
            "                    si,",
            "                    out pi))",
            "                {",
            "                    launch_success = true;",
            "                    break;",
            "                }",
            "            }",
            "",
            "            if (!launch_success)",
            "                throw new Win32Exception(\"Failed to start become process\");",
            "",
            "            CommandResult result = new CommandResult();",
            "            // Setup the output buffers and get stdout/stderr",
            "            FileStream stdout_fs = new FileStream(stdout_read, FileAccess.Read, 4096);",
            "            StreamReader stdout = new StreamReader(stdout_fs, utf8_encoding, true, 4096);",
            "            stdout_write.Close();",
            "",
            "            FileStream stderr_fs = new FileStream(stderr_read, FileAccess.Read, 4096);",
            "            StreamReader stderr = new StreamReader(stderr_fs, utf8_encoding, true, 4096);",
            "            stderr_write.Close();",
            "",
            "            stdin.WriteLine(stdinInput);",
            "            stdin.Close();",
            "",
            "            string stdout_str, stderr_str = null;",
            "            GetProcessOutput(stdout, stderr, out stdout_str, out stderr_str);",
            "            UInt32 rc = GetProcessExitCode(pi.hProcess);",
            "",
            "            result.StandardOut = stdout_str;",
            "            result.StandardError = stderr_str;",
            "            result.ExitCode = rc;",
            "",
            "            return result;",
            "        }",
            "",
            "        private static SecurityIdentifier GetBecomeSid(string username)",
            "        {",
            "            NTAccount account = new NTAccount(username);",
            "            try",
            "            {",
            "                SecurityIdentifier security_identifier = (SecurityIdentifier)account.Translate(typeof(SecurityIdentifier));",
            "                return security_identifier;",
            "            }",
            "            catch (IdentityNotMappedException ex)",
            "            {",
            "                throw new Exception(String.Format(\"Unable to find become user {0}: {1}\", username, ex.Message));",
            "            }",
            "        }",
            "",
            "        private static List<IntPtr> GetUserTokens(SecurityIdentifier account, string username, string password, LogonType logonType)",
            "        {",
            "            List<IntPtr> tokens = new List<IntPtr>();",
            "            List<String> service_sids = new List<String>()",
            "            {",
            "                \"S-1-5-18\", // NT AUTHORITY\\SYSTEM",
            "                \"S-1-5-19\", // NT AUTHORITY\\LocalService",
            "                \"S-1-5-20\"  // NT AUTHORITY\\NetworkService",
            "            };",
            "",
            "            IntPtr hSystemToken = IntPtr.Zero;",
            "            string account_sid = \"\";",
            "            if (logonType != LogonType.LOGON32_LOGON_NEW_CREDENTIALS)",
            "            {",
            "                GrantAccessToWindowStationAndDesktop(account);",
            "                // Try to get SYSTEM token handle so we can impersonate to get full admin token",
            "                hSystemToken = GetSystemUserHandle();",
            "                account_sid = account.ToString();",
            "            }",
            "            bool impersonated = false;",
            "",
            "            try",
            "            {",
            "                if (hSystemToken == IntPtr.Zero && service_sids.Contains(account_sid))",
            "                {",
            "                    // We need the SYSTEM token if we want to become one of those accounts, fail here",
            "                    throw new Win32Exception(\"Failed to get token for NT AUTHORITY\\\\SYSTEM\");",
            "                }",
            "                else if (hSystemToken != IntPtr.Zero)",
            "                {",
            "                    // If SYSTEM impersonation failed but we're trying to become a regular user, just proceed;",
            "                    // might get a limited token in UAC-enabled cases, but better than nothing...",
            "                    if (ImpersonateLoggedOnUser(hSystemToken))",
            "                        impersonated = true;",
            "                    else if (service_sids.Contains(account_sid))",
            "                        throw new Win32Exception(\"Failed to impersonate as SYSTEM account\");",
            "",
            "                }",
            "",
            "                string domain = null;",
            "",
            "                if (service_sids.Contains(account_sid))",
            "                {",
            "                    // We're using a well-known service account, do a service logon instead of the actual flag set",
            "                    logonType = LogonType.LOGON32_LOGON_SERVICE;",
            "                    domain = \"NT AUTHORITY\";",
            "                    password = null;",
            "                    switch (account_sid)",
            "                    {",
            "                        case \"S-1-5-18\":",
            "                            tokens.Add(hSystemToken);",
            "                            return tokens;",
            "                        case \"S-1-5-19\":",
            "                            username = \"LocalService\";",
            "                            break;",
            "                        case \"S-1-5-20\":",
            "                            username = \"NetworkService\";",
            "                            break;",
            "                    }",
            "                }",
            "                else",
            "                {",
            "                    // We are trying to become a local or domain account",
            "                    if (username.Contains(@\"\\\"))",
            "                    {",
            "                        var user_split = username.Split(Convert.ToChar(@\"\\\"));",
            "                        domain = user_split[0];",
            "                        username = user_split[1];",
            "                    }",
            "                    else if (username.Contains(\"@\"))",
            "                        domain = null;",
            "                    else",
            "                        domain = \".\";",
            "                }",
            "",
            "                IntPtr hToken = IntPtr.Zero;",
            "                if (!LogonUser(",
            "                    username,",
            "                    domain,",
            "                    password,",
            "                    logonType,",
            "                    LogonProvider.LOGON32_PROVIDER_DEFAULT,",
            "                    out hToken))",
            "                {",
            "                    throw new Win32Exception(\"LogonUser failed\");",
            "                }",
            "",
            "                if (!service_sids.Contains(account_sid))",
            "                {",
            "                    // Try and get the elevated token for local/domain account",
            "                    IntPtr hTokenElevated = GetElevatedToken(hToken);",
            "                    tokens.Add(hTokenElevated);",
            "                }",
            "",
            "                // add the original token as a fallback",
            "                tokens.Add(hToken);",
            "            }",
            "            finally",
            "            {",
            "                if (impersonated)",
            "                    RevertToSelf();",
            "            }",
            "",
            "            return tokens;",
            "        }",
            "",
            "        private static IntPtr GetSystemUserHandle()",
            "        {",
            "            // According to CreateProcessWithTokenW we require a token with",
            "            //  TOKEN_QUERY, TOKEN_DUPLICATE and TOKEN_ASSIGN_PRIMARY",
            "            // Also add in TOKEN_IMPERSONATE so we can get an impersontated token",
            "            TokenAccessLevels desired_access = TokenAccessLevels.Query |",
            "                TokenAccessLevels.Duplicate |",
            "                TokenAccessLevels.AssignPrimary |",
            "                TokenAccessLevels.Impersonate;",
            "",
            "            foreach (System.Diagnostics.Process process in System.Diagnostics.Process.GetProcesses())",
            "            {",
            "                using (process)",
            "                {",
            "                    IntPtr hProcess = OpenProcess(ProcessAccessFlags.PROCESS_QUERY_INFORMATION, false, (UInt32)process.Id);",
            "                    if (hProcess == IntPtr.Zero)",
            "                        continue;",
            "",
            "                    try",
            "                    {",
            "                        IntPtr hToken = IntPtr.Zero;",
            "                        if (!OpenProcessToken(hProcess, desired_access, out hToken))",
            "                            continue;",
            "",
            "                        try",
            "                        {",
            "                            string sid = GetTokenUserSID(hToken);",
            "                            if (sid != \"S-1-5-18\")",
            "                                continue;",
            "",
            "                            // Make sure the SYSTEM token we are checking contains the SeTcbPrivilege required for",
            "                            // escalation. Some SYSTEM tokens have this privilege stripped out.",
            "                            List<string> actualPrivileges = GetTokenPrivileges(hToken);",
            "                            if (!actualPrivileges.Contains(\"SeTcbPrivilege\"))",
            "                                continue;",
            "",
            "                            IntPtr dupToken = IntPtr.Zero;",
            "                            if (!DuplicateTokenEx(hToken, TokenAccessLevels.MaximumAllowed, IntPtr.Zero,",
            "                                SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation, TOKEN_TYPE.TokenPrimary,",
            "                                out dupToken))",
            "                            {",
            "                                continue;",
            "                            }",
            "                            return dupToken;",
            "                        }",
            "                        finally",
            "                        {",
            "                            CloseHandle(hToken);",
            "                        }",
            "                    }",
            "                    finally",
            "                    {",
            "                        CloseHandle(hProcess);",
            "                    }",
            "                }",
            "            }",
            "",
            "            return IntPtr.Zero;",
            "        }",
            "",
            "        private static string GetTokenUserSID(IntPtr hToken)",
            "        {",
            "            using (SafeMemoryBuffer tokenInfo = GetTokenInformation(hToken, TokenInformationClass.TokenUser))",
            "            {",
            "                TOKEN_USER tokenUser = (TOKEN_USER)Marshal.PtrToStructure(tokenInfo.DangerousGetHandle(),",
            "                    typeof(TOKEN_USER));",
            "                return new SecurityIdentifier(tokenUser.User.Sid).Value;",
            "            }",
            "        }",
            "",
            "        private static void GetProcessOutput(StreamReader stdoutStream, StreamReader stderrStream, out string stdout, out string stderr)",
            "        {",
            "            var sowait = new EventWaitHandle(false, EventResetMode.ManualReset);",
            "            var sewait = new EventWaitHandle(false, EventResetMode.ManualReset);",
            "            string so = null, se = null;",
            "            ThreadPool.QueueUserWorkItem((s) =>",
            "            {",
            "                so = stdoutStream.ReadToEnd();",
            "                sowait.Set();",
            "            });",
            "            ThreadPool.QueueUserWorkItem((s) =>",
            "            {",
            "                se = stderrStream.ReadToEnd();",
            "                sewait.Set();",
            "            });",
            "            foreach (var wh in new WaitHandle[] { sowait, sewait })",
            "                wh.WaitOne();",
            "            stdout = so;",
            "            stderr = se;",
            "        }",
            "",
            "        private static uint GetProcessExitCode(IntPtr processHandle)",
            "        {",
            "            new NativeWaitHandle(processHandle).WaitOne();",
            "            uint exitCode;",
            "            if (!GetExitCodeProcess(processHandle, out exitCode))",
            "                throw new Win32Exception(\"Error getting process exit code\");",
            "            return exitCode;",
            "        }",
            "",
            "        private static IntPtr GetElevatedToken(IntPtr hToken)",
            "        {",
            "            // First determine if the current token is a limited token",
            "            using (SafeMemoryBuffer tokenInfo = GetTokenInformation(hToken, TokenInformationClass.TokenElevationType))",
            "            {",
            "                TokenElevationType tet = (TokenElevationType)Marshal.ReadInt32(tokenInfo.DangerousGetHandle());",
            "                // We already have the best token we can get, just use it",
            "                if (tet != TokenElevationType.TokenElevationTypeLimited)",
            "                    return hToken;",
            "            }",
            "",
            "            // We have a limited token, get the linked elevated token",
            "            using (SafeMemoryBuffer tokenInfo = GetTokenInformation(hToken, TokenInformationClass.TokenLinkedToken))",
            "                return Marshal.ReadIntPtr(tokenInfo.DangerousGetHandle());",
            "        }",
            "",
            "        private static List<string> GetTokenPrivileges(IntPtr hToken)",
            "        {",
            "            using (SafeMemoryBuffer tokenInfo = GetTokenInformation(hToken, TokenInformationClass.TokenPrivileges))",
            "            {",
            "                TOKEN_PRIVILEGES tokenPrivileges = (TOKEN_PRIVILEGES)Marshal.PtrToStructure(",
            "                    tokenInfo.DangerousGetHandle(), typeof(TOKEN_PRIVILEGES));",
            "",
            "                LUID_AND_ATTRIBUTES[] luidAndAttributes = new LUID_AND_ATTRIBUTES[tokenPrivileges.PrivilegeCount];",
            "                PtrToStructureArray(luidAndAttributes, IntPtr.Add(tokenInfo.DangerousGetHandle(), Marshal.SizeOf(tokenPrivileges.PrivilegeCount)));",
            "",
            "                return luidAndAttributes.Select(x => GetPrivilegeName(x.Luid)).ToList();",
            "            }",
            "        }",
            "",
            "        private static SafeMemoryBuffer GetTokenInformation(IntPtr hToken, TokenInformationClass tokenClass)",
            "        {",
            "            UInt32 tokenLength;",
            "            bool res = GetTokenInformation(hToken, tokenClass, new SafeMemoryBuffer(IntPtr.Zero), 0, out tokenLength);",
            "            if (!res && tokenLength == 0)  // res will be false due to insufficient buffer size, we ignore if we got the buffer length",
            "                throw new Win32Exception(String.Format(\"GetTokenInformation({0}) failed to get buffer length\", tokenClass.ToString()));",
            "",
            "            SafeMemoryBuffer tokenInfo = new SafeMemoryBuffer((int)tokenLength);",
            "            if (!GetTokenInformation(hToken, tokenClass, tokenInfo, tokenLength, out tokenLength))",
            "                throw new Win32Exception(String.Format(\"GetTokenInformation({0}) failed\", tokenClass.ToString()));",
            "",
            "            return tokenInfo;",
            "        }",
            "",
            "        private static string GetPrivilegeName(LUID luid)",
            "        {",
            "            UInt32 nameLen = 0;",
            "            LookupPrivilegeNameW(null, ref luid, null, ref nameLen);",
            "",
            "            StringBuilder name = new StringBuilder((int)(nameLen + 1));",
            "            if (!LookupPrivilegeNameW(null, ref luid, name, ref nameLen))",
            "                throw new Win32Exception(\"LookupPrivilegeNameW() failed\");",
            "",
            "            return name.ToString();",
            "        }",
            "",
            "        private static void PtrToStructureArray<T>(T[] array, IntPtr ptr)",
            "        {",
            "            IntPtr ptrOffset = ptr;",
            "            for (int i = 0; i < array.Length; i++, ptrOffset = IntPtr.Add(ptrOffset, Marshal.SizeOf(typeof(T))))",
            "                array[i] = (T)Marshal.PtrToStructure(ptrOffset, typeof(T));",
            "        }",
            "",
            "        private static void GrantAccessToWindowStationAndDesktop(SecurityIdentifier account)",
            "        {",
            "            const int WindowStationAllAccess = 0x000f037f;",
            "            GrantAccess(account, GetProcessWindowStation(), WindowStationAllAccess);",
            "            const int DesktopRightsAllAccess = 0x000f01ff;",
            "            GrantAccess(account, GetThreadDesktop(GetCurrentThreadId()), DesktopRightsAllAccess);",
            "        }",
            "",
            "        private static void GrantAccess(SecurityIdentifier account, IntPtr handle, int accessMask)",
            "        {",
            "            SafeHandle safeHandle = new NoopSafeHandle(handle);",
            "            GenericSecurity security =",
            "                new GenericSecurity(false, ResourceType.WindowObject, safeHandle, AccessControlSections.Access);",
            "            security.AddAccessRule(",
            "                new GenericAccessRule(account, accessMask, AccessControlType.Allow));",
            "            security.Persist(safeHandle, AccessControlSections.Access);",
            "        }",
            "",
            "        private class GenericSecurity : NativeObjectSecurity",
            "        {",
            "            public GenericSecurity(bool isContainer, ResourceType resType, SafeHandle objectHandle, AccessControlSections sectionsRequested)",
            "                : base(isContainer, resType, objectHandle, sectionsRequested) { }",
            "            public new void Persist(SafeHandle handle, AccessControlSections includeSections) { base.Persist(handle, includeSections); }",
            "            public new void AddAccessRule(AccessRule rule) { base.AddAccessRule(rule); }",
            "            public override Type AccessRightType { get { throw new NotImplementedException(); } }",
            "            public override AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited,",
            "                InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)",
            "            { throw new NotImplementedException(); }",
            "            public override Type AccessRuleType { get { return typeof(AccessRule); } }",
            "            public override AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited,",
            "                InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)",
            "            { throw new NotImplementedException(); }",
            "            public override Type AuditRuleType { get { return typeof(AuditRule); } }",
            "        }",
            "",
            "        private class NoopSafeHandle : SafeHandle",
            "        {",
            "            public NoopSafeHandle(IntPtr handle) : base(handle, false) { }",
            "            public override bool IsInvalid { get { return false; } }",
            "            protected override bool ReleaseHandle() { return true; }",
            "        }",
            "",
            "        private class GenericAccessRule : AccessRule",
            "        {",
            "            public GenericAccessRule(IdentityReference identity, int accessMask, AccessControlType type) :",
            "                base(identity, accessMask, false, InheritanceFlags.None, PropagationFlags.None, type)",
            "            { }",
            "        }",
            "    }",
            "}",
            "\"@",
            "",
            "# due to the command line size limitations of CreateProcessWithTokenW, we",
            "# execute a simple PS script that executes our full exec_wrapper so no files",
            "# touch the disk",
            "$become_exec_wrapper = {",
            "    chcp.com 65001 > $null",
            "    $ProgressPreference = \"SilentlyContinue\"",
            "    $raw = [System.Console]::In.ReadToEnd()",
            "    $split_parts = $raw.Split(@(\"`0`0`0`0\"), 0)",
            "    If (-not $split_parts.Length -eq 2) { throw \"invalid payload\" }",
            "    $json_raw = $split_parts[1]",
            "    &([ScriptBlock]::Create($split_parts[0]))",
            "}",
            "",
            "$exec_wrapper = {",
            "    &chcp.com 65001 > $null",
            "    Set-StrictMode -Version 2",
            "    $DebugPreference = \"Continue\"",
            "    $ErrorActionPreference = \"Stop\"",
            "",
            "    Function ConvertTo-HashtableFromPsCustomObject($myPsObject) {",
            "        $output = @{}",
            "        $myPsObject | Get-Member -MemberType *Property | % {",
            "            $val = $myPsObject.($_.name)",
            "            if ($val -is [psobject]) {",
            "                $val = ConvertTo-HashtableFromPsCustomObject -myPsObject $val",
            "            }",
            "            $output.($_.name) = $val",
            "        }",
            "        return $output",
            "    }",
            "",
            "    # stream JSON including become_pw, ps_module_payload, bin_module_payload, become_payload, write_payload_path, preserve directives",
            "    # exec runspace, capture output, cleanup, return module output. Do not change this as it is set become before being passed to the",
            "    # become process.",
            "",
            "    if (-not $(Get-Variable \"json_raw\" -ErrorAction SilentlyContinue)) {",
            "        Write-Error \"no payload supplied\" -Category InvalidArgument",
            "    }",
            "",
            "    $payload = ConvertTo-HashtableFromPsCustomObject -myPsObject (ConvertFrom-Json $json_raw)",
            "",
            "    # TODO: handle binary modules",
            "    # TODO: handle persistence",
            "",
            "    $actions = $payload.actions",
            "",
            "    # pop 0th action as entrypoint",
            "    $entrypoint = $payload.($actions[0])",
            "    $payload.actions = $payload.actions[1..99]",
            "",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    # load the current action entrypoint as a module custom object with a Run method",
            "    $entrypoint = New-Module -ScriptBlock ([scriptblock]::Create($entrypoint)) -AsCustomObject",
            "",
            "    Set-Variable -Scope global -Name complex_args -Value $payload[\"module_args\"] | Out-Null",
            "",
            "    # dynamically create/load modules",
            "    ForEach ($mod in $payload.powershell_modules.GetEnumerator()) {",
            "        $decoded_module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($mod.Value))",
            "        New-Module -ScriptBlock ([scriptblock]::Create($decoded_module)) -Name $mod.Key | Import-Module -WarningAction SilentlyContinue | Out-Null",
            "    }",
            "",
            "    $output = $entrypoint.Run($payload)",
            "    # base64 encode the output so the non-ascii characters are preserved",
            "    Write-Output ([System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((Write-Output $output))))",
            "} # end exec_wrapper",
            "",
            "Function Dump-Error ($excep, $msg=$null) {",
            "    $eo = @{failed=$true}",
            "",
            "    $exception_message = $excep.Exception.Message",
            "    if ($null -ne $msg) {",
            "        $exception_message = \"$($msg): $exception_message\"",
            "    }",
            "    $eo.msg = $exception_message",
            "    $eo.exception = $excep | Out-String",
            "    $host.SetShouldExit(1)",
            "",
            "    $eo | ConvertTo-Json -Depth 10 -Compress",
            "}",
            "",
            "Function Parse-EnumValue($enum, $flag_type, $value, $prefix) {",
            "    $raw_enum_value = \"$prefix$($value.ToUpper())\"",
            "    try {",
            "        $enum_value = [Enum]::Parse($enum, $raw_enum_value)",
            "    } catch [System.ArgumentException] {",
            "        $valid_options = [Enum]::GetNames($enum) | ForEach-Object { $_.Substring($prefix.Length).ToLower() }",
            "        throw \"become_flags $flag_type value '$value' is not valid, valid values are: $($valid_options -join \", \")\"",
            "    }",
            "    return $enum_value",
            "}",
            "",
            "Function Parse-BecomeFlags($flags) {",
            "    $logon_type = [AnsibleBecome.LogonType]::LOGON32_LOGON_INTERACTIVE",
            "    $logon_flags = [AnsibleBecome.LogonFlags]::LOGON_WITH_PROFILE",
            "",
            "    if ($flags -eq $null -or $flags -eq \"\") {",
            "        $flag_split = @()",
            "    } elseif ($flags -is [string]) {",
            "        $flag_split = $flags.Split(\" \")",
            "    } else {",
            "        throw \"become_flags must be a string, was $($flags.GetType())\"",
            "    }",
            "",
            "    foreach ($flag in $flag_split) {",
            "        $split = $flag.Split(\"=\")",
            "        if ($split.Count -ne 2) {",
            "            throw \"become_flags entry '$flag' is in an invalid format, must be a key=value pair\"",
            "        }",
            "        $flag_key = $split[0]",
            "        $flag_value = $split[1]",
            "        if ($flag_key -eq \"logon_type\") {",
            "            $enum_details = @{",
            "                enum = [AnsibleBecome.LogonType]",
            "                flag_type = $flag_key",
            "                value = $flag_value",
            "                prefix = \"LOGON32_LOGON_\"",
            "            }",
            "            $logon_type = Parse-EnumValue @enum_details",
            "        } elseif ($flag_key -eq \"logon_flags\") {",
            "            $logon_flag_values = $flag_value.Split(\",\")",
            "            $logon_flags = 0 -as [AnsibleBecome.LogonFlags]",
            "            foreach ($logon_flag_value in $logon_flag_values) {",
            "                if ($logon_flag_value -eq \"\") {",
            "                    continue",
            "                }",
            "                $enum_details = @{",
            "                    enum = [AnsibleBecome.LogonFlags]",
            "                    flag_type = $flag_key",
            "                    value = $logon_flag_value",
            "                    prefix = \"LOGON_\"",
            "                }",
            "                $logon_flag = Parse-EnumValue @enum_details",
            "                $logon_flags = $logon_flags -bor $logon_flag",
            "            }",
            "        } else {",
            "            throw \"become_flags key '$flag_key' is not a valid runas flag, must be 'logon_type' or 'logon_flags'\"",
            "        }",
            "    }",
            "",
            "    return $logon_type, [AnsibleBecome.LogonFlags]$logon_flags",
            "}",
            "",
            "Function Run($payload) {",
            "    # NB: action popping handled inside subprocess wrapper",
            "",
            "    $original_tmp = $env:TMP",
            "    $remote_tmp = $payload[\"module_args\"][\"_ansible_remote_tmp\"]",
            "    $remote_tmp = [System.Environment]::ExpandEnvironmentVariables($remote_tmp)",
            "    if ($null -eq $remote_tmp) {",
            "        $remote_tmp = $original_tmp",
            "    }",
            "",
            "    # become process is run under a different console to the WinRM one so we",
            "    # need to set the UTF-8 codepage again",
            "    $env:TMP = $remote_tmp",
            "    Add-Type -TypeDefinition $helper_def -Debug:$false",
            "    $env:TMP = $original_tmp",
            "",
            "    $username = $payload.become_user",
            "    $password = $payload.become_password",
            "    try {",
            "        $logon_type, $logon_flags = Parse-BecomeFlags -flags $payload.become_flags",
            "    } catch {",
            "        Dump-Error -excep $_ -msg \"Failed to parse become_flags '$($payload.become_flags)'\"",
            "        return $null",
            "    }",
            "",
            "    # NB: CreateProcessWithTokenW commandline maxes out at 1024 chars, must bootstrap via small",
            "    # wrapper which calls our read wrapper passed through stdin. Cannot use 'powershell -' as",
            "    # the $ErrorActionPreference is always set to Stop and cannot be changed",
            "    $payload_string = $payload | ConvertTo-Json -Depth 99 -Compress",
            "    $exec_wrapper = $exec_wrapper.ToString() + \"`0`0`0`0\" + $payload_string",
            "    $rc = 0",
            "",
            "    $exec_command = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($become_exec_wrapper.ToString()))",
            "    $lp_command_line = New-Object System.Text.StringBuilder @(\"powershell.exe -NonInteractive -NoProfile -ExecutionPolicy Bypass -EncodedCommand $exec_command\")",
            "    $lp_current_directory = \"$env:SystemRoot\"",
            "",
            "    Try {",
            "        $result = [AnsibleBecome.BecomeUtil]::RunAsUser($username, $password, $lp_command_line, $lp_current_directory, $exec_wrapper, $logon_flags, $logon_type)",
            "        $stdout = $result.StandardOut",
            "        $stdout = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($stdout.Trim()))",
            "        $stderr = $result.StandardError",
            "        $rc = $result.ExitCode",
            "",
            "        $host.UI.WriteLine($stdout)",
            "        $host.UI.WriteErrorLine($stderr.Trim())",
            "    } Catch {",
            "        $excep = $_",
            "        Dump-Error -excep $excep -msg \"Failed to become user $username\"",
            "    }",
            "    $host.SetShouldExit($rc)",
            "}",
            "'''",
            "",
            "async_wrapper = br'''",
            "Set-StrictMode -Version 2",
            "$ErrorActionPreference = \"Stop\"",
            "",
            "# build exec_wrapper encoded command",
            "# start powershell with breakaway running exec_wrapper encodedcommand",
            "# stream payload to powershell with normal exec, but normal exec writes results to resultfile instead of stdout/stderr",
            "# return asyncresult to controller",
            "",
            "$exec_wrapper = {",
            "    # help to debug any errors in the exec_wrapper or async_watchdog by generating",
            "    # an error log in case of a terminating error",
            "    trap {",
            "        $log_path = \"$($env:TEMP)\\async-exec-wrapper-$(Get-Date -Format \"yyyy-MM-ddTHH-mm-ss.ffffZ\")-error.txt\"",
            "        $error_msg = \"Error while running the async exec wrapper`r`n$_`r`n$($_.ScriptStackTrace)\"",
            "        Set-Content -Path $log_path -Value $error_msg",
            "        throw $_",
            "    }",
            "",
            "    &chcp.com 65001 > $null",
            "    $DebugPreference = \"Continue\"",
            "    $ErrorActionPreference = \"Stop\"",
            "    Set-StrictMode -Version 2",
            "",
            "    function ConvertTo-HashtableFromPsCustomObject ($myPsObject){",
            "        $output = @{};",
            "        $myPsObject | Get-Member -MemberType *Property | % {",
            "            $val = $myPsObject.($_.name);",
            "            If ($val -is [psobject]) {",
            "                $val = ConvertTo-HashtableFromPsCustomObject $val",
            "            }",
            "            $output.($_.name) = $val",
            "        }",
            "        return $output;",
            "    }",
            "",
            "    # store the pipe name and no. of bytes to read, these are populated by the",
            "    # Run function before being run - do not remove or change",
            "    $pipe_name = \"\"",
            "    $bytes_length = 0",
            "",
            "    # stream JSON including become_pw, ps_module_payload, bin_module_payload, become_payload, write_payload_path, preserve directives",
            "    # exec runspace, capture output, cleanup, return module output",
            "    $input_bytes = New-Object -TypeName byte[] -ArgumentList $bytes_length",
            "    $pipe = New-Object -TypeName System.IO.Pipes.NamedPipeClientStream -ArgumentList @(",
            "        \".\",  # localhost",
            "        $pipe_name,",
            "        [System.IO.Pipes.PipeDirection]::In,",
            "        [System.IO.Pipes.PipeOptions]::None,",
            "        [System.Security.Principal.TokenImpersonationLevel]::Anonymous",
            "    )",
            "    try {",
            "        $pipe.Connect()",
            "        $pipe.Read($input_bytes, 0, $bytes_length) > $null",
            "    } finally {",
            "        $pipe.Close()",
            "    }",
            "    $json_raw = [System.Text.Encoding]::UTF8.GetString($input_bytes)",
            "",
            "    If (-not $json_raw) {",
            "        Write-Error \"no input given\" -Category InvalidArgument",
            "    }",
            "",
            "    $payload = ConvertTo-HashtableFromPsCustomObject (ConvertFrom-Json $json_raw)",
            "",
            "    # TODO: handle binary modules",
            "    # TODO: handle persistence",
            "",
            "    $actions = $payload.actions",
            "",
            "    # pop 0th action as entrypoint",
            "    $entrypoint = $payload.($actions[0])",
            "    $payload.actions = $payload.actions[1..99]",
            "",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    # load the current action entrypoint as a module custom object with a Run method",
            "    $entrypoint = New-Module -ScriptBlock ([scriptblock]::Create($entrypoint)) -AsCustomObject",
            "",
            "    Set-Variable -Scope global -Name complex_args -Value $payload[\"module_args\"] | Out-Null",
            "",
            "    # dynamically create/load modules",
            "    ForEach ($mod in $payload.powershell_modules.GetEnumerator()) {",
            "        $decoded_module = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($mod.Value))",
            "        New-Module -ScriptBlock ([scriptblock]::Create($decoded_module)) -Name $mod.Key | Import-Module -WarningAction SilentlyContinue | Out-Null",
            "    }",
            "",
            "    $output = $entrypoint.Run($payload)",
            "",
            "    Write-Output $output",
            "} # end exec_wrapper",
            "",
            "",
            "Function Run($payload) {",
            "    $remote_tmp = $payload[\"module_args\"][\"_ansible_remote_tmp\"]",
            "    $remote_tmp = [System.Environment]::ExpandEnvironmentVariables($remote_tmp)",
            "",
            "    # calculate the result path so we can include it in the worker payload",
            "    $jid = $payload.async_jid",
            "    $local_jid = $jid + \".\" + $pid",
            "",
            "    $results_path = [System.IO.Path]::Combine($remote_tmp, \".ansible_async\", $local_jid)",
            "",
            "    $payload.async_results_path = $results_path",
            "",
            "    [System.IO.Directory]::CreateDirectory([System.IO.Path]::GetDirectoryName($results_path)) | Out-Null",
            "",
            "    # can't use anonymous pipes as the spawned process will not be a child due to",
            "    # the way WMI works, use a named pipe with a random name instead and set to",
            "    # only allow current user to read from the pipe",
            "    $pipe_name = \"ansible-async-$jid-$([guid]::NewGuid())\"",
            "    $current_user = ([Security.Principal.WindowsIdentity]::GetCurrent()).User",
            "    $payload_string = $payload | ConvertTo-Json -Depth 99 -Compress",
            "    $payload_bytes = [System.Text.Encoding]::UTF8.GetBytes($payload_string)",
            "",
            "    $pipe_sec = New-Object -TypeName System.IO.Pipes.PipeSecurity",
            "    $pipe_ar = New-Object -TypeName System.IO.Pipes.PipeAccessRule -ArgumentList @(",
            "        $current_user,",
            "        [System.IO.Pipes.PipeAccessRights]::Read,",
            "        [System.Security.AccessControl.AccessControlType]::Allow",
            "    )",
            "    $pipe_sec.AddAccessRule($pipe_ar)",
            "    $pipe = New-Object -TypeName System.IO.Pipes.NamedPipeServerStream -ArgumentList @(",
            "        $pipe_name,",
            "        [System.IO.Pipes.PipeDirection]::Out,",
            "        1,",
            "        [System.IO.Pipes.PipeTransmissionMode]::Byte,",
            "        [System.IO.Pipes.PipeOptions]::Asynchronous,",
            "        0,",
            "        0,",
            "        $pipe_sec",
            "    )",
            "",
            "    try {",
            "        $exec_wrapper_str = $exec_wrapper.ToString()",
            "        $exec_wrapper_str = $exec_wrapper_str.Replace('$pipe_name = \"\"', \"`$pipe_name = `\"$pipe_name`\"\")",
            "        $exec_wrapper_str = $exec_wrapper_str.Replace('$bytes_length = 0', \"`$bytes_length = $($payload_bytes.Count)\")",
            "",
            "        $encoded_command = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($exec_wrapper_str))",
            "        $exec_args = \"powershell.exe -NonInteractive -NoProfile -ExecutionPolicy Bypass -EncodedCommand $encoded_command\"",
            "",
            "        # not all connection plugins support breakaway from job that is required",
            "        # for async, Win32_Process.Create() is still able to escape so we use",
            "        # that here",
            "        $process = Invoke-CimMethod -ClassName Win32_Process -Name Create -Arguments @{CommandLine=$exec_args}",
            "        $rc = $process.ReturnValue",
            "        if ($rc -ne 0) {",
            "            $error_msg = switch($rc) {",
            "                2 { \"Access denied\" }",
            "                3 { \"Insufficient privilege\" }",
            "                8 { \"Unknown failure\" }",
            "                9 { \"Path not found\" }",
            "                21 { \"Invalid parameter\" }",
            "                default { \"Other\" }",
            "            }",
            "            throw \"Failed to start async process: $rc ($error_msg)\"",
            "        }",
            "        $watchdog_pid = $process.ProcessId",
            "",
            "        # populate initial results before we send the async data to avoid result race",
            "        $result = @{",
            "            started = 1;",
            "            finished = 0;",
            "            results_file = $results_path;",
            "            ansible_job_id = $local_jid;",
            "            _ansible_suppress_tmpdir_delete = $true;",
            "            ansible_async_watchdog_pid = $watchdog_pid",
            "        }",
            "",
            "        $result_json = ConvertTo-Json $result",
            "        Set-Content $results_path -Value $result_json",
            "",
            "        # wait until the client connects, throw an error if the timeout is reached",
            "        $wait_async = $pipe.BeginWaitForConnection($null, $null)",
            "        $wait_async.AsyncWaitHandle.WaitOne(5000) > $null",
            "        if (-not $wait_async.IsCompleted) {",
            "            throw \"timeout while waiting for child process to connect to named pipe\"",
            "        }",
            "        $pipe.EndWaitForConnection($wait_async)",
            "",
            "        # write the exec manifest to the child process",
            "        $pipe.Write($payload_bytes, 0, $payload_bytes.Count)",
            "        $pipe.Flush()",
            "        $pipe.WaitForPipeDrain()",
            "    } finally {",
            "        $pipe.Close()",
            "    }",
            "",
            "    return $result_json",
            "}",
            "",
            "'''  # end async_wrapper",
            "",
            "async_watchdog = br'''",
            "Set-StrictMode -Version 2",
            "$ErrorActionPreference = \"Stop\"",
            "",
            "Add-Type -AssemblyName System.Web.Extensions",
            "",
            "Function Log {",
            "    Param(",
            "        [string]$msg",
            "    )",
            "",
            "    If(Get-Variable -Name log_path -ErrorAction SilentlyContinue) {",
            "        Add-Content $log_path $msg",
            "    }",
            "}",
            "",
            "Function Deserialize-Json {",
            "    Param(",
            "        [Parameter(ValueFromPipeline=$true)]",
            "        [string]$json",
            "    )",
            "",
            "    # FUTURE: move this into module_utils/powershell.ps1 and use for everything (sidestep PSCustomObject issues)",
            "    # FUTURE: won't work w/ Nano Server/.NET Core- fallback to DataContractJsonSerializer (which can't handle dicts on .NET 4.0)",
            "",
            "    Log \"Deserializing:`n$json\"",
            "",
            "    $jss = New-Object System.Web.Script.Serialization.JavaScriptSerializer",
            "    return $jss.DeserializeObject($json)",
            "}",
            "",
            "Function Write-Result {",
            "    Param(",
            "        [hashtable]$result,",
            "        [string]$resultfile_path",
            "    )",
            "",
            "    $result | ConvertTo-Json | Set-Content -Path $resultfile_path",
            "}",
            "",
            "Function Run($payload) {",
            "    $actions = $payload.actions",
            "",
            "    # pop 0th action as entrypoint",
            "    $entrypoint = $payload.($actions[0])",
            "    $entrypoint = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($entrypoint))",
            "",
            "    $payload.actions = $payload.actions[1..99]",
            "",
            "    $resultfile_path = $payload.async_results_path",
            "    $max_exec_time_sec = $payload.async_timeout_sec",
            "",
            "    Log \"deserializing existing resultfile args\"",
            "    # read in existing resultsfile to merge w/ module output (it should be written by the time we're unsuspended and running)",
            "    $result = Get-Content $resultfile_path -Raw | Deserialize-Json",
            "",
            "    Log \"deserialized result is $($result | Out-String)\"",
            "",
            "    Log \"creating runspace\"",
            "",
            "    $rs = [runspacefactory]::CreateRunspace()",
            "    $rs.Open()",
            "",
            "    Log \"creating Powershell object\"",
            "",
            "    $job = [powershell]::Create()",
            "    $job.Runspace = $rs",
            "",
            "    $job.AddScript($entrypoint) | Out-Null",
            "    $job.AddStatement().AddCommand(\"Run\").AddArgument($payload) | Out-Null",
            "",
            "    Log \"job BeginInvoke()\"",
            "",
            "    $job_asyncresult = $job.BeginInvoke()",
            "",
            "    Log \"waiting $max_exec_time_sec seconds for job to complete\"",
            "",
            "    $signaled = $job_asyncresult.AsyncWaitHandle.WaitOne($max_exec_time_sec * 1000)",
            "",
            "    $result[\"finished\"] = 1",
            "",
            "    If($job_asyncresult.IsCompleted) {",
            "        Log \"job completed, calling EndInvoke()\"",
            "",
            "        $job_output = $job.EndInvoke($job_asyncresult)",
            "        $job_error = $job.Streams.Error",
            "",
            "        Log \"raw module stdout: \\r\\n$job_output\"",
            "        If($job_error) {",
            "            Log \"raw module stderr: \\r\\n$job_error\"",
            "        }",
            "",
            "        # write success/output/error to result object",
            "",
            "        # TODO: cleanse leading/trailing junk",
            "        Try {",
            "            $module_result = Deserialize-Json $job_output",
            "            # TODO: check for conflicting keys",
            "            $result = $result + $module_result",
            "        }",
            "        Catch {",
            "            $excep = $_",
            "",
            "            $result.failed = $true",
            "            $result.msg = \"failed to parse module output: $excep\"",
            "            # return the output back to Ansible to help with debugging errors",
            "            $result.stdout = $job_output | Out-String",
            "            $result.stderr = $job_error | Out-String",
            "        }",
            "",
            "        # TODO: determine success/fail, or always include stderr if nonempty?",
            "        Write-Result $result $resultfile_path",
            "",
            "        Log \"wrote output to $resultfile_path\"",
            "    }",
            "    Else {",
            "        $job.BeginStop($null, $null) | Out-Null # best effort stop",
            "        # write timeout to result object",
            "        $result.failed = $true",
            "        $result.msg = \"timed out waiting for module completion\"",
            "        Write-Result $result $resultfile_path",
            "",
            "        Log \"wrote timeout to $resultfile_path\"",
            "    }",
            "",
            "    # in the case of a hung pipeline, this will cause the process to stay alive until it's un-hung...",
            "    #$rs.Close() | Out-Null",
            "}",
            "",
            "'''  # end async_watchdog",
            "",
            "from ansible.plugins import AnsiblePlugin",
            "",
            "",
            "class ShellModule(ShellBase):",
            "",
            "    # Common shell filenames that this plugin handles",
            "    # Powershell is handled differently.  It's selected when winrm is the",
            "    # connection",
            "    COMPATIBLE_SHELLS = frozenset()",
            "    # Family of shells this has.  Must match the filename without extension",
            "    SHELL_FAMILY = 'powershell'",
            "",
            "    env = dict()",
            "",
            "    # We're being overly cautious about which keys to accept (more so than",
            "    # the Windows environment is capable of doing), since the powershell",
            "    # env provider's limitations don't appear to be documented.",
            "    safe_envkey = re.compile(r'^[\\d\\w_]{1,255}$')",
            "",
            "    # TODO: add binary module support",
            "",
            "    def assert_safe_env_key(self, key):",
            "        if not self.safe_envkey.match(key):",
            "            raise AnsibleError(\"Invalid PowerShell environment key: %s\" % key)",
            "        return key",
            "",
            "    def safe_env_value(self, key, value):",
            "        if len(value) > 32767:",
            "            raise AnsibleError(\"PowerShell environment value for key '%s' exceeds 32767 characters in length\" % key)",
            "        # powershell single quoted literals need single-quote doubling as their only escaping",
            "        value = value.replace(\"'\", \"''\")",
            "        return to_text(value, errors='surrogate_or_strict')",
            "",
            "    def env_prefix(self, **kwargs):",
            "        # powershell/winrm env handling is handled in the exec wrapper",
            "        return \"\"",
            "",
            "    def join_path(self, *args):",
            "        parts = []",
            "        for arg in args:",
            "            arg = self._unquote(arg).replace('/', '\\\\')",
            "            parts.extend([a for a in arg.split('\\\\') if a])",
            "        path = '\\\\'.join(parts)",
            "        if path.startswith('~'):",
            "            return path",
            "        return path",
            "",
            "    def get_remote_filename(self, pathname):",
            "        # powershell requires that script files end with .ps1",
            "        base_name = os.path.basename(pathname.strip())",
            "        name, ext = os.path.splitext(base_name.strip())",
            "        if ext.lower() not in ['.ps1', '.exe']:",
            "            return name + '.ps1'",
            "",
            "        return base_name.strip()",
            "",
            "    def path_has_trailing_slash(self, path):",
            "        # Allow Windows paths to be specified using either slash.",
            "        path = self._unquote(path)",
            "        return path.endswith('/') or path.endswith('\\\\')",
            "",
            "    def chmod(self, paths, mode):",
            "        raise NotImplementedError('chmod is not implemented for Powershell')",
            "",
            "    def chown(self, paths, user):",
            "        raise NotImplementedError('chown is not implemented for Powershell')",
            "",
            "    def set_user_facl(self, paths, user, mode):",
            "        raise NotImplementedError('set_user_facl is not implemented for Powershell')",
            "",
            "    def remove(self, path, recurse=False):",
            "        path = self._escape(self._unquote(path))",
            "        if recurse:",
            "            return self._encode_script('''Remove-Item \"%s\" -Force -Recurse;''' % path)",
            "        else:",
            "            return self._encode_script('''Remove-Item \"%s\" -Force;''' % path)",
            "",
            "    def mkdtemp(self, basefile=None, system=False, mode=None, tmpdir=None):",
            "        # Windows does not have an equivalent for the system temp files, so",
            "        # the param is ignored",
            "        if not basefile:",
            "            basefile = self.__class__._generate_temp_dir_name()",
            "        basefile = self._escape(self._unquote(basefile))",
            "        basetmpdir = tmpdir if tmpdir else self.get_option('remote_tmp')",
            "",
            "        script = '''",
            "        $tmp_path = [System.Environment]::ExpandEnvironmentVariables('%s')",
            "        $tmp = New-Item -Type Directory -Path $tmp_path -Name '%s'",
            "        Write-Output -InputObject $tmp.FullName",
            "        ''' % (basetmpdir, basefile)",
            "        return self._encode_script(script.strip())",
            "",
            "    def expand_user(self, user_home_path, username=''):",
            "        # PowerShell only supports \"~\" (not \"~username\").  Resolve-Path ~ does",
            "        # not seem to work remotely, though by default we are always starting",
            "        # in the user's home directory.",
            "        user_home_path = self._unquote(user_home_path)",
            "        if user_home_path == '~':",
            "            script = 'Write-Output (Get-Location).Path'",
            "        elif user_home_path.startswith('~\\\\'):",
            "            script = 'Write-Output ((Get-Location).Path + \"%s\")' % self._escape(user_home_path[1:])",
            "        else:",
            "            script = 'Write-Output \"%s\"' % self._escape(user_home_path)",
            "        return self._encode_script(script)",
            "",
            "    def exists(self, path):",
            "        path = self._escape(self._unquote(path))",
            "        script = '''",
            "            If (Test-Path \"%s\")",
            "            {",
            "                $res = 0;",
            "            }",
            "            Else",
            "            {",
            "                $res = 1;",
            "            }",
            "            Write-Output \"$res\";",
            "            Exit $res;",
            "         ''' % path",
            "        return self._encode_script(script)",
            "",
            "    def checksum(self, path, *args, **kwargs):",
            "        path = self._escape(self._unquote(path))",
            "        script = '''",
            "            If (Test-Path -PathType Leaf \"%(path)s\")",
            "            {",
            "                $sp = new-object -TypeName System.Security.Cryptography.SHA1CryptoServiceProvider;",
            "                $fp = [System.IO.File]::Open(\"%(path)s\", [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read);",
            "                [System.BitConverter]::ToString($sp.ComputeHash($fp)).Replace(\"-\", \"\").ToLower();",
            "                $fp.Dispose();",
            "            }",
            "            ElseIf (Test-Path -PathType Container \"%(path)s\")",
            "            {",
            "                Write-Output \"3\";",
            "            }",
            "            Else",
            "            {",
            "                Write-Output \"1\";",
            "            }",
            "        ''' % dict(path=path)",
            "        return self._encode_script(script)",
            "",
            "    def build_module_command(self, env_string, shebang, cmd, arg_path=None):",
            "        bootstrap_wrapper = pkgutil.get_data(\"ansible.executor.powershell\", \"bootstrap_wrapper.ps1\")",
            "",
            "        # pipelining bypass",
            "        if cmd == '':",
            "            return self._encode_script(script=bootstrap_wrapper, strict_mode=False, preserve_rc=False)",
            "",
            "        # non-pipelining",
            "",
            "        cmd_parts = shlex.split(cmd, posix=False)",
            "        cmd_parts = list(map(to_text, cmd_parts))",
            "        if shebang and shebang.lower() == '#!powershell':",
            "            if not self._unquote(cmd_parts[0]).lower().endswith('.ps1'):",
            "                # we're running a module via the bootstrap wrapper",
            "                cmd_parts[0] = '\"%s.ps1\"' % self._unquote(cmd_parts[0])",
            "            wrapper_cmd = \"type \" + cmd_parts[0] + \" | \" + self._encode_script(script=bootstrap_wrapper,",
            "                                                                               strict_mode=False, preserve_rc=False)",
            "            return wrapper_cmd",
            "        elif shebang and shebang.startswith('#!'):",
            "            cmd_parts.insert(0, shebang[2:])",
            "        elif not shebang:",
            "            # The module is assumed to be a binary",
            "            cmd_parts[0] = self._unquote(cmd_parts[0])",
            "            cmd_parts.append(arg_path)",
            "        script = '''",
            "            Try",
            "            {",
            "                %s",
            "                %s",
            "            }",
            "            Catch",
            "            {",
            "                $_obj = @{ failed = $true }",
            "                If ($_.Exception.GetType)",
            "                {",
            "                    $_obj.Add('msg', $_.Exception.Message)",
            "                }",
            "                Else",
            "                {",
            "                    $_obj.Add('msg', $_.ToString())",
            "                }",
            "                If ($_.InvocationInfo.PositionMessage)",
            "                {",
            "                    $_obj.Add('exception', $_.InvocationInfo.PositionMessage)",
            "                }",
            "                ElseIf ($_.ScriptStackTrace)",
            "                {",
            "                    $_obj.Add('exception', $_.ScriptStackTrace)",
            "                }",
            "                Try",
            "                {",
            "                    $_obj.Add('error_record', ($_ | ConvertTo-Json | ConvertFrom-Json))",
            "                }",
            "                Catch",
            "                {",
            "                }",
            "                Echo $_obj | ConvertTo-Json -Compress -Depth 99",
            "                Exit 1",
            "            }",
            "        ''' % (env_string, ' '.join(cmd_parts))",
            "        return self._encode_script(script, preserve_rc=False)",
            "",
            "    def wrap_for_exec(self, cmd):",
            "        return '& %s; exit $LASTEXITCODE' % cmd",
            "",
            "    def _unquote(self, value):",
            "        '''Remove any matching quotes that wrap the given value.'''",
            "        value = to_text(value or '')",
            "        m = re.match(r'^\\s*?\\'(.*?)\\'\\s*?$', value)",
            "        if m:",
            "            return m.group(1)",
            "        m = re.match(r'^\\s*?\"(.*?)\"\\s*?$', value)",
            "        if m:",
            "            return m.group(1)",
            "        return value",
            "",
            "    def _escape(self, value, include_vars=False):",
            "        '''Return value escaped for use in PowerShell command.'''",
            "        # http://www.techotopia.com/index.php/Windows_PowerShell_1.0_String_Quoting_and_Escape_Sequences",
            "        # http://stackoverflow.com/questions/764360/a-list-of-string-replacements-in-python",
            "        subs = [('\\n', '`n'), ('\\r', '`r'), ('\\t', '`t'), ('\\a', '`a'),",
            "                ('\\b', '`b'), ('\\f', '`f'), ('\\v', '`v'), ('\"', '`\"'),",
            "                ('\\'', '`\\''), ('`', '``'), ('\\x00', '`0')]",
            "        if include_vars:",
            "            subs.append(('$', '`$'))",
            "        pattern = '|'.join('(%s)' % re.escape(p) for p, s in subs)",
            "        substs = [s for p, s in subs]",
            "",
            "        def replace(m):",
            "            return substs[m.lastindex - 1]",
            "",
            "        return re.sub(pattern, replace, value)",
            "",
            "    def _encode_script(self, script, as_list=False, strict_mode=True, preserve_rc=True):",
            "        '''Convert a PowerShell script to a single base64-encoded command.'''",
            "        script = to_text(script)",
            "",
            "        if script == u'-':",
            "            cmd_parts = _common_args + ['-']",
            "",
            "        else:",
            "            if strict_mode:",
            "                script = u'Set-StrictMode -Version Latest\\r\\n%s' % script",
            "            # try to propagate exit code if present- won't work with begin/process/end-style scripts (ala put_file)",
            "            # NB: the exit code returned may be incorrect in the case of a successful command followed by an invalid command",
            "            if preserve_rc:",
            "                script = u'%s\\r\\nIf (-not $?) { If (Get-Variable LASTEXITCODE -ErrorAction SilentlyContinue) { exit $LASTEXITCODE } Else { exit 1 } }\\r\\n'\\",
            "                    % script",
            "            script = '\\n'.join([x.strip() for x in script.splitlines() if x.strip()])",
            "            encoded_script = to_text(base64.b64encode(script.encode('utf-16-le')), 'utf-8')",
            "            cmd_parts = _common_args + ['-EncodedCommand', encoded_script]",
            "",
            "        if as_list:",
            "            return cmd_parts",
            "        return ' '.join(cmd_parts)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "copyparty.httpcli"
        ]
    }
}