{
    "vllm/assets/image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         image_path = get_vllm_public_assets(filename=f\"{self.name}.pt\","
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "                                             s3_prefix=VLM_IMAGES_DIR)"
            },
            "3": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return torch.load(image_path, map_location=\"cpu\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        return torch.load(image_path, map_location=\"cpu\", weights_only=True)"
            }
        },
        "frontPatchFile": [
            "from dataclasses import dataclass",
            "from typing import Literal",
            "",
            "import torch",
            "from PIL import Image",
            "",
            "from .base import get_vllm_public_assets",
            "",
            "VLM_IMAGES_DIR = \"vision_model_images\"",
            "",
            "",
            "@dataclass(frozen=True)",
            "class ImageAsset:",
            "    name: Literal[\"stop_sign\", \"cherry_blossom\"]",
            "",
            "    @property",
            "    def pil_image(self) -> Image.Image:",
            "        image_path = get_vllm_public_assets(filename=f\"{self.name}.jpg\",",
            "                                            s3_prefix=VLM_IMAGES_DIR)",
            "        return Image.open(image_path)",
            "",
            "    @property",
            "    def image_embeds(self) -> torch.Tensor:",
            "        \"\"\"",
            "        Image embeddings, only used for testing purposes with llava 1.5.",
            "        \"\"\"",
            "        image_path = get_vllm_public_assets(filename=f\"{self.name}.pt\",",
            "                                            s3_prefix=VLM_IMAGES_DIR)",
            "        return torch.load(image_path, map_location=\"cpu\")"
        ],
        "afterPatchFile": [
            "from dataclasses import dataclass",
            "from typing import Literal",
            "",
            "import torch",
            "from PIL import Image",
            "",
            "from .base import get_vllm_public_assets",
            "",
            "VLM_IMAGES_DIR = \"vision_model_images\"",
            "",
            "",
            "@dataclass(frozen=True)",
            "class ImageAsset:",
            "    name: Literal[\"stop_sign\", \"cherry_blossom\"]",
            "",
            "    @property",
            "    def pil_image(self) -> Image.Image:",
            "        image_path = get_vllm_public_assets(filename=f\"{self.name}.jpg\",",
            "                                            s3_prefix=VLM_IMAGES_DIR)",
            "        return Image.open(image_path)",
            "",
            "    @property",
            "    def image_embeds(self) -> torch.Tensor:",
            "        \"\"\"",
            "        Image embeddings, only used for testing purposes with llava 1.5.",
            "        \"\"\"",
            "        image_path = get_vllm_public_assets(filename=f\"{self.name}.pt\",",
            "                                            s3_prefix=VLM_IMAGES_DIR)",
            "        return torch.load(image_path, map_location=\"cpu\", weights_only=True)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "29": [
                "ImageAsset",
                "image_embeds"
            ]
        },
        "addLocation": []
    },
    "vllm/lora/models.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "                 new_embeddings_tensor_path)"
            },
            "1": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "         elif os.path.isfile(new_embeddings_bin_file_path):"
            },
            "2": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "             embeddings = torch.load(new_embeddings_bin_file_path,"
            },
            "3": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    map_location=device)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+                                    map_location=device,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+                                    weights_only=True)"
            },
            "6": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         return cls.from_lora_tensors("
            },
            "8": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "             lora_model_id=get_lora_id()"
            }
        },
        "frontPatchFile": [
            "import copy",
            "import math",
            "import os",
            "import re",
            "from dataclasses import dataclass, field",
            "from typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union",
            "",
            "import safetensors.torch",
            "import torch",
            "from torch import nn",
            "",
            "from vllm.adapter_commons.models import (AdapterLRUCache, AdapterModel,",
            "                                         AdapterModelManager)",
            "from vllm.adapter_commons.utils import (add_adapter, deactivate_adapter,",
            "                                        get_adapter, list_adapters,",
            "                                        remove_adapter, set_adapter_mapping)",
            "from vllm.config import LoRAConfig",
            "from vllm.logger import init_logger",
            "from vllm.lora.layers import (BaseLayerWithLoRA,",
            "                              LinearScalingRotaryEmbeddingWithLora,",
            "                              LoRAMapping)",
            "from vllm.lora.lora import LoRALayerWeights, PackedLoRALayerWeights",
            "from vllm.lora.peft_helper import PEFTHelper",
            "from vllm.lora.punica_wrapper import get_punica_wrapper",
            "from vllm.lora.utils import (from_layer, from_layer_logits_processor,",
            "                             is_regex_target_modules,",
            "                             parse_fine_tuned_lora_name, replace_submodule)",
            "from vllm.model_executor.models import SupportsLoRA, supports_multimodal",
            "from vllm.model_executor.models.module_mapping import MultiModelKeys",
            "from vllm.model_executor.models.utils import PPMissingLayer, WeightsMapper",
            "from vllm.utils import is_pin_memory_available",
            "",
            "logger = init_logger(__name__)",
            "",
            "_GLOBAL_LORA_ID = 0",
            "",
            "",
            "@dataclass",
            "class LongContextLoRAContext:",
            "    \"\"\"Context for lora adapters that support long context.\"\"\"",
            "    # The scaling factors to support long context lora fine tuned models.",
            "    scaling_factors: List[float]",
            "    # dimension to apply rotary embedding.",
            "    rot_dim: int",
            "    # offsets to the sin_cos_cache for each lora_id loaded.",
            "    # This value is dynamically modified.",
            "    offsets_by_lora_id: Dict[int, int] = field(default_factory=dict)",
            "",
            "",
            "def get_lora_id():",
            "    global _GLOBAL_LORA_ID",
            "    _GLOBAL_LORA_ID += 1",
            "    return _GLOBAL_LORA_ID",
            "",
            "",
            "class LoRAModel(AdapterModel):",
            "    \"\"\"A LoRA fine-tuned model.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        lora_model_id: int,",
            "        rank: int,",
            "        loras: Dict[str, LoRALayerWeights],",
            "        scaling_factor: Optional[float] = None,",
            "    ) -> None:",
            "        \"\"\"",
            "        Args:",
            "            lora_model_id: The integer id for the lora model.",
            "            rank: lora rank.",
            "            loras: module name -> weights for lora-replaced layers.",
            "            scaling_factor: Scaling factor to support long context lora model.",
            "                None if the lora is not tuned for long context support.",
            "        \"\"\"",
            "        self.id = lora_model_id",
            "        # Scaling factor for long context lora model. None if it is not",
            "        # fine tuned for the long context.",
            "        self.scaling_factor = scaling_factor",
            "        assert (lora_model_id >",
            "                0), f\"a valid lora id should be greater than 0, got {self.id}\"",
            "        self.rank = rank",
            "        self.loras: Dict[str, LoRALayerWeights] = loras",
            "",
            "    def clone(self, lora_model_id: int) -> \"LoRAModel\":",
            "        \"\"\"Return a copy of the object with different ids.",
            "",
            "        Will share the underlying tensors.\"\"\"",
            "        return self.__class__(",
            "            lora_model_id,",
            "            rank=self.rank,",
            "            loras=self.loras.copy(),",
            "        )",
            "",
            "    @property",
            "    def extra_vocab_size(self) -> int:",
            "        return max(lora.extra_vocab_size",
            "                   for lora in self.loras.values()) if self.loras else 0",
            "",
            "    def get_lora(self, module_name: str) -> Optional[LoRALayerWeights]:",
            "        \"\"\"Get LoRA for a given module by name\"\"\"",
            "        return self.loras.get(module_name, None)",
            "",
            "    # (yard1): TODO see if we can derive target_embedding_padding automatically",
            "    @classmethod",
            "    def from_lora_tensors(",
            "        cls,",
            "        lora_model_id: int,",
            "        tensors: Dict[str, torch.Tensor],",
            "        peft_helper: PEFTHelper,",
            "        device: str = \"cuda\",",
            "        dtype: Optional[torch.dtype] = None,",
            "        embeddings: Optional[Dict[str, torch.Tensor]] = None,",
            "        target_embedding_padding: Optional[int] = None,",
            "        embedding_modules: Optional[Dict[str, str]] = None,",
            "        embedding_padding_modules: Optional[List[str]] = None,",
            "        weights_mapper: Optional[WeightsMapper] = None,",
            "    ) -> \"LoRAModel\":",
            "        \"\"\"Create a LoRAModel from a dictionary of tensors.\"\"\"",
            "        pin_memory = str(device) == \"cpu\" and is_pin_memory_available()",
            "        loras: Dict[str, LoRALayerWeights] = {}",
            "        for tensor_name, tensor in tensors.items():",
            "            module_name, is_lora_a, is_bias = parse_fine_tuned_lora_name(",
            "                tensor_name, weights_mapper)",
            "            if module_name not in loras:",
            "                lora_embeddings_tensor = None",
            "                if embeddings:",
            "                    assert embedding_modules is not None",
            "                    embeddings_module = next(",
            "                        (k for k in embedding_modules if k in module_name),",
            "                        None)",
            "                    if embeddings_module:",
            "                        lora_embeddings_tensor = embeddings[",
            "                            embedding_modules[embeddings_module]].to(",
            "                                device=device, dtype=dtype)",
            "                        if pin_memory:",
            "                            lora_embeddings_tensor = (",
            "                                lora_embeddings_tensor.pin_memory())",
            "                loras[module_name] = LoRALayerWeights.from_config(",
            "                    module_name, peft_helper, lora_embeddings_tensor)",
            "",
            "            if is_bias:",
            "                loras[module_name].bias = tensor.to(device=device,",
            "                                                    dtype=dtype).t()",
            "                bias = tensor.to(device=device, dtype=dtype).t()",
            "                if pin_memory:",
            "                    bias = bias.pin_memory()",
            "                loras[module_name].bias = bias",
            "            elif is_lora_a:",
            "                loras[module_name].lora_a = tensor.to(device=device,",
            "                                                      dtype=dtype).t()",
            "                if pin_memory:",
            "                    loras[module_name].lora_a = loras[",
            "                        module_name].lora_a.pin_memory()",
            "            else:",
            "                loras[module_name].lora_b = tensor.to(device=device,",
            "                                                      dtype=dtype).t()",
            "                assert embedding_padding_modules is not None",
            "                if any(name in module_name",
            "                       for name in embedding_padding_modules",
            "                       ) and target_embedding_padding is not None:",
            "                    lora_b = loras[module_name].lora_b",
            "                    assert target_embedding_padding >= lora_b.shape[1]",
            "                    addition = target_embedding_padding - lora_b.shape[1]",
            "                    loras[module_name].lora_b = torch.nn.functional.pad(",
            "                        lora_b, (0, addition))",
            "                if pin_memory:",
            "                    loras[module_name].lora_b = loras[",
            "                        module_name].lora_b.pin_memory()",
            "",
            "        for lora in loras.values():",
            "            lora.optimize()",
            "",
            "        return cls(lora_model_id,",
            "                   peft_helper.r,",
            "                   loras,",
            "                   scaling_factor=peft_helper.vllm_long_context_scaling_factor)",
            "",
            "    @classmethod",
            "    def from_local_checkpoint(",
            "        cls,",
            "        lora_dir: str,",
            "        expected_lora_modules: List[str],",
            "        peft_helper: PEFTHelper,",
            "        *,",
            "        lora_model_id: Optional[int] = None,",
            "        device: str = \"cuda\",",
            "        dtype: Optional[torch.dtype] = None,",
            "        target_embedding_padding: Optional[int] = None,",
            "        embedding_modules: Optional[Dict[str, str]] = None,",
            "        embedding_padding_modules: Optional[List[str]] = None,",
            "        weights_mapper: Optional[WeightsMapper] = None,",
            "    ) -> \"LoRAModel\":",
            "        \"\"\"Create a LoRAModel from a local checkpoint.",
            "        ",
            "        Args:",
            "            lora_dir: The local path that has lora data.",
            "            expected_lora_modules: Name of modules that are expected to be",
            "                replaced by lora.",
            "            peft_helper: Loaded lora configuration information.",
            "            lora_model_id: Lora model id. If not given, automatically set by",
            "                a global counter.",
            "            device: Device where the lora model is loaded.",
            "            dtype: dtype of the lora model weights.",
            "",
            "        Returns:",
            "            Loaded LoRA Model.",
            "        \"\"\"",
            "        lora_tensor_path = os.path.join(lora_dir, \"adapter_model.safetensors\")",
            "        lora_bin_file_path = os.path.join(lora_dir, \"adapter_model.bin\")",
            "        new_embeddings_tensor_path = os.path.join(",
            "            lora_dir, \"new_embeddings.safetensors\")",
            "        new_embeddings_bin_file_path = os.path.join(lora_dir,",
            "                                                    \"new_embeddings.bin\")",
            "",
            "        unexpected_modules: List[Union[list[str], str]]",
            "        if os.path.isfile(lora_tensor_path):",
            "            tensors: Dict[str, torch.Tensor] = {}",
            "            # Find unexpected modules.",
            "            # Use safetensor key as a source of truth to find expected modules.",
            "            # in peft if you have target_modules A, B, C and C does not exist",
            "            # in the model it won\u2019t error and model will be trained with A, B",
            "            # loraified. C won\u2019t exist in the safetensor but it will exist in",
            "            # the target_modules of the adapter_config.json.",
            "            unexpected_modules = []",
            "            with safetensors.safe_open(lora_tensor_path,",
            "                                       framework=\"pt\") as f:  # type: ignore",
            "                for lora_module in f.keys():  # noqa",
            "                    module_name, _, _ = parse_fine_tuned_lora_name(",
            "                        lora_module, weights_mapper)",
            "                    part_name = module_name.split(\".\")[-1]",
            "                    if part_name not in expected_lora_modules:",
            "                        unexpected_modules.append(module_name)",
            "                if unexpected_modules:",
            "                    raise ValueError(",
            "                        f\"While loading {lora_dir}, expected\"",
            "                        f\" target modules in {expected_lora_modules}\"",
            "                        f\" but received {unexpected_modules}.\"",
            "                        f\" Please verify that the loaded LoRA module is correct\"",
            "                    )",
            "                # Load tensors if there are only expected modules.",
            "                for module in f.keys():  # noqa",
            "                    tensors[module] = f.get_tensor(module)",
            "        elif os.path.isfile(lora_bin_file_path):",
            "            # When a bin file is provided, we rely on config to find unexpected",
            "            # modules.",
            "            unexpected_modules = []",
            "            target_modules = peft_helper.target_modules",
            "            if not isinstance(target_modules, list):",
            "                target_modules = [target_modules]",
            "            for module in target_modules:",
            "                # Compatible with more modules,",
            "                # such as:layers.11.self_attn.k_proj",
            "                part_name = module.split(\".\")[-1]",
            "                if part_name not in expected_lora_modules:",
            "                    unexpected_modules.append(module)",
            "            # loaded lora's target modules must be a subset of",
            "            # expected_lora_modules. It is not reliable. See",
            "            # https://github.com/vllm-project/vllm/pull/5909. But there's no",
            "            # other better mechanism.",
            "            if unexpected_modules and not is_regex_target_modules(",
            "                    peft_helper.target_modules, expected_lora_modules):",
            "                raise ValueError(",
            "                    f\"While loading {lora_dir}, expected\"",
            "                    f\" target modules in {expected_lora_modules}\"",
            "                    f\" but received {unexpected_modules}.\"",
            "                    f\" Please verify that the loaded LoRA module is correct\")",
            "            tensors = torch.load(lora_bin_file_path, map_location=device)",
            "        else:",
            "            raise ValueError(f\"{lora_dir} doesn't contain tensors\")",
            "",
            "        embeddings = None",
            "        if os.path.isfile(new_embeddings_tensor_path):",
            "            embeddings = safetensors.torch.load_file(",
            "                new_embeddings_tensor_path)",
            "        elif os.path.isfile(new_embeddings_bin_file_path):",
            "            embeddings = torch.load(new_embeddings_bin_file_path,",
            "                                    map_location=device)",
            "",
            "        return cls.from_lora_tensors(",
            "            lora_model_id=get_lora_id()",
            "            if lora_model_id is None else lora_model_id,",
            "            tensors=tensors,",
            "            peft_helper=peft_helper,",
            "            device=device,",
            "            dtype=dtype,",
            "            embeddings=embeddings,",
            "            target_embedding_padding=target_embedding_padding,",
            "            embedding_modules=embedding_modules,",
            "            embedding_padding_modules=embedding_padding_modules,",
            "            weights_mapper=weights_mapper)",
            "",
            "",
            "class LoRAModelManager(AdapterModelManager):",
            "    \"\"\"A manager that manages multiple LoRA-fine-tuned models.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        model: SupportsLoRA,",
            "        max_num_seqs: int,",
            "        max_num_batched_tokens: int,",
            "        vocab_size: int,",
            "        lora_config: LoRAConfig,",
            "        device: torch.device,",
            "    ):",
            "        \"\"\"Create a LoRAModelManager and adapter for a given model.",
            "",
            "        Args:",
            "            model: the model to be adapted.",
            "            max_num_seqs: the maximum number of sequences model can run in a",
            "                single batch.",
            "            max_num_batched_tokens: the maximum number of tokens model can run",
            "                in a single batch.",
            "            vocab_size: the vocab size of the model.",
            "            lora_config: the LoRA configuration.",
            "        \"\"\"",
            "        self.lora_config = lora_config",
            "        self.device = device",
            "        self.max_num_seqs = max_num_seqs",
            "        assert self.capacity >= self.lora_slots",
            "        self.max_num_batched_tokens = math.ceil(max_num_batched_tokens / 8) * 8",
            "        self.lora_index_to_id: List[Optional[int]] = [None] * self.lora_slots",
            "        self.vocab_size = vocab_size",
            "        self.long_lora_context: Optional[LongContextLoRAContext] = None",
            "        self.punica_wrapper = get_punica_wrapper(max_num_batched_tokens,",
            "                                                 max_batches=self.max_num_seqs,",
            "                                                 device=self.device)",
            "        # Scaling factor -> offset to the sin_cos_cache to it.",
            "        # Used for long context lora.",
            "        self.scaling_factor_to_offset: Dict[float, int] = {}",
            "        super().__init__(model)",
            "        if hasattr(self.model, \"supported_lora_modules\"):",
            "            self.supported_lora_modules = copy.deepcopy(",
            "                self.model.supported_lora_modules)",
            "            if lora_config.long_lora_scaling_factors:",
            "                # We need to replace rotary emb layer to do batch computation",
            "                # for long lora.",
            "                self.supported_lora_modules.append(\"rotary_emb\")",
            "            self.packed_modules_mapping = copy.deepcopy(",
            "                self.model.packed_modules_mapping)",
            "        # Used to indicate whether the model is a multimodal model",
            "        self.supports_mm: bool = (",
            "            supports_multimodal(self.model)",
            "            # In case the model only supports LoRA for",
            "            # text modules (e.g. ChatGLM)",
            "            and hasattr(self.model, \"get_mm_mapping\"))",
            "        self.packed_modules: Dict[str, List[str]] = {}",
            "        self.modules: Dict[str, BaseLayerWithLoRA] = {}",
            "        # Dict instead of a Set for compatibility with LRUCache.",
            "        self._last_mapping: Optional[LoRAMapping] = None",
            "        self._create_lora_modules()",
            "        self.model.lora_manager = self",
            "        self.adapter_type = 'LoRa'",
            "",
            "    @property",
            "    def capacity(self) -> int:",
            "        return self.lora_config.max_cpu_loras",
            "",
            "    @property",
            "    def lora_slots(self) -> int:",
            "        return self.lora_config.max_loras",
            "",
            "    @property",
            "    def adapter_slots(self) -> int:",
            "        return self.lora_slots",
            "",
            "    def activate_adapter(",
            "        self,",
            "        lora_id: int,",
            "    ) -> bool:",
            "        \"\"\"Move LoRA into a GPU buffer to be used in the forward pass.\"\"\"",
            "        if lora_id in self._active_adapters:",
            "            return False",
            "        first_free_slot = next(",
            "            ((i, lora_id) for i, lora_id in enumerate(self.lora_index_to_id)",
            "             if lora_id is None), None)",
            "        if first_free_slot is None:",
            "            raise ValueError(\"No free lora slots\")",
            "        index, _ = first_free_slot",
            "        self._active_adapters[lora_id] = None",
            "        lora_model = self._registered_adapters[lora_id]",
            "        logger.debug(\"Activating LoRA. int id: %d, slot index: %d\",",
            "                     lora_model.id, index)",
            "        self.lora_index_to_id[index] = lora_model.id",
            "        for module_name, module in self.modules.items():",
            "            module_lora = lora_model.get_lora(module_name)",
            "            if module_lora:",
            "                module_lora.optimize()",
            "                # Bias is not explicitly enabled with the flag enable_lora_bias.",
            "                bias = module_lora.bias",
            "                if ((torch.is_tensor(bias) or",
            "                     (isinstance(bias, Sequence) and any(b is not None",
            "                                                         for b in bias)))",
            "                        and not self.lora_config.bias_enabled):",
            "                    module_lora.bias = None",
            "                    raise ValueError(",
            "                        f\"Adapter bias cannot be used for {module_name}\"",
            "                        \" without --enable-lora-bias.\")",
            "                module.set_lora(index, module_lora.lora_a, module_lora.lora_b,",
            "                                module_lora.embeddings_tensor,",
            "                                module_lora.bias)",
            "            else:",
            "                module.reset_lora(index)",
            "        return True",
            "",
            "    def _deactivate_adapter(self, lora_id: int):",
            "        try:",
            "            index = self.lora_index_to_id.index(lora_id)",
            "            self.lora_index_to_id[index] = None",
            "        except ValueError:",
            "            pass",
            "",
            "    def _set_long_lora_context(self, lora: LoRAModel):",
            "        if self.long_lora_context is None:",
            "            return",
            "",
            "        if lora.scaling_factor is None:",
            "            return",
            "",
            "        if (lora.scaling_factor not in self.scaling_factor_to_offset):",
            "            raise ValueError(f\"Long LoRA scaling factor {lora.scaling_factor}\"",
            "                             \" has not been initialized.\")",
            "",
            "        offsets = self.scaling_factor_to_offset.get(lora.scaling_factor)",
            "        if offsets:",
            "            self.long_lora_context.offsets_by_lora_id[lora.id] = offsets",
            "",
            "    def _add_adapter(self, lora: LoRAModel):",
            "        self._create_merged_loras_inplace(lora)",
            "        self._registered_adapters[lora.id] = lora",
            "        self._set_long_lora_context(lora)",
            "",
            "    def pin_adapter(self, lora_id: int) -> bool:",
            "        \"\"\"Pin a LoRAModel in the manager cache.\"\"\"",
            "        raise NotImplementedError(",
            "            \"Pinning is not supported in LoRAModelManager.\"",
            "            \"Use LRUCacheLoRAModelManager for pinning\")  # type: ignore",
            "",
            "    def _set_adapter_mapping(self, mapping: LoRAMapping) -> None:",
            "        # update lora states",
            "        self.punica_wrapper.update_metadata(",
            "            mapping,",
            "            self.lora_index_to_id,",
            "            self.lora_slots + 1,",
            "            self.vocab_size,",
            "            self.lora_config.lora_extra_vocab_size,",
            "            self.long_lora_context,",
            "        )",
            "",
            "    def remove_all_adapters(self):",
            "        \"\"\"Remove all LoRAModels from the manager.\"\"\"",
            "        self._registered_adapters.clear()",
            "        self.lora_index_to_id = [None] * self.lora_slots",
            "        self._active_adapters.clear()",
            "",
            "    def _create_lora_modules(self):",
            "        for module_name, module in self.model.named_modules(",
            "                remove_duplicate=False):",
            "            if isinstance(module, PPMissingLayer):",
            "                continue",
            "            if not self._match_target_modules(module_name):",
            "                continue",
            "            # A temporary approach for multimodal models to support LoRA",
            "            # TODO: Remove this restriction",
            "            if self._filter_unsupported_mm_module(module_name):",
            "                logger.warning(",
            "                    \"Regarding multimodal models, vLLM currently only supports \"",
            "                    \"adding LoRA to language model, %s will be ignored.\",",
            "                    module_name,",
            "                )",
            "                continue",
            "            parts = module_name.split(\".\")[-1]",
            "            packed_moduled_lst = self.packed_modules_mapping.get(parts, [])",
            "            new_module = replace_submodule(",
            "                self.model, module_name,",
            "                from_layer(module, self.lora_slots, self.lora_config,",
            "                           packed_moduled_lst, self.model.config))",
            "",
            "            # LinearScalingRotaryEmbeddingWithLora is used to handle",
            "            # long context lora. Register relevant metadata.",
            "            if isinstance(new_module, LinearScalingRotaryEmbeddingWithLora):",
            "                self.long_lora_context = LongContextLoRAContext(",
            "                    new_module.scaling_factors, new_module.rotary_dim)",
            "                self.scaling_factor_to_offset = \\",
            "                    new_module.scaling_factor_to_offset",
            "            # (yard1): TODO make this more robust",
            "            if \"lm_head\" in module_name:",
            "                logits_processor_module = self.model.get_submodule(",
            "                    \"logits_processor\")",
            "                new_module = replace_submodule(",
            "                    self.model, \"logits_processor\",",
            "                    from_layer_logits_processor(logits_processor_module,",
            "                                                module, self.lora_slots,",
            "                                                self.lora_config,",
            "                                                self.model.config))",
            "",
            "            # In some models, especially multimodal ones, layers with the same",
            "            # name may have different types, such as nn.Linear and",
            "            # ReplicatedLinear. The nn.Linear layers cannot be replaced with",
            "            # LoRA layers, leading to assertion error. The following check",
            "            # aims to prevent this error",
            "            if self.supports_mm and not isinstance(new_module,",
            "                                                   BaseLayerWithLoRA):",
            "                continue",
            "            self.register_module(module_name, new_module)",
            "            self._register_packed_modules(module_name)",
            "            # All lora layers share the same punica_wrapper based on reference.",
            "            new_module.set_mapping(self.punica_wrapper)",
            "",
            "    def register_module(self, module_name: str, module: \"BaseLayerWithLoRA\"):",
            "        assert isinstance(module, BaseLayerWithLoRA)",
            "        self.modules[module_name] = module",
            "",
            "    def create_dummy_lora(",
            "            self,",
            "            lora_id: int,",
            "            rank: int,",
            "            scaling_factor: Optional[float],",
            "            embedding_modules: Optional[Dict[str, str]] = None) -> LoRAModel:",
            "        \"\"\"Create zero-initialized LoRAModel for warmup.\"\"\"",
            "        model = LoRAModel(lora_id, rank, {}, scaling_factor)",
            "        for module_name, module in self.model.named_modules():",
            "            bias_enabled = self.lora_config.bias_enabled",
            "            if (not self._match_target_modules(module_name)",
            "                    or not isinstance(module, BaseLayerWithLoRA)",
            "                    or isinstance(module, LinearScalingRotaryEmbeddingWithLora)",
            "                    or self._filter_unsupported_mm_module(module_name)):",
            "                continue",
            "            parts = module_name.split(\".\")",
            "            if module_name not in self.packed_modules:",
            "                assert embedding_modules is not None",
            "                if parts[-1] in embedding_modules:",
            "                    input_dim = (module.base_layer.org_vocab_size +",
            "                                 self.lora_config.lora_extra_vocab_size if",
            "                                 hasattr(module.base_layer, \"org_vocab_size\")",
            "                                 else module.base_layer.weight.shape[1])",
            "                    output_dim = module.base_layer.embedding_dim if hasattr(",
            "                        module.base_layer,",
            "                        \"embedding_dim\") else module.base_layer.weight.shape[0]",
            "                    embeddings_tensor_dim = (module.base_layer.embedding_dim if",
            "                                             hasattr(module.base_layer,",
            "                                                     \"embedding_dim\") else",
            "                                             module.base_layer.weight.shape[1])",
            "                    lora = LoRALayerWeights.create_dummy_lora_weights(",
            "                        module_name,",
            "                        input_dim,",
            "                        output_dim,",
            "                        rank,",
            "                        module.lora_a_stacked[0].dtype,",
            "                        \"cpu\",",
            "                        embeddings_tensor_dim=embeddings_tensor_dim,",
            "                        bias_enabled=bias_enabled)",
            "                else:",
            "                    lora = LoRALayerWeights.create_dummy_lora_weights(",
            "                        module_name,",
            "                        module.lora_a_stacked[0].shape[-1],",
            "                        module.lora_b_stacked[0].shape[-2],",
            "                        rank,",
            "                        module.lora_a_stacked[0].dtype,",
            "                        \"cpu\",",
            "                        bias_enabled=bias_enabled,",
            "                    )",
            "                lora.optimize()",
            "            else:",
            "                parts = module_name.split(\".\")",
            "                replacements = self.packed_modules_mapping[parts[-1]]",
            "                subloras: List[Optional[LoRALayerWeights]] = []",
            "                for i, r in enumerate(replacements):",
            "                    lora = LoRALayerWeights.create_dummy_lora_weights(",
            "                        module_name + \".\" + r,",
            "                        module.lora_a_stacked[i].shape[-1],",
            "                        module.lora_b_stacked[i].shape[-2],",
            "                        rank,",
            "                        module.lora_a_stacked[i].dtype,",
            "                        \"cpu\",",
            "                        bias_enabled=bias_enabled,",
            "                    )",
            "                    lora.optimize()",
            "                    subloras.append(lora)",
            "                lora = PackedLoRALayerWeights.pack(subloras)",
            "            model.loras[module_name] = lora",
            "        return model",
            "",
            "    def _match_target_modules(self, module_name: str):",
            "        return any(",
            "            re.match(",
            "                r\".*\\.{target_module}$\".format(target_module=target_module),",
            "                module_name) or target_module == module_name",
            "            for target_module in self.supported_lora_modules)",
            "",
            "    def _filter_unsupported_mm_module(self, module_name: str) -> bool:",
            "        \"\"\"",
            "        Regarding multimodal models, vLLM currently only supports adding LoRA to",
            "        language model. LoRA for other modules, such as the vision tower, will ",
            "        be filtered out.",
            "        \"\"\"",
            "        if self.supports_mm:",
            "            module_mapping: MultiModelKeys = self.model.get_mm_mapping()",
            "            prefix_lst = module_mapping.connector + module_mapping.tower_model",
            "            return any(",
            "                [module_name.startswith(prefix) for prefix in prefix_lst])",
            "        return False",
            "",
            "    def _register_packed_modules(self, module_full_name: str) -> None:",
            "        parts = module_full_name.split(\".\")",
            "        module_name = parts[-1]",
            "        replacements = self.packed_modules_mapping.get(module_name, [])",
            "        # When replacements is less than or equal to 1, it indicates that this",
            "        # module is not a packed module.",
            "        if len(replacements) <= 1:",
            "            return",
            "        prefix = \".\".join(parts[:-1])",
            "        self.packed_modules[module_full_name] = [",
            "            prefix + \".\" + r if prefix else r for r in replacements",
            "        ]",
            "",
            "    def _create_merged_loras_inplace(self, lora_model: LoRAModel) -> None:",
            "        for module_name, new_module_names in self.packed_modules.items():",
            "            replacement_loras: List[Optional[LoRALayerWeights]] = []",
            "            has_replacement = False",
            "            for r in new_module_names:",
            "                lora = lora_model.get_lora(r)",
            "                replacement_loras.append(lora)",
            "                if lora:",
            "                    has_replacement = True",
            "            if not has_replacement:",
            "                continue",
            "            for i in range(len(replacement_loras)):",
            "                if replacement_loras[i]:",
            "                    continue",
            "                replacement_loras[i] = None",
            "            lora_model.loras[module_name] = PackedLoRALayerWeights.pack(",
            "                replacement_loras)",
            "",
            "    def deactivate_adapter(self, adapter_id: int) -> bool:",
            "        return deactivate_adapter(adapter_id, self._active_adapters,",
            "                                  self._deactivate_adapter)",
            "",
            "    def add_adapter(self, adapter: LoRAModel) -> bool:",
            "        logger.debug(",
            "            \"Adding lora. Model id: %d, \"",
            "            \"int id: %d, \"",
            "            \"scaling factor: %s\", adapter.id, adapter.id,",
            "            adapter.scaling_factor)",
            "        return add_adapter(adapter, self._registered_adapters, self.capacity,",
            "                           self._add_adapter)",
            "",
            "    def set_adapter_mapping(self, mapping: LoRAMapping) -> None:",
            "        self._last_mapping = set_adapter_mapping(mapping, self._last_mapping,",
            "                                                 self._set_adapter_mapping)",
            "",
            "    def remove_adapter(self, adapter_id: int) -> bool:",
            "        return remove_adapter(adapter_id, self._registered_adapters,",
            "                              self.deactivate_adapter)",
            "",
            "    def list_adapters(self) -> Dict[int, Any]:",
            "        return list_adapters(self._registered_adapters)",
            "",
            "    def get_adapter(self, adapter_id: int) -> Optional[Any]:",
            "        return get_adapter(adapter_id, self._registered_adapters)",
            "",
            "",
            "class LoRALRUCache(AdapterLRUCache[LoRAModel]):",
            "",
            "    def __init__(self, capacity: int, deactivate_lora_fn: Callable[[int],",
            "                                                                   bool]):",
            "        super().__init__(capacity, deactivate_lora_fn)",
            "",
            "",
            "class LRUCacheLoRAModelManager(LoRAModelManager):",
            "    \"\"\"A model manager that manages multiple LoRAs with LRU cache.\"\"\"",
            "",
            "    def __init__(self, model: nn.Module, max_num_seqs: int,",
            "                 max_num_batched_tokens: int, vocab_size: int,",
            "                 lora_config: LoRAConfig, device: torch.device):",
            "        super().__init__(model, max_num_seqs, max_num_batched_tokens,",
            "                         vocab_size, lora_config, device)",
            "        self._registered_adapters: LoRALRUCache = LoRALRUCache(",
            "            self.capacity, self.deactivate_adapter)",
            "        self._active_adapters: LoRALRUCache = LoRALRUCache(",
            "            self.lora_slots, self._deactivate_adapter)",
            "",
            "    def list_adapters(self) -> Dict[int, LoRAModel]:",
            "        \"\"\"List all registered LoRAModels.\"\"\"",
            "        return dict(self._registered_adapters.cache)",
            "",
            "    def add_adapter(self, lora: LoRAModel) -> bool:",
            "        \"\"\"Add a LoRAModel to the manager.\"\"\"",
            "        logger.debug(",
            "            \"Adding lora. Model id: %d, \"",
            "            \"int id: %d, \"",
            "            \"scaling factor: %s\", lora.id, lora.id, lora.scaling_factor)",
            "        if lora.id not in self._registered_adapters:",
            "            self._add_adapter(lora)",
            "            was_added = True",
            "        else:",
            "            # We always touch to update the LRU cache order",
            "            self._registered_adapters.touch(lora.id)",
            "            was_added = False",
            "        return was_added",
            "",
            "    def activate_adapter(",
            "        self,",
            "        lora_id: int,",
            "    ) -> bool:",
            "        if lora_id not in self._active_adapters and len(",
            "                self._active_adapters) >= self.lora_slots:",
            "            self._active_adapters.remove_oldest()",
            "        result = super().activate_adapter(lora_id)",
            "        # We always touch to update the LRU cache order",
            "        self._active_adapters.touch(lora_id)",
            "        return result",
            "",
            "    def remove_oldest_adapter(self) -> bool:",
            "        if len(self._registered_adapters) > 0:",
            "            self._registered_adapters.remove_oldest()",
            "            return True",
            "        return False",
            "",
            "    def pin_adapter(self, lora_id: int) -> bool:",
            "        \"\"\"Pin a LoRAModel in the manager cache.\"\"\"",
            "        self._pin_lora_in_cpu_cache(lora_id)",
            "        self._pin_lora_in_gpu_cache(lora_id)",
            "        return True",
            "",
            "    def _pin_lora_in_cpu_cache(self, lora_id: int):",
            "        try:",
            "            self._registered_adapters.pin(lora_id)",
            "        except ValueError as err:",
            "            raise ValueError(\"Pinning failed. \"",
            "                             f\"LoRA {lora_id} is not registered.\") from err",
            "",
            "    def _pin_lora_in_gpu_cache(self, lora_id: int):",
            "        if lora_id not in self._active_adapters:",
            "            # move lora to gpu if not already active",
            "            self.activate_adapter(lora_id)",
            "",
            "        self._active_adapters.pin(lora_id)",
            "",
            "",
            "def create_lora_manager(",
            "        model: nn.Module,",
            "        max_num_seqs: int,",
            "        max_num_batched_tokens: int,",
            "        vocab_size: int,",
            "        lora_config: LoRAConfig,",
            "        device: torch.device,",
            "        lora_manager_cls: Type[LoRAModelManager] = LoRAModelManager,",
            "        **kwargs) -> LoRAModelManager:",
            "    \"\"\"Create a LoRA adapter for a given model.\"\"\"",
            "    if not hasattr(model, \"supported_lora_modules\"):",
            "        raise ValueError(f\"Model {type(model)} is not supported for LoRA.\")",
            "    lora_manager = lora_manager_cls(",
            "        model=model,",
            "        max_num_seqs=max_num_seqs,",
            "        max_num_batched_tokens=max_num_batched_tokens,",
            "        vocab_size=vocab_size,",
            "        lora_config=lora_config,",
            "        device=device,",
            "        **kwargs)",
            "    return lora_manager"
        ],
        "afterPatchFile": [
            "import copy",
            "import math",
            "import os",
            "import re",
            "from dataclasses import dataclass, field",
            "from typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union",
            "",
            "import safetensors.torch",
            "import torch",
            "from torch import nn",
            "",
            "from vllm.adapter_commons.models import (AdapterLRUCache, AdapterModel,",
            "                                         AdapterModelManager)",
            "from vllm.adapter_commons.utils import (add_adapter, deactivate_adapter,",
            "                                        get_adapter, list_adapters,",
            "                                        remove_adapter, set_adapter_mapping)",
            "from vllm.config import LoRAConfig",
            "from vllm.logger import init_logger",
            "from vllm.lora.layers import (BaseLayerWithLoRA,",
            "                              LinearScalingRotaryEmbeddingWithLora,",
            "                              LoRAMapping)",
            "from vllm.lora.lora import LoRALayerWeights, PackedLoRALayerWeights",
            "from vllm.lora.peft_helper import PEFTHelper",
            "from vllm.lora.punica_wrapper import get_punica_wrapper",
            "from vllm.lora.utils import (from_layer, from_layer_logits_processor,",
            "                             is_regex_target_modules,",
            "                             parse_fine_tuned_lora_name, replace_submodule)",
            "from vllm.model_executor.models import SupportsLoRA, supports_multimodal",
            "from vllm.model_executor.models.module_mapping import MultiModelKeys",
            "from vllm.model_executor.models.utils import PPMissingLayer, WeightsMapper",
            "from vllm.utils import is_pin_memory_available",
            "",
            "logger = init_logger(__name__)",
            "",
            "_GLOBAL_LORA_ID = 0",
            "",
            "",
            "@dataclass",
            "class LongContextLoRAContext:",
            "    \"\"\"Context for lora adapters that support long context.\"\"\"",
            "    # The scaling factors to support long context lora fine tuned models.",
            "    scaling_factors: List[float]",
            "    # dimension to apply rotary embedding.",
            "    rot_dim: int",
            "    # offsets to the sin_cos_cache for each lora_id loaded.",
            "    # This value is dynamically modified.",
            "    offsets_by_lora_id: Dict[int, int] = field(default_factory=dict)",
            "",
            "",
            "def get_lora_id():",
            "    global _GLOBAL_LORA_ID",
            "    _GLOBAL_LORA_ID += 1",
            "    return _GLOBAL_LORA_ID",
            "",
            "",
            "class LoRAModel(AdapterModel):",
            "    \"\"\"A LoRA fine-tuned model.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        lora_model_id: int,",
            "        rank: int,",
            "        loras: Dict[str, LoRALayerWeights],",
            "        scaling_factor: Optional[float] = None,",
            "    ) -> None:",
            "        \"\"\"",
            "        Args:",
            "            lora_model_id: The integer id for the lora model.",
            "            rank: lora rank.",
            "            loras: module name -> weights for lora-replaced layers.",
            "            scaling_factor: Scaling factor to support long context lora model.",
            "                None if the lora is not tuned for long context support.",
            "        \"\"\"",
            "        self.id = lora_model_id",
            "        # Scaling factor for long context lora model. None if it is not",
            "        # fine tuned for the long context.",
            "        self.scaling_factor = scaling_factor",
            "        assert (lora_model_id >",
            "                0), f\"a valid lora id should be greater than 0, got {self.id}\"",
            "        self.rank = rank",
            "        self.loras: Dict[str, LoRALayerWeights] = loras",
            "",
            "    def clone(self, lora_model_id: int) -> \"LoRAModel\":",
            "        \"\"\"Return a copy of the object with different ids.",
            "",
            "        Will share the underlying tensors.\"\"\"",
            "        return self.__class__(",
            "            lora_model_id,",
            "            rank=self.rank,",
            "            loras=self.loras.copy(),",
            "        )",
            "",
            "    @property",
            "    def extra_vocab_size(self) -> int:",
            "        return max(lora.extra_vocab_size",
            "                   for lora in self.loras.values()) if self.loras else 0",
            "",
            "    def get_lora(self, module_name: str) -> Optional[LoRALayerWeights]:",
            "        \"\"\"Get LoRA for a given module by name\"\"\"",
            "        return self.loras.get(module_name, None)",
            "",
            "    # (yard1): TODO see if we can derive target_embedding_padding automatically",
            "    @classmethod",
            "    def from_lora_tensors(",
            "        cls,",
            "        lora_model_id: int,",
            "        tensors: Dict[str, torch.Tensor],",
            "        peft_helper: PEFTHelper,",
            "        device: str = \"cuda\",",
            "        dtype: Optional[torch.dtype] = None,",
            "        embeddings: Optional[Dict[str, torch.Tensor]] = None,",
            "        target_embedding_padding: Optional[int] = None,",
            "        embedding_modules: Optional[Dict[str, str]] = None,",
            "        embedding_padding_modules: Optional[List[str]] = None,",
            "        weights_mapper: Optional[WeightsMapper] = None,",
            "    ) -> \"LoRAModel\":",
            "        \"\"\"Create a LoRAModel from a dictionary of tensors.\"\"\"",
            "        pin_memory = str(device) == \"cpu\" and is_pin_memory_available()",
            "        loras: Dict[str, LoRALayerWeights] = {}",
            "        for tensor_name, tensor in tensors.items():",
            "            module_name, is_lora_a, is_bias = parse_fine_tuned_lora_name(",
            "                tensor_name, weights_mapper)",
            "            if module_name not in loras:",
            "                lora_embeddings_tensor = None",
            "                if embeddings:",
            "                    assert embedding_modules is not None",
            "                    embeddings_module = next(",
            "                        (k for k in embedding_modules if k in module_name),",
            "                        None)",
            "                    if embeddings_module:",
            "                        lora_embeddings_tensor = embeddings[",
            "                            embedding_modules[embeddings_module]].to(",
            "                                device=device, dtype=dtype)",
            "                        if pin_memory:",
            "                            lora_embeddings_tensor = (",
            "                                lora_embeddings_tensor.pin_memory())",
            "                loras[module_name] = LoRALayerWeights.from_config(",
            "                    module_name, peft_helper, lora_embeddings_tensor)",
            "",
            "            if is_bias:",
            "                loras[module_name].bias = tensor.to(device=device,",
            "                                                    dtype=dtype).t()",
            "                bias = tensor.to(device=device, dtype=dtype).t()",
            "                if pin_memory:",
            "                    bias = bias.pin_memory()",
            "                loras[module_name].bias = bias",
            "            elif is_lora_a:",
            "                loras[module_name].lora_a = tensor.to(device=device,",
            "                                                      dtype=dtype).t()",
            "                if pin_memory:",
            "                    loras[module_name].lora_a = loras[",
            "                        module_name].lora_a.pin_memory()",
            "            else:",
            "                loras[module_name].lora_b = tensor.to(device=device,",
            "                                                      dtype=dtype).t()",
            "                assert embedding_padding_modules is not None",
            "                if any(name in module_name",
            "                       for name in embedding_padding_modules",
            "                       ) and target_embedding_padding is not None:",
            "                    lora_b = loras[module_name].lora_b",
            "                    assert target_embedding_padding >= lora_b.shape[1]",
            "                    addition = target_embedding_padding - lora_b.shape[1]",
            "                    loras[module_name].lora_b = torch.nn.functional.pad(",
            "                        lora_b, (0, addition))",
            "                if pin_memory:",
            "                    loras[module_name].lora_b = loras[",
            "                        module_name].lora_b.pin_memory()",
            "",
            "        for lora in loras.values():",
            "            lora.optimize()",
            "",
            "        return cls(lora_model_id,",
            "                   peft_helper.r,",
            "                   loras,",
            "                   scaling_factor=peft_helper.vllm_long_context_scaling_factor)",
            "",
            "    @classmethod",
            "    def from_local_checkpoint(",
            "        cls,",
            "        lora_dir: str,",
            "        expected_lora_modules: List[str],",
            "        peft_helper: PEFTHelper,",
            "        *,",
            "        lora_model_id: Optional[int] = None,",
            "        device: str = \"cuda\",",
            "        dtype: Optional[torch.dtype] = None,",
            "        target_embedding_padding: Optional[int] = None,",
            "        embedding_modules: Optional[Dict[str, str]] = None,",
            "        embedding_padding_modules: Optional[List[str]] = None,",
            "        weights_mapper: Optional[WeightsMapper] = None,",
            "    ) -> \"LoRAModel\":",
            "        \"\"\"Create a LoRAModel from a local checkpoint.",
            "        ",
            "        Args:",
            "            lora_dir: The local path that has lora data.",
            "            expected_lora_modules: Name of modules that are expected to be",
            "                replaced by lora.",
            "            peft_helper: Loaded lora configuration information.",
            "            lora_model_id: Lora model id. If not given, automatically set by",
            "                a global counter.",
            "            device: Device where the lora model is loaded.",
            "            dtype: dtype of the lora model weights.",
            "",
            "        Returns:",
            "            Loaded LoRA Model.",
            "        \"\"\"",
            "        lora_tensor_path = os.path.join(lora_dir, \"adapter_model.safetensors\")",
            "        lora_bin_file_path = os.path.join(lora_dir, \"adapter_model.bin\")",
            "        new_embeddings_tensor_path = os.path.join(",
            "            lora_dir, \"new_embeddings.safetensors\")",
            "        new_embeddings_bin_file_path = os.path.join(lora_dir,",
            "                                                    \"new_embeddings.bin\")",
            "",
            "        unexpected_modules: List[Union[list[str], str]]",
            "        if os.path.isfile(lora_tensor_path):",
            "            tensors: Dict[str, torch.Tensor] = {}",
            "            # Find unexpected modules.",
            "            # Use safetensor key as a source of truth to find expected modules.",
            "            # in peft if you have target_modules A, B, C and C does not exist",
            "            # in the model it won\u2019t error and model will be trained with A, B",
            "            # loraified. C won\u2019t exist in the safetensor but it will exist in",
            "            # the target_modules of the adapter_config.json.",
            "            unexpected_modules = []",
            "            with safetensors.safe_open(lora_tensor_path,",
            "                                       framework=\"pt\") as f:  # type: ignore",
            "                for lora_module in f.keys():  # noqa",
            "                    module_name, _, _ = parse_fine_tuned_lora_name(",
            "                        lora_module, weights_mapper)",
            "                    part_name = module_name.split(\".\")[-1]",
            "                    if part_name not in expected_lora_modules:",
            "                        unexpected_modules.append(module_name)",
            "                if unexpected_modules:",
            "                    raise ValueError(",
            "                        f\"While loading {lora_dir}, expected\"",
            "                        f\" target modules in {expected_lora_modules}\"",
            "                        f\" but received {unexpected_modules}.\"",
            "                        f\" Please verify that the loaded LoRA module is correct\"",
            "                    )",
            "                # Load tensors if there are only expected modules.",
            "                for module in f.keys():  # noqa",
            "                    tensors[module] = f.get_tensor(module)",
            "        elif os.path.isfile(lora_bin_file_path):",
            "            # When a bin file is provided, we rely on config to find unexpected",
            "            # modules.",
            "            unexpected_modules = []",
            "            target_modules = peft_helper.target_modules",
            "            if not isinstance(target_modules, list):",
            "                target_modules = [target_modules]",
            "            for module in target_modules:",
            "                # Compatible with more modules,",
            "                # such as:layers.11.self_attn.k_proj",
            "                part_name = module.split(\".\")[-1]",
            "                if part_name not in expected_lora_modules:",
            "                    unexpected_modules.append(module)",
            "            # loaded lora's target modules must be a subset of",
            "            # expected_lora_modules. It is not reliable. See",
            "            # https://github.com/vllm-project/vllm/pull/5909. But there's no",
            "            # other better mechanism.",
            "            if unexpected_modules and not is_regex_target_modules(",
            "                    peft_helper.target_modules, expected_lora_modules):",
            "                raise ValueError(",
            "                    f\"While loading {lora_dir}, expected\"",
            "                    f\" target modules in {expected_lora_modules}\"",
            "                    f\" but received {unexpected_modules}.\"",
            "                    f\" Please verify that the loaded LoRA module is correct\")",
            "            tensors = torch.load(lora_bin_file_path, map_location=device)",
            "        else:",
            "            raise ValueError(f\"{lora_dir} doesn't contain tensors\")",
            "",
            "        embeddings = None",
            "        if os.path.isfile(new_embeddings_tensor_path):",
            "            embeddings = safetensors.torch.load_file(",
            "                new_embeddings_tensor_path)",
            "        elif os.path.isfile(new_embeddings_bin_file_path):",
            "            embeddings = torch.load(new_embeddings_bin_file_path,",
            "                                    map_location=device,",
            "                                    weights_only=True)",
            "",
            "        return cls.from_lora_tensors(",
            "            lora_model_id=get_lora_id()",
            "            if lora_model_id is None else lora_model_id,",
            "            tensors=tensors,",
            "            peft_helper=peft_helper,",
            "            device=device,",
            "            dtype=dtype,",
            "            embeddings=embeddings,",
            "            target_embedding_padding=target_embedding_padding,",
            "            embedding_modules=embedding_modules,",
            "            embedding_padding_modules=embedding_padding_modules,",
            "            weights_mapper=weights_mapper)",
            "",
            "",
            "class LoRAModelManager(AdapterModelManager):",
            "    \"\"\"A manager that manages multiple LoRA-fine-tuned models.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        model: SupportsLoRA,",
            "        max_num_seqs: int,",
            "        max_num_batched_tokens: int,",
            "        vocab_size: int,",
            "        lora_config: LoRAConfig,",
            "        device: torch.device,",
            "    ):",
            "        \"\"\"Create a LoRAModelManager and adapter for a given model.",
            "",
            "        Args:",
            "            model: the model to be adapted.",
            "            max_num_seqs: the maximum number of sequences model can run in a",
            "                single batch.",
            "            max_num_batched_tokens: the maximum number of tokens model can run",
            "                in a single batch.",
            "            vocab_size: the vocab size of the model.",
            "            lora_config: the LoRA configuration.",
            "        \"\"\"",
            "        self.lora_config = lora_config",
            "        self.device = device",
            "        self.max_num_seqs = max_num_seqs",
            "        assert self.capacity >= self.lora_slots",
            "        self.max_num_batched_tokens = math.ceil(max_num_batched_tokens / 8) * 8",
            "        self.lora_index_to_id: List[Optional[int]] = [None] * self.lora_slots",
            "        self.vocab_size = vocab_size",
            "        self.long_lora_context: Optional[LongContextLoRAContext] = None",
            "        self.punica_wrapper = get_punica_wrapper(max_num_batched_tokens,",
            "                                                 max_batches=self.max_num_seqs,",
            "                                                 device=self.device)",
            "        # Scaling factor -> offset to the sin_cos_cache to it.",
            "        # Used for long context lora.",
            "        self.scaling_factor_to_offset: Dict[float, int] = {}",
            "        super().__init__(model)",
            "        if hasattr(self.model, \"supported_lora_modules\"):",
            "            self.supported_lora_modules = copy.deepcopy(",
            "                self.model.supported_lora_modules)",
            "            if lora_config.long_lora_scaling_factors:",
            "                # We need to replace rotary emb layer to do batch computation",
            "                # for long lora.",
            "                self.supported_lora_modules.append(\"rotary_emb\")",
            "            self.packed_modules_mapping = copy.deepcopy(",
            "                self.model.packed_modules_mapping)",
            "        # Used to indicate whether the model is a multimodal model",
            "        self.supports_mm: bool = (",
            "            supports_multimodal(self.model)",
            "            # In case the model only supports LoRA for",
            "            # text modules (e.g. ChatGLM)",
            "            and hasattr(self.model, \"get_mm_mapping\"))",
            "        self.packed_modules: Dict[str, List[str]] = {}",
            "        self.modules: Dict[str, BaseLayerWithLoRA] = {}",
            "        # Dict instead of a Set for compatibility with LRUCache.",
            "        self._last_mapping: Optional[LoRAMapping] = None",
            "        self._create_lora_modules()",
            "        self.model.lora_manager = self",
            "        self.adapter_type = 'LoRa'",
            "",
            "    @property",
            "    def capacity(self) -> int:",
            "        return self.lora_config.max_cpu_loras",
            "",
            "    @property",
            "    def lora_slots(self) -> int:",
            "        return self.lora_config.max_loras",
            "",
            "    @property",
            "    def adapter_slots(self) -> int:",
            "        return self.lora_slots",
            "",
            "    def activate_adapter(",
            "        self,",
            "        lora_id: int,",
            "    ) -> bool:",
            "        \"\"\"Move LoRA into a GPU buffer to be used in the forward pass.\"\"\"",
            "        if lora_id in self._active_adapters:",
            "            return False",
            "        first_free_slot = next(",
            "            ((i, lora_id) for i, lora_id in enumerate(self.lora_index_to_id)",
            "             if lora_id is None), None)",
            "        if first_free_slot is None:",
            "            raise ValueError(\"No free lora slots\")",
            "        index, _ = first_free_slot",
            "        self._active_adapters[lora_id] = None",
            "        lora_model = self._registered_adapters[lora_id]",
            "        logger.debug(\"Activating LoRA. int id: %d, slot index: %d\",",
            "                     lora_model.id, index)",
            "        self.lora_index_to_id[index] = lora_model.id",
            "        for module_name, module in self.modules.items():",
            "            module_lora = lora_model.get_lora(module_name)",
            "            if module_lora:",
            "                module_lora.optimize()",
            "                # Bias is not explicitly enabled with the flag enable_lora_bias.",
            "                bias = module_lora.bias",
            "                if ((torch.is_tensor(bias) or",
            "                     (isinstance(bias, Sequence) and any(b is not None",
            "                                                         for b in bias)))",
            "                        and not self.lora_config.bias_enabled):",
            "                    module_lora.bias = None",
            "                    raise ValueError(",
            "                        f\"Adapter bias cannot be used for {module_name}\"",
            "                        \" without --enable-lora-bias.\")",
            "                module.set_lora(index, module_lora.lora_a, module_lora.lora_b,",
            "                                module_lora.embeddings_tensor,",
            "                                module_lora.bias)",
            "            else:",
            "                module.reset_lora(index)",
            "        return True",
            "",
            "    def _deactivate_adapter(self, lora_id: int):",
            "        try:",
            "            index = self.lora_index_to_id.index(lora_id)",
            "            self.lora_index_to_id[index] = None",
            "        except ValueError:",
            "            pass",
            "",
            "    def _set_long_lora_context(self, lora: LoRAModel):",
            "        if self.long_lora_context is None:",
            "            return",
            "",
            "        if lora.scaling_factor is None:",
            "            return",
            "",
            "        if (lora.scaling_factor not in self.scaling_factor_to_offset):",
            "            raise ValueError(f\"Long LoRA scaling factor {lora.scaling_factor}\"",
            "                             \" has not been initialized.\")",
            "",
            "        offsets = self.scaling_factor_to_offset.get(lora.scaling_factor)",
            "        if offsets:",
            "            self.long_lora_context.offsets_by_lora_id[lora.id] = offsets",
            "",
            "    def _add_adapter(self, lora: LoRAModel):",
            "        self._create_merged_loras_inplace(lora)",
            "        self._registered_adapters[lora.id] = lora",
            "        self._set_long_lora_context(lora)",
            "",
            "    def pin_adapter(self, lora_id: int) -> bool:",
            "        \"\"\"Pin a LoRAModel in the manager cache.\"\"\"",
            "        raise NotImplementedError(",
            "            \"Pinning is not supported in LoRAModelManager.\"",
            "            \"Use LRUCacheLoRAModelManager for pinning\")  # type: ignore",
            "",
            "    def _set_adapter_mapping(self, mapping: LoRAMapping) -> None:",
            "        # update lora states",
            "        self.punica_wrapper.update_metadata(",
            "            mapping,",
            "            self.lora_index_to_id,",
            "            self.lora_slots + 1,",
            "            self.vocab_size,",
            "            self.lora_config.lora_extra_vocab_size,",
            "            self.long_lora_context,",
            "        )",
            "",
            "    def remove_all_adapters(self):",
            "        \"\"\"Remove all LoRAModels from the manager.\"\"\"",
            "        self._registered_adapters.clear()",
            "        self.lora_index_to_id = [None] * self.lora_slots",
            "        self._active_adapters.clear()",
            "",
            "    def _create_lora_modules(self):",
            "        for module_name, module in self.model.named_modules(",
            "                remove_duplicate=False):",
            "            if isinstance(module, PPMissingLayer):",
            "                continue",
            "            if not self._match_target_modules(module_name):",
            "                continue",
            "            # A temporary approach for multimodal models to support LoRA",
            "            # TODO: Remove this restriction",
            "            if self._filter_unsupported_mm_module(module_name):",
            "                logger.warning(",
            "                    \"Regarding multimodal models, vLLM currently only supports \"",
            "                    \"adding LoRA to language model, %s will be ignored.\",",
            "                    module_name,",
            "                )",
            "                continue",
            "            parts = module_name.split(\".\")[-1]",
            "            packed_moduled_lst = self.packed_modules_mapping.get(parts, [])",
            "            new_module = replace_submodule(",
            "                self.model, module_name,",
            "                from_layer(module, self.lora_slots, self.lora_config,",
            "                           packed_moduled_lst, self.model.config))",
            "",
            "            # LinearScalingRotaryEmbeddingWithLora is used to handle",
            "            # long context lora. Register relevant metadata.",
            "            if isinstance(new_module, LinearScalingRotaryEmbeddingWithLora):",
            "                self.long_lora_context = LongContextLoRAContext(",
            "                    new_module.scaling_factors, new_module.rotary_dim)",
            "                self.scaling_factor_to_offset = \\",
            "                    new_module.scaling_factor_to_offset",
            "            # (yard1): TODO make this more robust",
            "            if \"lm_head\" in module_name:",
            "                logits_processor_module = self.model.get_submodule(",
            "                    \"logits_processor\")",
            "                new_module = replace_submodule(",
            "                    self.model, \"logits_processor\",",
            "                    from_layer_logits_processor(logits_processor_module,",
            "                                                module, self.lora_slots,",
            "                                                self.lora_config,",
            "                                                self.model.config))",
            "",
            "            # In some models, especially multimodal ones, layers with the same",
            "            # name may have different types, such as nn.Linear and",
            "            # ReplicatedLinear. The nn.Linear layers cannot be replaced with",
            "            # LoRA layers, leading to assertion error. The following check",
            "            # aims to prevent this error",
            "            if self.supports_mm and not isinstance(new_module,",
            "                                                   BaseLayerWithLoRA):",
            "                continue",
            "            self.register_module(module_name, new_module)",
            "            self._register_packed_modules(module_name)",
            "            # All lora layers share the same punica_wrapper based on reference.",
            "            new_module.set_mapping(self.punica_wrapper)",
            "",
            "    def register_module(self, module_name: str, module: \"BaseLayerWithLoRA\"):",
            "        assert isinstance(module, BaseLayerWithLoRA)",
            "        self.modules[module_name] = module",
            "",
            "    def create_dummy_lora(",
            "            self,",
            "            lora_id: int,",
            "            rank: int,",
            "            scaling_factor: Optional[float],",
            "            embedding_modules: Optional[Dict[str, str]] = None) -> LoRAModel:",
            "        \"\"\"Create zero-initialized LoRAModel for warmup.\"\"\"",
            "        model = LoRAModel(lora_id, rank, {}, scaling_factor)",
            "        for module_name, module in self.model.named_modules():",
            "            bias_enabled = self.lora_config.bias_enabled",
            "            if (not self._match_target_modules(module_name)",
            "                    or not isinstance(module, BaseLayerWithLoRA)",
            "                    or isinstance(module, LinearScalingRotaryEmbeddingWithLora)",
            "                    or self._filter_unsupported_mm_module(module_name)):",
            "                continue",
            "            parts = module_name.split(\".\")",
            "            if module_name not in self.packed_modules:",
            "                assert embedding_modules is not None",
            "                if parts[-1] in embedding_modules:",
            "                    input_dim = (module.base_layer.org_vocab_size +",
            "                                 self.lora_config.lora_extra_vocab_size if",
            "                                 hasattr(module.base_layer, \"org_vocab_size\")",
            "                                 else module.base_layer.weight.shape[1])",
            "                    output_dim = module.base_layer.embedding_dim if hasattr(",
            "                        module.base_layer,",
            "                        \"embedding_dim\") else module.base_layer.weight.shape[0]",
            "                    embeddings_tensor_dim = (module.base_layer.embedding_dim if",
            "                                             hasattr(module.base_layer,",
            "                                                     \"embedding_dim\") else",
            "                                             module.base_layer.weight.shape[1])",
            "                    lora = LoRALayerWeights.create_dummy_lora_weights(",
            "                        module_name,",
            "                        input_dim,",
            "                        output_dim,",
            "                        rank,",
            "                        module.lora_a_stacked[0].dtype,",
            "                        \"cpu\",",
            "                        embeddings_tensor_dim=embeddings_tensor_dim,",
            "                        bias_enabled=bias_enabled)",
            "                else:",
            "                    lora = LoRALayerWeights.create_dummy_lora_weights(",
            "                        module_name,",
            "                        module.lora_a_stacked[0].shape[-1],",
            "                        module.lora_b_stacked[0].shape[-2],",
            "                        rank,",
            "                        module.lora_a_stacked[0].dtype,",
            "                        \"cpu\",",
            "                        bias_enabled=bias_enabled,",
            "                    )",
            "                lora.optimize()",
            "            else:",
            "                parts = module_name.split(\".\")",
            "                replacements = self.packed_modules_mapping[parts[-1]]",
            "                subloras: List[Optional[LoRALayerWeights]] = []",
            "                for i, r in enumerate(replacements):",
            "                    lora = LoRALayerWeights.create_dummy_lora_weights(",
            "                        module_name + \".\" + r,",
            "                        module.lora_a_stacked[i].shape[-1],",
            "                        module.lora_b_stacked[i].shape[-2],",
            "                        rank,",
            "                        module.lora_a_stacked[i].dtype,",
            "                        \"cpu\",",
            "                        bias_enabled=bias_enabled,",
            "                    )",
            "                    lora.optimize()",
            "                    subloras.append(lora)",
            "                lora = PackedLoRALayerWeights.pack(subloras)",
            "            model.loras[module_name] = lora",
            "        return model",
            "",
            "    def _match_target_modules(self, module_name: str):",
            "        return any(",
            "            re.match(",
            "                r\".*\\.{target_module}$\".format(target_module=target_module),",
            "                module_name) or target_module == module_name",
            "            for target_module in self.supported_lora_modules)",
            "",
            "    def _filter_unsupported_mm_module(self, module_name: str) -> bool:",
            "        \"\"\"",
            "        Regarding multimodal models, vLLM currently only supports adding LoRA to",
            "        language model. LoRA for other modules, such as the vision tower, will ",
            "        be filtered out.",
            "        \"\"\"",
            "        if self.supports_mm:",
            "            module_mapping: MultiModelKeys = self.model.get_mm_mapping()",
            "            prefix_lst = module_mapping.connector + module_mapping.tower_model",
            "            return any(",
            "                [module_name.startswith(prefix) for prefix in prefix_lst])",
            "        return False",
            "",
            "    def _register_packed_modules(self, module_full_name: str) -> None:",
            "        parts = module_full_name.split(\".\")",
            "        module_name = parts[-1]",
            "        replacements = self.packed_modules_mapping.get(module_name, [])",
            "        # When replacements is less than or equal to 1, it indicates that this",
            "        # module is not a packed module.",
            "        if len(replacements) <= 1:",
            "            return",
            "        prefix = \".\".join(parts[:-1])",
            "        self.packed_modules[module_full_name] = [",
            "            prefix + \".\" + r if prefix else r for r in replacements",
            "        ]",
            "",
            "    def _create_merged_loras_inplace(self, lora_model: LoRAModel) -> None:",
            "        for module_name, new_module_names in self.packed_modules.items():",
            "            replacement_loras: List[Optional[LoRALayerWeights]] = []",
            "            has_replacement = False",
            "            for r in new_module_names:",
            "                lora = lora_model.get_lora(r)",
            "                replacement_loras.append(lora)",
            "                if lora:",
            "                    has_replacement = True",
            "            if not has_replacement:",
            "                continue",
            "            for i in range(len(replacement_loras)):",
            "                if replacement_loras[i]:",
            "                    continue",
            "                replacement_loras[i] = None",
            "            lora_model.loras[module_name] = PackedLoRALayerWeights.pack(",
            "                replacement_loras)",
            "",
            "    def deactivate_adapter(self, adapter_id: int) -> bool:",
            "        return deactivate_adapter(adapter_id, self._active_adapters,",
            "                                  self._deactivate_adapter)",
            "",
            "    def add_adapter(self, adapter: LoRAModel) -> bool:",
            "        logger.debug(",
            "            \"Adding lora. Model id: %d, \"",
            "            \"int id: %d, \"",
            "            \"scaling factor: %s\", adapter.id, adapter.id,",
            "            adapter.scaling_factor)",
            "        return add_adapter(adapter, self._registered_adapters, self.capacity,",
            "                           self._add_adapter)",
            "",
            "    def set_adapter_mapping(self, mapping: LoRAMapping) -> None:",
            "        self._last_mapping = set_adapter_mapping(mapping, self._last_mapping,",
            "                                                 self._set_adapter_mapping)",
            "",
            "    def remove_adapter(self, adapter_id: int) -> bool:",
            "        return remove_adapter(adapter_id, self._registered_adapters,",
            "                              self.deactivate_adapter)",
            "",
            "    def list_adapters(self) -> Dict[int, Any]:",
            "        return list_adapters(self._registered_adapters)",
            "",
            "    def get_adapter(self, adapter_id: int) -> Optional[Any]:",
            "        return get_adapter(adapter_id, self._registered_adapters)",
            "",
            "",
            "class LoRALRUCache(AdapterLRUCache[LoRAModel]):",
            "",
            "    def __init__(self, capacity: int, deactivate_lora_fn: Callable[[int],",
            "                                                                   bool]):",
            "        super().__init__(capacity, deactivate_lora_fn)",
            "",
            "",
            "class LRUCacheLoRAModelManager(LoRAModelManager):",
            "    \"\"\"A model manager that manages multiple LoRAs with LRU cache.\"\"\"",
            "",
            "    def __init__(self, model: nn.Module, max_num_seqs: int,",
            "                 max_num_batched_tokens: int, vocab_size: int,",
            "                 lora_config: LoRAConfig, device: torch.device):",
            "        super().__init__(model, max_num_seqs, max_num_batched_tokens,",
            "                         vocab_size, lora_config, device)",
            "        self._registered_adapters: LoRALRUCache = LoRALRUCache(",
            "            self.capacity, self.deactivate_adapter)",
            "        self._active_adapters: LoRALRUCache = LoRALRUCache(",
            "            self.lora_slots, self._deactivate_adapter)",
            "",
            "    def list_adapters(self) -> Dict[int, LoRAModel]:",
            "        \"\"\"List all registered LoRAModels.\"\"\"",
            "        return dict(self._registered_adapters.cache)",
            "",
            "    def add_adapter(self, lora: LoRAModel) -> bool:",
            "        \"\"\"Add a LoRAModel to the manager.\"\"\"",
            "        logger.debug(",
            "            \"Adding lora. Model id: %d, \"",
            "            \"int id: %d, \"",
            "            \"scaling factor: %s\", lora.id, lora.id, lora.scaling_factor)",
            "        if lora.id not in self._registered_adapters:",
            "            self._add_adapter(lora)",
            "            was_added = True",
            "        else:",
            "            # We always touch to update the LRU cache order",
            "            self._registered_adapters.touch(lora.id)",
            "            was_added = False",
            "        return was_added",
            "",
            "    def activate_adapter(",
            "        self,",
            "        lora_id: int,",
            "    ) -> bool:",
            "        if lora_id not in self._active_adapters and len(",
            "                self._active_adapters) >= self.lora_slots:",
            "            self._active_adapters.remove_oldest()",
            "        result = super().activate_adapter(lora_id)",
            "        # We always touch to update the LRU cache order",
            "        self._active_adapters.touch(lora_id)",
            "        return result",
            "",
            "    def remove_oldest_adapter(self) -> bool:",
            "        if len(self._registered_adapters) > 0:",
            "            self._registered_adapters.remove_oldest()",
            "            return True",
            "        return False",
            "",
            "    def pin_adapter(self, lora_id: int) -> bool:",
            "        \"\"\"Pin a LoRAModel in the manager cache.\"\"\"",
            "        self._pin_lora_in_cpu_cache(lora_id)",
            "        self._pin_lora_in_gpu_cache(lora_id)",
            "        return True",
            "",
            "    def _pin_lora_in_cpu_cache(self, lora_id: int):",
            "        try:",
            "            self._registered_adapters.pin(lora_id)",
            "        except ValueError as err:",
            "            raise ValueError(\"Pinning failed. \"",
            "                             f\"LoRA {lora_id} is not registered.\") from err",
            "",
            "    def _pin_lora_in_gpu_cache(self, lora_id: int):",
            "        if lora_id not in self._active_adapters:",
            "            # move lora to gpu if not already active",
            "            self.activate_adapter(lora_id)",
            "",
            "        self._active_adapters.pin(lora_id)",
            "",
            "",
            "def create_lora_manager(",
            "        model: nn.Module,",
            "        max_num_seqs: int,",
            "        max_num_batched_tokens: int,",
            "        vocab_size: int,",
            "        lora_config: LoRAConfig,",
            "        device: torch.device,",
            "        lora_manager_cls: Type[LoRAModelManager] = LoRAModelManager,",
            "        **kwargs) -> LoRAModelManager:",
            "    \"\"\"Create a LoRA adapter for a given model.\"\"\"",
            "    if not hasattr(model, \"supported_lora_modules\"):",
            "        raise ValueError(f\"Model {type(model)} is not supported for LoRA.\")",
            "    lora_manager = lora_manager_cls(",
            "        model=model,",
            "        max_num_seqs=max_num_seqs,",
            "        max_num_batched_tokens=max_num_batched_tokens,",
            "        vocab_size=vocab_size,",
            "        lora_config=lora_config,",
            "        device=device,",
            "        **kwargs)",
            "    return lora_manager"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "276": [
                "LoRAModel",
                "from_local_checkpoint"
            ]
        },
        "addLocation": []
    },
    "vllm/model_executor/model_loader/weight_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "     pt_filename: str,"
            },
            "1": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     sf_filename: str,"
            },
            "2": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " ) -> None:"
            },
            "3": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    loaded = torch.load(pt_filename, map_location=\"cpu\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    loaded = torch.load(pt_filename, map_location=\"cpu\", weights_only=True)"
            },
            "5": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     if \"state_dict\" in loaded:"
            },
            "6": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         loaded = loaded[\"state_dict\"]"
            },
            "7": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     shared = _shared_pointers(loaded)"
            },
            "8": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "                     disable=not enable_tqdm,"
            },
            "9": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "                     bar_format=_BAR_FORMAT,"
            },
            "10": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "             ):"
            },
            "11": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                state = torch.load(bin_file, map_location=\"cpu\")"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+                state = torch.load(bin_file,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+                                   map_location=\"cpu\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+                                   weights_only=True)"
            },
            "15": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "                 for name, param in state.items():"
            },
            "16": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "                     param_path = os.path.join(np_folder, name)"
            },
            "17": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "                     with open(param_path, \"wb\") as f:"
            },
            "18": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "             disable=not enable_tqdm,"
            },
            "19": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 450,
                "PatchRowcode": "             bar_format=_BAR_FORMAT,"
            },
            "20": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "     ):"
            },
            "21": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        state = torch.load(bin_file, map_location=\"cpu\")"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+        state = torch.load(bin_file, map_location=\"cpu\", weights_only=True)"
            },
            "23": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 453,
                "PatchRowcode": "         yield from state.items()"
            },
            "24": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 454,
                "PatchRowcode": "         del state"
            },
            "25": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 455,
                "PatchRowcode": "         torch.cuda.empty_cache()"
            }
        },
        "frontPatchFile": [
            "\"\"\"Utilities for downloading and initializing model weights.\"\"\"",
            "import fnmatch",
            "import glob",
            "import hashlib",
            "import json",
            "import os",
            "import tempfile",
            "from collections import defaultdict",
            "from typing import Any, Callable, Dict, Generator, List, Optional, Tuple, Union",
            "",
            "import filelock",
            "import gguf",
            "import huggingface_hub.constants",
            "import numpy as np",
            "import torch",
            "from huggingface_hub import HfFileSystem, hf_hub_download, snapshot_download",
            "from safetensors.torch import load_file, safe_open, save_file",
            "from tqdm.auto import tqdm",
            "",
            "from vllm.config import LoadConfig, ModelConfig",
            "from vllm.distributed import get_tensor_model_parallel_rank",
            "from vllm.logger import init_logger",
            "from vllm.model_executor.layers.quantization import (QuantizationConfig,",
            "                                                     get_quantization_config)",
            "from vllm.platforms import current_platform",
            "from vllm.utils import PlaceholderModule",
            "",
            "try:",
            "    from runai_model_streamer import SafetensorsStreamer",
            "except (ImportError, OSError):",
            "    # see https://github.com/run-ai/runai-model-streamer/issues/26",
            "    # OSError will be raised on arm64 platform",
            "    runai_model_streamer = PlaceholderModule(",
            "        \"runai_model_streamer\")  # type: ignore[assignment]",
            "    SafetensorsStreamer = runai_model_streamer.placeholder_attr(",
            "        \"SafetensorsStreamer\")",
            "",
            "logger = init_logger(__name__)",
            "",
            "# use system-level temp directory for file locks, so that multiple users",
            "# can share the same lock without error.",
            "# lock files in the temp directory will be automatically deleted when the",
            "# system reboots, so users will not complain about annoying lock files",
            "temp_dir = tempfile.gettempdir()",
            "",
            "",
            "def enable_hf_transfer():",
            "    \"\"\"automatically activates hf_transfer",
            "    \"\"\"",
            "    if \"HF_HUB_ENABLE_HF_TRANSFER\" not in os.environ:",
            "        try:",
            "            # enable hf hub transfer if available",
            "            import hf_transfer  # type: ignore # noqa",
            "            huggingface_hub.constants.HF_HUB_ENABLE_HF_TRANSFER = True",
            "        except ImportError:",
            "            pass",
            "",
            "",
            "enable_hf_transfer()",
            "",
            "",
            "class DisabledTqdm(tqdm):",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs, disable=True)",
            "",
            "",
            "def get_lock(model_name_or_path: str, cache_dir: Optional[str] = None):",
            "    lock_dir = cache_dir or temp_dir",
            "    os.makedirs(os.path.dirname(lock_dir), exist_ok=True)",
            "    model_name = model_name_or_path.replace(\"/\", \"-\")",
            "    hash_name = hashlib.sha256(model_name.encode()).hexdigest()",
            "    # add hash to avoid conflict with old users' lock files",
            "    lock_file_name = hash_name + model_name + \".lock\"",
            "    # mode 0o666 is required for the filelock to be shared across users",
            "    lock = filelock.FileLock(os.path.join(lock_dir, lock_file_name),",
            "                             mode=0o666)",
            "    return lock",
            "",
            "",
            "def _shared_pointers(tensors):",
            "    ptrs = defaultdict(list)",
            "    for k, v in tensors.items():",
            "        ptrs[v.data_ptr()].append(k)",
            "    failing = []",
            "    for _, names in ptrs.items():",
            "        if len(names) > 1:",
            "            failing.append(names)",
            "    return failing",
            "",
            "",
            "def convert_bin_to_safetensor_file(",
            "    pt_filename: str,",
            "    sf_filename: str,",
            ") -> None:",
            "    loaded = torch.load(pt_filename, map_location=\"cpu\")",
            "    if \"state_dict\" in loaded:",
            "        loaded = loaded[\"state_dict\"]",
            "    shared = _shared_pointers(loaded)",
            "    for shared_weights in shared:",
            "        for name in shared_weights[1:]:",
            "            loaded.pop(name)",
            "",
            "    # For tensors to be contiguous",
            "    loaded = {k: v.contiguous() for k, v in loaded.items()}",
            "",
            "    dirname = os.path.dirname(sf_filename)",
            "    os.makedirs(dirname, exist_ok=True)",
            "    save_file(loaded, sf_filename, metadata={\"format\": \"pt\"})",
            "",
            "    # check file size",
            "    sf_size = os.stat(sf_filename).st_size",
            "    pt_size = os.stat(pt_filename).st_size",
            "    if (sf_size - pt_size) / pt_size > 0.01:",
            "        raise RuntimeError(f\"\"\"The file size different is more than 1%:",
            "         - {sf_filename}: {sf_size}",
            "         - {pt_filename}: {pt_size}",
            "         \"\"\")",
            "",
            "    # check if the tensors are the same",
            "    reloaded = load_file(sf_filename)",
            "    for k in loaded:",
            "        pt_tensor = loaded[k]",
            "        sf_tensor = reloaded[k]",
            "        if not torch.equal(pt_tensor, sf_tensor):",
            "            raise RuntimeError(f\"The output tensors do not match for key {k}\")",
            "",
            "",
            "# TODO(woosuk): Move this to other place.",
            "def get_quant_config(model_config: ModelConfig,",
            "                     load_config: LoadConfig) -> QuantizationConfig:",
            "",
            "    quant_cls = get_quantization_config(model_config.quantization)",
            "",
            "    # GGUF doesn't have config file",
            "    if model_config.quantization == \"gguf\":",
            "        return quant_cls.from_config({})",
            "",
            "    # Read the quantization config from the HF model config, if available.",
            "    hf_quant_config = getattr(model_config.hf_config, \"quantization_config\",",
            "                              None)",
            "    # some vision model may keep quantization_config in their text_config",
            "    hf_text_config = getattr(model_config.hf_config, \"text_config\", None)",
            "    if hf_quant_config is None and hf_text_config is not None:",
            "        hf_quant_config = getattr(hf_text_config, \"quantization_config\", None)",
            "    if hf_quant_config is None:",
            "        # compressed-tensors uses a compressions_config",
            "        hf_quant_config = getattr(model_config.hf_config, \"compression_config\",",
            "                                  None)",
            "    if hf_quant_config is not None:",
            "        return quant_cls.from_config(hf_quant_config)",
            "    # In case of bitsandbytes/QLoRA, get quant config from the adapter model.",
            "    if model_config.quantization == \"bitsandbytes\":",
            "        if (not load_config.model_loader_extra_config",
            "                or \"qlora_adapter_name_or_path\"",
            "                not in load_config.model_loader_extra_config):",
            "            return quant_cls.from_config({\"adapter_name_or_path\": \"\"})",
            "        model_name_or_path = load_config.model_loader_extra_config[",
            "            \"qlora_adapter_name_or_path\"]",
            "",
            "    else:",
            "        model_name_or_path = model_config.model",
            "    is_local = os.path.isdir(model_name_or_path)",
            "    if not is_local:",
            "        # Download the config files.",
            "        with get_lock(model_name_or_path, load_config.download_dir):",
            "            hf_folder = snapshot_download(",
            "                model_name_or_path,",
            "                revision=model_config.revision,",
            "                allow_patterns=\"*.json\",",
            "                cache_dir=load_config.download_dir,",
            "                local_files_only=huggingface_hub.constants.HF_HUB_OFFLINE,",
            "                tqdm_class=DisabledTqdm,",
            "            )",
            "    else:",
            "        hf_folder = model_name_or_path",
            "",
            "    possible_config_filenames = quant_cls.get_config_filenames()",
            "",
            "    # If the quantization config is not found, use the default config.",
            "    if not possible_config_filenames:",
            "        return quant_cls()",
            "",
            "    config_files = glob.glob(os.path.join(hf_folder, \"*.json\"))",
            "",
            "    quant_config_files = [",
            "        f for f in config_files if any(",
            "            f.endswith(x) for x in possible_config_filenames)",
            "    ]",
            "    if len(quant_config_files) == 0:",
            "        raise ValueError(",
            "            f\"Cannot find the config file for {model_config.quantization}\")",
            "    if len(quant_config_files) > 1:",
            "        raise ValueError(",
            "            f\"Found multiple config files for {model_config.quantization}: \"",
            "            f\"{quant_config_files}\")",
            "",
            "    quant_config_file = quant_config_files[0]",
            "    with open(quant_config_file) as f:",
            "        config = json.load(f)",
            "",
            "        if model_config.quantization == \"bitsandbytes\":",
            "            config[\"adapter_name_or_path\"] = model_name_or_path",
            "        elif model_config.quantization == \"modelopt\":",
            "            if config[\"producer\"][\"name\"] == \"modelopt\":",
            "                return quant_cls.from_config(config)",
            "            else:",
            "                raise ValueError(",
            "                    f\"Unsupported quantization config\"",
            "                    f\" found for {model_config.quantization} in {f}.\")",
            "",
            "    return quant_cls.from_config(config)",
            "",
            "",
            "def download_weights_from_hf(",
            "    model_name_or_path: str,",
            "    cache_dir: Optional[str],",
            "    allow_patterns: List[str],",
            "    revision: Optional[str] = None,",
            "    ignore_patterns: Optional[Union[str, List[str]]] = None,",
            ") -> str:",
            "    \"\"\"Download model weights from Hugging Face Hub.",
            "",
            "    Args:",
            "        model_name_or_path (str): The model name or path.",
            "        cache_dir (Optional[str]): The cache directory to store the model",
            "            weights. If None, will use HF defaults.",
            "        allow_patterns (List[str]): The allowed patterns for the",
            "            weight files. Files matched by any of the patterns will be",
            "            downloaded.",
            "        revision (Optional[str]): The revision of the model.",
            "        ignore_patterns (Optional[Union[str, List[str]]]): The patterns to",
            "            filter out the weight files. Files matched by any of the patterns",
            "            will be ignored.",
            "",
            "    Returns:",
            "        str: The path to the downloaded model weights.",
            "    \"\"\"",
            "    if not huggingface_hub.constants.HF_HUB_OFFLINE:",
            "        # Before we download we look at that is available:",
            "        fs = HfFileSystem()",
            "        file_list = fs.ls(model_name_or_path, detail=False, revision=revision)",
            "",
            "        # depending on what is available we download different things",
            "        for pattern in allow_patterns:",
            "            matching = fnmatch.filter(file_list, pattern)",
            "            if len(matching) > 0:",
            "                allow_patterns = [pattern]",
            "                break",
            "",
            "    logger.info(\"Using model weights format %s\", allow_patterns)",
            "    # Use file lock to prevent multiple processes from",
            "    # downloading the same model weights at the same time.",
            "    with get_lock(model_name_or_path, cache_dir):",
            "        hf_folder = snapshot_download(",
            "            model_name_or_path,",
            "            allow_patterns=allow_patterns,",
            "            ignore_patterns=ignore_patterns,",
            "            cache_dir=cache_dir,",
            "            tqdm_class=DisabledTqdm,",
            "            revision=revision,",
            "            local_files_only=huggingface_hub.constants.HF_HUB_OFFLINE,",
            "        )",
            "    return hf_folder",
            "",
            "",
            "def download_safetensors_index_file_from_hf(",
            "    model_name_or_path: str,",
            "    index_file: str,",
            "    cache_dir: Optional[str],",
            "    revision: Optional[str] = None,",
            ") -> None:",
            "    \"\"\"Download hf safetensors index file from Hugging Face Hub.",
            "",
            "    Args:",
            "        model_name_or_path (str): The model name or path.",
            "        cache_dir (Optional[str]): The cache directory to store the model",
            "            weights. If None, will use HF defaults.",
            "        revision (Optional[str]): The revision of the model.",
            "    \"\"\"",
            "    # Use file lock to prevent multiple processes from",
            "    # downloading the same model weights at the same time.",
            "    with get_lock(model_name_or_path, cache_dir):",
            "        try:",
            "            # Download the safetensors index file.",
            "            hf_hub_download(",
            "                repo_id=model_name_or_path,",
            "                filename=index_file,",
            "                cache_dir=cache_dir,",
            "                revision=revision,",
            "                local_files_only=huggingface_hub.constants.HF_HUB_OFFLINE,",
            "            )",
            "        # If file not found on remote or locally, we should not fail since",
            "        # only some models will have index_file.",
            "        except huggingface_hub.utils.EntryNotFoundError:",
            "            logger.info(\"No %s found in remote.\", index_file)",
            "        except huggingface_hub.utils.LocalEntryNotFoundError:",
            "            logger.info(\"No %s found in local cache.\", index_file)",
            "",
            "",
            "# For models like Mistral-7B-v0.3, there are both sharded",
            "# safetensors files and a consolidated safetensors file.",
            "# Passing both of these to the weight loader functionality breaks.",
            "# So, we use the index_file to",
            "# look up which safetensors files should be used.",
            "def filter_duplicate_safetensors_files(hf_weights_files: List[str],",
            "                                       hf_folder: str,",
            "                                       index_file: str) -> List[str]:",
            "    # model.safetensors.index.json is a mapping from keys in the",
            "    # torch state_dict to safetensors file holding that weight.",
            "    index_file_name = os.path.join(hf_folder, index_file)",
            "    if not os.path.isfile(index_file_name):",
            "        return hf_weights_files",
            "",
            "    # Iterate through the weight_map (weight_name: safetensors files)",
            "    # to identify weights that we should use.",
            "    with open(index_file_name) as f:",
            "        weight_map = json.load(f)[\"weight_map\"]",
            "    weight_files_in_index = set()",
            "    for weight_name in weight_map:",
            "        weight_files_in_index.add(",
            "            os.path.join(hf_folder, weight_map[weight_name]))",
            "    # Filter out any fields that are not found in the index file.",
            "    hf_weights_files = [",
            "        f for f in hf_weights_files if f in weight_files_in_index",
            "    ]",
            "    return hf_weights_files",
            "",
            "",
            "def filter_files_not_needed_for_inference(",
            "        hf_weights_files: List[str]) -> List[str]:",
            "    \"\"\"",
            "    Exclude files that are not needed for inference.",
            "",
            "    See https://github.com/huggingface/transformers/blob/v4.34.0/src/transformers/trainer.py#L227-L233",
            "    \"\"\"",
            "    blacklist = [",
            "        \"training_args.bin\",",
            "        \"optimizer.bin\",",
            "        \"optimizer.pt\",",
            "        \"scheduler.pt\",",
            "        \"scaler.pt\",",
            "    ]",
            "    hf_weights_files = [",
            "        f for f in hf_weights_files",
            "        if not any(f.endswith(x) for x in blacklist)",
            "    ]",
            "    return hf_weights_files",
            "",
            "",
            "# explicitly use pure text format, with a newline at the end",
            "# this makes it impossible to see the animation in the progress bar",
            "# but will avoid messing up with ray or multiprocessing, which wraps",
            "# each line of output with some prefix.",
            "_BAR_FORMAT = \"{desc}: {percentage:3.0f}% Completed | {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}]\\n\"  # noqa: E501",
            "",
            "",
            "def np_cache_weights_iterator(",
            "    model_name_or_path: str, cache_dir: Optional[str], hf_folder: str,",
            "    hf_weights_files: List[str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"Iterate over the weights in the model np files.",
            "",
            "    Will dump the model weights to numpy files if they are not already dumped.",
            "    \"\"\"",
            "    enable_tqdm = not torch.distributed.is_initialized(",
            "    ) or torch.distributed.get_rank() == 0",
            "    # Convert the model weights from torch tensors to numpy arrays for",
            "    # faster loading.",
            "    np_folder = os.path.join(hf_folder, \"np\")",
            "    os.makedirs(np_folder, exist_ok=True)",
            "    weight_names_file = os.path.join(np_folder, \"weight_names.json\")",
            "    # Use file lock to prevent multiple processes from",
            "    # dumping the same model weights to numpy at the same time.",
            "    with get_lock(model_name_or_path, cache_dir):",
            "        if not os.path.exists(weight_names_file):",
            "            weight_names: List[str] = []",
            "            for bin_file in tqdm(",
            "                    hf_weights_files,",
            "                    desc=\"Loading np_cache checkpoint shards\",",
            "                    disable=not enable_tqdm,",
            "                    bar_format=_BAR_FORMAT,",
            "            ):",
            "                state = torch.load(bin_file, map_location=\"cpu\")",
            "                for name, param in state.items():",
            "                    param_path = os.path.join(np_folder, name)",
            "                    with open(param_path, \"wb\") as f:",
            "                        np.save(f, param.cpu().detach().numpy())",
            "                    weight_names.append(name)",
            "            with open(weight_names_file, \"w\") as f:",
            "                json.dump(weight_names, f)",
            "",
            "    with open(weight_names_file) as f:",
            "        weight_names = json.load(f)",
            "",
            "    for name in weight_names:",
            "        param_path = os.path.join(np_folder, name)",
            "        with open(param_path, \"rb\") as f:",
            "            param = np.load(f)",
            "        yield name, torch.from_numpy(param)",
            "",
            "",
            "def safetensors_weights_iterator(",
            "    hf_weights_files: List[str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"Iterate over the weights in the model safetensor files.\"\"\"",
            "    enable_tqdm = not torch.distributed.is_initialized(",
            "    ) or torch.distributed.get_rank() == 0",
            "    for st_file in tqdm(",
            "            hf_weights_files,",
            "            desc=\"Loading safetensors checkpoint shards\",",
            "            disable=not enable_tqdm,",
            "            bar_format=_BAR_FORMAT,",
            "    ):",
            "        with safe_open(st_file, framework=\"pt\") as f:",
            "            for name in f.keys():  # noqa: SIM118",
            "                param = f.get_tensor(name)",
            "                yield name, param",
            "",
            "",
            "def runai_safetensors_weights_iterator(",
            "    hf_weights_files: List[str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"Iterate over the weights in the model safetensor files.\"\"\"",
            "    enable_tqdm = not torch.distributed.is_initialized(",
            "    ) or torch.distributed.get_rank() == 0",
            "    with SafetensorsStreamer() as streamer:",
            "        for st_file in tqdm(",
            "                hf_weights_files,",
            "                desc=\"Loading safetensors using Runai Model Streamer\",",
            "                disable=not enable_tqdm,",
            "                bar_format=_BAR_FORMAT,",
            "        ):",
            "            streamer.stream_file(st_file)",
            "            yield from streamer.get_tensors()",
            "",
            "",
            "def pt_weights_iterator(",
            "    hf_weights_files: List[str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"Iterate over the weights in the model bin/pt files.\"\"\"",
            "    enable_tqdm = not torch.distributed.is_initialized(",
            "    ) or torch.distributed.get_rank() == 0",
            "    for bin_file in tqdm(",
            "            hf_weights_files,",
            "            desc=\"Loading pt checkpoint shards\",",
            "            disable=not enable_tqdm,",
            "            bar_format=_BAR_FORMAT,",
            "    ):",
            "        state = torch.load(bin_file, map_location=\"cpu\")",
            "        yield from state.items()",
            "        del state",
            "        torch.cuda.empty_cache()",
            "",
            "",
            "def get_gguf_extra_tensor_names(",
            "        gguf_file: str, gguf_to_hf_name_map: Dict[str, str]) -> List[str]:",
            "    reader = gguf.GGUFReader(gguf_file)",
            "    expected_gguf_keys = set(gguf_to_hf_name_map.keys())",
            "    exact_gguf_keys = set([tensor.name for tensor in reader.tensors])",
            "    extra_keys = expected_gguf_keys - exact_gguf_keys",
            "    return [gguf_to_hf_name_map[key] for key in extra_keys]",
            "",
            "",
            "def gguf_quant_weights_iterator(",
            "    gguf_file: str, gguf_to_hf_name_map: Dict[str, str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"",
            "    Iterate over the quant weights in the model gguf files and convert",
            "    them to torch tensors",
            "    \"\"\"",
            "",
            "    reader = gguf.GGUFReader(gguf_file)",
            "",
            "    for tensor in reader.tensors:",
            "        if tensor.name in gguf_to_hf_name_map:",
            "            weight_type = tensor.tensor_type",
            "            name = gguf_to_hf_name_map[tensor.name]",
            "",
            "            if weight_type.name != \"F32\":",
            "                weight_type_name = name.replace(\"weight\", \"qweight_type\")",
            "                weight_type = torch.tensor(weight_type)",
            "                yield weight_type_name, weight_type",
            "",
            "    for tensor in reader.tensors:",
            "        if tensor.name in gguf_to_hf_name_map:",
            "            weight = tensor.data",
            "            weight_type = tensor.tensor_type",
            "            name = gguf_to_hf_name_map[tensor.name]",
            "",
            "            if weight_type.name != \"F32\":",
            "                name = name.replace(\"weight\", \"qweight\")",
            "            param = torch.tensor(weight)",
            "            yield name, param",
            "",
            "",
            "def convert_pyslice_to_tensor(x: Any) -> torch.Tensor:",
            "    \"\"\"convert PySafeSlice object from safetensors to torch.Tensor",
            "",
            "    PySafeSlice object supports indexing, which is done before loading the",
            "    actual tensor and can reduce the amount of memory being read into the",
            "    memory. However, it does not support more advanced functionalities",
            "    like `.view()` or `.t()`. Therefore, if we need to modify the loaded",
            "    tensor with these more complicated operators, we need to convert to",
            "    tensor first.",
            "    \"\"\"",
            "    if not isinstance(x, torch.Tensor):",
            "        x = x[:]",
            "    return x",
            "",
            "",
            "def default_weight_loader(param: torch.Tensor,",
            "                          loaded_weight: torch.Tensor) -> None:",
            "    \"\"\"Default weight loader.\"\"\"",
            "    try:",
            "        if param.numel() == 1 and loaded_weight.numel() == 1:",
            "            # Sometimes scalar values aren't considered tensors with shapes",
            "            # so if both param and loaded_weight are a scalar,",
            "            # \"broadcast\" instead of copy",
            "            param.data.fill_(loaded_weight.item())",
            "        else:",
            "            assert param.size() == loaded_weight.size(), (",
            "                f\"Attempted to load weight ({loaded_weight.size()}) \"",
            "                f\"into parameter ({param.size()})\")",
            "",
            "            param.data.copy_(loaded_weight)",
            "    except Exception:",
            "        # NOTE: This exception is added for the purpose of setting breakpoint to",
            "        # debug weight loading issues.",
            "        raise",
            "",
            "",
            "def row_parallel_weight_loader(param: torch.Tensor,",
            "                               loaded_weight: torch.Tensor) -> None:",
            "    \"\"\"Load weights that are row-parallelized.\"\"\"",
            "    tp_rank = get_tensor_model_parallel_rank()",
            "    shard_dim = 0 if param.dim() != 1 else None",
            "",
            "    if shard_dim is not None:",
            "        shard_size = param.data.shape[shard_dim]",
            "        start_idx = tp_rank * shard_size",
            "        loaded_weight = loaded_weight.narrow(shard_dim, start_idx, shard_size)",
            "",
            "    return default_weight_loader(param, loaded_weight)",
            "",
            "",
            "LoaderFunction = Callable[[torch.Tensor, torch.Tensor], torch.Tensor]",
            "",
            "",
            "def sharded_weight_loader(shard_axis: int) -> LoaderFunction:",
            "    \"\"\"Create a weight loader that shards the weights along the given axis\"\"\"",
            "",
            "    def loader(param: torch.Tensor, loaded_weight: torch.Tensor) -> None:",
            "        tp_rank = get_tensor_model_parallel_rank()",
            "",
            "        shard_size = param.data.shape[shard_axis]",
            "        start_idx = tp_rank * shard_size",
            "        loaded_weight = loaded_weight.narrow(shard_axis, start_idx, shard_size)",
            "",
            "        return default_weight_loader(param, loaded_weight)",
            "",
            "    return loader",
            "",
            "",
            "def composed_weight_loader(",
            "        loader: LoaderFunction, fn: Callable[[torch.Tensor],",
            "                                             torch.Tensor]) -> LoaderFunction:",
            "    \"\"\"Create a weight loader that post-processes the weights after loading\"\"\"",
            "",
            "    def composed_loader(param: torch.Tensor,",
            "                        loaded_weight: torch.Tensor) -> None:",
            "        loader(param, loaded_weight)",
            "        param.data.copy_(fn(param))",
            "        return",
            "",
            "    return composed_loader",
            "",
            "",
            "def initialize_dummy_weights(",
            "    model: torch.nn.Module,",
            "    low: float = -1e-3,",
            "    high: float = 1e-3,",
            "    seed: int = 1234,",
            ") -> None:",
            "    \"\"\"Initialize model weights with random values.",
            "",
            "    The model weights must be randomly initialized for accurate performance",
            "    measurements. Additionally, the model weights should not cause NaNs in the",
            "    forward pass. We empirically found that initializing the weights with",
            "    values between -1e-3 and 1e-3 works well for most models.",
            "",
            "    We use per-parameter random seed, so that dummy weights are consistent,",
            "    even if the model is partitioned across multiple devices. When the seed",
            "    is fixed, the random values generated by this function only depends on",
            "    the parameter's number of elements and its data type.",
            "    \"\"\"",
            "    for param in model.state_dict().values():",
            "        if torch.is_floating_point(param):",
            "            if current_platform.is_tpu():",
            "                # XLA device does not support torch.Generator()",
            "                param.uniform_(low, high)",
            "                continue",
            "",
            "            generator = torch.Generator(device=param.data.device)",
            "            generator.manual_seed(seed)",
            "            if torch.finfo(param.data.dtype).bits < 16:",
            "                # uniform_ doesn't support < 16-bit datatypes (FP8)",
            "                dtype = param.data.dtype",
            "                tmp_param = param.data.to(torch.float16)",
            "                tmp_param = tmp_param.uniform_(low, high,",
            "                                               generator=generator).to(dtype)",
            "                param.data.copy_(tmp_param)",
            "            else:",
            "                param.uniform_(low, high, generator=generator)",
            "",
            "",
            "def maybe_remap_kv_scale_name(name: str, params_dict: dict) -> Optional[str]:",
            "    \"\"\"Remap the name of FP8 k/v_scale parameters.",
            "",
            "    This function handles the remapping of FP8 k/v_scale parameter names.",
            "    It detects if the given name ends with a suffix and attempts to remap",
            "    it to the expected name format in the model. If the remapped name is not",
            "    found in the params_dict, a warning is printed and None is returned.",
            "",
            "    Args:",
            "        name (str): The original loaded checkpoint parameter name.",
            "        params_dict (dict): Dictionary containing the model's named parameters.",
            "",
            "    Returns:",
            "        str: The remapped parameter name if successful, or the original name",
            "             if no remapping is needed.",
            "        None: If the remapped name is not found in params_dict.",
            "    \"\"\"",
            "    if name.endswith(\".kv_scale\"):",
            "        logger.warning_once(",
            "            \"DEPRECATED. Found kv_scale in the checkpoint. \"",
            "            \"This format is deprecated in favor of separate k_scale and \"",
            "            \"v_scale tensors and will be removed in a future release. \"",
            "            \"Functionally, we will remap kv_scale to k_scale and duplicate \"",
            "            \"k_scale to v_scale\")",
            "        # NOTE: we remap the deprecated kv_scale to k_scale",
            "        remapped_name = name.replace(\".kv_scale\", \".attn.k_scale\")",
            "        if remapped_name not in params_dict:",
            "            logger.warning_once(",
            "                f\"Found kv_scale in the checkpoint (e.g. {name}), \"",
            "                \"but not found the expected name in the model \"",
            "                f\"(e.g. {remapped_name}). kv_scale is \"",
            "                \"not loaded.\")",
            "            return None",
            "        return remapped_name",
            "",
            "    possible_scale_names = [\".k_scale\", \".v_scale\"]",
            "    for scale_name in possible_scale_names:",
            "        if name.endswith(scale_name):",
            "            remapped_name = name.replace(scale_name, f\".attn{scale_name}\")",
            "            if remapped_name not in params_dict:",
            "                logger.warning_once(",
            "                    f\"Found {scale_name} in the checkpoint (e.g. {name}), \"",
            "                    \"but not found the expected name in the model \"",
            "                    f\"(e.g. {remapped_name}). {scale_name} is \"",
            "                    \"not loaded.\")",
            "                return None",
            "            return remapped_name",
            "",
            "    # If there were no matches, return the untouched param name",
            "    return name"
        ],
        "afterPatchFile": [
            "\"\"\"Utilities for downloading and initializing model weights.\"\"\"",
            "import fnmatch",
            "import glob",
            "import hashlib",
            "import json",
            "import os",
            "import tempfile",
            "from collections import defaultdict",
            "from typing import Any, Callable, Dict, Generator, List, Optional, Tuple, Union",
            "",
            "import filelock",
            "import gguf",
            "import huggingface_hub.constants",
            "import numpy as np",
            "import torch",
            "from huggingface_hub import HfFileSystem, hf_hub_download, snapshot_download",
            "from safetensors.torch import load_file, safe_open, save_file",
            "from tqdm.auto import tqdm",
            "",
            "from vllm.config import LoadConfig, ModelConfig",
            "from vllm.distributed import get_tensor_model_parallel_rank",
            "from vllm.logger import init_logger",
            "from vllm.model_executor.layers.quantization import (QuantizationConfig,",
            "                                                     get_quantization_config)",
            "from vllm.platforms import current_platform",
            "from vllm.utils import PlaceholderModule",
            "",
            "try:",
            "    from runai_model_streamer import SafetensorsStreamer",
            "except (ImportError, OSError):",
            "    # see https://github.com/run-ai/runai-model-streamer/issues/26",
            "    # OSError will be raised on arm64 platform",
            "    runai_model_streamer = PlaceholderModule(",
            "        \"runai_model_streamer\")  # type: ignore[assignment]",
            "    SafetensorsStreamer = runai_model_streamer.placeholder_attr(",
            "        \"SafetensorsStreamer\")",
            "",
            "logger = init_logger(__name__)",
            "",
            "# use system-level temp directory for file locks, so that multiple users",
            "# can share the same lock without error.",
            "# lock files in the temp directory will be automatically deleted when the",
            "# system reboots, so users will not complain about annoying lock files",
            "temp_dir = tempfile.gettempdir()",
            "",
            "",
            "def enable_hf_transfer():",
            "    \"\"\"automatically activates hf_transfer",
            "    \"\"\"",
            "    if \"HF_HUB_ENABLE_HF_TRANSFER\" not in os.environ:",
            "        try:",
            "            # enable hf hub transfer if available",
            "            import hf_transfer  # type: ignore # noqa",
            "            huggingface_hub.constants.HF_HUB_ENABLE_HF_TRANSFER = True",
            "        except ImportError:",
            "            pass",
            "",
            "",
            "enable_hf_transfer()",
            "",
            "",
            "class DisabledTqdm(tqdm):",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs, disable=True)",
            "",
            "",
            "def get_lock(model_name_or_path: str, cache_dir: Optional[str] = None):",
            "    lock_dir = cache_dir or temp_dir",
            "    os.makedirs(os.path.dirname(lock_dir), exist_ok=True)",
            "    model_name = model_name_or_path.replace(\"/\", \"-\")",
            "    hash_name = hashlib.sha256(model_name.encode()).hexdigest()",
            "    # add hash to avoid conflict with old users' lock files",
            "    lock_file_name = hash_name + model_name + \".lock\"",
            "    # mode 0o666 is required for the filelock to be shared across users",
            "    lock = filelock.FileLock(os.path.join(lock_dir, lock_file_name),",
            "                             mode=0o666)",
            "    return lock",
            "",
            "",
            "def _shared_pointers(tensors):",
            "    ptrs = defaultdict(list)",
            "    for k, v in tensors.items():",
            "        ptrs[v.data_ptr()].append(k)",
            "    failing = []",
            "    for _, names in ptrs.items():",
            "        if len(names) > 1:",
            "            failing.append(names)",
            "    return failing",
            "",
            "",
            "def convert_bin_to_safetensor_file(",
            "    pt_filename: str,",
            "    sf_filename: str,",
            ") -> None:",
            "    loaded = torch.load(pt_filename, map_location=\"cpu\", weights_only=True)",
            "    if \"state_dict\" in loaded:",
            "        loaded = loaded[\"state_dict\"]",
            "    shared = _shared_pointers(loaded)",
            "    for shared_weights in shared:",
            "        for name in shared_weights[1:]:",
            "            loaded.pop(name)",
            "",
            "    # For tensors to be contiguous",
            "    loaded = {k: v.contiguous() for k, v in loaded.items()}",
            "",
            "    dirname = os.path.dirname(sf_filename)",
            "    os.makedirs(dirname, exist_ok=True)",
            "    save_file(loaded, sf_filename, metadata={\"format\": \"pt\"})",
            "",
            "    # check file size",
            "    sf_size = os.stat(sf_filename).st_size",
            "    pt_size = os.stat(pt_filename).st_size",
            "    if (sf_size - pt_size) / pt_size > 0.01:",
            "        raise RuntimeError(f\"\"\"The file size different is more than 1%:",
            "         - {sf_filename}: {sf_size}",
            "         - {pt_filename}: {pt_size}",
            "         \"\"\")",
            "",
            "    # check if the tensors are the same",
            "    reloaded = load_file(sf_filename)",
            "    for k in loaded:",
            "        pt_tensor = loaded[k]",
            "        sf_tensor = reloaded[k]",
            "        if not torch.equal(pt_tensor, sf_tensor):",
            "            raise RuntimeError(f\"The output tensors do not match for key {k}\")",
            "",
            "",
            "# TODO(woosuk): Move this to other place.",
            "def get_quant_config(model_config: ModelConfig,",
            "                     load_config: LoadConfig) -> QuantizationConfig:",
            "",
            "    quant_cls = get_quantization_config(model_config.quantization)",
            "",
            "    # GGUF doesn't have config file",
            "    if model_config.quantization == \"gguf\":",
            "        return quant_cls.from_config({})",
            "",
            "    # Read the quantization config from the HF model config, if available.",
            "    hf_quant_config = getattr(model_config.hf_config, \"quantization_config\",",
            "                              None)",
            "    # some vision model may keep quantization_config in their text_config",
            "    hf_text_config = getattr(model_config.hf_config, \"text_config\", None)",
            "    if hf_quant_config is None and hf_text_config is not None:",
            "        hf_quant_config = getattr(hf_text_config, \"quantization_config\", None)",
            "    if hf_quant_config is None:",
            "        # compressed-tensors uses a compressions_config",
            "        hf_quant_config = getattr(model_config.hf_config, \"compression_config\",",
            "                                  None)",
            "    if hf_quant_config is not None:",
            "        return quant_cls.from_config(hf_quant_config)",
            "    # In case of bitsandbytes/QLoRA, get quant config from the adapter model.",
            "    if model_config.quantization == \"bitsandbytes\":",
            "        if (not load_config.model_loader_extra_config",
            "                or \"qlora_adapter_name_or_path\"",
            "                not in load_config.model_loader_extra_config):",
            "            return quant_cls.from_config({\"adapter_name_or_path\": \"\"})",
            "        model_name_or_path = load_config.model_loader_extra_config[",
            "            \"qlora_adapter_name_or_path\"]",
            "",
            "    else:",
            "        model_name_or_path = model_config.model",
            "    is_local = os.path.isdir(model_name_or_path)",
            "    if not is_local:",
            "        # Download the config files.",
            "        with get_lock(model_name_or_path, load_config.download_dir):",
            "            hf_folder = snapshot_download(",
            "                model_name_or_path,",
            "                revision=model_config.revision,",
            "                allow_patterns=\"*.json\",",
            "                cache_dir=load_config.download_dir,",
            "                local_files_only=huggingface_hub.constants.HF_HUB_OFFLINE,",
            "                tqdm_class=DisabledTqdm,",
            "            )",
            "    else:",
            "        hf_folder = model_name_or_path",
            "",
            "    possible_config_filenames = quant_cls.get_config_filenames()",
            "",
            "    # If the quantization config is not found, use the default config.",
            "    if not possible_config_filenames:",
            "        return quant_cls()",
            "",
            "    config_files = glob.glob(os.path.join(hf_folder, \"*.json\"))",
            "",
            "    quant_config_files = [",
            "        f for f in config_files if any(",
            "            f.endswith(x) for x in possible_config_filenames)",
            "    ]",
            "    if len(quant_config_files) == 0:",
            "        raise ValueError(",
            "            f\"Cannot find the config file for {model_config.quantization}\")",
            "    if len(quant_config_files) > 1:",
            "        raise ValueError(",
            "            f\"Found multiple config files for {model_config.quantization}: \"",
            "            f\"{quant_config_files}\")",
            "",
            "    quant_config_file = quant_config_files[0]",
            "    with open(quant_config_file) as f:",
            "        config = json.load(f)",
            "",
            "        if model_config.quantization == \"bitsandbytes\":",
            "            config[\"adapter_name_or_path\"] = model_name_or_path",
            "        elif model_config.quantization == \"modelopt\":",
            "            if config[\"producer\"][\"name\"] == \"modelopt\":",
            "                return quant_cls.from_config(config)",
            "            else:",
            "                raise ValueError(",
            "                    f\"Unsupported quantization config\"",
            "                    f\" found for {model_config.quantization} in {f}.\")",
            "",
            "    return quant_cls.from_config(config)",
            "",
            "",
            "def download_weights_from_hf(",
            "    model_name_or_path: str,",
            "    cache_dir: Optional[str],",
            "    allow_patterns: List[str],",
            "    revision: Optional[str] = None,",
            "    ignore_patterns: Optional[Union[str, List[str]]] = None,",
            ") -> str:",
            "    \"\"\"Download model weights from Hugging Face Hub.",
            "",
            "    Args:",
            "        model_name_or_path (str): The model name or path.",
            "        cache_dir (Optional[str]): The cache directory to store the model",
            "            weights. If None, will use HF defaults.",
            "        allow_patterns (List[str]): The allowed patterns for the",
            "            weight files. Files matched by any of the patterns will be",
            "            downloaded.",
            "        revision (Optional[str]): The revision of the model.",
            "        ignore_patterns (Optional[Union[str, List[str]]]): The patterns to",
            "            filter out the weight files. Files matched by any of the patterns",
            "            will be ignored.",
            "",
            "    Returns:",
            "        str: The path to the downloaded model weights.",
            "    \"\"\"",
            "    if not huggingface_hub.constants.HF_HUB_OFFLINE:",
            "        # Before we download we look at that is available:",
            "        fs = HfFileSystem()",
            "        file_list = fs.ls(model_name_or_path, detail=False, revision=revision)",
            "",
            "        # depending on what is available we download different things",
            "        for pattern in allow_patterns:",
            "            matching = fnmatch.filter(file_list, pattern)",
            "            if len(matching) > 0:",
            "                allow_patterns = [pattern]",
            "                break",
            "",
            "    logger.info(\"Using model weights format %s\", allow_patterns)",
            "    # Use file lock to prevent multiple processes from",
            "    # downloading the same model weights at the same time.",
            "    with get_lock(model_name_or_path, cache_dir):",
            "        hf_folder = snapshot_download(",
            "            model_name_or_path,",
            "            allow_patterns=allow_patterns,",
            "            ignore_patterns=ignore_patterns,",
            "            cache_dir=cache_dir,",
            "            tqdm_class=DisabledTqdm,",
            "            revision=revision,",
            "            local_files_only=huggingface_hub.constants.HF_HUB_OFFLINE,",
            "        )",
            "    return hf_folder",
            "",
            "",
            "def download_safetensors_index_file_from_hf(",
            "    model_name_or_path: str,",
            "    index_file: str,",
            "    cache_dir: Optional[str],",
            "    revision: Optional[str] = None,",
            ") -> None:",
            "    \"\"\"Download hf safetensors index file from Hugging Face Hub.",
            "",
            "    Args:",
            "        model_name_or_path (str): The model name or path.",
            "        cache_dir (Optional[str]): The cache directory to store the model",
            "            weights. If None, will use HF defaults.",
            "        revision (Optional[str]): The revision of the model.",
            "    \"\"\"",
            "    # Use file lock to prevent multiple processes from",
            "    # downloading the same model weights at the same time.",
            "    with get_lock(model_name_or_path, cache_dir):",
            "        try:",
            "            # Download the safetensors index file.",
            "            hf_hub_download(",
            "                repo_id=model_name_or_path,",
            "                filename=index_file,",
            "                cache_dir=cache_dir,",
            "                revision=revision,",
            "                local_files_only=huggingface_hub.constants.HF_HUB_OFFLINE,",
            "            )",
            "        # If file not found on remote or locally, we should not fail since",
            "        # only some models will have index_file.",
            "        except huggingface_hub.utils.EntryNotFoundError:",
            "            logger.info(\"No %s found in remote.\", index_file)",
            "        except huggingface_hub.utils.LocalEntryNotFoundError:",
            "            logger.info(\"No %s found in local cache.\", index_file)",
            "",
            "",
            "# For models like Mistral-7B-v0.3, there are both sharded",
            "# safetensors files and a consolidated safetensors file.",
            "# Passing both of these to the weight loader functionality breaks.",
            "# So, we use the index_file to",
            "# look up which safetensors files should be used.",
            "def filter_duplicate_safetensors_files(hf_weights_files: List[str],",
            "                                       hf_folder: str,",
            "                                       index_file: str) -> List[str]:",
            "    # model.safetensors.index.json is a mapping from keys in the",
            "    # torch state_dict to safetensors file holding that weight.",
            "    index_file_name = os.path.join(hf_folder, index_file)",
            "    if not os.path.isfile(index_file_name):",
            "        return hf_weights_files",
            "",
            "    # Iterate through the weight_map (weight_name: safetensors files)",
            "    # to identify weights that we should use.",
            "    with open(index_file_name) as f:",
            "        weight_map = json.load(f)[\"weight_map\"]",
            "    weight_files_in_index = set()",
            "    for weight_name in weight_map:",
            "        weight_files_in_index.add(",
            "            os.path.join(hf_folder, weight_map[weight_name]))",
            "    # Filter out any fields that are not found in the index file.",
            "    hf_weights_files = [",
            "        f for f in hf_weights_files if f in weight_files_in_index",
            "    ]",
            "    return hf_weights_files",
            "",
            "",
            "def filter_files_not_needed_for_inference(",
            "        hf_weights_files: List[str]) -> List[str]:",
            "    \"\"\"",
            "    Exclude files that are not needed for inference.",
            "",
            "    See https://github.com/huggingface/transformers/blob/v4.34.0/src/transformers/trainer.py#L227-L233",
            "    \"\"\"",
            "    blacklist = [",
            "        \"training_args.bin\",",
            "        \"optimizer.bin\",",
            "        \"optimizer.pt\",",
            "        \"scheduler.pt\",",
            "        \"scaler.pt\",",
            "    ]",
            "    hf_weights_files = [",
            "        f for f in hf_weights_files",
            "        if not any(f.endswith(x) for x in blacklist)",
            "    ]",
            "    return hf_weights_files",
            "",
            "",
            "# explicitly use pure text format, with a newline at the end",
            "# this makes it impossible to see the animation in the progress bar",
            "# but will avoid messing up with ray or multiprocessing, which wraps",
            "# each line of output with some prefix.",
            "_BAR_FORMAT = \"{desc}: {percentage:3.0f}% Completed | {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}]\\n\"  # noqa: E501",
            "",
            "",
            "def np_cache_weights_iterator(",
            "    model_name_or_path: str, cache_dir: Optional[str], hf_folder: str,",
            "    hf_weights_files: List[str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"Iterate over the weights in the model np files.",
            "",
            "    Will dump the model weights to numpy files if they are not already dumped.",
            "    \"\"\"",
            "    enable_tqdm = not torch.distributed.is_initialized(",
            "    ) or torch.distributed.get_rank() == 0",
            "    # Convert the model weights from torch tensors to numpy arrays for",
            "    # faster loading.",
            "    np_folder = os.path.join(hf_folder, \"np\")",
            "    os.makedirs(np_folder, exist_ok=True)",
            "    weight_names_file = os.path.join(np_folder, \"weight_names.json\")",
            "    # Use file lock to prevent multiple processes from",
            "    # dumping the same model weights to numpy at the same time.",
            "    with get_lock(model_name_or_path, cache_dir):",
            "        if not os.path.exists(weight_names_file):",
            "            weight_names: List[str] = []",
            "            for bin_file in tqdm(",
            "                    hf_weights_files,",
            "                    desc=\"Loading np_cache checkpoint shards\",",
            "                    disable=not enable_tqdm,",
            "                    bar_format=_BAR_FORMAT,",
            "            ):",
            "                state = torch.load(bin_file,",
            "                                   map_location=\"cpu\",",
            "                                   weights_only=True)",
            "                for name, param in state.items():",
            "                    param_path = os.path.join(np_folder, name)",
            "                    with open(param_path, \"wb\") as f:",
            "                        np.save(f, param.cpu().detach().numpy())",
            "                    weight_names.append(name)",
            "            with open(weight_names_file, \"w\") as f:",
            "                json.dump(weight_names, f)",
            "",
            "    with open(weight_names_file) as f:",
            "        weight_names = json.load(f)",
            "",
            "    for name in weight_names:",
            "        param_path = os.path.join(np_folder, name)",
            "        with open(param_path, \"rb\") as f:",
            "            param = np.load(f)",
            "        yield name, torch.from_numpy(param)",
            "",
            "",
            "def safetensors_weights_iterator(",
            "    hf_weights_files: List[str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"Iterate over the weights in the model safetensor files.\"\"\"",
            "    enable_tqdm = not torch.distributed.is_initialized(",
            "    ) or torch.distributed.get_rank() == 0",
            "    for st_file in tqdm(",
            "            hf_weights_files,",
            "            desc=\"Loading safetensors checkpoint shards\",",
            "            disable=not enable_tqdm,",
            "            bar_format=_BAR_FORMAT,",
            "    ):",
            "        with safe_open(st_file, framework=\"pt\") as f:",
            "            for name in f.keys():  # noqa: SIM118",
            "                param = f.get_tensor(name)",
            "                yield name, param",
            "",
            "",
            "def runai_safetensors_weights_iterator(",
            "    hf_weights_files: List[str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"Iterate over the weights in the model safetensor files.\"\"\"",
            "    enable_tqdm = not torch.distributed.is_initialized(",
            "    ) or torch.distributed.get_rank() == 0",
            "    with SafetensorsStreamer() as streamer:",
            "        for st_file in tqdm(",
            "                hf_weights_files,",
            "                desc=\"Loading safetensors using Runai Model Streamer\",",
            "                disable=not enable_tqdm,",
            "                bar_format=_BAR_FORMAT,",
            "        ):",
            "            streamer.stream_file(st_file)",
            "            yield from streamer.get_tensors()",
            "",
            "",
            "def pt_weights_iterator(",
            "    hf_weights_files: List[str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"Iterate over the weights in the model bin/pt files.\"\"\"",
            "    enable_tqdm = not torch.distributed.is_initialized(",
            "    ) or torch.distributed.get_rank() == 0",
            "    for bin_file in tqdm(",
            "            hf_weights_files,",
            "            desc=\"Loading pt checkpoint shards\",",
            "            disable=not enable_tqdm,",
            "            bar_format=_BAR_FORMAT,",
            "    ):",
            "        state = torch.load(bin_file, map_location=\"cpu\", weights_only=True)",
            "        yield from state.items()",
            "        del state",
            "        torch.cuda.empty_cache()",
            "",
            "",
            "def get_gguf_extra_tensor_names(",
            "        gguf_file: str, gguf_to_hf_name_map: Dict[str, str]) -> List[str]:",
            "    reader = gguf.GGUFReader(gguf_file)",
            "    expected_gguf_keys = set(gguf_to_hf_name_map.keys())",
            "    exact_gguf_keys = set([tensor.name for tensor in reader.tensors])",
            "    extra_keys = expected_gguf_keys - exact_gguf_keys",
            "    return [gguf_to_hf_name_map[key] for key in extra_keys]",
            "",
            "",
            "def gguf_quant_weights_iterator(",
            "    gguf_file: str, gguf_to_hf_name_map: Dict[str, str]",
            ") -> Generator[Tuple[str, torch.Tensor], None, None]:",
            "    \"\"\"",
            "    Iterate over the quant weights in the model gguf files and convert",
            "    them to torch tensors",
            "    \"\"\"",
            "",
            "    reader = gguf.GGUFReader(gguf_file)",
            "",
            "    for tensor in reader.tensors:",
            "        if tensor.name in gguf_to_hf_name_map:",
            "            weight_type = tensor.tensor_type",
            "            name = gguf_to_hf_name_map[tensor.name]",
            "",
            "            if weight_type.name != \"F32\":",
            "                weight_type_name = name.replace(\"weight\", \"qweight_type\")",
            "                weight_type = torch.tensor(weight_type)",
            "                yield weight_type_name, weight_type",
            "",
            "    for tensor in reader.tensors:",
            "        if tensor.name in gguf_to_hf_name_map:",
            "            weight = tensor.data",
            "            weight_type = tensor.tensor_type",
            "            name = gguf_to_hf_name_map[tensor.name]",
            "",
            "            if weight_type.name != \"F32\":",
            "                name = name.replace(\"weight\", \"qweight\")",
            "            param = torch.tensor(weight)",
            "            yield name, param",
            "",
            "",
            "def convert_pyslice_to_tensor(x: Any) -> torch.Tensor:",
            "    \"\"\"convert PySafeSlice object from safetensors to torch.Tensor",
            "",
            "    PySafeSlice object supports indexing, which is done before loading the",
            "    actual tensor and can reduce the amount of memory being read into the",
            "    memory. However, it does not support more advanced functionalities",
            "    like `.view()` or `.t()`. Therefore, if we need to modify the loaded",
            "    tensor with these more complicated operators, we need to convert to",
            "    tensor first.",
            "    \"\"\"",
            "    if not isinstance(x, torch.Tensor):",
            "        x = x[:]",
            "    return x",
            "",
            "",
            "def default_weight_loader(param: torch.Tensor,",
            "                          loaded_weight: torch.Tensor) -> None:",
            "    \"\"\"Default weight loader.\"\"\"",
            "    try:",
            "        if param.numel() == 1 and loaded_weight.numel() == 1:",
            "            # Sometimes scalar values aren't considered tensors with shapes",
            "            # so if both param and loaded_weight are a scalar,",
            "            # \"broadcast\" instead of copy",
            "            param.data.fill_(loaded_weight.item())",
            "        else:",
            "            assert param.size() == loaded_weight.size(), (",
            "                f\"Attempted to load weight ({loaded_weight.size()}) \"",
            "                f\"into parameter ({param.size()})\")",
            "",
            "            param.data.copy_(loaded_weight)",
            "    except Exception:",
            "        # NOTE: This exception is added for the purpose of setting breakpoint to",
            "        # debug weight loading issues.",
            "        raise",
            "",
            "",
            "def row_parallel_weight_loader(param: torch.Tensor,",
            "                               loaded_weight: torch.Tensor) -> None:",
            "    \"\"\"Load weights that are row-parallelized.\"\"\"",
            "    tp_rank = get_tensor_model_parallel_rank()",
            "    shard_dim = 0 if param.dim() != 1 else None",
            "",
            "    if shard_dim is not None:",
            "        shard_size = param.data.shape[shard_dim]",
            "        start_idx = tp_rank * shard_size",
            "        loaded_weight = loaded_weight.narrow(shard_dim, start_idx, shard_size)",
            "",
            "    return default_weight_loader(param, loaded_weight)",
            "",
            "",
            "LoaderFunction = Callable[[torch.Tensor, torch.Tensor], torch.Tensor]",
            "",
            "",
            "def sharded_weight_loader(shard_axis: int) -> LoaderFunction:",
            "    \"\"\"Create a weight loader that shards the weights along the given axis\"\"\"",
            "",
            "    def loader(param: torch.Tensor, loaded_weight: torch.Tensor) -> None:",
            "        tp_rank = get_tensor_model_parallel_rank()",
            "",
            "        shard_size = param.data.shape[shard_axis]",
            "        start_idx = tp_rank * shard_size",
            "        loaded_weight = loaded_weight.narrow(shard_axis, start_idx, shard_size)",
            "",
            "        return default_weight_loader(param, loaded_weight)",
            "",
            "    return loader",
            "",
            "",
            "def composed_weight_loader(",
            "        loader: LoaderFunction, fn: Callable[[torch.Tensor],",
            "                                             torch.Tensor]) -> LoaderFunction:",
            "    \"\"\"Create a weight loader that post-processes the weights after loading\"\"\"",
            "",
            "    def composed_loader(param: torch.Tensor,",
            "                        loaded_weight: torch.Tensor) -> None:",
            "        loader(param, loaded_weight)",
            "        param.data.copy_(fn(param))",
            "        return",
            "",
            "    return composed_loader",
            "",
            "",
            "def initialize_dummy_weights(",
            "    model: torch.nn.Module,",
            "    low: float = -1e-3,",
            "    high: float = 1e-3,",
            "    seed: int = 1234,",
            ") -> None:",
            "    \"\"\"Initialize model weights with random values.",
            "",
            "    The model weights must be randomly initialized for accurate performance",
            "    measurements. Additionally, the model weights should not cause NaNs in the",
            "    forward pass. We empirically found that initializing the weights with",
            "    values between -1e-3 and 1e-3 works well for most models.",
            "",
            "    We use per-parameter random seed, so that dummy weights are consistent,",
            "    even if the model is partitioned across multiple devices. When the seed",
            "    is fixed, the random values generated by this function only depends on",
            "    the parameter's number of elements and its data type.",
            "    \"\"\"",
            "    for param in model.state_dict().values():",
            "        if torch.is_floating_point(param):",
            "            if current_platform.is_tpu():",
            "                # XLA device does not support torch.Generator()",
            "                param.uniform_(low, high)",
            "                continue",
            "",
            "            generator = torch.Generator(device=param.data.device)",
            "            generator.manual_seed(seed)",
            "            if torch.finfo(param.data.dtype).bits < 16:",
            "                # uniform_ doesn't support < 16-bit datatypes (FP8)",
            "                dtype = param.data.dtype",
            "                tmp_param = param.data.to(torch.float16)",
            "                tmp_param = tmp_param.uniform_(low, high,",
            "                                               generator=generator).to(dtype)",
            "                param.data.copy_(tmp_param)",
            "            else:",
            "                param.uniform_(low, high, generator=generator)",
            "",
            "",
            "def maybe_remap_kv_scale_name(name: str, params_dict: dict) -> Optional[str]:",
            "    \"\"\"Remap the name of FP8 k/v_scale parameters.",
            "",
            "    This function handles the remapping of FP8 k/v_scale parameter names.",
            "    It detects if the given name ends with a suffix and attempts to remap",
            "    it to the expected name format in the model. If the remapped name is not",
            "    found in the params_dict, a warning is printed and None is returned.",
            "",
            "    Args:",
            "        name (str): The original loaded checkpoint parameter name.",
            "        params_dict (dict): Dictionary containing the model's named parameters.",
            "",
            "    Returns:",
            "        str: The remapped parameter name if successful, or the original name",
            "             if no remapping is needed.",
            "        None: If the remapped name is not found in params_dict.",
            "    \"\"\"",
            "    if name.endswith(\".kv_scale\"):",
            "        logger.warning_once(",
            "            \"DEPRECATED. Found kv_scale in the checkpoint. \"",
            "            \"This format is deprecated in favor of separate k_scale and \"",
            "            \"v_scale tensors and will be removed in a future release. \"",
            "            \"Functionally, we will remap kv_scale to k_scale and duplicate \"",
            "            \"k_scale to v_scale\")",
            "        # NOTE: we remap the deprecated kv_scale to k_scale",
            "        remapped_name = name.replace(\".kv_scale\", \".attn.k_scale\")",
            "        if remapped_name not in params_dict:",
            "            logger.warning_once(",
            "                f\"Found kv_scale in the checkpoint (e.g. {name}), \"",
            "                \"but not found the expected name in the model \"",
            "                f\"(e.g. {remapped_name}). kv_scale is \"",
            "                \"not loaded.\")",
            "            return None",
            "        return remapped_name",
            "",
            "    possible_scale_names = [\".k_scale\", \".v_scale\"]",
            "    for scale_name in possible_scale_names:",
            "        if name.endswith(scale_name):",
            "            remapped_name = name.replace(scale_name, f\".attn{scale_name}\")",
            "            if remapped_name not in params_dict:",
            "                logger.warning_once(",
            "                    f\"Found {scale_name} in the checkpoint (e.g. {name}), \"",
            "                    \"but not found the expected name in the model \"",
            "                    f\"(e.g. {remapped_name}). {scale_name} is \"",
            "                    \"not loaded.\")",
            "                return None",
            "            return remapped_name",
            "",
            "    # If there were no matches, return the untouched param name",
            "    return name"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "96": [
                "convert_bin_to_safetensor_file"
            ],
            "384": [
                "np_cache_weights_iterator"
            ],
            "450": [
                "pt_weights_iterator"
            ]
        },
        "addLocation": []
    },
    "vllm/prompt_adapter/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         adapters_weights = safe_load_file(filename, device=device)"
            },
            "1": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "     else:"
            },
            "2": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         adapters_weights = torch.load(filename,"
            },
            "3": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                      map_location=torch.device(device))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                                      map_location=torch.device(device),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                                      weights_only=True)"
            },
            "6": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "     return adapters_weights"
            }
        },
        "frontPatchFile": [
            "# code borrowed from: https://github.com/huggingface/peft/blob/v0.12.0/src/peft/utils/save_and_load.py#L420",
            "",
            "import os",
            "from typing import Optional",
            "",
            "import torch",
            "from huggingface_hub import file_exists, hf_hub_download",
            "from huggingface_hub.utils import EntryNotFoundError",
            "from safetensors.torch import load_file as safe_load_file",
            "",
            "from vllm.platforms import current_platform",
            "",
            "WEIGHTS_NAME = \"adapter_model.bin\"",
            "SAFETENSORS_WEIGHTS_NAME = \"adapter_model.safetensors\"",
            "",
            "",
            "# Get current device name based on available devices",
            "def infer_device() -> str:",
            "    if current_platform.is_cuda_alike():",
            "        return \"cuda\"",
            "    return \"cpu\"",
            "",
            "",
            "def load_peft_weights(model_id: str,",
            "                      device: Optional[str] = None,",
            "                      **hf_hub_download_kwargs) -> dict:",
            "    r\"\"\"",
            "    A helper method to load the PEFT weights from the HuggingFace Hub or locally",
            "",
            "    Args:",
            "        model_id (`str`):",
            "            The local path to the adapter weights or the name of the adapter to",
            "            load from the HuggingFace Hub.",
            "        device (`str`):",
            "            The device to load the weights onto.",
            "        hf_hub_download_kwargs (`dict`):",
            "            Additional arguments to pass to the `hf_hub_download` method when ",
            "            loading from the HuggingFace Hub.",
            "    \"\"\"",
            "    path = (os.path.join(model_id, hf_hub_download_kwargs[\"subfolder\"]) if",
            "            hf_hub_download_kwargs.get(\"subfolder\") is not None else model_id)",
            "",
            "    if device is None:",
            "        device = infer_device()",
            "",
            "    if os.path.exists(os.path.join(path, SAFETENSORS_WEIGHTS_NAME)):",
            "        filename = os.path.join(path, SAFETENSORS_WEIGHTS_NAME)",
            "        use_safetensors = True",
            "    elif os.path.exists(os.path.join(path, WEIGHTS_NAME)):",
            "        filename = os.path.join(path, WEIGHTS_NAME)",
            "        use_safetensors = False",
            "    else:",
            "        token = hf_hub_download_kwargs.get(\"token\")",
            "        if token is None:",
            "            token = hf_hub_download_kwargs.get(\"use_auth_token\")",
            "",
            "        hub_filename = (os.path.join(hf_hub_download_kwargs[\"subfolder\"],",
            "                                     SAFETENSORS_WEIGHTS_NAME)",
            "                        if hf_hub_download_kwargs.get(\"subfolder\") is not None",
            "                        else SAFETENSORS_WEIGHTS_NAME)",
            "        has_remote_safetensors_file = file_exists(",
            "            repo_id=model_id,",
            "            filename=hub_filename,",
            "            revision=hf_hub_download_kwargs.get(\"revision\"),",
            "            repo_type=hf_hub_download_kwargs.get(\"repo_type\"),",
            "            token=token,",
            "        )",
            "        use_safetensors = has_remote_safetensors_file",
            "",
            "        if has_remote_safetensors_file:",
            "            # Priority 1: load safetensors weights",
            "            filename = hf_hub_download(",
            "                model_id,",
            "                SAFETENSORS_WEIGHTS_NAME,",
            "                **hf_hub_download_kwargs,",
            "            )",
            "        else:",
            "            try:",
            "                filename = hf_hub_download(model_id, WEIGHTS_NAME,",
            "                                           **hf_hub_download_kwargs)",
            "            except EntryNotFoundError:",
            "                raise ValueError(  # noqa: B904",
            "                    f\"Can't find weights for {model_id} in {model_id} or \\",
            "                    in the Hugging Face Hub. \"",
            "                    f\"Please check that the file {WEIGHTS_NAME} or \\",
            "                    {SAFETENSORS_WEIGHTS_NAME} is present at {model_id}.\")",
            "",
            "    if use_safetensors:",
            "        adapters_weights = safe_load_file(filename, device=device)",
            "    else:",
            "        adapters_weights = torch.load(filename,",
            "                                      map_location=torch.device(device))",
            "",
            "    return adapters_weights"
        ],
        "afterPatchFile": [
            "# code borrowed from: https://github.com/huggingface/peft/blob/v0.12.0/src/peft/utils/save_and_load.py#L420",
            "",
            "import os",
            "from typing import Optional",
            "",
            "import torch",
            "from huggingface_hub import file_exists, hf_hub_download",
            "from huggingface_hub.utils import EntryNotFoundError",
            "from safetensors.torch import load_file as safe_load_file",
            "",
            "from vllm.platforms import current_platform",
            "",
            "WEIGHTS_NAME = \"adapter_model.bin\"",
            "SAFETENSORS_WEIGHTS_NAME = \"adapter_model.safetensors\"",
            "",
            "",
            "# Get current device name based on available devices",
            "def infer_device() -> str:",
            "    if current_platform.is_cuda_alike():",
            "        return \"cuda\"",
            "    return \"cpu\"",
            "",
            "",
            "def load_peft_weights(model_id: str,",
            "                      device: Optional[str] = None,",
            "                      **hf_hub_download_kwargs) -> dict:",
            "    r\"\"\"",
            "    A helper method to load the PEFT weights from the HuggingFace Hub or locally",
            "",
            "    Args:",
            "        model_id (`str`):",
            "            The local path to the adapter weights or the name of the adapter to",
            "            load from the HuggingFace Hub.",
            "        device (`str`):",
            "            The device to load the weights onto.",
            "        hf_hub_download_kwargs (`dict`):",
            "            Additional arguments to pass to the `hf_hub_download` method when ",
            "            loading from the HuggingFace Hub.",
            "    \"\"\"",
            "    path = (os.path.join(model_id, hf_hub_download_kwargs[\"subfolder\"]) if",
            "            hf_hub_download_kwargs.get(\"subfolder\") is not None else model_id)",
            "",
            "    if device is None:",
            "        device = infer_device()",
            "",
            "    if os.path.exists(os.path.join(path, SAFETENSORS_WEIGHTS_NAME)):",
            "        filename = os.path.join(path, SAFETENSORS_WEIGHTS_NAME)",
            "        use_safetensors = True",
            "    elif os.path.exists(os.path.join(path, WEIGHTS_NAME)):",
            "        filename = os.path.join(path, WEIGHTS_NAME)",
            "        use_safetensors = False",
            "    else:",
            "        token = hf_hub_download_kwargs.get(\"token\")",
            "        if token is None:",
            "            token = hf_hub_download_kwargs.get(\"use_auth_token\")",
            "",
            "        hub_filename = (os.path.join(hf_hub_download_kwargs[\"subfolder\"],",
            "                                     SAFETENSORS_WEIGHTS_NAME)",
            "                        if hf_hub_download_kwargs.get(\"subfolder\") is not None",
            "                        else SAFETENSORS_WEIGHTS_NAME)",
            "        has_remote_safetensors_file = file_exists(",
            "            repo_id=model_id,",
            "            filename=hub_filename,",
            "            revision=hf_hub_download_kwargs.get(\"revision\"),",
            "            repo_type=hf_hub_download_kwargs.get(\"repo_type\"),",
            "            token=token,",
            "        )",
            "        use_safetensors = has_remote_safetensors_file",
            "",
            "        if has_remote_safetensors_file:",
            "            # Priority 1: load safetensors weights",
            "            filename = hf_hub_download(",
            "                model_id,",
            "                SAFETENSORS_WEIGHTS_NAME,",
            "                **hf_hub_download_kwargs,",
            "            )",
            "        else:",
            "            try:",
            "                filename = hf_hub_download(model_id, WEIGHTS_NAME,",
            "                                           **hf_hub_download_kwargs)",
            "            except EntryNotFoundError:",
            "                raise ValueError(  # noqa: B904",
            "                    f\"Can't find weights for {model_id} in {model_id} or \\",
            "                    in the Hugging Face Hub. \"",
            "                    f\"Please check that the file {WEIGHTS_NAME} or \\",
            "                    {SAFETENSORS_WEIGHTS_NAME} is present at {model_id}.\")",
            "",
            "    if use_safetensors:",
            "        adapters_weights = safe_load_file(filename, device=device)",
            "    else:",
            "        adapters_weights = torch.load(filename,",
            "                                      map_location=torch.device(device),",
            "                                      weights_only=True)",
            "",
            "    return adapters_weights"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "92": [
                "load_peft_weights"
            ]
        },
        "addLocation": []
    }
}