{
    "nova/console/websocketproxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " Leverages websockify.py by Joel Martin"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " '''"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+import copy"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import socket"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import sys"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "                 detail = _(\"Origin header protocol does not match this host.\")"
            },
            "8": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "                 raise exception.ValidationError(detail=detail)"
            },
            "9": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 223,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.msg(_('connect info: %s'), str(connect_info))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        sanitized_info = copy.copy(connect_info)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+        sanitized_info.token = '***'"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        self.msg(_('connect info: %s'), sanitized_info)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "         host = connect_info.host"
            },
            "16": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         port = connect_info.port"
            },
            "17": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "'''",
            "Websocket proxy that is compatible with OpenStack Nova.",
            "Leverages websockify.py by Joel Martin",
            "'''",
            "",
            "import socket",
            "import sys",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import encodeutils",
            "from oslo_utils import importutils",
            "import six",
            "from six.moves import http_cookies as Cookie",
            "import six.moves.urllib.parse as urlparse",
            "import websockify",
            "",
            "from nova.compute import rpcapi as compute_rpcapi",
            "import nova.conf",
            "from nova import context",
            "from nova import exception",
            "from nova.i18n import _",
            "from nova import objects",
            "",
            "# Location of WebSockifyServer class in websockify v0.9.0",
            "websockifyserver = importutils.try_import('websockify.websockifyserver')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class TenantSock(object):",
            "    \"\"\"A socket wrapper for communicating with the tenant.",
            "",
            "    This class provides a socket-like interface to the internal",
            "    websockify send/receive queue for the client connection to",
            "    the tenant user. It is used with the security proxy classes.",
            "    \"\"\"",
            "",
            "    def __init__(self, reqhandler):",
            "        self.reqhandler = reqhandler",
            "        self.queue = []",
            "",
            "    def recv(self, cnt):",
            "        # NB(sross): it's ok to block here because we know",
            "        #            exactly the sequence of data arriving",
            "        while len(self.queue) < cnt:",
            "            # new_frames looks like ['abc', 'def']",
            "            new_frames, closed = self.reqhandler.recv_frames()",
            "            # flatten frames onto queue",
            "            for frame in new_frames:",
            "                # The socket returns (byte) strings in Python 2...",
            "                if six.PY2:",
            "                    self.queue.extend(frame)",
            "                # ...and integers in Python 3. For the Python 3 case, we need",
            "                # to convert these to characters using 'chr' and then, as this",
            "                # returns unicode, convert the result to byte strings.",
            "                else:",
            "                    self.queue.extend(",
            "                        [six.binary_type(chr(c), 'ascii') for c in frame])",
            "",
            "            if closed:",
            "                break",
            "",
            "        popped = self.queue[0:cnt]",
            "        del self.queue[0:cnt]",
            "        return b''.join(popped)",
            "",
            "    def sendall(self, data):",
            "        self.reqhandler.send_frames([encodeutils.safe_encode(data)])",
            "",
            "    def finish_up(self):",
            "        self.reqhandler.send_frames([b''.join(self.queue)])",
            "",
            "    def close(self):",
            "        self.finish_up()",
            "        self.reqhandler.send_close()",
            "",
            "",
            "class NovaProxyRequestHandlerBase(object):",
            "    def address_string(self):",
            "        # NOTE(rpodolyaka): override the superclass implementation here and",
            "        # explicitly disable the reverse DNS lookup, which might fail on some",
            "        # deployments due to DNS configuration and break VNC access completely",
            "        return str(self.client_address[0])",
            "",
            "    def verify_origin_proto(self, connect_info, origin_proto):",
            "        if 'access_url_base' not in connect_info:",
            "            detail = _(\"No access_url_base in connect_info. \"",
            "                       \"Cannot validate protocol\")",
            "            raise exception.ValidationError(detail=detail)",
            "",
            "        expected_protos = [",
            "            urlparse.urlparse(connect_info.access_url_base).scheme]",
            "        # NOTE: For serial consoles the expected protocol could be ws or",
            "        # wss which correspond to http and https respectively in terms of",
            "        # security.",
            "        if 'ws' in expected_protos:",
            "            expected_protos.append('http')",
            "        if 'wss' in expected_protos:",
            "            expected_protos.append('https')",
            "",
            "        return origin_proto in expected_protos",
            "",
            "    def _check_console_port(self, ctxt, instance_uuid, port, console_type):",
            "",
            "        try:",
            "            instance = objects.Instance.get_by_uuid(ctxt, instance_uuid)",
            "        except exception.InstanceNotFound:",
            "            return",
            "",
            "        # NOTE(melwitt): The port is expected to be a str for validation.",
            "        return self.compute_rpcapi.validate_console_port(ctxt, instance,",
            "                                                         str(port),",
            "                                                         console_type)",
            "",
            "    def _get_connect_info(self, ctxt, token):",
            "        \"\"\"Validate the token and get the connect info.\"\"\"",
            "        # NOTE(PaulMurray) ConsoleAuthToken.validate validates the token.",
            "        # We call the compute manager directly to check the console port",
            "        # is correct.",
            "        connect_info = objects.ConsoleAuthToken.validate(ctxt, token)",
            "",
            "        valid_port = self._check_console_port(",
            "            ctxt, connect_info.instance_uuid, connect_info.port,",
            "            connect_info.console_type)",
            "",
            "        if not valid_port:",
            "            raise exception.InvalidToken(token='***')",
            "",
            "        return connect_info",
            "",
            "    def new_websocket_client(self):",
            "        \"\"\"Called after a new WebSocket connection has been established.\"\"\"",
            "        # Reopen the eventlet hub to make sure we don't share an epoll",
            "        # fd with parent and/or siblings, which would be bad",
            "        from eventlet import hubs",
            "        hubs.use_hub()",
            "",
            "        # The nova expected behavior is to have token",
            "        # passed to the method GET of the request",
            "        parse = urlparse.urlparse(self.path)",
            "        if parse.scheme not in ('http', 'https'):",
            "            # From a bug in urlparse in Python < 2.7.4 we cannot support",
            "            # special schemes (cf: http://bugs.python.org/issue9374)",
            "            if sys.version_info < (2, 7, 4):",
            "                raise exception.NovaException(",
            "                    _(\"We do not support scheme '%s' under Python < 2.7.4, \"",
            "                      \"please use http or https\") % parse.scheme)",
            "",
            "        query = parse.query",
            "        token = urlparse.parse_qs(query).get(\"token\", [\"\"]).pop()",
            "        if not token:",
            "            # NoVNC uses it's own convention that forward token",
            "            # from the request to a cookie header, we should check",
            "            # also for this behavior",
            "            hcookie = self.headers.get('cookie')",
            "            if hcookie:",
            "                cookie = Cookie.SimpleCookie()",
            "                for hcookie_part in hcookie.split(';'):",
            "                    hcookie_part = hcookie_part.lstrip()",
            "                    try:",
            "                        cookie.load(hcookie_part)",
            "                    except Cookie.CookieError:",
            "                        # NOTE(stgleb): Do not print out cookie content",
            "                        # for security reasons.",
            "                        LOG.warning('Found malformed cookie')",
            "                    else:",
            "                        if 'token' in cookie:",
            "                            token = cookie['token'].value",
            "",
            "        ctxt = context.get_admin_context()",
            "        connect_info = self._get_connect_info(ctxt, token)",
            "",
            "        # Verify Origin",
            "        expected_origin_hostname = self.headers.get('Host')",
            "        if ':' in expected_origin_hostname:",
            "            e = expected_origin_hostname",
            "            if '[' in e and ']' in e:",
            "                expected_origin_hostname = e.split(']')[0][1:]",
            "            else:",
            "                expected_origin_hostname = e.split(':')[0]",
            "        expected_origin_hostnames = CONF.console.allowed_origins",
            "        expected_origin_hostnames.append(expected_origin_hostname)",
            "        origin_url = self.headers.get('Origin')",
            "        # missing origin header indicates non-browser client which is OK",
            "        if origin_url is not None:",
            "            origin = urlparse.urlparse(origin_url)",
            "            origin_hostname = origin.hostname",
            "            origin_scheme = origin.scheme",
            "            # If the console connection was forwarded by a proxy (example:",
            "            # haproxy), the original protocol could be contained in the",
            "            # X-Forwarded-Proto header instead of the Origin header. Prefer the",
            "            # forwarded protocol if it is present.",
            "            forwarded_proto = self.headers.get('X-Forwarded-Proto')",
            "            if forwarded_proto is not None:",
            "                origin_scheme = forwarded_proto",
            "            if origin_hostname == '' or origin_scheme == '':",
            "                detail = _(\"Origin header not valid.\")",
            "                raise exception.ValidationError(detail=detail)",
            "            if origin_hostname not in expected_origin_hostnames:",
            "                detail = _(\"Origin header does not match this host.\")",
            "                raise exception.ValidationError(detail=detail)",
            "            if not self.verify_origin_proto(connect_info, origin_scheme):",
            "                detail = _(\"Origin header protocol does not match this host.\")",
            "                raise exception.ValidationError(detail=detail)",
            "",
            "        self.msg(_('connect info: %s'), str(connect_info))",
            "        host = connect_info.host",
            "        port = connect_info.port",
            "",
            "        # Connect to the target",
            "        self.msg(_(\"connecting to: %(host)s:%(port)s\") % {'host': host,",
            "                                                          'port': port})",
            "        tsock = self.socket(host, port, connect=True)",
            "",
            "        # Handshake as necessary",
            "        if 'internal_access_path' in connect_info:",
            "            path = connect_info.internal_access_path",
            "            if path:",
            "                tsock.send(encodeutils.safe_encode(",
            "                    'CONNECT %s HTTP/1.1\\r\\n\\r\\n' % path))",
            "                end_token = \"\\r\\n\\r\\n\"",
            "                while True:",
            "                    data = tsock.recv(4096, socket.MSG_PEEK)",
            "                    token_loc = data.find(end_token)",
            "                    if token_loc != -1:",
            "                        if data.split(\"\\r\\n\")[0].find(\"200\") == -1:",
            "                            raise exception.InvalidConnectionInfo()",
            "                        # remove the response from recv buffer",
            "                        tsock.recv(token_loc + len(end_token))",
            "                        break",
            "",
            "        if self.server.security_proxy is not None:",
            "            tenant_sock = TenantSock(self)",
            "",
            "            try:",
            "                tsock = self.server.security_proxy.connect(tenant_sock, tsock)",
            "            except exception.SecurityProxyNegotiationFailed:",
            "                LOG.exception(\"Unable to perform security proxying, shutting \"",
            "                              \"down connection\")",
            "                tenant_sock.close()",
            "                tsock.shutdown(socket.SHUT_RDWR)",
            "                tsock.close()",
            "                raise",
            "",
            "            tenant_sock.finish_up()",
            "",
            "        # Start proxying",
            "        try:",
            "            self.do_proxy(tsock)",
            "        except Exception:",
            "            if tsock:",
            "                tsock.shutdown(socket.SHUT_RDWR)",
            "                tsock.close()",
            "                self.vmsg(_(\"%(host)s:%(port)s: \"",
            "                          \"Websocket client or target closed\") %",
            "                          {'host': host, 'port': port})",
            "            raise",
            "",
            "",
            "class NovaProxyRequestHandler(NovaProxyRequestHandlerBase,",
            "                              websockify.ProxyRequestHandler):",
            "    def __init__(self, *args, **kwargs):",
            "        self._compute_rpcapi = None",
            "        websockify.ProxyRequestHandler.__init__(self, *args, **kwargs)",
            "",
            "    @property",
            "    def compute_rpcapi(self):",
            "        # Lazy load the rpcapi/ComputeAPI upon first use for this connection.",
            "        # This way, if we receive a TCP RST, we will not create a ComputeAPI",
            "        # object we won't use.",
            "        if not self._compute_rpcapi:",
            "            self._compute_rpcapi = compute_rpcapi.ComputeAPI()",
            "        return self._compute_rpcapi",
            "",
            "    def socket(self, *args, **kwargs):",
            "        # TODO(melwitt): The try_import and if-else condition can be removed",
            "        # when we get to the point where we're requiring at least websockify",
            "        # v.0.9.0 in our lower-constraints.",
            "        if websockifyserver is not None:",
            "            # In websockify v0.9.0, the 'socket' method moved to the",
            "            # websockify.websockifyserver.WebSockifyServer class.",
            "            return websockifyserver.WebSockifyServer.socket(*args, **kwargs)",
            "        else:",
            "            # Fall back to the websockify <= v0.8.0 'socket' method location.",
            "            return websockify.WebSocketServer.socket(*args, **kwargs)",
            "",
            "",
            "class NovaWebSocketProxy(websockify.WebSocketProxy):",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\":param security_proxy: instance of",
            "            nova.console.securityproxy.base.SecurityProxy",
            "",
            "        Create a new web socket proxy, optionally using the",
            "        @security_proxy instance to negotiate security layer",
            "        with the compute node.",
            "        \"\"\"",
            "        self.security_proxy = kwargs.pop('security_proxy', None)",
            "        super(NovaWebSocketProxy, self).__init__(*args, **kwargs)",
            "",
            "    @staticmethod",
            "    def get_logger():",
            "        return LOG"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "'''",
            "Websocket proxy that is compatible with OpenStack Nova.",
            "Leverages websockify.py by Joel Martin",
            "'''",
            "",
            "import copy",
            "import socket",
            "import sys",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import encodeutils",
            "from oslo_utils import importutils",
            "import six",
            "from six.moves import http_cookies as Cookie",
            "import six.moves.urllib.parse as urlparse",
            "import websockify",
            "",
            "from nova.compute import rpcapi as compute_rpcapi",
            "import nova.conf",
            "from nova import context",
            "from nova import exception",
            "from nova.i18n import _",
            "from nova import objects",
            "",
            "# Location of WebSockifyServer class in websockify v0.9.0",
            "websockifyserver = importutils.try_import('websockify.websockifyserver')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class TenantSock(object):",
            "    \"\"\"A socket wrapper for communicating with the tenant.",
            "",
            "    This class provides a socket-like interface to the internal",
            "    websockify send/receive queue for the client connection to",
            "    the tenant user. It is used with the security proxy classes.",
            "    \"\"\"",
            "",
            "    def __init__(self, reqhandler):",
            "        self.reqhandler = reqhandler",
            "        self.queue = []",
            "",
            "    def recv(self, cnt):",
            "        # NB(sross): it's ok to block here because we know",
            "        #            exactly the sequence of data arriving",
            "        while len(self.queue) < cnt:",
            "            # new_frames looks like ['abc', 'def']",
            "            new_frames, closed = self.reqhandler.recv_frames()",
            "            # flatten frames onto queue",
            "            for frame in new_frames:",
            "                # The socket returns (byte) strings in Python 2...",
            "                if six.PY2:",
            "                    self.queue.extend(frame)",
            "                # ...and integers in Python 3. For the Python 3 case, we need",
            "                # to convert these to characters using 'chr' and then, as this",
            "                # returns unicode, convert the result to byte strings.",
            "                else:",
            "                    self.queue.extend(",
            "                        [six.binary_type(chr(c), 'ascii') for c in frame])",
            "",
            "            if closed:",
            "                break",
            "",
            "        popped = self.queue[0:cnt]",
            "        del self.queue[0:cnt]",
            "        return b''.join(popped)",
            "",
            "    def sendall(self, data):",
            "        self.reqhandler.send_frames([encodeutils.safe_encode(data)])",
            "",
            "    def finish_up(self):",
            "        self.reqhandler.send_frames([b''.join(self.queue)])",
            "",
            "    def close(self):",
            "        self.finish_up()",
            "        self.reqhandler.send_close()",
            "",
            "",
            "class NovaProxyRequestHandlerBase(object):",
            "    def address_string(self):",
            "        # NOTE(rpodolyaka): override the superclass implementation here and",
            "        # explicitly disable the reverse DNS lookup, which might fail on some",
            "        # deployments due to DNS configuration and break VNC access completely",
            "        return str(self.client_address[0])",
            "",
            "    def verify_origin_proto(self, connect_info, origin_proto):",
            "        if 'access_url_base' not in connect_info:",
            "            detail = _(\"No access_url_base in connect_info. \"",
            "                       \"Cannot validate protocol\")",
            "            raise exception.ValidationError(detail=detail)",
            "",
            "        expected_protos = [",
            "            urlparse.urlparse(connect_info.access_url_base).scheme]",
            "        # NOTE: For serial consoles the expected protocol could be ws or",
            "        # wss which correspond to http and https respectively in terms of",
            "        # security.",
            "        if 'ws' in expected_protos:",
            "            expected_protos.append('http')",
            "        if 'wss' in expected_protos:",
            "            expected_protos.append('https')",
            "",
            "        return origin_proto in expected_protos",
            "",
            "    def _check_console_port(self, ctxt, instance_uuid, port, console_type):",
            "",
            "        try:",
            "            instance = objects.Instance.get_by_uuid(ctxt, instance_uuid)",
            "        except exception.InstanceNotFound:",
            "            return",
            "",
            "        # NOTE(melwitt): The port is expected to be a str for validation.",
            "        return self.compute_rpcapi.validate_console_port(ctxt, instance,",
            "                                                         str(port),",
            "                                                         console_type)",
            "",
            "    def _get_connect_info(self, ctxt, token):",
            "        \"\"\"Validate the token and get the connect info.\"\"\"",
            "        # NOTE(PaulMurray) ConsoleAuthToken.validate validates the token.",
            "        # We call the compute manager directly to check the console port",
            "        # is correct.",
            "        connect_info = objects.ConsoleAuthToken.validate(ctxt, token)",
            "",
            "        valid_port = self._check_console_port(",
            "            ctxt, connect_info.instance_uuid, connect_info.port,",
            "            connect_info.console_type)",
            "",
            "        if not valid_port:",
            "            raise exception.InvalidToken(token='***')",
            "",
            "        return connect_info",
            "",
            "    def new_websocket_client(self):",
            "        \"\"\"Called after a new WebSocket connection has been established.\"\"\"",
            "        # Reopen the eventlet hub to make sure we don't share an epoll",
            "        # fd with parent and/or siblings, which would be bad",
            "        from eventlet import hubs",
            "        hubs.use_hub()",
            "",
            "        # The nova expected behavior is to have token",
            "        # passed to the method GET of the request",
            "        parse = urlparse.urlparse(self.path)",
            "        if parse.scheme not in ('http', 'https'):",
            "            # From a bug in urlparse in Python < 2.7.4 we cannot support",
            "            # special schemes (cf: http://bugs.python.org/issue9374)",
            "            if sys.version_info < (2, 7, 4):",
            "                raise exception.NovaException(",
            "                    _(\"We do not support scheme '%s' under Python < 2.7.4, \"",
            "                      \"please use http or https\") % parse.scheme)",
            "",
            "        query = parse.query",
            "        token = urlparse.parse_qs(query).get(\"token\", [\"\"]).pop()",
            "        if not token:",
            "            # NoVNC uses it's own convention that forward token",
            "            # from the request to a cookie header, we should check",
            "            # also for this behavior",
            "            hcookie = self.headers.get('cookie')",
            "            if hcookie:",
            "                cookie = Cookie.SimpleCookie()",
            "                for hcookie_part in hcookie.split(';'):",
            "                    hcookie_part = hcookie_part.lstrip()",
            "                    try:",
            "                        cookie.load(hcookie_part)",
            "                    except Cookie.CookieError:",
            "                        # NOTE(stgleb): Do not print out cookie content",
            "                        # for security reasons.",
            "                        LOG.warning('Found malformed cookie')",
            "                    else:",
            "                        if 'token' in cookie:",
            "                            token = cookie['token'].value",
            "",
            "        ctxt = context.get_admin_context()",
            "        connect_info = self._get_connect_info(ctxt, token)",
            "",
            "        # Verify Origin",
            "        expected_origin_hostname = self.headers.get('Host')",
            "        if ':' in expected_origin_hostname:",
            "            e = expected_origin_hostname",
            "            if '[' in e and ']' in e:",
            "                expected_origin_hostname = e.split(']')[0][1:]",
            "            else:",
            "                expected_origin_hostname = e.split(':')[0]",
            "        expected_origin_hostnames = CONF.console.allowed_origins",
            "        expected_origin_hostnames.append(expected_origin_hostname)",
            "        origin_url = self.headers.get('Origin')",
            "        # missing origin header indicates non-browser client which is OK",
            "        if origin_url is not None:",
            "            origin = urlparse.urlparse(origin_url)",
            "            origin_hostname = origin.hostname",
            "            origin_scheme = origin.scheme",
            "            # If the console connection was forwarded by a proxy (example:",
            "            # haproxy), the original protocol could be contained in the",
            "            # X-Forwarded-Proto header instead of the Origin header. Prefer the",
            "            # forwarded protocol if it is present.",
            "            forwarded_proto = self.headers.get('X-Forwarded-Proto')",
            "            if forwarded_proto is not None:",
            "                origin_scheme = forwarded_proto",
            "            if origin_hostname == '' or origin_scheme == '':",
            "                detail = _(\"Origin header not valid.\")",
            "                raise exception.ValidationError(detail=detail)",
            "            if origin_hostname not in expected_origin_hostnames:",
            "                detail = _(\"Origin header does not match this host.\")",
            "                raise exception.ValidationError(detail=detail)",
            "            if not self.verify_origin_proto(connect_info, origin_scheme):",
            "                detail = _(\"Origin header protocol does not match this host.\")",
            "                raise exception.ValidationError(detail=detail)",
            "",
            "        sanitized_info = copy.copy(connect_info)",
            "        sanitized_info.token = '***'",
            "        self.msg(_('connect info: %s'), sanitized_info)",
            "",
            "        host = connect_info.host",
            "        port = connect_info.port",
            "",
            "        # Connect to the target",
            "        self.msg(_(\"connecting to: %(host)s:%(port)s\") % {'host': host,",
            "                                                          'port': port})",
            "        tsock = self.socket(host, port, connect=True)",
            "",
            "        # Handshake as necessary",
            "        if 'internal_access_path' in connect_info:",
            "            path = connect_info.internal_access_path",
            "            if path:",
            "                tsock.send(encodeutils.safe_encode(",
            "                    'CONNECT %s HTTP/1.1\\r\\n\\r\\n' % path))",
            "                end_token = \"\\r\\n\\r\\n\"",
            "                while True:",
            "                    data = tsock.recv(4096, socket.MSG_PEEK)",
            "                    token_loc = data.find(end_token)",
            "                    if token_loc != -1:",
            "                        if data.split(\"\\r\\n\")[0].find(\"200\") == -1:",
            "                            raise exception.InvalidConnectionInfo()",
            "                        # remove the response from recv buffer",
            "                        tsock.recv(token_loc + len(end_token))",
            "                        break",
            "",
            "        if self.server.security_proxy is not None:",
            "            tenant_sock = TenantSock(self)",
            "",
            "            try:",
            "                tsock = self.server.security_proxy.connect(tenant_sock, tsock)",
            "            except exception.SecurityProxyNegotiationFailed:",
            "                LOG.exception(\"Unable to perform security proxying, shutting \"",
            "                              \"down connection\")",
            "                tenant_sock.close()",
            "                tsock.shutdown(socket.SHUT_RDWR)",
            "                tsock.close()",
            "                raise",
            "",
            "            tenant_sock.finish_up()",
            "",
            "        # Start proxying",
            "        try:",
            "            self.do_proxy(tsock)",
            "        except Exception:",
            "            if tsock:",
            "                tsock.shutdown(socket.SHUT_RDWR)",
            "                tsock.close()",
            "                self.vmsg(_(\"%(host)s:%(port)s: \"",
            "                          \"Websocket client or target closed\") %",
            "                          {'host': host, 'port': port})",
            "            raise",
            "",
            "",
            "class NovaProxyRequestHandler(NovaProxyRequestHandlerBase,",
            "                              websockify.ProxyRequestHandler):",
            "    def __init__(self, *args, **kwargs):",
            "        self._compute_rpcapi = None",
            "        websockify.ProxyRequestHandler.__init__(self, *args, **kwargs)",
            "",
            "    @property",
            "    def compute_rpcapi(self):",
            "        # Lazy load the rpcapi/ComputeAPI upon first use for this connection.",
            "        # This way, if we receive a TCP RST, we will not create a ComputeAPI",
            "        # object we won't use.",
            "        if not self._compute_rpcapi:",
            "            self._compute_rpcapi = compute_rpcapi.ComputeAPI()",
            "        return self._compute_rpcapi",
            "",
            "    def socket(self, *args, **kwargs):",
            "        # TODO(melwitt): The try_import and if-else condition can be removed",
            "        # when we get to the point where we're requiring at least websockify",
            "        # v.0.9.0 in our lower-constraints.",
            "        if websockifyserver is not None:",
            "            # In websockify v0.9.0, the 'socket' method moved to the",
            "            # websockify.websockifyserver.WebSockifyServer class.",
            "            return websockifyserver.WebSockifyServer.socket(*args, **kwargs)",
            "        else:",
            "            # Fall back to the websockify <= v0.8.0 'socket' method location.",
            "            return websockify.WebSocketServer.socket(*args, **kwargs)",
            "",
            "",
            "class NovaWebSocketProxy(websockify.WebSocketProxy):",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\":param security_proxy: instance of",
            "            nova.console.securityproxy.base.SecurityProxy",
            "",
            "        Create a new web socket proxy, optionally using the",
            "        @security_proxy instance to negotiate security layer",
            "        with the compute node.",
            "        \"\"\"",
            "        self.security_proxy = kwargs.pop('security_proxy', None)",
            "        super(NovaWebSocketProxy, self).__init__(*args, **kwargs)",
            "",
            "    @staticmethod",
            "    def get_logger():",
            "        return LOG"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "223": [
                "NovaProxyRequestHandlerBase",
                "new_websocket_client"
            ]
        },
        "addLocation": []
    },
    "nova/tests/unit/console/test_websocketproxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "         validate.assert_called_with(mock.ANY, \"123-456-789\")"
            },
            "1": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "         self.wh.socket.assert_called_with('node1', 10000, connect=True)"
            },
            "2": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         self.wh.do_proxy.assert_called_with('<socket>')"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        # ensure that token is masked when logged"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        connection_info = self.wh.msg.mock_calls[0][1][1]"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        self.assertEqual('***', connection_info.token)"
            },
            "6": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 225,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "     @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'"
            },
            "8": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "                 '_check_console_port')"
            }
        },
        "frontPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Tests for nova websocketproxy.\"\"\"",
            "",
            "import copy",
            "import socket",
            "",
            "import mock",
            "from oslo_utils.fixture import uuidsentinel as uuids",
            "",
            "import nova.conf",
            "from nova.console.securityproxy import base",
            "from nova.console import websocketproxy",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova import objects",
            "from nova import test",
            "from nova.tests.unit import fake_console_auth_token as fake_ca",
            "from nova import utils",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class NovaProxyRequestHandlerDBTestCase(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaProxyRequestHandlerDBTestCase, self).setUp()",
            "",
            "        self.flags(console_allowed_origins=['allowed-origin-example-1.net',",
            "                                            'allowed-origin-example-2.net'])",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = websocketproxy.NovaWebSocketProxy()",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "    def _fake_console_db(self, **updates):",
            "        console_db = copy.deepcopy(fake_ca.fake_token_dict)",
            "        console_db['token_hash'] = utils.get_sha256_str('123-456-789')",
            "        if updates:",
            "            console_db.update(updates)",
            "        return console_db",
            "",
            "    fake_header = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    def test_new_websocket_client_db(",
            "            self, mock_validate_port, mock_inst_get, mock_validate,",
            "            internal_access_path=None,",
            "            instance_not_found=False):",
            "",
            "        db_obj = self._fake_console_db(",
            "            host='node1',",
            "            port=10000,",
            "            console_type='novnc',",
            "            access_url_base='https://example.net:6080',",
            "            internal_access_path=internal_access_path,",
            "            instance_uuid=uuids.instance,",
            "            # This is set by ConsoleAuthToken.validate",
            "            token='123-456-789'",
            "        )",
            "        ctxt = nova_context.get_context()",
            "        obj = nova.objects.ConsoleAuthToken._from_db_object(",
            "            ctxt, nova.objects.ConsoleAuthToken(), db_obj)",
            "        mock_validate.return_value = obj",
            "",
            "        if instance_not_found:",
            "            mock_inst_get.side_effect = exception.InstanceNotFound(",
            "                instance_id=uuids.instance)",
            "",
            "        if internal_access_path is None:",
            "            self.wh.socket.return_value = '<socket>'",
            "        else:",
            "            tsock = mock.MagicMock()",
            "            tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "            self.wh.socket.return_value = tsock",
            "",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        if instance_not_found:",
            "            self.assertRaises(exception.InvalidToken,",
            "                              self.wh.new_websocket_client)",
            "        else:",
            "            with mock.patch('nova.context.get_admin_context',",
            "                            return_value=ctxt):",
            "                self.wh.new_websocket_client()",
            "",
            "            mock_validate.assert_called_once_with(ctxt, '123-456-789')",
            "            mock_validate_port.assert_called_once_with(",
            "                ctxt, mock_inst_get.return_value, str(db_obj['port']),",
            "                db_obj['console_type'])",
            "",
            "            self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "",
            "            if internal_access_path is None:",
            "                self.wh.do_proxy.assert_called_with('<socket>')",
            "            else:",
            "                self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    def test_new_websocket_client_db_internal_access_path(self):",
            "        self.test_new_websocket_client_db(internal_access_path='vmid')",
            "",
            "    def test_new_websocket_client_db_instance_not_found(self):",
            "        self.test_new_websocket_client_db(instance_not_found=True)",
            "",
            "",
            "class NovaProxyRequestHandlerBaseTestCase(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaProxyRequestHandlerBaseTestCase, self).setUp()",
            "",
            "        self.flags(allowed_origins=['allowed-origin-example-1.net',",
            "                                    'allowed-origin-example-2.net'],",
            "                   group='console')",
            "        self.server = websocketproxy.NovaWebSocketProxy()",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = self.server",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "    fake_header = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_ipv6 = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://[2001:db8::1]:6080',",
            "        'Host': '[2001:db8::1]:6080',",
            "    }",
            "",
            "    fake_header_bad_token = {",
            "        'cookie': 'token=\"XXX\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_bad_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://bad-origin-example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_allowed_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://allowed-origin-example-2.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_blank_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': '',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_no_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_http = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'http://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_malformed_cookie = {",
            "        'cookie': '?=!; token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_ipv6_url(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://[2001:db8::1]:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://[2001:db8::1]/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header_ipv6",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_token_invalid(self, validate):",
            "        validate.side_effect = exception.InvalidToken(token='XXX')",
            "",
            "        self.wh.path = \"http://127.0.0.1/?token=XXX\"",
            "        self.wh.headers = self.fake_header_bad_token",
            "",
            "        self.assertRaises(exception.InvalidToken,",
            "                          self.wh.new_websocket_client)",
            "        validate.assert_called_with(mock.ANY, \"XXX\")",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path(self, validate,",
            "                                                       check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'vmid',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        tsock.send.assert_called_with(test.MatchType(bytes))",
            "        self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path_err(self, validate,",
            "                                                           check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'xxx',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        tsock.recv.return_value = \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\"",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.InvalidConnectionInfo,",
            "                          self.wh.new_websocket_client)",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path_rfb(self, validate,",
            "                                                           check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'vmid',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        HTTP_RESP = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "        RFB_MSG = \"RFB 003.003\\n\"",
            "        # RFB negotiation message may arrive earlier.",
            "        tsock.recv.side_effect = [HTTP_RESP + RFB_MSG,",
            "                                  HTTP_RESP]",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        tsock.recv.assert_has_calls([mock.call(4096, socket.MSG_PEEK),",
            "                                     mock.call(len(HTTP_RESP))])",
            "        self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    @mock.patch.object(websocketproxy, 'sys')",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_py273_good_scheme(",
            "            self, validate, check_port, mock_sys):",
            "        mock_sys.version_info.return_value = (2, 7, 3)",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('socket.getfqdn')",
            "    def test_address_string_doesnt_do_reverse_dns_lookup(self, getfqdn):",
            "        request_mock = mock.MagicMock()",
            "        request_mock.makefile().readline.side_effect = [",
            "            b'GET /vnc.html?token=123-456-789 HTTP/1.1\\r\\n',",
            "            b''",
            "        ]",
            "        server_mock = mock.MagicMock()",
            "        client_address = ('8.8.8.8', 54321)",
            "",
            "        handler = websocketproxy.NovaProxyRequestHandler(",
            "            request_mock, client_address, server_mock)",
            "        handler.log_message('log message using client address context info')",
            "",
            "        self.assertFalse(getfqdn.called)  # no reverse dns look up",
            "        self.assertEqual(handler.address_string(), '8.8.8.8')  # plain address",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_bad_origin_header(self, validate,",
            "                                                          check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_bad_origin",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_allowed_origin_header(self, validate,",
            "                                                              check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_allowed_origin",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_blank_origin_header(self, validate,",
            "                                                            check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_blank_origin",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_no_origin_header(self, validate,",
            "                                                         check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_no_origin",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_https_origin_proto_http(",
            "            self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'http://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_https_origin_proto_ws(self, validate,",
            "                                                              check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'serial',",
            "            'access_url_base': 'ws://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_http_forwarded_proto_https(self, validate,",
            "                                                             check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'serial',",
            "            'access_url_base': 'wss://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        header = {",
            "            'cookie': 'token=\"123-456-789\"',",
            "            'Origin': 'http://example.net:6080',",
            "            'Host': 'example.net:6080',",
            "            'X-Forwarded-Proto': 'https'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_bad_console_type(self, validate,",
            "                                                         check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'bad-console-type'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_malformed_cookie(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_malformed_cookie",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    def test_tcp_rst_no_compute_rpcapi(self):",
            "        # Tests that we don't create a ComputeAPI object if we receive a",
            "        # TCP RST message. Simulate by raising the socket.err upon recv.",
            "        err = socket.error('[Errno 104] Connection reset by peer')",
            "        self.wh.socket.recv.side_effect = err",
            "        conn = mock.MagicMock()",
            "        address = mock.MagicMock()",
            "        self.wh.server.top_new_client(conn, address)",
            "        self.assertIsNone(self.wh._compute_rpcapi)",
            "",
            "",
            "class NovaWebsocketSecurityProxyTestCase(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaWebsocketSecurityProxyTestCase, self).setUp()",
            "",
            "        self.flags(allowed_origins=['allowed-origin-example-1.net',",
            "                                    'allowed-origin-example-2.net'],",
            "                   group='console')",
            "",
            "        self.server = websocketproxy.NovaWebSocketProxy(",
            "            security_proxy=mock.MagicMock(",
            "                spec=base.SecurityProxy)",
            "        )",
            "",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = self.server",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "        def get_header(header):",
            "            if header == 'cookie':",
            "                return 'token=\"123-456-789\"'",
            "            elif header == 'Origin':",
            "                return 'https://example.net:6080'",
            "            elif header == 'Host':",
            "                return 'example.net:6080'",
            "            else:",
            "                return",
            "",
            "        self.wh.headers.get = get_header",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.close')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')",
            "    def test_proxy_connect_ok(self, mock_finish, mock_close,",
            "                              mock_port_validate, mock_get,",
            "                              mock_token_validate):",
            "        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(",
            "            instance_uuid=uuids.instance, host='node1', port='10000',",
            "            console_type='novnc', access_url_base='https://example.net:6080')",
            "        # The token and id attributes are set by the validate() method.",
            "        mock_token_validate.return_value.token = '123-456-789'",
            "        mock_token_validate.return_value.id = 1",
            "",
            "        sock = mock.MagicMock(",
            "            spec=websocketproxy.TenantSock)",
            "        self.server.security_proxy.connect.return_value = sock",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        self.wh.do_proxy.assert_called_with(sock)",
            "        mock_finish.assert_called_with()",
            "        self.assertEqual(len(mock_close.calls), 0)",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.close')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')",
            "    def test_proxy_connect_err(self, mock_finish, mock_close,",
            "                               mock_port_validate, mock_get,",
            "                               mock_token_validate):",
            "        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(",
            "            instance_uuid=uuids.instance, host='node1', port='10000',",
            "            console_type='novnc', access_url_base='https://example.net:6080')",
            "        # The token attribute is set by the validate() method.",
            "        mock_token_validate.return_value.token = '123-456-789'",
            "        mock_token_validate.return_value.id = 1",
            "",
            "        ex = exception.SecurityProxyNegotiationFailed(\"Wibble\")",
            "        self.server.security_proxy.connect.side_effect = ex",
            "",
            "        self.assertRaises(exception.SecurityProxyNegotiationFailed,",
            "                          self.wh.new_websocket_client)",
            "",
            "        self.assertEqual(len(self.wh.do_proxy.calls), 0)",
            "        mock_close.assert_called_with()",
            "        self.assertEqual(len(mock_finish.calls), 0)"
        ],
        "afterPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Tests for nova websocketproxy.\"\"\"",
            "",
            "import copy",
            "import socket",
            "",
            "import mock",
            "from oslo_utils.fixture import uuidsentinel as uuids",
            "",
            "import nova.conf",
            "from nova.console.securityproxy import base",
            "from nova.console import websocketproxy",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova import objects",
            "from nova import test",
            "from nova.tests.unit import fake_console_auth_token as fake_ca",
            "from nova import utils",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class NovaProxyRequestHandlerDBTestCase(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaProxyRequestHandlerDBTestCase, self).setUp()",
            "",
            "        self.flags(console_allowed_origins=['allowed-origin-example-1.net',",
            "                                            'allowed-origin-example-2.net'])",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = websocketproxy.NovaWebSocketProxy()",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "    def _fake_console_db(self, **updates):",
            "        console_db = copy.deepcopy(fake_ca.fake_token_dict)",
            "        console_db['token_hash'] = utils.get_sha256_str('123-456-789')",
            "        if updates:",
            "            console_db.update(updates)",
            "        return console_db",
            "",
            "    fake_header = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    def test_new_websocket_client_db(",
            "            self, mock_validate_port, mock_inst_get, mock_validate,",
            "            internal_access_path=None,",
            "            instance_not_found=False):",
            "",
            "        db_obj = self._fake_console_db(",
            "            host='node1',",
            "            port=10000,",
            "            console_type='novnc',",
            "            access_url_base='https://example.net:6080',",
            "            internal_access_path=internal_access_path,",
            "            instance_uuid=uuids.instance,",
            "            # This is set by ConsoleAuthToken.validate",
            "            token='123-456-789'",
            "        )",
            "        ctxt = nova_context.get_context()",
            "        obj = nova.objects.ConsoleAuthToken._from_db_object(",
            "            ctxt, nova.objects.ConsoleAuthToken(), db_obj)",
            "        mock_validate.return_value = obj",
            "",
            "        if instance_not_found:",
            "            mock_inst_get.side_effect = exception.InstanceNotFound(",
            "                instance_id=uuids.instance)",
            "",
            "        if internal_access_path is None:",
            "            self.wh.socket.return_value = '<socket>'",
            "        else:",
            "            tsock = mock.MagicMock()",
            "            tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "            self.wh.socket.return_value = tsock",
            "",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        if instance_not_found:",
            "            self.assertRaises(exception.InvalidToken,",
            "                              self.wh.new_websocket_client)",
            "        else:",
            "            with mock.patch('nova.context.get_admin_context',",
            "                            return_value=ctxt):",
            "                self.wh.new_websocket_client()",
            "",
            "            mock_validate.assert_called_once_with(ctxt, '123-456-789')",
            "            mock_validate_port.assert_called_once_with(",
            "                ctxt, mock_inst_get.return_value, str(db_obj['port']),",
            "                db_obj['console_type'])",
            "",
            "            self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "",
            "            if internal_access_path is None:",
            "                self.wh.do_proxy.assert_called_with('<socket>')",
            "            else:",
            "                self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    def test_new_websocket_client_db_internal_access_path(self):",
            "        self.test_new_websocket_client_db(internal_access_path='vmid')",
            "",
            "    def test_new_websocket_client_db_instance_not_found(self):",
            "        self.test_new_websocket_client_db(instance_not_found=True)",
            "",
            "",
            "class NovaProxyRequestHandlerBaseTestCase(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaProxyRequestHandlerBaseTestCase, self).setUp()",
            "",
            "        self.flags(allowed_origins=['allowed-origin-example-1.net',",
            "                                    'allowed-origin-example-2.net'],",
            "                   group='console')",
            "        self.server = websocketproxy.NovaWebSocketProxy()",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = self.server",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "    fake_header = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_ipv6 = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://[2001:db8::1]:6080',",
            "        'Host': '[2001:db8::1]:6080',",
            "    }",
            "",
            "    fake_header_bad_token = {",
            "        'cookie': 'token=\"XXX\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_bad_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://bad-origin-example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_allowed_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://allowed-origin-example-2.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_blank_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': '',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_no_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_http = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'http://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_malformed_cookie = {",
            "        'cookie': '?=!; token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "        # ensure that token is masked when logged",
            "        connection_info = self.wh.msg.mock_calls[0][1][1]",
            "        self.assertEqual('***', connection_info.token)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_ipv6_url(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://[2001:db8::1]:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://[2001:db8::1]/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header_ipv6",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_token_invalid(self, validate):",
            "        validate.side_effect = exception.InvalidToken(token='XXX')",
            "",
            "        self.wh.path = \"http://127.0.0.1/?token=XXX\"",
            "        self.wh.headers = self.fake_header_bad_token",
            "",
            "        self.assertRaises(exception.InvalidToken,",
            "                          self.wh.new_websocket_client)",
            "        validate.assert_called_with(mock.ANY, \"XXX\")",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path(self, validate,",
            "                                                       check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'vmid',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        tsock.send.assert_called_with(test.MatchType(bytes))",
            "        self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path_err(self, validate,",
            "                                                           check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'xxx',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        tsock.recv.return_value = \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\"",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.InvalidConnectionInfo,",
            "                          self.wh.new_websocket_client)",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path_rfb(self, validate,",
            "                                                           check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'vmid',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        HTTP_RESP = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "        RFB_MSG = \"RFB 003.003\\n\"",
            "        # RFB negotiation message may arrive earlier.",
            "        tsock.recv.side_effect = [HTTP_RESP + RFB_MSG,",
            "                                  HTTP_RESP]",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        tsock.recv.assert_has_calls([mock.call(4096, socket.MSG_PEEK),",
            "                                     mock.call(len(HTTP_RESP))])",
            "        self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    @mock.patch.object(websocketproxy, 'sys')",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_py273_good_scheme(",
            "            self, validate, check_port, mock_sys):",
            "        mock_sys.version_info.return_value = (2, 7, 3)",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('socket.getfqdn')",
            "    def test_address_string_doesnt_do_reverse_dns_lookup(self, getfqdn):",
            "        request_mock = mock.MagicMock()",
            "        request_mock.makefile().readline.side_effect = [",
            "            b'GET /vnc.html?token=123-456-789 HTTP/1.1\\r\\n',",
            "            b''",
            "        ]",
            "        server_mock = mock.MagicMock()",
            "        client_address = ('8.8.8.8', 54321)",
            "",
            "        handler = websocketproxy.NovaProxyRequestHandler(",
            "            request_mock, client_address, server_mock)",
            "        handler.log_message('log message using client address context info')",
            "",
            "        self.assertFalse(getfqdn.called)  # no reverse dns look up",
            "        self.assertEqual(handler.address_string(), '8.8.8.8')  # plain address",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_bad_origin_header(self, validate,",
            "                                                          check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_bad_origin",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_allowed_origin_header(self, validate,",
            "                                                              check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_allowed_origin",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_blank_origin_header(self, validate,",
            "                                                            check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_blank_origin",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_no_origin_header(self, validate,",
            "                                                         check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_no_origin",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_https_origin_proto_http(",
            "            self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'http://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_https_origin_proto_ws(self, validate,",
            "                                                              check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'serial',",
            "            'access_url_base': 'ws://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_http_forwarded_proto_https(self, validate,",
            "                                                             check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'serial',",
            "            'access_url_base': 'wss://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        header = {",
            "            'cookie': 'token=\"123-456-789\"',",
            "            'Origin': 'http://example.net:6080',",
            "            'Host': 'example.net:6080',",
            "            'X-Forwarded-Proto': 'https'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_bad_console_type(self, validate,",
            "                                                         check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'bad-console-type'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_malformed_cookie(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_malformed_cookie",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    def test_tcp_rst_no_compute_rpcapi(self):",
            "        # Tests that we don't create a ComputeAPI object if we receive a",
            "        # TCP RST message. Simulate by raising the socket.err upon recv.",
            "        err = socket.error('[Errno 104] Connection reset by peer')",
            "        self.wh.socket.recv.side_effect = err",
            "        conn = mock.MagicMock()",
            "        address = mock.MagicMock()",
            "        self.wh.server.top_new_client(conn, address)",
            "        self.assertIsNone(self.wh._compute_rpcapi)",
            "",
            "",
            "class NovaWebsocketSecurityProxyTestCase(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaWebsocketSecurityProxyTestCase, self).setUp()",
            "",
            "        self.flags(allowed_origins=['allowed-origin-example-1.net',",
            "                                    'allowed-origin-example-2.net'],",
            "                   group='console')",
            "",
            "        self.server = websocketproxy.NovaWebSocketProxy(",
            "            security_proxy=mock.MagicMock(",
            "                spec=base.SecurityProxy)",
            "        )",
            "",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = self.server",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "        def get_header(header):",
            "            if header == 'cookie':",
            "                return 'token=\"123-456-789\"'",
            "            elif header == 'Origin':",
            "                return 'https://example.net:6080'",
            "            elif header == 'Host':",
            "                return 'example.net:6080'",
            "            else:",
            "                return",
            "",
            "        self.wh.headers.get = get_header",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.close')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')",
            "    def test_proxy_connect_ok(self, mock_finish, mock_close,",
            "                              mock_port_validate, mock_get,",
            "                              mock_token_validate):",
            "        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(",
            "            instance_uuid=uuids.instance, host='node1', port='10000',",
            "            console_type='novnc', access_url_base='https://example.net:6080')",
            "        # The token and id attributes are set by the validate() method.",
            "        mock_token_validate.return_value.token = '123-456-789'",
            "        mock_token_validate.return_value.id = 1",
            "",
            "        sock = mock.MagicMock(",
            "            spec=websocketproxy.TenantSock)",
            "        self.server.security_proxy.connect.return_value = sock",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        self.wh.do_proxy.assert_called_with(sock)",
            "        mock_finish.assert_called_with()",
            "        self.assertEqual(len(mock_close.calls), 0)",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.close')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')",
            "    def test_proxy_connect_err(self, mock_finish, mock_close,",
            "                               mock_port_validate, mock_get,",
            "                               mock_token_validate):",
            "        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(",
            "            instance_uuid=uuids.instance, host='node1', port='10000',",
            "            console_type='novnc', access_url_base='https://example.net:6080')",
            "        # The token attribute is set by the validate() method.",
            "        mock_token_validate.return_value.token = '123-456-789'",
            "        mock_token_validate.return_value.id = 1",
            "",
            "        ex = exception.SecurityProxyNegotiationFailed(\"Wibble\")",
            "        self.server.security_proxy.connect.side_effect = ex",
            "",
            "        self.assertRaises(exception.SecurityProxyNegotiationFailed,",
            "                          self.wh.new_websocket_client)",
            "",
            "        self.assertEqual(len(self.wh.do_proxy.calls), 0)",
            "        mock_close.assert_called_with()",
            "        self.assertEqual(len(mock_finish.calls), 0)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.console.test_websocketproxy.NovaProxyRequestHandlerBaseTestCase.test_new_websocket_client.params"
        ]
    }
}