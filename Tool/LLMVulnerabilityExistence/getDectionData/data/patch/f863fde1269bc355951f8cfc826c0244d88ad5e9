{
    "src/zenml/config/server_config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from secrets import token_hex"
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Any, Dict, List, Optional"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from typing import Any, Dict, List, Optional, Union"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from uuid import UUID"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from pydantic import BaseModel, Field, SecretStr, root_validator"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE,"
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     DEFAULT_ZENML_SERVER_MAX_DEVICE_AUTH_ATTEMPTS,"
            },
            "10": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     DEFAULT_ZENML_SERVER_PIPELINE_RUN_AUTH_WINDOW,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    DEFAULT_ZENML_SERVER_SECURE_HEADERS_CACHE,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    DEFAULT_ZENML_SERVER_SECURE_HEADERS_CONTENT,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    DEFAULT_ZENML_SERVER_SECURE_HEADERS_CSP,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    DEFAULT_ZENML_SERVER_SECURE_HEADERS_HSTS,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    DEFAULT_ZENML_SERVER_SECURE_HEADERS_PERMISSIONS,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    DEFAULT_ZENML_SERVER_SECURE_HEADERS_REFERRER,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    DEFAULT_ZENML_SERVER_SECURE_HEADERS_XFO,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    DEFAULT_ZENML_SERVER_SECURE_HEADERS_XXP,"
            },
            "19": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     ENV_ZENML_SERVER_PREFIX,"
            },
            "20": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " )"
            },
            "21": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " from zenml.enums import AuthScheme"
            },
            "22": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "             server."
            },
            "23": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         login_rate_limit_minute: The number of login attempts allowed per minute."
            },
            "24": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         login_rate_limit_day: The number of login attempts allowed per day."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        secure_headers_server: Custom value to be set in the `Server` HTTP"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+            header to identify the server. If not specified, or if set to one of"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+            the reserved values `enabled`, `yes`, `true`, `on`, the `Server`"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+            header will be set to the default value (ZenML server ID). If set to"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            one of the reserved values `disabled`, `no`, `none`, `false`, `off`"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            or to an empty string, the `Server` header will not be included in"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            responses."
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        secure_headers_hsts: The server header value to be set in the HTTP"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            header `Strict-Transport-Security`. If not specified, or if set to"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            one of the reserved values `enabled`, `yes`, `true`, `on`, the"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            `Strict-Transport-Security` header will be set to the default value"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            (`max-age=63072000; includeSubdomains`). If set to one of"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            the reserved values `disabled`, `no`, `none`, `false`, `off` or to"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            an empty string, the `Strict-Transport-Security` header will not be"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            included in responses."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        secure_headers_xfo: The server header value to be set in the HTTP"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            header `X-Frame-Options`. If not specified, or if set to one of the"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+            reserved values `enabled`, `yes`, `true`, `on`, the `X-Frame-Options`"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+            header will be set to the default value (`SAMEORIGIN`). If set to"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            one of the reserved values `disabled`, `no`, `none`, `false`, `off`"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+            or to an empty string, the `X-Frame-Options` header will not be"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            included in responses."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        secure_headers_xxp: The server header value to be set in the HTTP"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            header `X-XSS-Protection`. If not specified, or if set to one of the"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            reserved values `enabled`, `yes`, `true`, `on`, the `X-XSS-Protection`"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            header will be set to the default value (`0`). If set to one of the"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            reserved values `disabled`, `no`, `none`, `false`, `off` or"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            to an empty string, the `X-XSS-Protection` header will not be"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            included in responses. NOTE: this header is deprecated and should"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            always be set to `0`. The `Content-Security-Policy` header should be"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            used instead."
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        secure_headers_content: The server header value to be set in the HTTP"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+            header `X-Content-Type-Options`. If not specified, or if set to one"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+            of the reserved values `enabled`, `yes`, `true`, `on`, the"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+            `X-Content-Type-Options` header will be set to the default value"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+            (`nosniff`). If set to one of the reserved values `disabled`, `no`,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+            `none`, `false`, `off` or to an empty string, the"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            `X-Content-Type-Options` header will not be included in responses."
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        secure_headers_csp: The server header value to be set in the HTTP"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            header `Content-Security-Policy`. If not specified, or if set to one"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            of the reserved values `enabled`, `yes`, `true`, `on`, the"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            `Content-Security-Policy` header will be set to a default value"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+            that is compatible with the ZenML dashboard. If set to one of the"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+            reserved values `disabled`, `no`, `none`, `false`, `off` or to an"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+            empty string, the `Content-Security-Policy` header will not be"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+            included in responses."
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        secure_headers_referrer: The server header value to be set in the HTTP"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+            header `Referrer-Policy`. If not specified, or if set to one of the"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+            reserved values `enabled`, `yes`, `true`, `on`, the `Referrer-Policy`"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+            header will be set to the default value"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            (`no-referrer-when-downgrade`). If set to one of the reserved values"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            `disabled`, `no`, `none`, `false`, `off` or to an empty string, the"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+            `Referrer-Policy` header will not be included in responses."
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        secure_headers_cache: The server header value to be set in the HTTP"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            header `Cache-Control`. If not specified, or if set to one of the"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+            reserved values `enabled`, `yes`, `true`, `on`, the `Cache-Control`"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            header will be set to the default value"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            (`no-store, no-cache, must-revalidate`). If set to one of the"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            reserved values `disabled`, `no`, `none`, `false`, `off` or to an"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            empty string, the `Cache-Control` header will not be included in"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+            responses."
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        secure_headers_permissions: The server header value to be set in the"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            HTTP header `Permissions-Policy`. If not specified, or if set to one"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            of the reserved values `enabled`, `yes`, `true`, `on`, the"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+            `Permissions-Policy` header will be set to the default value"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+            (`accelerometer=(), camera=(), geolocation=(), gyroscope=(),"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+              magnetometer=(), microphone=(), payment=(), usb=()`). If set to"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+            one of the reserved values `disabled`, `no`, `none`, `false`, `off`"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+            or to an empty string, the `Permissions-Policy` header will not be"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+            included in responses."
            },
            "95": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "     \"\"\""
            },
            "96": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 210,
                "PatchRowcode": " "
            },
            "97": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     deployment_type: ServerDeploymentType = ServerDeploymentType.OTHER"
            },
            "98": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "     login_rate_limit_minute: int = DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE"
            },
            "99": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "     login_rate_limit_day: int = DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_DAY"
            },
            "100": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " "
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+    secure_headers_server: Union[bool, str] = True"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+    secure_headers_hsts: Union[bool, str] = ("
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        DEFAULT_ZENML_SERVER_SECURE_HEADERS_HSTS"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+    )"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+    secure_headers_xfo: Union[bool, str] = ("
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+        DEFAULT_ZENML_SERVER_SECURE_HEADERS_XFO"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+    )"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+    secure_headers_xxp: Union[bool, str] = ("
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+        DEFAULT_ZENML_SERVER_SECURE_HEADERS_XXP"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+    )"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+    secure_headers_content: Union[bool, str] = ("
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+        DEFAULT_ZENML_SERVER_SECURE_HEADERS_CONTENT"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+    )"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+    secure_headers_csp: Union[bool, str] = ("
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+        DEFAULT_ZENML_SERVER_SECURE_HEADERS_CSP"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+    )"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+    secure_headers_referrer: Union[bool, str] = ("
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+        DEFAULT_ZENML_SERVER_SECURE_HEADERS_REFERRER"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+    )"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+    secure_headers_cache: Union[bool, str] = ("
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+        DEFAULT_ZENML_SERVER_SECURE_HEADERS_CACHE"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    )"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+    secure_headers_permissions: Union[bool, str] = ("
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+        DEFAULT_ZENML_SERVER_SECURE_HEADERS_PERMISSIONS"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+    )"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+"
            },
            "127": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "     _deployment_id: Optional[UUID] = None"
            },
            "128": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 279,
                "PatchRowcode": " "
            },
            "129": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "     @root_validator(pre=True)"
            },
            "130": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "                     f\"The server metadata is not a valid JSON string: {e}\""
            },
            "131": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "                 )"
            },
            "132": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 327,
                "PatchRowcode": " "
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+        # if one of the secure headers options is set to a boolean value, set"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+        # the corresponding value"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+        for k, v in values.copy().items():"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+            if k.startswith(\"secure_headers_\") and isinstance(v, str):"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+                if v.lower() in [\"disabled\", \"no\", \"none\", \"false\", \"off\", \"\"]:"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+                    values[k] = False"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+                if v.lower() in [\"enabled\", \"yes\", \"true\", \"on\"]:"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+                    # Revert to the default value if the header is enabled"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+                    del values[k]"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+"
            },
            "143": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "         return values"
            },
            "144": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 339,
                "PatchRowcode": " "
            },
            "145": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "     @property"
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Functionality to support ZenML GlobalConfiguration.\"\"\"",
            "",
            "import json",
            "import os",
            "from secrets import token_hex",
            "from typing import Any, Dict, List, Optional",
            "from uuid import UUID",
            "",
            "from pydantic import BaseModel, Field, SecretStr, root_validator",
            "",
            "from zenml.constants import (",
            "    DEFAULT_ZENML_JWT_TOKEN_ALGORITHM,",
            "    DEFAULT_ZENML_JWT_TOKEN_LEEWAY,",
            "    DEFAULT_ZENML_SERVER_DEVICE_AUTH_POLLING,",
            "    DEFAULT_ZENML_SERVER_DEVICE_AUTH_TIMEOUT,",
            "    DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_DAY,",
            "    DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE,",
            "    DEFAULT_ZENML_SERVER_MAX_DEVICE_AUTH_ATTEMPTS,",
            "    DEFAULT_ZENML_SERVER_PIPELINE_RUN_AUTH_WINDOW,",
            "    ENV_ZENML_SERVER_PREFIX,",
            ")",
            "from zenml.enums import AuthScheme",
            "from zenml.logger import get_logger",
            "from zenml.models import ServerDeploymentType",
            "",
            "logger = get_logger(__name__)",
            "",
            "",
            "def generate_jwt_secret_key() -> str:",
            "    \"\"\"Generate a random JWT secret key.",
            "",
            "    This key is used to sign and verify generated JWT tokens.",
            "",
            "    Returns:",
            "        A random JWT secret key.",
            "    \"\"\"",
            "    return token_hex(32)",
            "",
            "",
            "class ServerConfiguration(BaseModel):",
            "    \"\"\"ZenML Server configuration attributes.",
            "",
            "    Attributes:",
            "        deployment_type: The type of ZenML server deployment that is running.",
            "        base_url: The base URL of the ZenML server.",
            "        root_url_path: The root URL path of the ZenML server.",
            "        auth_scheme: The authentication scheme used by the ZenML server.",
            "        jwt_token_algorithm: The algorithm used to sign and verify JWT tokens.",
            "        jwt_token_issuer: The issuer of the JWT tokens. If not specified, the",
            "            issuer is set to the ZenML Server ID.",
            "        jwt_token_audience: The audience of the JWT tokens. If not specified,",
            "            the audience is set to the ZenML Server ID.",
            "        jwt_token_leeway_seconds: The leeway in seconds allowed when verifying",
            "            the expiration time of JWT tokens.",
            "        jwt_token_expire_minutes: The expiration time of JWT tokens in minutes.",
            "            If not specified, generated JWT tokens will not be set to expire.",
            "        jwt_secret_key: The secret key used to sign and verify JWT tokens. If",
            "            not specified, a random secret key is generated.",
            "        auth_cookie_name: The name of the http-only cookie used to store the JWT",
            "            token. If not specified, the cookie name is set to a value computed",
            "            from the ZenML server ID.",
            "        auth_cookie_domain: The domain of the http-only cookie used to store the",
            "            JWT token. If not specified, the cookie will be valid for the",
            "            domain where the ZenML server is running.",
            "        cors_allow_origins: The origins allowed to make cross-origin requests",
            "            to the ZenML server. If not specified, all origins are allowed.",
            "        max_failed_device_auth_attempts: The maximum number of failed OAuth 2.0",
            "            device authentication attempts before the device is locked.",
            "        device_auth_timeout: The timeout in seconds after which a pending OAuth",
            "            2.0 device authorization request expires.",
            "        device_auth_polling_interval: The polling interval in seconds used to",
            "            poll the OAuth 2.0 device authorization endpoint.",
            "        dashboard_url: The URL where the ZenML dashboard is hosted. Used to",
            "            construct the OAuth 2.0 device authorization endpoint. If not set,",
            "            a partial URL is returned to the client which is used to construct",
            "            the full URL based on the server's root URL path.",
            "        device_expiration_minutes: The time in minutes that an OAuth 2.0 device is",
            "            allowed to be used to authenticate with the ZenML server. If not",
            "            set or if `jwt_token_expire_minutes` is not set, the devices are",
            "            allowed to be used indefinitely. This controls the expiration time",
            "            of the JWT tokens issued to clients after they have authenticated",
            "            with the ZenML server using an OAuth 2.0 device.",
            "        trusted_device_expiration_minutes: The time in minutes that a trusted OAuth 2.0",
            "            device is allowed to be used to authenticate with the ZenML server.",
            "            If not set or if `jwt_token_expire_minutes` is not set, the devices",
            "            are allowed to be used indefinitely. This controls the expiration",
            "            time of the JWT tokens issued to clients after they have",
            "            authenticated with the ZenML server using an OAuth 2.0 device",
            "            that has been marked as trusted.",
            "        external_login_url: The login URL of an external authenticator service",
            "            to use with the `EXTERNAL` authentication scheme.",
            "        external_user_info_url: The user info URL of an external authenticator",
            "            service to use with the `EXTERNAL` authentication scheme.",
            "        external_cookie_name: The name of the http-only cookie used to store the",
            "            bearer token used to authenticate with the external authenticator",
            "            service. Must be specified if the `EXTERNAL` authentication scheme",
            "            is used.",
            "        external_server_id: The ID of the ZenML server to use with the",
            "            `EXTERNAL` authentication scheme. If not specified, the regular",
            "            ZenML server ID is used.",
            "        metadata: Additional metadata to be associated with the ZenML server.",
            "        rbac_implementation_source: Source pointing to a class implementing",
            "            the RBAC interface defined by",
            "            `zenml.zen_server.rbac_interface.RBACInterface`. If not specified,",
            "            RBAC will not be enabled for this server.",
            "        feature_gate_implementation_source: Source pointing to a class",
            "            implementing the feature gate interface defined by",
            "            `zenml.zen_server.feature_gate.feature_gate_interface.FeatureGateInterface`.",
            "            If not specified, feature usage will not be gated/tracked for this",
            "            server.",
            "        workload_manager_implementation_source: Source pointing to a class",
            "            implementing the workload management interface.",
            "        pipeline_run_auth_window: The default time window in minutes for which",
            "            a pipeline run action is allowed to authenticate with the ZenML",
            "            server.",
            "        login_rate_limit_minute: The number of login attempts allowed per minute.",
            "        login_rate_limit_day: The number of login attempts allowed per day.",
            "    \"\"\"",
            "",
            "    deployment_type: ServerDeploymentType = ServerDeploymentType.OTHER",
            "    base_url: str = \"\"",
            "    root_url_path: str = \"\"",
            "    metadata: Dict[str, Any] = {}",
            "    auth_scheme: AuthScheme = AuthScheme.OAUTH2_PASSWORD_BEARER",
            "    jwt_token_algorithm: str = DEFAULT_ZENML_JWT_TOKEN_ALGORITHM",
            "    jwt_token_issuer: Optional[str] = None",
            "    jwt_token_audience: Optional[str] = None",
            "    jwt_token_leeway_seconds: int = DEFAULT_ZENML_JWT_TOKEN_LEEWAY",
            "    jwt_token_expire_minutes: Optional[int] = None",
            "    jwt_secret_key: str = Field(default_factory=generate_jwt_secret_key)",
            "    auth_cookie_name: Optional[str] = None",
            "    auth_cookie_domain: Optional[str] = None",
            "    cors_allow_origins: Optional[List[str]] = None",
            "    max_failed_device_auth_attempts: int = (",
            "        DEFAULT_ZENML_SERVER_MAX_DEVICE_AUTH_ATTEMPTS",
            "    )",
            "    device_auth_timeout: int = DEFAULT_ZENML_SERVER_DEVICE_AUTH_TIMEOUT",
            "    device_auth_polling_interval: int = (",
            "        DEFAULT_ZENML_SERVER_DEVICE_AUTH_POLLING",
            "    )",
            "    dashboard_url: Optional[str] = None",
            "    device_expiration_minutes: Optional[int] = None",
            "    trusted_device_expiration_minutes: Optional[int] = None",
            "",
            "    external_login_url: Optional[str] = None",
            "    external_user_info_url: Optional[str] = None",
            "    external_cookie_name: Optional[str] = None",
            "    external_server_id: Optional[UUID] = None",
            "",
            "    rbac_implementation_source: Optional[str] = None",
            "    feature_gate_implementation_source: Optional[str] = None",
            "    workload_manager_implementation_source: Optional[str] = None",
            "    pipeline_run_auth_window: int = (",
            "        DEFAULT_ZENML_SERVER_PIPELINE_RUN_AUTH_WINDOW",
            "    )",
            "",
            "    rate_limit_enabled: bool = False",
            "    login_rate_limit_minute: int = DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE",
            "    login_rate_limit_day: int = DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_DAY",
            "",
            "    _deployment_id: Optional[UUID] = None",
            "",
            "    @root_validator(pre=True)",
            "    def _validate_config(cls, values: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Validate the server configuration.",
            "",
            "        Args:",
            "            values: The server configuration values.",
            "",
            "        Returns:",
            "            The validated server configuration values.",
            "",
            "        Raises:",
            "            ValueError: If the server configuration is invalid.",
            "        \"\"\"",
            "        if values.get(\"auth_scheme\") == AuthScheme.EXTERNAL:",
            "            # If the authentication scheme is set to `EXTERNAL`, the",
            "            # external authenticator URLs must be specified.",
            "            if not values.get(\"external_login_url\") or not values.get(",
            "                \"external_user_info_url\"",
            "            ):",
            "                raise ValueError(",
            "                    \"The external login and user info authenticator \"",
            "                    \"URLs must be specified when using the EXTERNAL \"",
            "                    \"authentication scheme.\"",
            "                )",
            "",
            "            # If the authentication scheme is set to `EXTERNAL`, the",
            "            # external cookie name must be specified.",
            "            if not values.get(\"external_cookie_name\"):",
            "                raise ValueError(",
            "                    \"The external cookie name must be specified when \"",
            "                    \"using the EXTERNAL authentication scheme.\"",
            "                )",
            "",
            "        if cors_allow_origins := values.get(\"cors_allow_origins\"):",
            "            origins = cors_allow_origins.split(\",\")",
            "            values[\"cors_allow_origins\"] = origins",
            "        else:",
            "            values[\"cors_allow_origins\"] = [\"*\"]",
            "",
            "        # if metadata is a string, convert it to a dictionary",
            "        if isinstance(values.get(\"metadata\"), str):",
            "            try:",
            "                values[\"metadata\"] = json.loads(values[\"metadata\"])",
            "            except json.JSONDecodeError as e:",
            "                raise ValueError(",
            "                    f\"The server metadata is not a valid JSON string: {e}\"",
            "                )",
            "",
            "        return values",
            "",
            "    @property",
            "    def deployment_id(self) -> UUID:",
            "        \"\"\"Get the ZenML server deployment ID.",
            "",
            "        Returns:",
            "            The ZenML server deployment ID.",
            "        \"\"\"",
            "        from zenml.config.global_config import GlobalConfiguration",
            "",
            "        if self._deployment_id:",
            "            return self._deployment_id",
            "",
            "        self._deployment_id = (",
            "            GlobalConfiguration().zen_store.get_deployment_id()",
            "        )",
            "",
            "        return self._deployment_id",
            "",
            "    @property",
            "    def rbac_enabled(self) -> bool:",
            "        \"\"\"Whether RBAC is enabled on the server or not.",
            "",
            "        Returns:",
            "            Whether RBAC is enabled on the server or not.",
            "        \"\"\"",
            "        return self.rbac_implementation_source is not None",
            "",
            "    @property",
            "    def feature_gate_enabled(self) -> bool:",
            "        \"\"\"Whether feature gating is enabled on the server or not.",
            "",
            "        Returns:",
            "            Whether feature gating is enabled on the server or not.",
            "        \"\"\"",
            "        return self.feature_gate_implementation_source is not None",
            "",
            "    @property",
            "    def workload_manager_enabled(self) -> bool:",
            "        \"\"\"Whether workload management is enabled on the server or not.",
            "",
            "        Returns:",
            "            Whether workload management is enabled on the server or not.",
            "        \"\"\"",
            "        return self.workload_manager_implementation_source is not None",
            "",
            "    def get_jwt_token_issuer(self) -> str:",
            "        \"\"\"Get the JWT token issuer.",
            "",
            "        If not configured, the issuer is set to the ZenML Server ID.",
            "",
            "        Returns:",
            "            The JWT token issuer.",
            "        \"\"\"",
            "        if self.jwt_token_issuer:",
            "            return self.jwt_token_issuer",
            "",
            "        self.jwt_token_issuer = str(self.deployment_id)",
            "",
            "        return self.jwt_token_issuer",
            "",
            "    def get_jwt_token_audience(self) -> str:",
            "        \"\"\"Get the JWT token audience.",
            "",
            "        If not configured, the audience is set to the ZenML Server ID.",
            "",
            "        Returns:",
            "            The JWT token audience.",
            "        \"\"\"",
            "        if self.jwt_token_audience:",
            "            return self.jwt_token_audience",
            "",
            "        self.jwt_token_audience = str(self.deployment_id)",
            "",
            "        return self.jwt_token_audience",
            "",
            "    def get_auth_cookie_name(self) -> str:",
            "        \"\"\"Get the authentication cookie name.",
            "",
            "        If not configured, the cookie name is set to a value computed from the",
            "        ZenML server ID.",
            "",
            "        Returns:",
            "            The authentication cookie name.",
            "        \"\"\"",
            "        if self.auth_cookie_name:",
            "            return self.auth_cookie_name",
            "",
            "        self.auth_cookie_name = f\"zenml-server-{self.deployment_id}\"",
            "",
            "        return self.auth_cookie_name",
            "",
            "    def get_external_server_id(self) -> UUID:",
            "        \"\"\"Get the external server ID.",
            "",
            "        If not configured, the regular ZenML server ID is used.",
            "",
            "        Returns:",
            "            The external server ID.",
            "        \"\"\"",
            "        if self.external_server_id:",
            "            return self.external_server_id",
            "",
            "        self.external_server_id = self.deployment_id",
            "",
            "        return self.external_server_id",
            "",
            "    @classmethod",
            "    def get_server_config(cls) -> \"ServerConfiguration\":",
            "        \"\"\"Get the server configuration.",
            "",
            "        Returns:",
            "            The server configuration.",
            "        \"\"\"",
            "        env_server_config: Dict[str, Any] = {}",
            "        for k, v in os.environ.items():",
            "            if v == \"\":",
            "                continue",
            "            if k.startswith(ENV_ZENML_SERVER_PREFIX):",
            "                env_server_config[",
            "                    k[len(ENV_ZENML_SERVER_PREFIX) :].lower()",
            "                ] = v",
            "",
            "        return ServerConfiguration(**env_server_config)",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration class.\"\"\"",
            "",
            "        # Allow extra attributes from configs of previous ZenML versions to",
            "        # permit downgrading",
            "        extra = \"allow\"",
            "        # all attributes with leading underscore are private and therefore",
            "        # are mutable and not included in serialization",
            "        underscore_attrs_are_private = True",
            "",
            "        # This is needed to allow correct handling of SecretStr values during",
            "        # serialization.",
            "        json_encoders = {",
            "            SecretStr: lambda v: v.get_secret_value() if v else None",
            "        }"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Functionality to support ZenML GlobalConfiguration.\"\"\"",
            "",
            "import json",
            "import os",
            "from secrets import token_hex",
            "from typing import Any, Dict, List, Optional, Union",
            "from uuid import UUID",
            "",
            "from pydantic import BaseModel, Field, SecretStr, root_validator",
            "",
            "from zenml.constants import (",
            "    DEFAULT_ZENML_JWT_TOKEN_ALGORITHM,",
            "    DEFAULT_ZENML_JWT_TOKEN_LEEWAY,",
            "    DEFAULT_ZENML_SERVER_DEVICE_AUTH_POLLING,",
            "    DEFAULT_ZENML_SERVER_DEVICE_AUTH_TIMEOUT,",
            "    DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_DAY,",
            "    DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE,",
            "    DEFAULT_ZENML_SERVER_MAX_DEVICE_AUTH_ATTEMPTS,",
            "    DEFAULT_ZENML_SERVER_PIPELINE_RUN_AUTH_WINDOW,",
            "    DEFAULT_ZENML_SERVER_SECURE_HEADERS_CACHE,",
            "    DEFAULT_ZENML_SERVER_SECURE_HEADERS_CONTENT,",
            "    DEFAULT_ZENML_SERVER_SECURE_HEADERS_CSP,",
            "    DEFAULT_ZENML_SERVER_SECURE_HEADERS_HSTS,",
            "    DEFAULT_ZENML_SERVER_SECURE_HEADERS_PERMISSIONS,",
            "    DEFAULT_ZENML_SERVER_SECURE_HEADERS_REFERRER,",
            "    DEFAULT_ZENML_SERVER_SECURE_HEADERS_XFO,",
            "    DEFAULT_ZENML_SERVER_SECURE_HEADERS_XXP,",
            "    ENV_ZENML_SERVER_PREFIX,",
            ")",
            "from zenml.enums import AuthScheme",
            "from zenml.logger import get_logger",
            "from zenml.models import ServerDeploymentType",
            "",
            "logger = get_logger(__name__)",
            "",
            "",
            "def generate_jwt_secret_key() -> str:",
            "    \"\"\"Generate a random JWT secret key.",
            "",
            "    This key is used to sign and verify generated JWT tokens.",
            "",
            "    Returns:",
            "        A random JWT secret key.",
            "    \"\"\"",
            "    return token_hex(32)",
            "",
            "",
            "class ServerConfiguration(BaseModel):",
            "    \"\"\"ZenML Server configuration attributes.",
            "",
            "    Attributes:",
            "        deployment_type: The type of ZenML server deployment that is running.",
            "        base_url: The base URL of the ZenML server.",
            "        root_url_path: The root URL path of the ZenML server.",
            "        auth_scheme: The authentication scheme used by the ZenML server.",
            "        jwt_token_algorithm: The algorithm used to sign and verify JWT tokens.",
            "        jwt_token_issuer: The issuer of the JWT tokens. If not specified, the",
            "            issuer is set to the ZenML Server ID.",
            "        jwt_token_audience: The audience of the JWT tokens. If not specified,",
            "            the audience is set to the ZenML Server ID.",
            "        jwt_token_leeway_seconds: The leeway in seconds allowed when verifying",
            "            the expiration time of JWT tokens.",
            "        jwt_token_expire_minutes: The expiration time of JWT tokens in minutes.",
            "            If not specified, generated JWT tokens will not be set to expire.",
            "        jwt_secret_key: The secret key used to sign and verify JWT tokens. If",
            "            not specified, a random secret key is generated.",
            "        auth_cookie_name: The name of the http-only cookie used to store the JWT",
            "            token. If not specified, the cookie name is set to a value computed",
            "            from the ZenML server ID.",
            "        auth_cookie_domain: The domain of the http-only cookie used to store the",
            "            JWT token. If not specified, the cookie will be valid for the",
            "            domain where the ZenML server is running.",
            "        cors_allow_origins: The origins allowed to make cross-origin requests",
            "            to the ZenML server. If not specified, all origins are allowed.",
            "        max_failed_device_auth_attempts: The maximum number of failed OAuth 2.0",
            "            device authentication attempts before the device is locked.",
            "        device_auth_timeout: The timeout in seconds after which a pending OAuth",
            "            2.0 device authorization request expires.",
            "        device_auth_polling_interval: The polling interval in seconds used to",
            "            poll the OAuth 2.0 device authorization endpoint.",
            "        dashboard_url: The URL where the ZenML dashboard is hosted. Used to",
            "            construct the OAuth 2.0 device authorization endpoint. If not set,",
            "            a partial URL is returned to the client which is used to construct",
            "            the full URL based on the server's root URL path.",
            "        device_expiration_minutes: The time in minutes that an OAuth 2.0 device is",
            "            allowed to be used to authenticate with the ZenML server. If not",
            "            set or if `jwt_token_expire_minutes` is not set, the devices are",
            "            allowed to be used indefinitely. This controls the expiration time",
            "            of the JWT tokens issued to clients after they have authenticated",
            "            with the ZenML server using an OAuth 2.0 device.",
            "        trusted_device_expiration_minutes: The time in minutes that a trusted OAuth 2.0",
            "            device is allowed to be used to authenticate with the ZenML server.",
            "            If not set or if `jwt_token_expire_minutes` is not set, the devices",
            "            are allowed to be used indefinitely. This controls the expiration",
            "            time of the JWT tokens issued to clients after they have",
            "            authenticated with the ZenML server using an OAuth 2.0 device",
            "            that has been marked as trusted.",
            "        external_login_url: The login URL of an external authenticator service",
            "            to use with the `EXTERNAL` authentication scheme.",
            "        external_user_info_url: The user info URL of an external authenticator",
            "            service to use with the `EXTERNAL` authentication scheme.",
            "        external_cookie_name: The name of the http-only cookie used to store the",
            "            bearer token used to authenticate with the external authenticator",
            "            service. Must be specified if the `EXTERNAL` authentication scheme",
            "            is used.",
            "        external_server_id: The ID of the ZenML server to use with the",
            "            `EXTERNAL` authentication scheme. If not specified, the regular",
            "            ZenML server ID is used.",
            "        metadata: Additional metadata to be associated with the ZenML server.",
            "        rbac_implementation_source: Source pointing to a class implementing",
            "            the RBAC interface defined by",
            "            `zenml.zen_server.rbac_interface.RBACInterface`. If not specified,",
            "            RBAC will not be enabled for this server.",
            "        feature_gate_implementation_source: Source pointing to a class",
            "            implementing the feature gate interface defined by",
            "            `zenml.zen_server.feature_gate.feature_gate_interface.FeatureGateInterface`.",
            "            If not specified, feature usage will not be gated/tracked for this",
            "            server.",
            "        workload_manager_implementation_source: Source pointing to a class",
            "            implementing the workload management interface.",
            "        pipeline_run_auth_window: The default time window in minutes for which",
            "            a pipeline run action is allowed to authenticate with the ZenML",
            "            server.",
            "        login_rate_limit_minute: The number of login attempts allowed per minute.",
            "        login_rate_limit_day: The number of login attempts allowed per day.",
            "        secure_headers_server: Custom value to be set in the `Server` HTTP",
            "            header to identify the server. If not specified, or if set to one of",
            "            the reserved values `enabled`, `yes`, `true`, `on`, the `Server`",
            "            header will be set to the default value (ZenML server ID). If set to",
            "            one of the reserved values `disabled`, `no`, `none`, `false`, `off`",
            "            or to an empty string, the `Server` header will not be included in",
            "            responses.",
            "        secure_headers_hsts: The server header value to be set in the HTTP",
            "            header `Strict-Transport-Security`. If not specified, or if set to",
            "            one of the reserved values `enabled`, `yes`, `true`, `on`, the",
            "            `Strict-Transport-Security` header will be set to the default value",
            "            (`max-age=63072000; includeSubdomains`). If set to one of",
            "            the reserved values `disabled`, `no`, `none`, `false`, `off` or to",
            "            an empty string, the `Strict-Transport-Security` header will not be",
            "            included in responses.",
            "        secure_headers_xfo: The server header value to be set in the HTTP",
            "            header `X-Frame-Options`. If not specified, or if set to one of the",
            "            reserved values `enabled`, `yes`, `true`, `on`, the `X-Frame-Options`",
            "            header will be set to the default value (`SAMEORIGIN`). If set to",
            "            one of the reserved values `disabled`, `no`, `none`, `false`, `off`",
            "            or to an empty string, the `X-Frame-Options` header will not be",
            "            included in responses.",
            "        secure_headers_xxp: The server header value to be set in the HTTP",
            "            header `X-XSS-Protection`. If not specified, or if set to one of the",
            "            reserved values `enabled`, `yes`, `true`, `on`, the `X-XSS-Protection`",
            "            header will be set to the default value (`0`). If set to one of the",
            "            reserved values `disabled`, `no`, `none`, `false`, `off` or",
            "            to an empty string, the `X-XSS-Protection` header will not be",
            "            included in responses. NOTE: this header is deprecated and should",
            "            always be set to `0`. The `Content-Security-Policy` header should be",
            "            used instead.",
            "        secure_headers_content: The server header value to be set in the HTTP",
            "            header `X-Content-Type-Options`. If not specified, or if set to one",
            "            of the reserved values `enabled`, `yes`, `true`, `on`, the",
            "            `X-Content-Type-Options` header will be set to the default value",
            "            (`nosniff`). If set to one of the reserved values `disabled`, `no`,",
            "            `none`, `false`, `off` or to an empty string, the",
            "            `X-Content-Type-Options` header will not be included in responses.",
            "        secure_headers_csp: The server header value to be set in the HTTP",
            "            header `Content-Security-Policy`. If not specified, or if set to one",
            "            of the reserved values `enabled`, `yes`, `true`, `on`, the",
            "            `Content-Security-Policy` header will be set to a default value",
            "            that is compatible with the ZenML dashboard. If set to one of the",
            "            reserved values `disabled`, `no`, `none`, `false`, `off` or to an",
            "            empty string, the `Content-Security-Policy` header will not be",
            "            included in responses.",
            "        secure_headers_referrer: The server header value to be set in the HTTP",
            "            header `Referrer-Policy`. If not specified, or if set to one of the",
            "            reserved values `enabled`, `yes`, `true`, `on`, the `Referrer-Policy`",
            "            header will be set to the default value",
            "            (`no-referrer-when-downgrade`). If set to one of the reserved values",
            "            `disabled`, `no`, `none`, `false`, `off` or to an empty string, the",
            "            `Referrer-Policy` header will not be included in responses.",
            "        secure_headers_cache: The server header value to be set in the HTTP",
            "            header `Cache-Control`. If not specified, or if set to one of the",
            "            reserved values `enabled`, `yes`, `true`, `on`, the `Cache-Control`",
            "            header will be set to the default value",
            "            (`no-store, no-cache, must-revalidate`). If set to one of the",
            "            reserved values `disabled`, `no`, `none`, `false`, `off` or to an",
            "            empty string, the `Cache-Control` header will not be included in",
            "            responses.",
            "        secure_headers_permissions: The server header value to be set in the",
            "            HTTP header `Permissions-Policy`. If not specified, or if set to one",
            "            of the reserved values `enabled`, `yes`, `true`, `on`, the",
            "            `Permissions-Policy` header will be set to the default value",
            "            (`accelerometer=(), camera=(), geolocation=(), gyroscope=(),",
            "              magnetometer=(), microphone=(), payment=(), usb=()`). If set to",
            "            one of the reserved values `disabled`, `no`, `none`, `false`, `off`",
            "            or to an empty string, the `Permissions-Policy` header will not be",
            "            included in responses.",
            "    \"\"\"",
            "",
            "    deployment_type: ServerDeploymentType = ServerDeploymentType.OTHER",
            "    base_url: str = \"\"",
            "    root_url_path: str = \"\"",
            "    metadata: Dict[str, Any] = {}",
            "    auth_scheme: AuthScheme = AuthScheme.OAUTH2_PASSWORD_BEARER",
            "    jwt_token_algorithm: str = DEFAULT_ZENML_JWT_TOKEN_ALGORITHM",
            "    jwt_token_issuer: Optional[str] = None",
            "    jwt_token_audience: Optional[str] = None",
            "    jwt_token_leeway_seconds: int = DEFAULT_ZENML_JWT_TOKEN_LEEWAY",
            "    jwt_token_expire_minutes: Optional[int] = None",
            "    jwt_secret_key: str = Field(default_factory=generate_jwt_secret_key)",
            "    auth_cookie_name: Optional[str] = None",
            "    auth_cookie_domain: Optional[str] = None",
            "    cors_allow_origins: Optional[List[str]] = None",
            "    max_failed_device_auth_attempts: int = (",
            "        DEFAULT_ZENML_SERVER_MAX_DEVICE_AUTH_ATTEMPTS",
            "    )",
            "    device_auth_timeout: int = DEFAULT_ZENML_SERVER_DEVICE_AUTH_TIMEOUT",
            "    device_auth_polling_interval: int = (",
            "        DEFAULT_ZENML_SERVER_DEVICE_AUTH_POLLING",
            "    )",
            "    dashboard_url: Optional[str] = None",
            "    device_expiration_minutes: Optional[int] = None",
            "    trusted_device_expiration_minutes: Optional[int] = None",
            "",
            "    external_login_url: Optional[str] = None",
            "    external_user_info_url: Optional[str] = None",
            "    external_cookie_name: Optional[str] = None",
            "    external_server_id: Optional[UUID] = None",
            "",
            "    rbac_implementation_source: Optional[str] = None",
            "    feature_gate_implementation_source: Optional[str] = None",
            "    workload_manager_implementation_source: Optional[str] = None",
            "    pipeline_run_auth_window: int = (",
            "        DEFAULT_ZENML_SERVER_PIPELINE_RUN_AUTH_WINDOW",
            "    )",
            "",
            "    rate_limit_enabled: bool = False",
            "    login_rate_limit_minute: int = DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE",
            "    login_rate_limit_day: int = DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_DAY",
            "",
            "    secure_headers_server: Union[bool, str] = True",
            "    secure_headers_hsts: Union[bool, str] = (",
            "        DEFAULT_ZENML_SERVER_SECURE_HEADERS_HSTS",
            "    )",
            "    secure_headers_xfo: Union[bool, str] = (",
            "        DEFAULT_ZENML_SERVER_SECURE_HEADERS_XFO",
            "    )",
            "    secure_headers_xxp: Union[bool, str] = (",
            "        DEFAULT_ZENML_SERVER_SECURE_HEADERS_XXP",
            "    )",
            "    secure_headers_content: Union[bool, str] = (",
            "        DEFAULT_ZENML_SERVER_SECURE_HEADERS_CONTENT",
            "    )",
            "    secure_headers_csp: Union[bool, str] = (",
            "        DEFAULT_ZENML_SERVER_SECURE_HEADERS_CSP",
            "    )",
            "    secure_headers_referrer: Union[bool, str] = (",
            "        DEFAULT_ZENML_SERVER_SECURE_HEADERS_REFERRER",
            "    )",
            "    secure_headers_cache: Union[bool, str] = (",
            "        DEFAULT_ZENML_SERVER_SECURE_HEADERS_CACHE",
            "    )",
            "    secure_headers_permissions: Union[bool, str] = (",
            "        DEFAULT_ZENML_SERVER_SECURE_HEADERS_PERMISSIONS",
            "    )",
            "",
            "    _deployment_id: Optional[UUID] = None",
            "",
            "    @root_validator(pre=True)",
            "    def _validate_config(cls, values: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Validate the server configuration.",
            "",
            "        Args:",
            "            values: The server configuration values.",
            "",
            "        Returns:",
            "            The validated server configuration values.",
            "",
            "        Raises:",
            "            ValueError: If the server configuration is invalid.",
            "        \"\"\"",
            "        if values.get(\"auth_scheme\") == AuthScheme.EXTERNAL:",
            "            # If the authentication scheme is set to `EXTERNAL`, the",
            "            # external authenticator URLs must be specified.",
            "            if not values.get(\"external_login_url\") or not values.get(",
            "                \"external_user_info_url\"",
            "            ):",
            "                raise ValueError(",
            "                    \"The external login and user info authenticator \"",
            "                    \"URLs must be specified when using the EXTERNAL \"",
            "                    \"authentication scheme.\"",
            "                )",
            "",
            "            # If the authentication scheme is set to `EXTERNAL`, the",
            "            # external cookie name must be specified.",
            "            if not values.get(\"external_cookie_name\"):",
            "                raise ValueError(",
            "                    \"The external cookie name must be specified when \"",
            "                    \"using the EXTERNAL authentication scheme.\"",
            "                )",
            "",
            "        if cors_allow_origins := values.get(\"cors_allow_origins\"):",
            "            origins = cors_allow_origins.split(\",\")",
            "            values[\"cors_allow_origins\"] = origins",
            "        else:",
            "            values[\"cors_allow_origins\"] = [\"*\"]",
            "",
            "        # if metadata is a string, convert it to a dictionary",
            "        if isinstance(values.get(\"metadata\"), str):",
            "            try:",
            "                values[\"metadata\"] = json.loads(values[\"metadata\"])",
            "            except json.JSONDecodeError as e:",
            "                raise ValueError(",
            "                    f\"The server metadata is not a valid JSON string: {e}\"",
            "                )",
            "",
            "        # if one of the secure headers options is set to a boolean value, set",
            "        # the corresponding value",
            "        for k, v in values.copy().items():",
            "            if k.startswith(\"secure_headers_\") and isinstance(v, str):",
            "                if v.lower() in [\"disabled\", \"no\", \"none\", \"false\", \"off\", \"\"]:",
            "                    values[k] = False",
            "                if v.lower() in [\"enabled\", \"yes\", \"true\", \"on\"]:",
            "                    # Revert to the default value if the header is enabled",
            "                    del values[k]",
            "",
            "        return values",
            "",
            "    @property",
            "    def deployment_id(self) -> UUID:",
            "        \"\"\"Get the ZenML server deployment ID.",
            "",
            "        Returns:",
            "            The ZenML server deployment ID.",
            "        \"\"\"",
            "        from zenml.config.global_config import GlobalConfiguration",
            "",
            "        if self._deployment_id:",
            "            return self._deployment_id",
            "",
            "        self._deployment_id = (",
            "            GlobalConfiguration().zen_store.get_deployment_id()",
            "        )",
            "",
            "        return self._deployment_id",
            "",
            "    @property",
            "    def rbac_enabled(self) -> bool:",
            "        \"\"\"Whether RBAC is enabled on the server or not.",
            "",
            "        Returns:",
            "            Whether RBAC is enabled on the server or not.",
            "        \"\"\"",
            "        return self.rbac_implementation_source is not None",
            "",
            "    @property",
            "    def feature_gate_enabled(self) -> bool:",
            "        \"\"\"Whether feature gating is enabled on the server or not.",
            "",
            "        Returns:",
            "            Whether feature gating is enabled on the server or not.",
            "        \"\"\"",
            "        return self.feature_gate_implementation_source is not None",
            "",
            "    @property",
            "    def workload_manager_enabled(self) -> bool:",
            "        \"\"\"Whether workload management is enabled on the server or not.",
            "",
            "        Returns:",
            "            Whether workload management is enabled on the server or not.",
            "        \"\"\"",
            "        return self.workload_manager_implementation_source is not None",
            "",
            "    def get_jwt_token_issuer(self) -> str:",
            "        \"\"\"Get the JWT token issuer.",
            "",
            "        If not configured, the issuer is set to the ZenML Server ID.",
            "",
            "        Returns:",
            "            The JWT token issuer.",
            "        \"\"\"",
            "        if self.jwt_token_issuer:",
            "            return self.jwt_token_issuer",
            "",
            "        self.jwt_token_issuer = str(self.deployment_id)",
            "",
            "        return self.jwt_token_issuer",
            "",
            "    def get_jwt_token_audience(self) -> str:",
            "        \"\"\"Get the JWT token audience.",
            "",
            "        If not configured, the audience is set to the ZenML Server ID.",
            "",
            "        Returns:",
            "            The JWT token audience.",
            "        \"\"\"",
            "        if self.jwt_token_audience:",
            "            return self.jwt_token_audience",
            "",
            "        self.jwt_token_audience = str(self.deployment_id)",
            "",
            "        return self.jwt_token_audience",
            "",
            "    def get_auth_cookie_name(self) -> str:",
            "        \"\"\"Get the authentication cookie name.",
            "",
            "        If not configured, the cookie name is set to a value computed from the",
            "        ZenML server ID.",
            "",
            "        Returns:",
            "            The authentication cookie name.",
            "        \"\"\"",
            "        if self.auth_cookie_name:",
            "            return self.auth_cookie_name",
            "",
            "        self.auth_cookie_name = f\"zenml-server-{self.deployment_id}\"",
            "",
            "        return self.auth_cookie_name",
            "",
            "    def get_external_server_id(self) -> UUID:",
            "        \"\"\"Get the external server ID.",
            "",
            "        If not configured, the regular ZenML server ID is used.",
            "",
            "        Returns:",
            "            The external server ID.",
            "        \"\"\"",
            "        if self.external_server_id:",
            "            return self.external_server_id",
            "",
            "        self.external_server_id = self.deployment_id",
            "",
            "        return self.external_server_id",
            "",
            "    @classmethod",
            "    def get_server_config(cls) -> \"ServerConfiguration\":",
            "        \"\"\"Get the server configuration.",
            "",
            "        Returns:",
            "            The server configuration.",
            "        \"\"\"",
            "        env_server_config: Dict[str, Any] = {}",
            "        for k, v in os.environ.items():",
            "            if v == \"\":",
            "                continue",
            "            if k.startswith(ENV_ZENML_SERVER_PREFIX):",
            "                env_server_config[",
            "                    k[len(ENV_ZENML_SERVER_PREFIX) :].lower()",
            "                ] = v",
            "",
            "        return ServerConfiguration(**env_server_config)",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration class.\"\"\"",
            "",
            "        # Allow extra attributes from configs of previous ZenML versions to",
            "        # permit downgrading",
            "        extra = \"allow\"",
            "        # all attributes with leading underscore are private and therefore",
            "        # are mutable and not included in serialization",
            "        underscore_attrs_are_private = True",
            "",
            "        # This is needed to allow correct handling of SecretStr values during",
            "        # serialization.",
            "        json_encoders = {",
            "            SecretStr: lambda v: v.get_secret_value() if v else None",
            "        }"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "19": []
        },
        "addLocation": []
    },
    "src/zenml/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE = 5"
            },
            "1": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_DAY = 1000"
            },
            "2": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_HSTS = ("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+    \"max-age=63072000; includeSubdomains\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_XFO = \"SAMEORIGIN\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_XXP = \"0\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_CONTENT = \"nosniff\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_CSP = ("
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+    \"default-src 'none'; \""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+    \"script-src 'self' 'unsafe-inline' 'unsafe-eval'; \""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+    \"connect-src 'self' https://sdkdocs.zenml.io https://hubapi.zenml.io; \""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+    \"img-src 'self' data: https://public-flavor-logos.s3.eu-central-1.amazonaws.com; \""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+    \"style-src 'self' 'unsafe-inline'; \""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+    \"base-uri 'self'; \""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+    \"form-action 'self'; \""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+    \"font-src 'self';\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+    \"frame-src https://zenml.hellonext.co https://sdkdocs.zenml.io \""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_REFERRER = \"no-referrer-when-downgrade\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_CACHE = ("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+    \"no-store, no-cache, must-revalidate\""
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_PERMISSIONS = ("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+    \"accelerometer=(), autoplay=(), camera=(), encrypted-media=(), \""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+    \"geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), \""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    \"payment=(), sync-xhr=(), usb=()\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+DEFAULT_ZENML_SERVER_SECURE_HEADERS_REPORT_TO = \"default\""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 267,
                "PatchRowcode": " # Configurations to decide which resources report their usage and check for"
            },
            "32": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 268,
                "PatchRowcode": " # entitlement in the case of a cloud deployment. Expected Format is this:"
            },
            "33": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 269,
                "PatchRowcode": " # ENV_ZENML_REPORTABLE_RESOURCES='[\"Foo\", \"bar\"]'"
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2021. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"ZenML constants.\"\"\"",
            "",
            "import json",
            "import logging",
            "import os",
            "from typing import Any, List, Optional, Type, TypeVar",
            "",
            "from zenml.enums import AuthScheme",
            "",
            "T = TypeVar(\"T\")",
            "",
            "",
            "def handle_json_env_var(",
            "    var: str,",
            "    expected_type: Type[T],",
            "    default: Optional[List[str]] = None,",
            ") -> Any:",
            "    \"\"\"Converts a json env var into a Python object.",
            "",
            "    Args:",
            "        var:  The environment variable to convert.",
            "        default: The default value to return if the env var is not set.",
            "        expected_type: The type of the expected Python object.",
            "",
            "    Returns:",
            "        The converted list value.",
            "",
            "    Raises:",
            "        TypeError: In case the value of the environment variable is not of a",
            "                   valid type.",
            "",
            "    \"\"\"",
            "    # this needs to be here to avoid mutable defaults",
            "    if default is None:",
            "        default = []",
            "",
            "    value = os.getenv(var)",
            "    if value:",
            "        try:",
            "            loaded_value = json.loads(value)",
            "            # check if loaded value is of correct type",
            "            if expected_type is None or isinstance(",
            "                loaded_value, expected_type",
            "            ):",
            "                return loaded_value",
            "            else:",
            "                raise TypeError  # if not correct type, raise TypeError",
            "        except (TypeError, json.JSONDecodeError):",
            "            # Use raw logging to avoid cyclic dependency",
            "            logging.warning(",
            "                f\"Environment Variable {var} could not be loaded, into type \"",
            "                f\"{expected_type}, defaulting to: {default}.\"",
            "            )",
            "            return default",
            "    else:",
            "        return default",
            "",
            "",
            "def handle_bool_env_var(var: str, default: bool = False) -> bool:",
            "    \"\"\"Converts normal env var to boolean.",
            "",
            "    Args:",
            "        var: The environment variable to convert.",
            "        default: The default value to return if the env var is not set.",
            "",
            "    Returns:",
            "        The converted value.",
            "    \"\"\"",
            "    value = os.getenv(var)",
            "    if value in [\"1\", \"y\", \"yes\", \"True\", \"true\"]:",
            "        return True",
            "    elif value in [\"0\", \"n\", \"no\", \"False\", \"false\"]:",
            "        return False",
            "    return default",
            "",
            "",
            "def handle_int_env_var(var: str, default: int = 0) -> int:",
            "    \"\"\"Converts normal env var to int.",
            "",
            "    Args:",
            "        var: The environment variable to convert.",
            "        default: The default value to return if the env var is not set.",
            "",
            "    Returns:",
            "        The converted value.",
            "    \"\"\"",
            "    value = os.getenv(var, \"\")",
            "    try:",
            "        return int(value)",
            "    except (ValueError, TypeError):",
            "        return default",
            "",
            "",
            "# Global constants",
            "APP_NAME = \"zenml\"",
            "",
            "# Environment variables",
            "ENV_ZENML_LOGGING_COLORS_DISABLED = \"ZENML_LOGGING_COLORS_DISABLED\"",
            "ENV_ZENML_ANALYTICS_OPT_IN = \"ZENML_ANALYTICS_OPT_IN\"",
            "ENV_ZENML_CONFIG_PATH = \"ZENML_CONFIG_PATH\"",
            "ENV_ZENML_DEBUG = \"ZENML_DEBUG\"",
            "ENV_ZENML_LOGGING_VERBOSITY = \"ZENML_LOGGING_VERBOSITY\"",
            "ENV_ZENML_REPOSITORY_PATH = \"ZENML_REPOSITORY_PATH\"",
            "ENV_ZENML_PREVENT_PIPELINE_EXECUTION = \"ZENML_PREVENT_PIPELINE_EXECUTION\"",
            "ENV_ZENML_ENABLE_RICH_TRACEBACK = \"ZENML_ENABLE_RICH_TRACEBACK\"",
            "ENV_ZENML_ACTIVE_STACK_ID = \"ZENML_ACTIVE_STACK_ID\"",
            "ENV_ZENML_ACTIVE_WORKSPACE_ID = \"ZENML_ACTIVE_WORKSPACE_ID\"",
            "ENV_ZENML_SUPPRESS_LOGS = \"ZENML_SUPPRESS_LOGS\"",
            "ENV_ZENML_ENABLE_REPO_INIT_WARNINGS = \"ZENML_ENABLE_REPO_INIT_WARNINGS\"",
            "ENV_ZENML_SECRET_VALIDATION_LEVEL = \"ZENML_SECRET_VALIDATION_LEVEL\"",
            "ENV_ZENML_DEFAULT_USER_NAME = \"ZENML_DEFAULT_USER_NAME\"",
            "ENV_ZENML_DEFAULT_USER_PASSWORD = \"ZENML_DEFAULT_USER_PASSWORD\"",
            "ENV_ZENML_DEFAULT_WORKSPACE_NAME = \"ZENML_DEFAULT_WORKSPACE_NAME\"",
            "ENV_ZENML_STORE_PREFIX = \"ZENML_STORE_\"",
            "ENV_ZENML_SECRETS_STORE_PREFIX = \"ZENML_SECRETS_STORE_\"",
            "ENV_ZENML_BACKUP_SECRETS_STORE_PREFIX = \"ZENML_BACKUP_SECRETS_STORE_\"",
            "ENV_ZENML_SKIP_PIPELINE_REGISTRATION = \"ZENML_SKIP_PIPELINE_REGISTRATION\"",
            "ENV_AUTO_OPEN_DASHBOARD = \"AUTO_OPEN_DASHBOARD\"",
            "ENV_ZENML_DISABLE_DATABASE_MIGRATION = \"DISABLE_DATABASE_MIGRATION\"",
            "ENV_ZENML_LOCAL_STORES_PATH = \"ZENML_LOCAL_STORES_PATH\"",
            "ENV_ZENML_CONTAINER = \"ZENML_CONTAINER\"",
            "ENV_ZENML_PAGINATION_DEFAULT_LIMIT = \"ZENML_PAGINATION_DEFAULT_LIMIT\"",
            "ENV_ZENML_DISABLE_CLIENT_SERVER_MISMATCH_WARNING = (",
            "    \"ZENML_DISABLE_CLIENT_SERVER_MISMATCH_WARNING\"",
            ")",
            "ENV_ZENML_DISABLE_WORKSPACE_WARNINGS = \"ZENML_DISABLE_WORKSPACE_WARNINGS\"",
            "ENV_ZENML_SKIP_IMAGE_BUILDER_DEFAULT = \"ZENML_SKIP_IMAGE_BUILDER_DEFAULT\"",
            "ENV_ZENML_REQUIRES_CODE_DOWNLOAD = \"ZENML_REQUIRES_CODE_DOWNLOAD\"",
            "ENV_ZENML_SERVER = \"ZENML_SERVER\"",
            "ENV_ZENML_HUB_URL = \"ZENML_HUB_URL\"",
            "ENV_ZENML_ENFORCE_TYPE_ANNOTATIONS = \"ZENML_ENFORCE_TYPE_ANNOTATIONS\"",
            "ENV_ZENML_ENABLE_IMPLICIT_AUTH_METHODS = \"ZENML_ENABLE_IMPLICIT_AUTH_METHODS\"",
            "ENV_ZENML_DISABLE_STEP_LOGS_STORAGE = \"ZENML_DISABLE_STEP_LOGS_STORAGE\"",
            "ENV_ZENML_PIPELINE_API_TOKEN_EXPIRES_MINUTES = (",
            "    \"ZENML_PIPELINE_API_TOKEN_EXPIRES_MINUTES\"",
            ")",
            "",
            "# ZenML Server environment variables",
            "ENV_ZENML_SERVER_PREFIX = \"ZENML_SERVER_\"",
            "ENV_ZENML_SERVER_DEPLOYMENT_TYPE = f\"{ENV_ZENML_SERVER_PREFIX}DEPLOYMENT_TYPE\"",
            "ENV_ZENML_SERVER_AUTH_SCHEME = f\"{ENV_ZENML_SERVER_PREFIX}AUTH_SCHEME\"",
            "ENV_ZENML_SERVER_REPORTABLE_RESOURCES = (",
            "    f\"{ENV_ZENML_SERVER_PREFIX}REPORTABLE_RESOURCES\"",
            ")",
            "",
            "# Logging variables",
            "IS_DEBUG_ENV: bool = handle_bool_env_var(ENV_ZENML_DEBUG, default=False)",
            "",
            "if IS_DEBUG_ENV:",
            "    ZENML_LOGGING_VERBOSITY = os.getenv(",
            "        ENV_ZENML_LOGGING_VERBOSITY, default=\"DEBUG\"",
            "    ).upper()",
            "else:",
            "    ZENML_LOGGING_VERBOSITY = os.getenv(",
            "        ENV_ZENML_LOGGING_VERBOSITY, default=\"INFO\"",
            "    ).upper()",
            "",
            "INSIDE_ZENML_CONTAINER = handle_bool_env_var(ENV_ZENML_CONTAINER, False)",
            "",
            "# Analytics constants",
            "VALID_OPERATING_SYSTEMS = [\"Windows\", \"Darwin\", \"Linux\"]",
            "",
            "# Path utilities constants",
            "REMOTE_FS_PREFIX = [\"gs://\", \"hdfs://\", \"s3://\", \"az://\", \"abfs://\"]",
            "",
            "# ZenML Analytics Server - URL",
            "ANALYTICS_SERVER_URL = \"https://analytics.zenml.io/\"",
            "",
            "# Container utils",
            "SHOULD_PREVENT_PIPELINE_EXECUTION = handle_bool_env_var(",
            "    ENV_ZENML_PREVENT_PIPELINE_EXECUTION",
            ")",
            "",
            "# Repository and local store directory paths:",
            "REPOSITORY_DIRECTORY_NAME = \".zen\"",
            "LOCAL_STORES_DIRECTORY_NAME = \"local_stores\"",
            "",
            "# Config file name",
            "CONFIG_FILE_NAME = \"config.yaml\"",
            "",
            "# Default store directory subpath:",
            "DEFAULT_STORE_DIRECTORY_NAME = \"default_zen_store\"",
            "",
            "# SQL Store backup directory subpath:",
            "SQL_STORE_BACKUP_DIRECTORY_NAME = \"database_backup\"",
            "",
            "DEFAULT_USERNAME = \"default\"",
            "DEFAULT_PASSWORD = \"\"",
            "DEFAULT_WORKSPACE_NAME = \"default\"",
            "DEFAULT_STACK_AND_COMPONENT_NAME = \"default\"",
            "",
            "# Rich config",
            "ENABLE_RICH_TRACEBACK = handle_bool_env_var(",
            "    ENV_ZENML_ENABLE_RICH_TRACEBACK, True",
            ")",
            "",
            "DISABLE_CLIENT_SERVER_MISMATCH_WARNING = handle_bool_env_var(",
            "    ENV_ZENML_DISABLE_CLIENT_SERVER_MISMATCH_WARNING, default=False",
            ")",
            "",
            "ENFORCE_TYPE_ANNOTATIONS = handle_bool_env_var(",
            "    ENV_ZENML_ENFORCE_TYPE_ANNOTATIONS, default=False",
            ")",
            "",
            "# Services",
            "DEFAULT_SERVICE_START_STOP_TIMEOUT = 60",
            "DEFAULT_LOCAL_SERVICE_IP_ADDRESS = \"127.0.0.1\"",
            "ZEN_SERVER_ENTRYPOINT = \"zenml.zen_server.zen_server_api:app\"",
            "",
            "STEP_SOURCE_PARAMETER_NAME = \"step_source\"",
            "",
            "# Server settings",
            "DEFAULT_ZENML_JWT_TOKEN_LEEWAY = 10",
            "DEFAULT_ZENML_JWT_TOKEN_ALGORITHM = \"HS256\"",
            "DEFAULT_ZENML_AUTH_SCHEME = AuthScheme.OAUTH2_PASSWORD_BEARER",
            "EXTERNAL_AUTHENTICATOR_TIMEOUT = 10  # seconds",
            "DEFAULT_ZENML_SERVER_MAX_DEVICE_AUTH_ATTEMPTS = 3",
            "DEFAULT_ZENML_SERVER_DEVICE_AUTH_TIMEOUT = 60 * 5  # 5 minutes",
            "DEFAULT_ZENML_SERVER_DEVICE_AUTH_POLLING = 5  # seconds",
            "DEFAULT_HTTP_TIMEOUT = 30",
            "ZENML_API_KEY_PREFIX = \"ZENKEY_\"",
            "DEFAULT_ZENML_SERVER_PIPELINE_RUN_AUTH_WINDOW = 60 * 48  # 48 hours",
            "DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE = 5",
            "DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_DAY = 1000",
            "",
            "# Configurations to decide which resources report their usage and check for",
            "# entitlement in the case of a cloud deployment. Expected Format is this:",
            "# ENV_ZENML_REPORTABLE_RESOURCES='[\"Foo\", \"bar\"]'",
            "REPORTABLE_RESOURCES: List[str] = handle_json_env_var(",
            "    ENV_ZENML_SERVER_REPORTABLE_RESOURCES,",
            "    expected_type=list,",
            "    default=[\"pipeline_run\", \"model\"],",
            ")",
            "REQUIRES_CUSTOM_RESOURCE_REPORTING = [\"pipeline\"]",
            "",
            "# API Endpoint paths:",
            "ACTIVATE = \"/activate\"",
            "ACTIONS = \"/action-flavors\"",
            "API = \"/api\"",
            "API_KEYS = \"/api_keys\"",
            "API_KEY_ROTATE = \"/rotate\"",
            "API_TOKEN = \"/api_token\"",
            "ARTIFACTS = \"/artifacts\"",
            "ARTIFACT_VERSIONS = \"/artifact_versions\"",
            "ARTIFACT_VISUALIZATIONS = \"/artifact_visualizations\"",
            "CODE_REFERENCES = \"/code_references\"",
            "CODE_REPOSITORIES = \"/code_repositories\"",
            "COMPONENT_TYPES = \"/component-types\"",
            "CURRENT_USER = \"/current-user\"",
            "DEACTIVATE = \"/deactivate\"",
            "DEVICES = \"/devices\"",
            "DEVICE_AUTHORIZATION = \"/device_authorization\"",
            "DEVICE_VERIFY = \"/verify\"",
            "EMAIL_ANALYTICS = \"/email-opt-in\"",
            "EVENT_FLAVORS = \"/event-flavors\"",
            "EVENT_SOURCES = \"/event-sources\"",
            "FLAVORS = \"/flavors\"",
            "GET_OR_CREATE = \"/get-or-create\"",
            "GRAPH = \"/graph\"",
            "HEALTH = \"/health\"",
            "INFO = \"/info\"",
            "LOGIN = \"/login\"",
            "LOGOUT = \"/logout\"",
            "LOGS = \"/logs\"",
            "PIPELINE_BUILDS = \"/pipeline_builds\"",
            "PIPELINE_CONFIGURATION = \"/pipeline-configuration\"",
            "PIPELINE_DEPLOYMENTS = \"/pipeline_deployments\"",
            "PIPELINES = \"/pipelines\"",
            "PIPELINE_SPEC = \"/pipeline-spec\"",
            "PLUGIN_FLAVORS = \"/plugin-flavors\"",
            "RUNS = \"/runs\"",
            "RUN_METADATA = \"/run-metadata\"",
            "SCHEDULES = \"/schedules\"",
            "SECRETS = \"/secrets\"",
            "SECRETS_OPERATIONS = \"/secrets_operations\"",
            "SECRETS_BACKUP = \"/backup\"",
            "SECRETS_RESTORE = \"/restore\"",
            "SERVICE_ACCOUNTS = \"/service_accounts\"",
            "SERVICE_CONNECTOR_CLIENT = \"/client\"",
            "SERVICE_CONNECTOR_RESOURCES = \"/resources\"",
            "SERVICE_CONNECTOR_TYPES = \"/service_connector_types\"",
            "SERVICE_CONNECTOR_VERIFY = \"/verify\"",
            "SERVICE_CONNECTOR_RESOURCES = \"/resources\"",
            "MODELS = \"/models\"",
            "MODEL_VERSIONS = \"/model_versions\"",
            "MODEL_VERSION_ARTIFACTS = \"/model_version_artifacts\"",
            "MODEL_VERSION_PIPELINE_RUNS = \"/model_version_pipeline_runs\"",
            "SERVICES = \"/services\"",
            "SERVICE_CONNECTORS = \"/service_connectors\"",
            "STACKS = \"/stacks\"",
            "STACK_COMPONENTS = \"/components\"",
            "STATISTICS = \"/statistics\"",
            "STATUS = \"/status\"",
            "STEP_CONFIGURATION = \"/step-configuration\"",
            "STEPS = \"/steps\"",
            "TAGS = \"/tags\"",
            "TRIGGERS = \"/triggers\"",
            "TRIGGER_EXECUTIONS = \"/trigger_executions\"",
            "USERS = \"/users\"",
            "VERSION_1 = \"/v1\"",
            "VISUALIZE = \"/visualize\"",
            "WEBHOOKS = \"/webhooks\"",
            "WORKSPACES = \"/workspaces\"",
            "",
            "# model metadata yaml file name",
            "MODEL_METADATA_YAML_FILE_NAME = \"model_metadata.yaml\"",
            "",
            "# orchestrator constants",
            "ORCHESTRATOR_DOCKER_IMAGE_KEY = \"orchestrator\"",
            "PIPELINE_API_TOKEN_EXPIRES_MINUTES = handle_int_env_var(",
            "    ENV_ZENML_PIPELINE_API_TOKEN_EXPIRES_MINUTES,",
            "    default=60 * 24,  # 24 hours",
            ")",
            "",
            "# Secret constants",
            "SECRET_VALUES = \"values\"",
            "",
            "# Pagination and filtering defaults",
            "PAGINATION_STARTING_PAGE: int = 1",
            "PAGE_SIZE_DEFAULT: int = handle_int_env_var(",
            "    ENV_ZENML_PAGINATION_DEFAULT_LIMIT, default=20",
            ")",
            "PAGE_SIZE_MAXIMUM: int = handle_int_env_var(",
            "    ENV_ZENML_PAGINATION_DEFAULT_LIMIT, default=10000",
            ")",
            "FILTERING_DATETIME_FORMAT: str = \"%Y-%m-%d %H:%M:%S\"",
            "",
            "# Metadata constants",
            "METADATA_ORCHESTRATOR_URL = \"orchestrator_url\"",
            "METADATA_EXPERIMENT_TRACKER_URL = \"experiment_tracker_url\"",
            "METADATA_DEPLOYED_MODEL_URL = \"deployed_model_url\"",
            "",
            "# Model registries constants",
            "MLFLOW_MODEL_FORMAT = \"MLflow\"",
            "",
            "# Service connector constants",
            "DOCKER_REGISTRY_RESOURCE_TYPE = \"docker-registry\"",
            "KUBERNETES_CLUSTER_RESOURCE_TYPE = \"kubernetes-cluster\"",
            "",
            "# Stack Recipe constants",
            "STACK_RECIPES_GITHUB_REPO = \"https://github.com/zenml-io/mlops-stacks.git\"",
            "ALPHA_MESSAGE = (",
            "    \"The mlstacks tool/package is in alpha and actively being developed. \"",
            "    \"Please avoid running mission-critical workloads on resources deployed \"",
            "    \"through these commands. If you encounter any problems, create an issue \"",
            "    f\"on the repository {STACK_RECIPES_GITHUB_REPO} and we'll help you out!\"",
            ")",
            "NOT_INSTALLED_MESSAGE = (",
            "    \"The prerequisites for using `mlstacks` (the `mlstacks` and \"",
            "    \"`python-terraform` packages seem to be unavailable on your machine \"",
            "    \"and/or in your environment. To install the missing dependencies: \\n\\n\"",
            "    \"`pip install mlstacks`\"",
            ")",
            "TERRAFORM_NOT_INSTALLED_MESSAGE = (",
            "    \"Terraform appears not to be installed on your machine and/or in your \"",
            "    \"environment. Please install Terraform and try again.\"",
            ")",
            "STACK_RECIPE_MODULAR_RECIPES = [\"aws\", \"gcp\", \"k3d\"]",
            "MLSTACKS_SUPPORTED_STACK_COMPONENTS = [",
            "    \"artifact_store\",",
            "    \"container_registry\",",
            "    \"experiment_tracker\",",
            "    \"orchestrator\",",
            "    \"model_deployer\",",
            "    \"mlops_platform\",",
            "    \"step_operator\",",
            "]",
            "",
            "# Parameters for internal ZenML Models",
            "TEXT_FIELD_MAX_LENGTH = 65535",
            "STR_FIELD_MAX_LENGTH = 255",
            "MEDIUMTEXT_MAX_LENGTH = 2**24 - 1",
            "",
            "# Model Control Plane constants",
            "LATEST_MODEL_VERSION_PLACEHOLDER = \"__latest__\"",
            "",
            "",
            "# Service connector constants",
            "SERVICE_CONNECTOR_SKEW_TOLERANCE_SECONDS = 60 * 5  # 5 minutes",
            "",
            "# Versioned entities",
            "MAX_RETRIES_FOR_VERSIONED_ENTITY_CREATION = (",
            "    10  # empirical value to pass heavy parallelized tests",
            ")"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2021. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"ZenML constants.\"\"\"",
            "",
            "import json",
            "import logging",
            "import os",
            "from typing import Any, List, Optional, Type, TypeVar",
            "",
            "from zenml.enums import AuthScheme",
            "",
            "T = TypeVar(\"T\")",
            "",
            "",
            "def handle_json_env_var(",
            "    var: str,",
            "    expected_type: Type[T],",
            "    default: Optional[List[str]] = None,",
            ") -> Any:",
            "    \"\"\"Converts a json env var into a Python object.",
            "",
            "    Args:",
            "        var:  The environment variable to convert.",
            "        default: The default value to return if the env var is not set.",
            "        expected_type: The type of the expected Python object.",
            "",
            "    Returns:",
            "        The converted list value.",
            "",
            "    Raises:",
            "        TypeError: In case the value of the environment variable is not of a",
            "                   valid type.",
            "",
            "    \"\"\"",
            "    # this needs to be here to avoid mutable defaults",
            "    if default is None:",
            "        default = []",
            "",
            "    value = os.getenv(var)",
            "    if value:",
            "        try:",
            "            loaded_value = json.loads(value)",
            "            # check if loaded value is of correct type",
            "            if expected_type is None or isinstance(",
            "                loaded_value, expected_type",
            "            ):",
            "                return loaded_value",
            "            else:",
            "                raise TypeError  # if not correct type, raise TypeError",
            "        except (TypeError, json.JSONDecodeError):",
            "            # Use raw logging to avoid cyclic dependency",
            "            logging.warning(",
            "                f\"Environment Variable {var} could not be loaded, into type \"",
            "                f\"{expected_type}, defaulting to: {default}.\"",
            "            )",
            "            return default",
            "    else:",
            "        return default",
            "",
            "",
            "def handle_bool_env_var(var: str, default: bool = False) -> bool:",
            "    \"\"\"Converts normal env var to boolean.",
            "",
            "    Args:",
            "        var: The environment variable to convert.",
            "        default: The default value to return if the env var is not set.",
            "",
            "    Returns:",
            "        The converted value.",
            "    \"\"\"",
            "    value = os.getenv(var)",
            "    if value in [\"1\", \"y\", \"yes\", \"True\", \"true\"]:",
            "        return True",
            "    elif value in [\"0\", \"n\", \"no\", \"False\", \"false\"]:",
            "        return False",
            "    return default",
            "",
            "",
            "def handle_int_env_var(var: str, default: int = 0) -> int:",
            "    \"\"\"Converts normal env var to int.",
            "",
            "    Args:",
            "        var: The environment variable to convert.",
            "        default: The default value to return if the env var is not set.",
            "",
            "    Returns:",
            "        The converted value.",
            "    \"\"\"",
            "    value = os.getenv(var, \"\")",
            "    try:",
            "        return int(value)",
            "    except (ValueError, TypeError):",
            "        return default",
            "",
            "",
            "# Global constants",
            "APP_NAME = \"zenml\"",
            "",
            "# Environment variables",
            "ENV_ZENML_LOGGING_COLORS_DISABLED = \"ZENML_LOGGING_COLORS_DISABLED\"",
            "ENV_ZENML_ANALYTICS_OPT_IN = \"ZENML_ANALYTICS_OPT_IN\"",
            "ENV_ZENML_CONFIG_PATH = \"ZENML_CONFIG_PATH\"",
            "ENV_ZENML_DEBUG = \"ZENML_DEBUG\"",
            "ENV_ZENML_LOGGING_VERBOSITY = \"ZENML_LOGGING_VERBOSITY\"",
            "ENV_ZENML_REPOSITORY_PATH = \"ZENML_REPOSITORY_PATH\"",
            "ENV_ZENML_PREVENT_PIPELINE_EXECUTION = \"ZENML_PREVENT_PIPELINE_EXECUTION\"",
            "ENV_ZENML_ENABLE_RICH_TRACEBACK = \"ZENML_ENABLE_RICH_TRACEBACK\"",
            "ENV_ZENML_ACTIVE_STACK_ID = \"ZENML_ACTIVE_STACK_ID\"",
            "ENV_ZENML_ACTIVE_WORKSPACE_ID = \"ZENML_ACTIVE_WORKSPACE_ID\"",
            "ENV_ZENML_SUPPRESS_LOGS = \"ZENML_SUPPRESS_LOGS\"",
            "ENV_ZENML_ENABLE_REPO_INIT_WARNINGS = \"ZENML_ENABLE_REPO_INIT_WARNINGS\"",
            "ENV_ZENML_SECRET_VALIDATION_LEVEL = \"ZENML_SECRET_VALIDATION_LEVEL\"",
            "ENV_ZENML_DEFAULT_USER_NAME = \"ZENML_DEFAULT_USER_NAME\"",
            "ENV_ZENML_DEFAULT_USER_PASSWORD = \"ZENML_DEFAULT_USER_PASSWORD\"",
            "ENV_ZENML_DEFAULT_WORKSPACE_NAME = \"ZENML_DEFAULT_WORKSPACE_NAME\"",
            "ENV_ZENML_STORE_PREFIX = \"ZENML_STORE_\"",
            "ENV_ZENML_SECRETS_STORE_PREFIX = \"ZENML_SECRETS_STORE_\"",
            "ENV_ZENML_BACKUP_SECRETS_STORE_PREFIX = \"ZENML_BACKUP_SECRETS_STORE_\"",
            "ENV_ZENML_SKIP_PIPELINE_REGISTRATION = \"ZENML_SKIP_PIPELINE_REGISTRATION\"",
            "ENV_AUTO_OPEN_DASHBOARD = \"AUTO_OPEN_DASHBOARD\"",
            "ENV_ZENML_DISABLE_DATABASE_MIGRATION = \"DISABLE_DATABASE_MIGRATION\"",
            "ENV_ZENML_LOCAL_STORES_PATH = \"ZENML_LOCAL_STORES_PATH\"",
            "ENV_ZENML_CONTAINER = \"ZENML_CONTAINER\"",
            "ENV_ZENML_PAGINATION_DEFAULT_LIMIT = \"ZENML_PAGINATION_DEFAULT_LIMIT\"",
            "ENV_ZENML_DISABLE_CLIENT_SERVER_MISMATCH_WARNING = (",
            "    \"ZENML_DISABLE_CLIENT_SERVER_MISMATCH_WARNING\"",
            ")",
            "ENV_ZENML_DISABLE_WORKSPACE_WARNINGS = \"ZENML_DISABLE_WORKSPACE_WARNINGS\"",
            "ENV_ZENML_SKIP_IMAGE_BUILDER_DEFAULT = \"ZENML_SKIP_IMAGE_BUILDER_DEFAULT\"",
            "ENV_ZENML_REQUIRES_CODE_DOWNLOAD = \"ZENML_REQUIRES_CODE_DOWNLOAD\"",
            "ENV_ZENML_SERVER = \"ZENML_SERVER\"",
            "ENV_ZENML_HUB_URL = \"ZENML_HUB_URL\"",
            "ENV_ZENML_ENFORCE_TYPE_ANNOTATIONS = \"ZENML_ENFORCE_TYPE_ANNOTATIONS\"",
            "ENV_ZENML_ENABLE_IMPLICIT_AUTH_METHODS = \"ZENML_ENABLE_IMPLICIT_AUTH_METHODS\"",
            "ENV_ZENML_DISABLE_STEP_LOGS_STORAGE = \"ZENML_DISABLE_STEP_LOGS_STORAGE\"",
            "ENV_ZENML_PIPELINE_API_TOKEN_EXPIRES_MINUTES = (",
            "    \"ZENML_PIPELINE_API_TOKEN_EXPIRES_MINUTES\"",
            ")",
            "",
            "# ZenML Server environment variables",
            "ENV_ZENML_SERVER_PREFIX = \"ZENML_SERVER_\"",
            "ENV_ZENML_SERVER_DEPLOYMENT_TYPE = f\"{ENV_ZENML_SERVER_PREFIX}DEPLOYMENT_TYPE\"",
            "ENV_ZENML_SERVER_AUTH_SCHEME = f\"{ENV_ZENML_SERVER_PREFIX}AUTH_SCHEME\"",
            "ENV_ZENML_SERVER_REPORTABLE_RESOURCES = (",
            "    f\"{ENV_ZENML_SERVER_PREFIX}REPORTABLE_RESOURCES\"",
            ")",
            "",
            "# Logging variables",
            "IS_DEBUG_ENV: bool = handle_bool_env_var(ENV_ZENML_DEBUG, default=False)",
            "",
            "if IS_DEBUG_ENV:",
            "    ZENML_LOGGING_VERBOSITY = os.getenv(",
            "        ENV_ZENML_LOGGING_VERBOSITY, default=\"DEBUG\"",
            "    ).upper()",
            "else:",
            "    ZENML_LOGGING_VERBOSITY = os.getenv(",
            "        ENV_ZENML_LOGGING_VERBOSITY, default=\"INFO\"",
            "    ).upper()",
            "",
            "INSIDE_ZENML_CONTAINER = handle_bool_env_var(ENV_ZENML_CONTAINER, False)",
            "",
            "# Analytics constants",
            "VALID_OPERATING_SYSTEMS = [\"Windows\", \"Darwin\", \"Linux\"]",
            "",
            "# Path utilities constants",
            "REMOTE_FS_PREFIX = [\"gs://\", \"hdfs://\", \"s3://\", \"az://\", \"abfs://\"]",
            "",
            "# ZenML Analytics Server - URL",
            "ANALYTICS_SERVER_URL = \"https://analytics.zenml.io/\"",
            "",
            "# Container utils",
            "SHOULD_PREVENT_PIPELINE_EXECUTION = handle_bool_env_var(",
            "    ENV_ZENML_PREVENT_PIPELINE_EXECUTION",
            ")",
            "",
            "# Repository and local store directory paths:",
            "REPOSITORY_DIRECTORY_NAME = \".zen\"",
            "LOCAL_STORES_DIRECTORY_NAME = \"local_stores\"",
            "",
            "# Config file name",
            "CONFIG_FILE_NAME = \"config.yaml\"",
            "",
            "# Default store directory subpath:",
            "DEFAULT_STORE_DIRECTORY_NAME = \"default_zen_store\"",
            "",
            "# SQL Store backup directory subpath:",
            "SQL_STORE_BACKUP_DIRECTORY_NAME = \"database_backup\"",
            "",
            "DEFAULT_USERNAME = \"default\"",
            "DEFAULT_PASSWORD = \"\"",
            "DEFAULT_WORKSPACE_NAME = \"default\"",
            "DEFAULT_STACK_AND_COMPONENT_NAME = \"default\"",
            "",
            "# Rich config",
            "ENABLE_RICH_TRACEBACK = handle_bool_env_var(",
            "    ENV_ZENML_ENABLE_RICH_TRACEBACK, True",
            ")",
            "",
            "DISABLE_CLIENT_SERVER_MISMATCH_WARNING = handle_bool_env_var(",
            "    ENV_ZENML_DISABLE_CLIENT_SERVER_MISMATCH_WARNING, default=False",
            ")",
            "",
            "ENFORCE_TYPE_ANNOTATIONS = handle_bool_env_var(",
            "    ENV_ZENML_ENFORCE_TYPE_ANNOTATIONS, default=False",
            ")",
            "",
            "# Services",
            "DEFAULT_SERVICE_START_STOP_TIMEOUT = 60",
            "DEFAULT_LOCAL_SERVICE_IP_ADDRESS = \"127.0.0.1\"",
            "ZEN_SERVER_ENTRYPOINT = \"zenml.zen_server.zen_server_api:app\"",
            "",
            "STEP_SOURCE_PARAMETER_NAME = \"step_source\"",
            "",
            "# Server settings",
            "DEFAULT_ZENML_JWT_TOKEN_LEEWAY = 10",
            "DEFAULT_ZENML_JWT_TOKEN_ALGORITHM = \"HS256\"",
            "DEFAULT_ZENML_AUTH_SCHEME = AuthScheme.OAUTH2_PASSWORD_BEARER",
            "EXTERNAL_AUTHENTICATOR_TIMEOUT = 10  # seconds",
            "DEFAULT_ZENML_SERVER_MAX_DEVICE_AUTH_ATTEMPTS = 3",
            "DEFAULT_ZENML_SERVER_DEVICE_AUTH_TIMEOUT = 60 * 5  # 5 minutes",
            "DEFAULT_ZENML_SERVER_DEVICE_AUTH_POLLING = 5  # seconds",
            "DEFAULT_HTTP_TIMEOUT = 30",
            "ZENML_API_KEY_PREFIX = \"ZENKEY_\"",
            "DEFAULT_ZENML_SERVER_PIPELINE_RUN_AUTH_WINDOW = 60 * 48  # 48 hours",
            "DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_MINUTE = 5",
            "DEFAULT_ZENML_SERVER_LOGIN_RATE_LIMIT_DAY = 1000",
            "",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_HSTS = (",
            "    \"max-age=63072000; includeSubdomains\"",
            ")",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_XFO = \"SAMEORIGIN\"",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_XXP = \"0\"",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_CONTENT = \"nosniff\"",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_CSP = (",
            "    \"default-src 'none'; \"",
            "    \"script-src 'self' 'unsafe-inline' 'unsafe-eval'; \"",
            "    \"connect-src 'self' https://sdkdocs.zenml.io https://hubapi.zenml.io; \"",
            "    \"img-src 'self' data: https://public-flavor-logos.s3.eu-central-1.amazonaws.com; \"",
            "    \"style-src 'self' 'unsafe-inline'; \"",
            "    \"base-uri 'self'; \"",
            "    \"form-action 'self'; \"",
            "    \"font-src 'self';\"",
            "    \"frame-src https://zenml.hellonext.co https://sdkdocs.zenml.io \"",
            ")",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_REFERRER = \"no-referrer-when-downgrade\"",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_CACHE = (",
            "    \"no-store, no-cache, must-revalidate\"",
            ")",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_PERMISSIONS = (",
            "    \"accelerometer=(), autoplay=(), camera=(), encrypted-media=(), \"",
            "    \"geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), \"",
            "    \"payment=(), sync-xhr=(), usb=()\"",
            ")",
            "DEFAULT_ZENML_SERVER_SECURE_HEADERS_REPORT_TO = \"default\"",
            "",
            "# Configurations to decide which resources report their usage and check for",
            "# entitlement in the case of a cloud deployment. Expected Format is this:",
            "# ENV_ZENML_REPORTABLE_RESOURCES='[\"Foo\", \"bar\"]'",
            "REPORTABLE_RESOURCES: List[str] = handle_json_env_var(",
            "    ENV_ZENML_SERVER_REPORTABLE_RESOURCES,",
            "    expected_type=list,",
            "    default=[\"pipeline_run\", \"model\"],",
            ")",
            "REQUIRES_CUSTOM_RESOURCE_REPORTING = [\"pipeline\"]",
            "",
            "# API Endpoint paths:",
            "ACTIVATE = \"/activate\"",
            "ACTIONS = \"/action-flavors\"",
            "API = \"/api\"",
            "API_KEYS = \"/api_keys\"",
            "API_KEY_ROTATE = \"/rotate\"",
            "API_TOKEN = \"/api_token\"",
            "ARTIFACTS = \"/artifacts\"",
            "ARTIFACT_VERSIONS = \"/artifact_versions\"",
            "ARTIFACT_VISUALIZATIONS = \"/artifact_visualizations\"",
            "CODE_REFERENCES = \"/code_references\"",
            "CODE_REPOSITORIES = \"/code_repositories\"",
            "COMPONENT_TYPES = \"/component-types\"",
            "CURRENT_USER = \"/current-user\"",
            "DEACTIVATE = \"/deactivate\"",
            "DEVICES = \"/devices\"",
            "DEVICE_AUTHORIZATION = \"/device_authorization\"",
            "DEVICE_VERIFY = \"/verify\"",
            "EMAIL_ANALYTICS = \"/email-opt-in\"",
            "EVENT_FLAVORS = \"/event-flavors\"",
            "EVENT_SOURCES = \"/event-sources\"",
            "FLAVORS = \"/flavors\"",
            "GET_OR_CREATE = \"/get-or-create\"",
            "GRAPH = \"/graph\"",
            "HEALTH = \"/health\"",
            "INFO = \"/info\"",
            "LOGIN = \"/login\"",
            "LOGOUT = \"/logout\"",
            "LOGS = \"/logs\"",
            "PIPELINE_BUILDS = \"/pipeline_builds\"",
            "PIPELINE_CONFIGURATION = \"/pipeline-configuration\"",
            "PIPELINE_DEPLOYMENTS = \"/pipeline_deployments\"",
            "PIPELINES = \"/pipelines\"",
            "PIPELINE_SPEC = \"/pipeline-spec\"",
            "PLUGIN_FLAVORS = \"/plugin-flavors\"",
            "RUNS = \"/runs\"",
            "RUN_METADATA = \"/run-metadata\"",
            "SCHEDULES = \"/schedules\"",
            "SECRETS = \"/secrets\"",
            "SECRETS_OPERATIONS = \"/secrets_operations\"",
            "SECRETS_BACKUP = \"/backup\"",
            "SECRETS_RESTORE = \"/restore\"",
            "SERVICE_ACCOUNTS = \"/service_accounts\"",
            "SERVICE_CONNECTOR_CLIENT = \"/client\"",
            "SERVICE_CONNECTOR_RESOURCES = \"/resources\"",
            "SERVICE_CONNECTOR_TYPES = \"/service_connector_types\"",
            "SERVICE_CONNECTOR_VERIFY = \"/verify\"",
            "SERVICE_CONNECTOR_RESOURCES = \"/resources\"",
            "MODELS = \"/models\"",
            "MODEL_VERSIONS = \"/model_versions\"",
            "MODEL_VERSION_ARTIFACTS = \"/model_version_artifacts\"",
            "MODEL_VERSION_PIPELINE_RUNS = \"/model_version_pipeline_runs\"",
            "SERVICES = \"/services\"",
            "SERVICE_CONNECTORS = \"/service_connectors\"",
            "STACKS = \"/stacks\"",
            "STACK_COMPONENTS = \"/components\"",
            "STATISTICS = \"/statistics\"",
            "STATUS = \"/status\"",
            "STEP_CONFIGURATION = \"/step-configuration\"",
            "STEPS = \"/steps\"",
            "TAGS = \"/tags\"",
            "TRIGGERS = \"/triggers\"",
            "TRIGGER_EXECUTIONS = \"/trigger_executions\"",
            "USERS = \"/users\"",
            "VERSION_1 = \"/v1\"",
            "VISUALIZE = \"/visualize\"",
            "WEBHOOKS = \"/webhooks\"",
            "WORKSPACES = \"/workspaces\"",
            "",
            "# model metadata yaml file name",
            "MODEL_METADATA_YAML_FILE_NAME = \"model_metadata.yaml\"",
            "",
            "# orchestrator constants",
            "ORCHESTRATOR_DOCKER_IMAGE_KEY = \"orchestrator\"",
            "PIPELINE_API_TOKEN_EXPIRES_MINUTES = handle_int_env_var(",
            "    ENV_ZENML_PIPELINE_API_TOKEN_EXPIRES_MINUTES,",
            "    default=60 * 24,  # 24 hours",
            ")",
            "",
            "# Secret constants",
            "SECRET_VALUES = \"values\"",
            "",
            "# Pagination and filtering defaults",
            "PAGINATION_STARTING_PAGE: int = 1",
            "PAGE_SIZE_DEFAULT: int = handle_int_env_var(",
            "    ENV_ZENML_PAGINATION_DEFAULT_LIMIT, default=20",
            ")",
            "PAGE_SIZE_MAXIMUM: int = handle_int_env_var(",
            "    ENV_ZENML_PAGINATION_DEFAULT_LIMIT, default=10000",
            ")",
            "FILTERING_DATETIME_FORMAT: str = \"%Y-%m-%d %H:%M:%S\"",
            "",
            "# Metadata constants",
            "METADATA_ORCHESTRATOR_URL = \"orchestrator_url\"",
            "METADATA_EXPERIMENT_TRACKER_URL = \"experiment_tracker_url\"",
            "METADATA_DEPLOYED_MODEL_URL = \"deployed_model_url\"",
            "",
            "# Model registries constants",
            "MLFLOW_MODEL_FORMAT = \"MLflow\"",
            "",
            "# Service connector constants",
            "DOCKER_REGISTRY_RESOURCE_TYPE = \"docker-registry\"",
            "KUBERNETES_CLUSTER_RESOURCE_TYPE = \"kubernetes-cluster\"",
            "",
            "# Stack Recipe constants",
            "STACK_RECIPES_GITHUB_REPO = \"https://github.com/zenml-io/mlops-stacks.git\"",
            "ALPHA_MESSAGE = (",
            "    \"The mlstacks tool/package is in alpha and actively being developed. \"",
            "    \"Please avoid running mission-critical workloads on resources deployed \"",
            "    \"through these commands. If you encounter any problems, create an issue \"",
            "    f\"on the repository {STACK_RECIPES_GITHUB_REPO} and we'll help you out!\"",
            ")",
            "NOT_INSTALLED_MESSAGE = (",
            "    \"The prerequisites for using `mlstacks` (the `mlstacks` and \"",
            "    \"`python-terraform` packages seem to be unavailable on your machine \"",
            "    \"and/or in your environment. To install the missing dependencies: \\n\\n\"",
            "    \"`pip install mlstacks`\"",
            ")",
            "TERRAFORM_NOT_INSTALLED_MESSAGE = (",
            "    \"Terraform appears not to be installed on your machine and/or in your \"",
            "    \"environment. Please install Terraform and try again.\"",
            ")",
            "STACK_RECIPE_MODULAR_RECIPES = [\"aws\", \"gcp\", \"k3d\"]",
            "MLSTACKS_SUPPORTED_STACK_COMPONENTS = [",
            "    \"artifact_store\",",
            "    \"container_registry\",",
            "    \"experiment_tracker\",",
            "    \"orchestrator\",",
            "    \"model_deployer\",",
            "    \"mlops_platform\",",
            "    \"step_operator\",",
            "]",
            "",
            "# Parameters for internal ZenML Models",
            "TEXT_FIELD_MAX_LENGTH = 65535",
            "STR_FIELD_MAX_LENGTH = 255",
            "MEDIUMTEXT_MAX_LENGTH = 2**24 - 1",
            "",
            "# Model Control Plane constants",
            "LATEST_MODEL_VERSION_PLACEHOLDER = \"__latest__\"",
            "",
            "",
            "# Service connector constants",
            "SERVICE_CONNECTOR_SKEW_TOLERANCE_SECONDS = 60 * 5  # 5 minutes",
            "",
            "# Versioned entities",
            "MAX_RETRIES_FOR_VERSIONED_ENTITY_CREATION = (",
            "    10  # empirical value to pass heavy parallelized tests",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "src/zenml/zen_server/deploy/docker/docker_zen_server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "                 host=\"0.0.0.0\",  # nosec"
            },
            "1": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "                 port=self.endpoint.config.port or 8000,"
            },
            "2": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "                 log_level=\"info\","
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+                server_header=False,"
            },
            "4": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "         except KeyboardInterrupt:"
            },
            "6": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "             logger.info(\"ZenML Server stopped. Resuming normal execution.\")"
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Service implementation for the ZenML docker server deployment.\"\"\"",
            "",
            "import os",
            "from typing import Dict, List, Optional, Tuple, cast",
            "",
            "import zenml",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.config.store_config import StoreConfiguration",
            "from zenml.constants import (",
            "    ENV_ZENML_ANALYTICS_OPT_IN,",
            "    ENV_ZENML_CONFIG_PATH,",
            "    ENV_ZENML_DISABLE_DATABASE_MIGRATION,",
            "    ENV_ZENML_LOCAL_STORES_PATH,",
            "    ENV_ZENML_SERVER_DEPLOYMENT_TYPE,",
            "    LOCAL_STORES_DIRECTORY_NAME,",
            "    ZEN_SERVER_ENTRYPOINT,",
            ")",
            "from zenml.enums import StoreType",
            "from zenml.logger import get_logger",
            "from zenml.models import ServerDeploymentType",
            "from zenml.services import (",
            "    ContainerService,",
            "    ContainerServiceConfig,",
            "    ContainerServiceEndpoint,",
            "    ServiceType,",
            ")",
            "from zenml.services.container.container_service import (",
            "    SERVICE_CONTAINER_GLOBAL_CONFIG_DIR,",
            "    SERVICE_CONTAINER_GLOBAL_CONFIG_PATH,",
            "    SERVICE_CONTAINER_PATH,",
            ")",
            "from zenml.utils.io_utils import get_global_config_directory",
            "from zenml.zen_server.deploy.deployment import ServerDeploymentConfig",
            "",
            "logger = get_logger(__name__)",
            "",
            "ZEN_SERVER_HEALTHCHECK_URL_PATH = \"health\"",
            "DOCKER_ZENML_SERVER_DEFAULT_IMAGE = (",
            "    f\"zenmldocker/zenml-server:{zenml.__version__}\"",
            ")",
            "DOCKER_ZENML_SERVER_DEFAULT_TIMEOUT = 60",
            "",
            "",
            "class DockerServerDeploymentConfig(ServerDeploymentConfig):",
            "    \"\"\"Docker server deployment configuration.",
            "",
            "    Attributes:",
            "        port: The TCP port number where the server is accepting connections.",
            "        image: The Docker image to use for the server.",
            "    \"\"\"",
            "",
            "    port: int = 8238",
            "    image: str = DOCKER_ZENML_SERVER_DEFAULT_IMAGE",
            "    store: Optional[StoreConfiguration] = None",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration.\"\"\"",
            "",
            "        extra = \"forbid\"",
            "",
            "",
            "class DockerZenServerConfig(ContainerServiceConfig):",
            "    \"\"\"Docker Zen server configuration.",
            "",
            "    Attributes:",
            "        server: The deployment configuration.",
            "    \"\"\"",
            "",
            "    server: DockerServerDeploymentConfig",
            "",
            "",
            "class DockerZenServer(ContainerService):",
            "    \"\"\"Service that can be used to start a docker ZenServer.",
            "",
            "    Attributes:",
            "        config: service configuration",
            "        endpoint: service endpoint",
            "    \"\"\"",
            "",
            "    SERVICE_TYPE = ServiceType(",
            "        name=\"docker_zenml_server\",",
            "        type=\"zen_server\",",
            "        flavor=\"docker\",",
            "        description=\"Docker ZenML server deployment\",",
            "    )",
            "",
            "    config: DockerZenServerConfig",
            "    endpoint: ContainerServiceEndpoint",
            "",
            "    @classmethod",
            "    def config_path(cls) -> str:",
            "        \"\"\"Path to the directory where the docker ZenML server files are located.",
            "",
            "        Returns:",
            "            Path to the docker ZenML server runtime directory.",
            "        \"\"\"",
            "        return os.path.join(",
            "            get_global_config_directory(),",
            "            \"zen_server\",",
            "            \"docker\",",
            "        )",
            "",
            "    @property",
            "    def _global_config_path(self) -> str:",
            "        \"\"\"Path to the global configuration directory used by this server.",
            "",
            "        Returns:",
            "            Path to the global configuration directory used by this server.",
            "        \"\"\"",
            "        return os.path.join(",
            "            self.config_path(), SERVICE_CONTAINER_GLOBAL_CONFIG_DIR",
            "        )",
            "",
            "    @classmethod",
            "    def get_service(cls) -> Optional[\"DockerZenServer\"]:",
            "        \"\"\"Load and return the docker ZenML server service, if present.",
            "",
            "        Returns:",
            "            The docker ZenML server service or None, if the docker server",
            "            deployment is not found.",
            "        \"\"\"",
            "        config_filename = os.path.join(cls.config_path(), \"service.json\")",
            "        try:",
            "            with open(config_filename, \"r\") as f:",
            "                return cast(",
            "                    \"DockerZenServer\", DockerZenServer.from_json(f.read())",
            "                )",
            "        except FileNotFoundError:",
            "            return None",
            "",
            "    def _get_container_cmd(self) -> Tuple[List[str], Dict[str, str]]:",
            "        \"\"\"Get the command to run the service container.",
            "",
            "        Override the inherited method to use a ZenML global config path inside",
            "        the container that points to the global config copy instead of the",
            "        one mounted from the local host.",
            "",
            "        Returns:",
            "            Command needed to launch the docker container and the environment",
            "            variables to set, in the formats accepted by subprocess.Popen.",
            "        \"\"\"",
            "        gc = GlobalConfiguration()",
            "",
            "        cmd, env = super()._get_container_cmd()",
            "        env[ENV_ZENML_CONFIG_PATH] = os.path.join(",
            "            SERVICE_CONTAINER_PATH,",
            "            SERVICE_CONTAINER_GLOBAL_CONFIG_DIR,",
            "        )",
            "        env[ENV_ZENML_SERVER_DEPLOYMENT_TYPE] = ServerDeploymentType.DOCKER",
            "        env[ENV_ZENML_ANALYTICS_OPT_IN] = str(gc.analytics_opt_in)",
            "",
            "        # Set the local stores path to the same path used by the client (mounted",
            "        # in the container by the super class). This ensures that the server's",
            "        # default store configuration is initialized to point at the same local",
            "        # SQLite database as the client.",
            "        env[ENV_ZENML_LOCAL_STORES_PATH] = os.path.join(",
            "            SERVICE_CONTAINER_GLOBAL_CONFIG_PATH,",
            "            LOCAL_STORES_DIRECTORY_NAME,",
            "        )",
            "        env[ENV_ZENML_DISABLE_DATABASE_MIGRATION] = \"True\"",
            "",
            "        return cmd, env",
            "",
            "    def provision(self) -> None:",
            "        \"\"\"Provision the service.\"\"\"",
            "        super().provision()",
            "",
            "    def run(self) -> None:",
            "        \"\"\"Run the ZenML Server.",
            "",
            "        Raises:",
            "            ValueError: if started with a global configuration that connects to",
            "                another ZenML server.",
            "        \"\"\"",
            "        import uvicorn",
            "",
            "        gc = GlobalConfiguration()",
            "        if gc.store_configuration.type == StoreType.REST:",
            "            raise ValueError(",
            "                \"The ZenML server cannot be started with REST store type.\"",
            "            )",
            "        logger.info(",
            "            \"Starting ZenML Server as blocking \"",
            "            \"process... press CTRL+C once to stop it.\"",
            "        )",
            "",
            "        self.endpoint.prepare_for_start()",
            "",
            "        try:",
            "            uvicorn.run(",
            "                ZEN_SERVER_ENTRYPOINT,",
            "                host=\"0.0.0.0\",  # nosec",
            "                port=self.endpoint.config.port or 8000,",
            "                log_level=\"info\",",
            "            )",
            "        except KeyboardInterrupt:",
            "            logger.info(\"ZenML Server stopped. Resuming normal execution.\")"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Service implementation for the ZenML docker server deployment.\"\"\"",
            "",
            "import os",
            "from typing import Dict, List, Optional, Tuple, cast",
            "",
            "import zenml",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.config.store_config import StoreConfiguration",
            "from zenml.constants import (",
            "    ENV_ZENML_ANALYTICS_OPT_IN,",
            "    ENV_ZENML_CONFIG_PATH,",
            "    ENV_ZENML_DISABLE_DATABASE_MIGRATION,",
            "    ENV_ZENML_LOCAL_STORES_PATH,",
            "    ENV_ZENML_SERVER_DEPLOYMENT_TYPE,",
            "    LOCAL_STORES_DIRECTORY_NAME,",
            "    ZEN_SERVER_ENTRYPOINT,",
            ")",
            "from zenml.enums import StoreType",
            "from zenml.logger import get_logger",
            "from zenml.models import ServerDeploymentType",
            "from zenml.services import (",
            "    ContainerService,",
            "    ContainerServiceConfig,",
            "    ContainerServiceEndpoint,",
            "    ServiceType,",
            ")",
            "from zenml.services.container.container_service import (",
            "    SERVICE_CONTAINER_GLOBAL_CONFIG_DIR,",
            "    SERVICE_CONTAINER_GLOBAL_CONFIG_PATH,",
            "    SERVICE_CONTAINER_PATH,",
            ")",
            "from zenml.utils.io_utils import get_global_config_directory",
            "from zenml.zen_server.deploy.deployment import ServerDeploymentConfig",
            "",
            "logger = get_logger(__name__)",
            "",
            "ZEN_SERVER_HEALTHCHECK_URL_PATH = \"health\"",
            "DOCKER_ZENML_SERVER_DEFAULT_IMAGE = (",
            "    f\"zenmldocker/zenml-server:{zenml.__version__}\"",
            ")",
            "DOCKER_ZENML_SERVER_DEFAULT_TIMEOUT = 60",
            "",
            "",
            "class DockerServerDeploymentConfig(ServerDeploymentConfig):",
            "    \"\"\"Docker server deployment configuration.",
            "",
            "    Attributes:",
            "        port: The TCP port number where the server is accepting connections.",
            "        image: The Docker image to use for the server.",
            "    \"\"\"",
            "",
            "    port: int = 8238",
            "    image: str = DOCKER_ZENML_SERVER_DEFAULT_IMAGE",
            "    store: Optional[StoreConfiguration] = None",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration.\"\"\"",
            "",
            "        extra = \"forbid\"",
            "",
            "",
            "class DockerZenServerConfig(ContainerServiceConfig):",
            "    \"\"\"Docker Zen server configuration.",
            "",
            "    Attributes:",
            "        server: The deployment configuration.",
            "    \"\"\"",
            "",
            "    server: DockerServerDeploymentConfig",
            "",
            "",
            "class DockerZenServer(ContainerService):",
            "    \"\"\"Service that can be used to start a docker ZenServer.",
            "",
            "    Attributes:",
            "        config: service configuration",
            "        endpoint: service endpoint",
            "    \"\"\"",
            "",
            "    SERVICE_TYPE = ServiceType(",
            "        name=\"docker_zenml_server\",",
            "        type=\"zen_server\",",
            "        flavor=\"docker\",",
            "        description=\"Docker ZenML server deployment\",",
            "    )",
            "",
            "    config: DockerZenServerConfig",
            "    endpoint: ContainerServiceEndpoint",
            "",
            "    @classmethod",
            "    def config_path(cls) -> str:",
            "        \"\"\"Path to the directory where the docker ZenML server files are located.",
            "",
            "        Returns:",
            "            Path to the docker ZenML server runtime directory.",
            "        \"\"\"",
            "        return os.path.join(",
            "            get_global_config_directory(),",
            "            \"zen_server\",",
            "            \"docker\",",
            "        )",
            "",
            "    @property",
            "    def _global_config_path(self) -> str:",
            "        \"\"\"Path to the global configuration directory used by this server.",
            "",
            "        Returns:",
            "            Path to the global configuration directory used by this server.",
            "        \"\"\"",
            "        return os.path.join(",
            "            self.config_path(), SERVICE_CONTAINER_GLOBAL_CONFIG_DIR",
            "        )",
            "",
            "    @classmethod",
            "    def get_service(cls) -> Optional[\"DockerZenServer\"]:",
            "        \"\"\"Load and return the docker ZenML server service, if present.",
            "",
            "        Returns:",
            "            The docker ZenML server service or None, if the docker server",
            "            deployment is not found.",
            "        \"\"\"",
            "        config_filename = os.path.join(cls.config_path(), \"service.json\")",
            "        try:",
            "            with open(config_filename, \"r\") as f:",
            "                return cast(",
            "                    \"DockerZenServer\", DockerZenServer.from_json(f.read())",
            "                )",
            "        except FileNotFoundError:",
            "            return None",
            "",
            "    def _get_container_cmd(self) -> Tuple[List[str], Dict[str, str]]:",
            "        \"\"\"Get the command to run the service container.",
            "",
            "        Override the inherited method to use a ZenML global config path inside",
            "        the container that points to the global config copy instead of the",
            "        one mounted from the local host.",
            "",
            "        Returns:",
            "            Command needed to launch the docker container and the environment",
            "            variables to set, in the formats accepted by subprocess.Popen.",
            "        \"\"\"",
            "        gc = GlobalConfiguration()",
            "",
            "        cmd, env = super()._get_container_cmd()",
            "        env[ENV_ZENML_CONFIG_PATH] = os.path.join(",
            "            SERVICE_CONTAINER_PATH,",
            "            SERVICE_CONTAINER_GLOBAL_CONFIG_DIR,",
            "        )",
            "        env[ENV_ZENML_SERVER_DEPLOYMENT_TYPE] = ServerDeploymentType.DOCKER",
            "        env[ENV_ZENML_ANALYTICS_OPT_IN] = str(gc.analytics_opt_in)",
            "",
            "        # Set the local stores path to the same path used by the client (mounted",
            "        # in the container by the super class). This ensures that the server's",
            "        # default store configuration is initialized to point at the same local",
            "        # SQLite database as the client.",
            "        env[ENV_ZENML_LOCAL_STORES_PATH] = os.path.join(",
            "            SERVICE_CONTAINER_GLOBAL_CONFIG_PATH,",
            "            LOCAL_STORES_DIRECTORY_NAME,",
            "        )",
            "        env[ENV_ZENML_DISABLE_DATABASE_MIGRATION] = \"True\"",
            "",
            "        return cmd, env",
            "",
            "    def provision(self) -> None:",
            "        \"\"\"Provision the service.\"\"\"",
            "        super().provision()",
            "",
            "    def run(self) -> None:",
            "        \"\"\"Run the ZenML Server.",
            "",
            "        Raises:",
            "            ValueError: if started with a global configuration that connects to",
            "                another ZenML server.",
            "        \"\"\"",
            "        import uvicorn",
            "",
            "        gc = GlobalConfiguration()",
            "        if gc.store_configuration.type == StoreType.REST:",
            "            raise ValueError(",
            "                \"The ZenML server cannot be started with REST store type.\"",
            "            )",
            "        logger.info(",
            "            \"Starting ZenML Server as blocking \"",
            "            \"process... press CTRL+C once to stop it.\"",
            "        )",
            "",
            "        self.endpoint.prepare_for_start()",
            "",
            "        try:",
            "            uvicorn.run(",
            "                ZEN_SERVER_ENTRYPOINT,",
            "                host=\"0.0.0.0\",  # nosec",
            "                port=self.endpoint.config.port or 8000,",
            "                log_level=\"info\",",
            "                server_header=False,",
            "            )",
            "        except KeyboardInterrupt:",
            "            logger.info(\"ZenML Server stopped. Resuming normal execution.\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nltk.downloader.Downloader.download"
        ]
    },
    "src/zenml/zen_server/deploy/local/local_zen_server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "                 host=self.endpoint.config.ip_address,"
            },
            "1": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "                 port=self.endpoint.config.port or 8000,"
            },
            "2": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "                 log_level=\"info\","
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+                server_header=False,"
            },
            "4": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         except KeyboardInterrupt:"
            },
            "6": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "             logger.info(\"ZenML Server stopped. Resuming normal execution.\")"
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Local ZenML server deployment service implementation.\"\"\"",
            "",
            "import ipaddress",
            "import os",
            "from typing import Dict, List, Optional, Tuple, Union, cast",
            "",
            "from zenml.client import Client",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.config.store_config import StoreConfiguration",
            "from zenml.constants import (",
            "    DEFAULT_LOCAL_SERVICE_IP_ADDRESS,",
            "    ENV_ZENML_CONFIG_PATH,",
            "    ENV_ZENML_DISABLE_DATABASE_MIGRATION,",
            "    ENV_ZENML_LOCAL_STORES_PATH,",
            "    ENV_ZENML_SERVER_DEPLOYMENT_TYPE,",
            "    ZEN_SERVER_ENTRYPOINT,",
            ")",
            "from zenml.enums import StoreType",
            "from zenml.logger import get_logger",
            "from zenml.models import ServerDeploymentType",
            "from zenml.services import (",
            "    LocalDaemonService,",
            "    LocalDaemonServiceConfig,",
            "    LocalDaemonServiceEndpoint,",
            "    ServiceType,",
            ")",
            "from zenml.utils.io_utils import get_global_config_directory",
            "from zenml.zen_server.deploy.deployment import ServerDeploymentConfig",
            "",
            "logger = get_logger(__name__)",
            "",
            "ZEN_SERVER_HEALTHCHECK_URL_PATH = \"health\"",
            "LOCAL_ZENML_SERVER_DEFAULT_TIMEOUT = 30",
            "",
            "",
            "class LocalServerDeploymentConfig(ServerDeploymentConfig):",
            "    \"\"\"Local server deployment configuration.",
            "",
            "    Attributes:",
            "        port: The TCP port number where the server is accepting connections.",
            "        address: The IP address where the server is reachable.",
            "        blocking: Run the server in blocking mode instead of using a daemon",
            "            process.",
            "    \"\"\"",
            "",
            "    port: int = 8237",
            "    ip_address: Union[ipaddress.IPv4Address, ipaddress.IPv6Address] = (",
            "        ipaddress.IPv4Address(DEFAULT_LOCAL_SERVICE_IP_ADDRESS)",
            "    )",
            "    blocking: bool = False",
            "    store: Optional[StoreConfiguration] = None",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration.\"\"\"",
            "",
            "        extra = \"forbid\"",
            "",
            "",
            "class LocalZenServerConfig(LocalDaemonServiceConfig):",
            "    \"\"\"Local Zen server configuration.",
            "",
            "    Attributes:",
            "        server: The deployment configuration.",
            "    \"\"\"",
            "",
            "    server: LocalServerDeploymentConfig",
            "",
            "",
            "class LocalZenServer(LocalDaemonService):",
            "    \"\"\"Service daemon that can be used to start a local ZenML Server.",
            "",
            "    Attributes:",
            "        config: service configuration",
            "        endpoint: optional service endpoint",
            "    \"\"\"",
            "",
            "    SERVICE_TYPE = ServiceType(",
            "        name=\"local_zenml_server\",",
            "        type=\"zen_server\",",
            "        flavor=\"local\",",
            "        description=\"Local ZenML server deployment\",",
            "    )",
            "",
            "    config: LocalZenServerConfig",
            "    endpoint: LocalDaemonServiceEndpoint",
            "",
            "    @classmethod",
            "    def config_path(cls) -> str:",
            "        \"\"\"Path to the directory where the local ZenML server files are located.",
            "",
            "        Returns:",
            "            Path to the local ZenML server runtime directory.",
            "        \"\"\"",
            "        return os.path.join(",
            "            get_global_config_directory(),",
            "            \"zen_server\",",
            "            \"local\",",
            "        )",
            "",
            "    @property",
            "    def _global_config_path(self) -> str:",
            "        \"\"\"Path to the global configuration directory used by this server.",
            "",
            "        Returns:",
            "            Path to the global configuration directory used by this server.",
            "        \"\"\"",
            "        return os.path.join(self.config_path(), \".zenconfig\")",
            "",
            "    @classmethod",
            "    def get_service(cls) -> Optional[\"LocalZenServer\"]:",
            "        \"\"\"Load and return the local ZenML server service, if present.",
            "",
            "        Returns:",
            "            The local ZenML server service or None, if the local server",
            "            deployment is not found.",
            "        \"\"\"",
            "        config_filename = os.path.join(cls.config_path(), \"service.json\")",
            "        try:",
            "            with open(config_filename, \"r\") as f:",
            "                return cast(",
            "                    \"LocalZenServer\", LocalZenServer.from_json(f.read())",
            "                )",
            "        except FileNotFoundError:",
            "            return None",
            "",
            "    def _get_daemon_cmd(self) -> Tuple[List[str], Dict[str, str]]:",
            "        \"\"\"Get the command to start the daemon.",
            "",
            "        Overrides the base class implementation to add the environment variable",
            "        that forces the ZenML server to use the copied global config.",
            "",
            "        Returns:",
            "            The command to start the daemon and the environment variables to",
            "            set for the command.",
            "        \"\"\"",
            "        cmd, env = super()._get_daemon_cmd()",
            "        env[ENV_ZENML_CONFIG_PATH] = self._global_config_path",
            "        env[ENV_ZENML_SERVER_DEPLOYMENT_TYPE] = ServerDeploymentType.LOCAL",
            "        # Set the local stores path to the same path used by the client. This",
            "        # ensures that the server's default store configuration is initialized",
            "        # to point at the same local SQLite database as the client.",
            "        env[ENV_ZENML_LOCAL_STORES_PATH] = (",
            "            GlobalConfiguration().local_stores_path",
            "        )",
            "        env[ENV_ZENML_DISABLE_DATABASE_MIGRATION] = \"True\"",
            "",
            "        return cmd, env",
            "",
            "    def provision(self) -> None:",
            "        \"\"\"Provision the service.\"\"\"",
            "        super().provision()",
            "",
            "    def start(self, timeout: int = 0) -> None:",
            "        \"\"\"Start the service and optionally wait for it to become active.",
            "",
            "        Args:",
            "            timeout: amount of time to wait for the service to become active.",
            "                If set to 0, the method will return immediately after checking",
            "                the service status.",
            "        \"\"\"",
            "        if not self.config.blocking:",
            "            super().start(timeout)",
            "        else:",
            "            # In the blocking mode, we need to temporarily set the environment",
            "            # variables for the running process to make it look like the server",
            "            # is running in a separate environment (i.e. using a different",
            "            # global configuration path). This is necessary to avoid polluting",
            "            # the client environment with the server's configuration.",
            "            local_stores_path = GlobalConfiguration().local_stores_path",
            "            GlobalConfiguration._reset_instance()",
            "            Client._reset_instance()",
            "            original_config_path = os.environ.get(ENV_ZENML_CONFIG_PATH)",
            "            os.environ[ENV_ZENML_CONFIG_PATH] = self._global_config_path",
            "            # Set the local stores path to the same path used by the client.",
            "            # This ensures that the server's default store configuration is",
            "            # initialized to point at the same local SQLite database as the",
            "            # client.",
            "            os.environ[ENV_ZENML_LOCAL_STORES_PATH] = local_stores_path",
            "            try:",
            "                self.run()",
            "            finally:",
            "                # Restore the original client environment variables",
            "                if original_config_path:",
            "                    os.environ[ENV_ZENML_CONFIG_PATH] = original_config_path",
            "                else:",
            "                    del os.environ[ENV_ZENML_CONFIG_PATH]",
            "                del os.environ[ENV_ZENML_LOCAL_STORES_PATH]",
            "                GlobalConfiguration._reset_instance()",
            "                Client._reset_instance()",
            "",
            "    def run(self) -> None:",
            "        \"\"\"Run the ZenML Server.",
            "",
            "        Raises:",
            "            ValueError: if started with a global configuration that connects to",
            "                another ZenML server.",
            "        \"\"\"",
            "        import uvicorn",
            "",
            "        gc = GlobalConfiguration()",
            "        if gc.store_configuration.type == StoreType.REST:",
            "            raise ValueError(",
            "                \"The ZenML server cannot be started with REST store type.\"",
            "            )",
            "        logger.info(",
            "            \"Starting ZenML Server as blocking \"",
            "            \"process... press CTRL+C once to stop it.\"",
            "        )",
            "",
            "        self.endpoint.prepare_for_start()",
            "",
            "        try:",
            "            uvicorn.run(",
            "                ZEN_SERVER_ENTRYPOINT,",
            "                host=self.endpoint.config.ip_address,",
            "                port=self.endpoint.config.port or 8000,",
            "                log_level=\"info\",",
            "            )",
            "        except KeyboardInterrupt:",
            "            logger.info(\"ZenML Server stopped. Resuming normal execution.\")"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Local ZenML server deployment service implementation.\"\"\"",
            "",
            "import ipaddress",
            "import os",
            "from typing import Dict, List, Optional, Tuple, Union, cast",
            "",
            "from zenml.client import Client",
            "from zenml.config.global_config import GlobalConfiguration",
            "from zenml.config.store_config import StoreConfiguration",
            "from zenml.constants import (",
            "    DEFAULT_LOCAL_SERVICE_IP_ADDRESS,",
            "    ENV_ZENML_CONFIG_PATH,",
            "    ENV_ZENML_DISABLE_DATABASE_MIGRATION,",
            "    ENV_ZENML_LOCAL_STORES_PATH,",
            "    ENV_ZENML_SERVER_DEPLOYMENT_TYPE,",
            "    ZEN_SERVER_ENTRYPOINT,",
            ")",
            "from zenml.enums import StoreType",
            "from zenml.logger import get_logger",
            "from zenml.models import ServerDeploymentType",
            "from zenml.services import (",
            "    LocalDaemonService,",
            "    LocalDaemonServiceConfig,",
            "    LocalDaemonServiceEndpoint,",
            "    ServiceType,",
            ")",
            "from zenml.utils.io_utils import get_global_config_directory",
            "from zenml.zen_server.deploy.deployment import ServerDeploymentConfig",
            "",
            "logger = get_logger(__name__)",
            "",
            "ZEN_SERVER_HEALTHCHECK_URL_PATH = \"health\"",
            "LOCAL_ZENML_SERVER_DEFAULT_TIMEOUT = 30",
            "",
            "",
            "class LocalServerDeploymentConfig(ServerDeploymentConfig):",
            "    \"\"\"Local server deployment configuration.",
            "",
            "    Attributes:",
            "        port: The TCP port number where the server is accepting connections.",
            "        address: The IP address where the server is reachable.",
            "        blocking: Run the server in blocking mode instead of using a daemon",
            "            process.",
            "    \"\"\"",
            "",
            "    port: int = 8237",
            "    ip_address: Union[ipaddress.IPv4Address, ipaddress.IPv6Address] = (",
            "        ipaddress.IPv4Address(DEFAULT_LOCAL_SERVICE_IP_ADDRESS)",
            "    )",
            "    blocking: bool = False",
            "    store: Optional[StoreConfiguration] = None",
            "",
            "    class Config:",
            "        \"\"\"Pydantic configuration.\"\"\"",
            "",
            "        extra = \"forbid\"",
            "",
            "",
            "class LocalZenServerConfig(LocalDaemonServiceConfig):",
            "    \"\"\"Local Zen server configuration.",
            "",
            "    Attributes:",
            "        server: The deployment configuration.",
            "    \"\"\"",
            "",
            "    server: LocalServerDeploymentConfig",
            "",
            "",
            "class LocalZenServer(LocalDaemonService):",
            "    \"\"\"Service daemon that can be used to start a local ZenML Server.",
            "",
            "    Attributes:",
            "        config: service configuration",
            "        endpoint: optional service endpoint",
            "    \"\"\"",
            "",
            "    SERVICE_TYPE = ServiceType(",
            "        name=\"local_zenml_server\",",
            "        type=\"zen_server\",",
            "        flavor=\"local\",",
            "        description=\"Local ZenML server deployment\",",
            "    )",
            "",
            "    config: LocalZenServerConfig",
            "    endpoint: LocalDaemonServiceEndpoint",
            "",
            "    @classmethod",
            "    def config_path(cls) -> str:",
            "        \"\"\"Path to the directory where the local ZenML server files are located.",
            "",
            "        Returns:",
            "            Path to the local ZenML server runtime directory.",
            "        \"\"\"",
            "        return os.path.join(",
            "            get_global_config_directory(),",
            "            \"zen_server\",",
            "            \"local\",",
            "        )",
            "",
            "    @property",
            "    def _global_config_path(self) -> str:",
            "        \"\"\"Path to the global configuration directory used by this server.",
            "",
            "        Returns:",
            "            Path to the global configuration directory used by this server.",
            "        \"\"\"",
            "        return os.path.join(self.config_path(), \".zenconfig\")",
            "",
            "    @classmethod",
            "    def get_service(cls) -> Optional[\"LocalZenServer\"]:",
            "        \"\"\"Load and return the local ZenML server service, if present.",
            "",
            "        Returns:",
            "            The local ZenML server service or None, if the local server",
            "            deployment is not found.",
            "        \"\"\"",
            "        config_filename = os.path.join(cls.config_path(), \"service.json\")",
            "        try:",
            "            with open(config_filename, \"r\") as f:",
            "                return cast(",
            "                    \"LocalZenServer\", LocalZenServer.from_json(f.read())",
            "                )",
            "        except FileNotFoundError:",
            "            return None",
            "",
            "    def _get_daemon_cmd(self) -> Tuple[List[str], Dict[str, str]]:",
            "        \"\"\"Get the command to start the daemon.",
            "",
            "        Overrides the base class implementation to add the environment variable",
            "        that forces the ZenML server to use the copied global config.",
            "",
            "        Returns:",
            "            The command to start the daemon and the environment variables to",
            "            set for the command.",
            "        \"\"\"",
            "        cmd, env = super()._get_daemon_cmd()",
            "        env[ENV_ZENML_CONFIG_PATH] = self._global_config_path",
            "        env[ENV_ZENML_SERVER_DEPLOYMENT_TYPE] = ServerDeploymentType.LOCAL",
            "        # Set the local stores path to the same path used by the client. This",
            "        # ensures that the server's default store configuration is initialized",
            "        # to point at the same local SQLite database as the client.",
            "        env[ENV_ZENML_LOCAL_STORES_PATH] = (",
            "            GlobalConfiguration().local_stores_path",
            "        )",
            "        env[ENV_ZENML_DISABLE_DATABASE_MIGRATION] = \"True\"",
            "",
            "        return cmd, env",
            "",
            "    def provision(self) -> None:",
            "        \"\"\"Provision the service.\"\"\"",
            "        super().provision()",
            "",
            "    def start(self, timeout: int = 0) -> None:",
            "        \"\"\"Start the service and optionally wait for it to become active.",
            "",
            "        Args:",
            "            timeout: amount of time to wait for the service to become active.",
            "                If set to 0, the method will return immediately after checking",
            "                the service status.",
            "        \"\"\"",
            "        if not self.config.blocking:",
            "            super().start(timeout)",
            "        else:",
            "            # In the blocking mode, we need to temporarily set the environment",
            "            # variables for the running process to make it look like the server",
            "            # is running in a separate environment (i.e. using a different",
            "            # global configuration path). This is necessary to avoid polluting",
            "            # the client environment with the server's configuration.",
            "            local_stores_path = GlobalConfiguration().local_stores_path",
            "            GlobalConfiguration._reset_instance()",
            "            Client._reset_instance()",
            "            original_config_path = os.environ.get(ENV_ZENML_CONFIG_PATH)",
            "            os.environ[ENV_ZENML_CONFIG_PATH] = self._global_config_path",
            "            # Set the local stores path to the same path used by the client.",
            "            # This ensures that the server's default store configuration is",
            "            # initialized to point at the same local SQLite database as the",
            "            # client.",
            "            os.environ[ENV_ZENML_LOCAL_STORES_PATH] = local_stores_path",
            "            try:",
            "                self.run()",
            "            finally:",
            "                # Restore the original client environment variables",
            "                if original_config_path:",
            "                    os.environ[ENV_ZENML_CONFIG_PATH] = original_config_path",
            "                else:",
            "                    del os.environ[ENV_ZENML_CONFIG_PATH]",
            "                del os.environ[ENV_ZENML_LOCAL_STORES_PATH]",
            "                GlobalConfiguration._reset_instance()",
            "                Client._reset_instance()",
            "",
            "    def run(self) -> None:",
            "        \"\"\"Run the ZenML Server.",
            "",
            "        Raises:",
            "            ValueError: if started with a global configuration that connects to",
            "                another ZenML server.",
            "        \"\"\"",
            "        import uvicorn",
            "",
            "        gc = GlobalConfiguration()",
            "        if gc.store_configuration.type == StoreType.REST:",
            "            raise ValueError(",
            "                \"The ZenML server cannot be started with REST store type.\"",
            "            )",
            "        logger.info(",
            "            \"Starting ZenML Server as blocking \"",
            "            \"process... press CTRL+C once to stop it.\"",
            "        )",
            "",
            "        self.endpoint.prepare_for_start()",
            "",
            "        try:",
            "            uvicorn.run(",
            "                ZEN_SERVER_ENTRYPOINT,",
            "                host=self.endpoint.config.ip_address,",
            "                port=self.endpoint.config.port or 8000,",
            "                log_level=\"info\",",
            "                server_header=False,",
            "            )",
            "        except KeyboardInterrupt:",
            "            logger.info(\"ZenML Server stopped. Resuming normal execution.\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nltk.downloader.Downloader.download",
            "src.zenml.zen_server.deploy.local.local_zen_server.LocalZenServer.start"
        ]
    }
}