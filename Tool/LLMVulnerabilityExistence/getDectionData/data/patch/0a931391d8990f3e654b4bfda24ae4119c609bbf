{
    "neutron/plugins/ml2/drivers/linuxbridge/agent/arp_protect.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     _delete_arp_spoofing_protection(vifs, current_rules, table='nat',"
            },
            "1": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "                                     chain='PREROUTING')"
            },
            "2": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # TODO(haleyb) this can go away in \"R\" cycle, it's here to cleanup"
            },
            "4": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # old chains in the filter table"
            },
            "5": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    current_rules = ebtables(['-L'], table='filter').splitlines()"
            },
            "6": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _delete_arp_spoofing_protection(vifs, current_rules, table='filter',"
            },
            "7": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    chain='FORWARD')"
            },
            "8": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "9": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " def _delete_arp_spoofing_protection(vifs, current_rules, table, chain):"
            },
            "11": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     # delete the jump rule and then delete the whole chain"
            },
            "12": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                                     chain=chain)"
            },
            "13": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def _delete_unreferenced_arp_protection(current_vifs, table, chain):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+@lockutils.synchronized('ebtables')"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+def delete_unreferenced_arp_protection(current_vifs):"
            },
            "18": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     # deletes all jump rules and chains that aren't in current_vifs but match"
            },
            "19": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     # the spoof prefix"
            },
            "20": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    current_rules = ebtables(['-L'], table=table).splitlines()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+    current_rules = ebtables(['-L'], table='nat').splitlines()"
            },
            "22": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     to_delete = []"
            },
            "23": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "     for line in current_rules:"
            },
            "24": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         # we're looking to find and turn the following:"
            },
            "25": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "                 to_delete.append(devname)"
            },
            "26": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     LOG.info(\"Clearing orphaned ARP spoofing entries for devices %s\","
            },
            "27": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "              to_delete)"
            },
            "28": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _delete_arp_spoofing_protection(to_delete, current_rules, table=table,"
            },
            "29": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    chain=chain)"
            },
            "30": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "31": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "32": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@lockutils.synchronized('ebtables')"
            },
            "33": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def delete_unreferenced_arp_protection(current_vifs):"
            },
            "34": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _delete_unreferenced_arp_protection(current_vifs,"
            },
            "35": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                        table='nat', chain='PREROUTING')"
            },
            "36": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "37": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # TODO(haleyb) this can go away in \"R\" cycle, it's here to cleanup"
            },
            "38": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # old chains in the filter table"
            },
            "39": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _delete_unreferenced_arp_protection(current_vifs,"
            },
            "40": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                        table='filter', chain='FORWARD')"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    _delete_arp_spoofing_protection(to_delete, current_rules, table='nat',"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+                                    chain='PREROUTING')"
            },
            "43": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " @lockutils.synchronized('ebtables')"
            },
            "46": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     vif_chain = chain_name(vif)"
            },
            "47": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "     if not chain_exists(vif_chain, current_rules):"
            },
            "48": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         ebtables(['-N', vif_chain, '-P', 'DROP'])"
            },
            "49": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # flush the chain to clear previous accepts. this will cause dropped ARP"
            },
            "50": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # packets until the allows are installed, but that's better than leaked"
            },
            "51": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # spoofed packets and ARP can handle losses."
            },
            "52": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ebtables(['-F', vif_chain])"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        # Append a default DROP rule at the end of the chain. This will"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        # avoid \"ebtables-nft\" error when listing the chain."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        ebtables(['-A', vif_chain, '-j', 'DROP'])"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    else:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        # Flush the chain to clear previous accepts. This will cause dropped"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        # ARP packets until the allows are installed, but that's better than"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        # leaked spoofed packets and ARP can handle losses."
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        ebtables(['-F', vif_chain])"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        ebtables(['-A', vif_chain, '-j', 'DROP'])"
            },
            "62": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     for addr in sorted(addresses):"
            },
            "63": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ebtables(['-A', vif_chain, '-p', 'ARP', '--arp-ip-src', addr,"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        ebtables(['-I', vif_chain, '-p', 'ARP', '--arp-ip-src', addr,"
            },
            "65": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "                   '-j', 'ACCEPT'])"
            },
            "66": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "     # check if jump rule already exists, if not, install it"
            },
            "67": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     if not vif_jump_present(vif, current_rules):"
            },
            "68": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     # mac filter chain for each vif which has a default deny"
            },
            "69": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     if not chain_exists(vif_chain, current_rules):"
            },
            "70": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         ebtables(['-N', vif_chain, '-P', 'DROP'])"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        # Append a default DROP rule at the end of the chain. This will"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        # avoid \"ebtables-nft\" error when listing the chain."
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        ebtables(['-A', vif_chain, '-j', 'DROP'])"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     # check if jump rule already exists, if not, install it"
            },
            "76": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "     if not _mac_vif_jump_present(vif, current_rules):"
            },
            "77": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ebtables(['-A', 'PREROUTING', '-i', vif, '-j', vif_chain])"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        ebtables(['-I', 'PREROUTING', '-i', vif, '-j', vif_chain])"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+    _delete_vif_mac_rules(vif, current_rules)"
            },
            "81": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     # we can't just feed all allowed macs at once because we can exceed"
            },
            "82": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     # the maximum argument size. limit to 500 per rule."
            },
            "83": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "     for chunk in (mac_addresses[i:i + 500]"
            },
            "84": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                   for i in range(0, len(mac_addresses), 500)):"
            },
            "85": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        new_rule = ['-A', vif_chain, '-i', vif,"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        new_rule = ['-I', vif_chain, '-i', vif,"
            },
            "87": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "                     '--among-src', ','.join(sorted(chunk)), '-j', 'RETURN']"
            },
            "88": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "         ebtables(new_rule)"
            },
            "89": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _delete_vif_mac_rules(vif, current_rules)"
            },
            "90": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 187,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " def _mac_vif_jump_present(vif, current_rules):"
            },
            "93": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 221,
                "PatchRowcode": " "
            },
            "94": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 222,
                "PatchRowcode": " @tenacity.retry("
            },
            "95": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "     wait=tenacity.wait_exponential(multiplier=0.02),"
            },
            "96": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    retry=tenacity.retry_if_exception(lambda e: e.returncode == 255),"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+    retry=tenacity.retry_if_exception(lambda e: e.returncode in [255, 4]),"
            },
            "98": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "     reraise=True"
            },
            "99": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 226,
                "PatchRowcode": " )"
            },
            "100": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " def ebtables(comm, table='nat'):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2015 Mirantis, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import netaddr",
            "from neutron_lib.utils import net",
            "from oslo_concurrency import lockutils",
            "from oslo_log import log as logging",
            "import tenacity",
            "",
            "from neutron.agent.linux import ip_lib",
            "",
            "LOG = logging.getLogger(__name__)",
            "SPOOF_CHAIN_PREFIX = 'neutronARP-'",
            "MAC_CHAIN_PREFIX = 'neutronMAC-'",
            "",
            "",
            "def setup_arp_spoofing_protection(vif, port_details):",
            "    if not port_details.get('port_security_enabled', True):",
            "        # clear any previous entries related to this port",
            "        delete_arp_spoofing_protection([vif])",
            "        LOG.info(\"Skipping ARP spoofing rules for port '%s' because \"",
            "                 \"it has port security disabled\", vif)",
            "        return",
            "    if net.is_port_trusted(port_details):",
            "        # clear any previous entries related to this port",
            "        delete_arp_spoofing_protection([vif])",
            "        LOG.debug(\"Skipping ARP spoofing rules for network owned port \"",
            "                  \"'%s'.\", vif)",
            "        return",
            "    _setup_arp_spoofing_protection(vif, port_details)",
            "",
            "",
            "@lockutils.synchronized('ebtables')",
            "def _setup_arp_spoofing_protection(vif, port_details):",
            "    current_rules = ebtables(['-L']).splitlines()",
            "    _install_mac_spoofing_protection(vif, port_details, current_rules)",
            "    # collect all of the addresses and cidrs that belong to the port",
            "    addresses = {f['ip_address'] for f in port_details['fixed_ips']}",
            "    if port_details.get('allowed_address_pairs'):",
            "        addresses |= {p['ip_address']",
            "                      for p in port_details['allowed_address_pairs']}",
            "",
            "    addresses = {ip for ip in addresses",
            "                 if netaddr.IPNetwork(ip).version == 4}",
            "    if any(netaddr.IPNetwork(ip).prefixlen == 0 for ip in addresses):",
            "        # don't try to install protection because a /0 prefix allows any",
            "        # address anyway and the ARP_SPA can only match on /1 or more.",
            "        return",
            "",
            "    _install_arp_spoofing_protection(vif, addresses, current_rules)",
            "",
            "",
            "def chain_name(vif):",
            "    # start each chain with a common identifier for cleanup to find",
            "    return '%s%s' % (SPOOF_CHAIN_PREFIX, vif)",
            "",
            "",
            "@lockutils.synchronized('ebtables')",
            "def delete_arp_spoofing_protection(vifs):",
            "    current_rules = ebtables(['-L']).splitlines()",
            "    _delete_arp_spoofing_protection(vifs, current_rules, table='nat',",
            "                                    chain='PREROUTING')",
            "",
            "    # TODO(haleyb) this can go away in \"R\" cycle, it's here to cleanup",
            "    # old chains in the filter table",
            "    current_rules = ebtables(['-L'], table='filter').splitlines()",
            "    _delete_arp_spoofing_protection(vifs, current_rules, table='filter',",
            "                                    chain='FORWARD')",
            "",
            "",
            "def _delete_arp_spoofing_protection(vifs, current_rules, table, chain):",
            "    # delete the jump rule and then delete the whole chain",
            "    jumps = [vif for vif in vifs if vif_jump_present(vif, current_rules)]",
            "    for vif in jumps:",
            "        ebtables(['-D', chain, '-i', vif, '-j',",
            "                  chain_name(vif), '-p', 'ARP'], table=table)",
            "    for vif in vifs:",
            "        chain_delete(chain_name(vif), table, current_rules)",
            "    _delete_mac_spoofing_protection(vifs, current_rules, table=table,",
            "                                    chain=chain)",
            "",
            "",
            "def _delete_unreferenced_arp_protection(current_vifs, table, chain):",
            "    # deletes all jump rules and chains that aren't in current_vifs but match",
            "    # the spoof prefix",
            "    current_rules = ebtables(['-L'], table=table).splitlines()",
            "    to_delete = []",
            "    for line in current_rules:",
            "        # we're looking to find and turn the following:",
            "        # Bridge chain: SPOOF_CHAIN_PREFIXtap199, entries: 0, policy: DROP",
            "        # into 'tap199'",
            "        if line.startswith('Bridge chain: %s' % SPOOF_CHAIN_PREFIX):",
            "            devname = line.split(SPOOF_CHAIN_PREFIX, 1)[1].split(',')[0]",
            "            if devname not in current_vifs:",
            "                to_delete.append(devname)",
            "    LOG.info(\"Clearing orphaned ARP spoofing entries for devices %s\",",
            "             to_delete)",
            "    _delete_arp_spoofing_protection(to_delete, current_rules, table=table,",
            "                                    chain=chain)",
            "",
            "",
            "@lockutils.synchronized('ebtables')",
            "def delete_unreferenced_arp_protection(current_vifs):",
            "    _delete_unreferenced_arp_protection(current_vifs,",
            "                                        table='nat', chain='PREROUTING')",
            "",
            "    # TODO(haleyb) this can go away in \"R\" cycle, it's here to cleanup",
            "    # old chains in the filter table",
            "    _delete_unreferenced_arp_protection(current_vifs,",
            "                                        table='filter', chain='FORWARD')",
            "",
            "",
            "@lockutils.synchronized('ebtables')",
            "def install_arp_spoofing_protection(vif, addresses):",
            "    current_rules = ebtables(['-L']).splitlines()",
            "    _install_arp_spoofing_protection(vif, addresses, current_rules)",
            "",
            "",
            "def _install_arp_spoofing_protection(vif, addresses, current_rules):",
            "    # make a VIF-specific ARP chain so we don't conflict with other rules",
            "    vif_chain = chain_name(vif)",
            "    if not chain_exists(vif_chain, current_rules):",
            "        ebtables(['-N', vif_chain, '-P', 'DROP'])",
            "    # flush the chain to clear previous accepts. this will cause dropped ARP",
            "    # packets until the allows are installed, but that's better than leaked",
            "    # spoofed packets and ARP can handle losses.",
            "    ebtables(['-F', vif_chain])",
            "    for addr in sorted(addresses):",
            "        ebtables(['-A', vif_chain, '-p', 'ARP', '--arp-ip-src', addr,",
            "                  '-j', 'ACCEPT'])",
            "    # check if jump rule already exists, if not, install it",
            "    if not vif_jump_present(vif, current_rules):",
            "        ebtables(['-A', 'PREROUTING', '-i', vif, '-j',",
            "                  vif_chain, '-p', 'ARP'])",
            "",
            "",
            "def chain_exists(chain, current_rules):",
            "    for rule in current_rules:",
            "        if rule.startswith('Bridge chain: %s' % chain):",
            "            return True",
            "    return False",
            "",
            "",
            "def chain_delete(chain, table, current_rules):",
            "    # flush and delete chain if exists",
            "    if chain_exists(chain, current_rules):",
            "        ebtables(['-F', chain], table=table)",
            "        ebtables(['-X', chain], table=table)",
            "",
            "",
            "def vif_jump_present(vif, current_rules):",
            "    searches = (('-i %s' % vif), ('-j %s' % chain_name(vif)), ('-p ARP'))",
            "    for line in current_rules:",
            "        if all(s in line for s in searches):",
            "            return True",
            "    return False",
            "",
            "",
            "def _install_mac_spoofing_protection(vif, port_details, current_rules):",
            "    mac_addresses = {port_details['mac_address']}",
            "    if port_details.get('allowed_address_pairs'):",
            "        mac_addresses |= {p['mac_address']",
            "                          for p in port_details['allowed_address_pairs']}",
            "    mac_addresses = list(mac_addresses)",
            "    vif_chain = _mac_chain_name(vif)",
            "    # mac filter chain for each vif which has a default deny",
            "    if not chain_exists(vif_chain, current_rules):",
            "        ebtables(['-N', vif_chain, '-P', 'DROP'])",
            "    # check if jump rule already exists, if not, install it",
            "    if not _mac_vif_jump_present(vif, current_rules):",
            "        ebtables(['-A', 'PREROUTING', '-i', vif, '-j', vif_chain])",
            "    # we can't just feed all allowed macs at once because we can exceed",
            "    # the maximum argument size. limit to 500 per rule.",
            "    for chunk in (mac_addresses[i:i + 500]",
            "                  for i in range(0, len(mac_addresses), 500)):",
            "        new_rule = ['-A', vif_chain, '-i', vif,",
            "                    '--among-src', ','.join(sorted(chunk)), '-j', 'RETURN']",
            "        ebtables(new_rule)",
            "    _delete_vif_mac_rules(vif, current_rules)",
            "",
            "",
            "def _mac_vif_jump_present(vif, current_rules):",
            "    searches = (('-i %s' % vif), ('-j %s' % _mac_chain_name(vif)))",
            "    for line in current_rules:",
            "        if all(s in line for s in searches):",
            "            return True",
            "    return False",
            "",
            "",
            "def _mac_chain_name(vif):",
            "    return '%s%s' % (MAC_CHAIN_PREFIX, vif)",
            "",
            "",
            "def _delete_vif_mac_rules(vif, current_rules):",
            "    chain = _mac_chain_name(vif)",
            "    for rule in current_rules:",
            "        if '-i %s' % vif in rule and '--among-src' in rule:",
            "            ebtables(['-D', chain] + rule.split())",
            "",
            "",
            "def _delete_mac_spoofing_protection(vifs, current_rules, table, chain):",
            "    # delete the jump rule and then delete the whole chain",
            "    jumps = [vif for vif in vifs",
            "             if _mac_vif_jump_present(vif, current_rules)]",
            "    for vif in jumps:",
            "        ebtables(['-D', chain, '-i', vif, '-j',",
            "                  _mac_chain_name(vif)], table=table)",
            "    for vif in vifs:",
            "        chain_delete(_mac_chain_name(vif), table, current_rules)",
            "",
            "",
            "# Used to scope ebtables commands in testing",
            "NAMESPACE = None",
            "",
            "",
            "@tenacity.retry(",
            "    wait=tenacity.wait_exponential(multiplier=0.02),",
            "    retry=tenacity.retry_if_exception(lambda e: e.returncode == 255),",
            "    reraise=True",
            ")",
            "def ebtables(comm, table='nat'):",
            "    execute = ip_lib.IPWrapper(NAMESPACE).netns.execute",
            "    return execute(['ebtables', '-t', table, '--concurrent'] + comm,",
            "                   run_as_root=True, privsep_exec=True)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2015 Mirantis, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import netaddr",
            "from neutron_lib.utils import net",
            "from oslo_concurrency import lockutils",
            "from oslo_log import log as logging",
            "import tenacity",
            "",
            "from neutron.agent.linux import ip_lib",
            "",
            "LOG = logging.getLogger(__name__)",
            "SPOOF_CHAIN_PREFIX = 'neutronARP-'",
            "MAC_CHAIN_PREFIX = 'neutronMAC-'",
            "",
            "",
            "def setup_arp_spoofing_protection(vif, port_details):",
            "    if not port_details.get('port_security_enabled', True):",
            "        # clear any previous entries related to this port",
            "        delete_arp_spoofing_protection([vif])",
            "        LOG.info(\"Skipping ARP spoofing rules for port '%s' because \"",
            "                 \"it has port security disabled\", vif)",
            "        return",
            "    if net.is_port_trusted(port_details):",
            "        # clear any previous entries related to this port",
            "        delete_arp_spoofing_protection([vif])",
            "        LOG.debug(\"Skipping ARP spoofing rules for network owned port \"",
            "                  \"'%s'.\", vif)",
            "        return",
            "    _setup_arp_spoofing_protection(vif, port_details)",
            "",
            "",
            "@lockutils.synchronized('ebtables')",
            "def _setup_arp_spoofing_protection(vif, port_details):",
            "    current_rules = ebtables(['-L']).splitlines()",
            "    _install_mac_spoofing_protection(vif, port_details, current_rules)",
            "    # collect all of the addresses and cidrs that belong to the port",
            "    addresses = {f['ip_address'] for f in port_details['fixed_ips']}",
            "    if port_details.get('allowed_address_pairs'):",
            "        addresses |= {p['ip_address']",
            "                      for p in port_details['allowed_address_pairs']}",
            "",
            "    addresses = {ip for ip in addresses",
            "                 if netaddr.IPNetwork(ip).version == 4}",
            "    if any(netaddr.IPNetwork(ip).prefixlen == 0 for ip in addresses):",
            "        # don't try to install protection because a /0 prefix allows any",
            "        # address anyway and the ARP_SPA can only match on /1 or more.",
            "        return",
            "",
            "    _install_arp_spoofing_protection(vif, addresses, current_rules)",
            "",
            "",
            "def chain_name(vif):",
            "    # start each chain with a common identifier for cleanup to find",
            "    return '%s%s' % (SPOOF_CHAIN_PREFIX, vif)",
            "",
            "",
            "@lockutils.synchronized('ebtables')",
            "def delete_arp_spoofing_protection(vifs):",
            "    current_rules = ebtables(['-L']).splitlines()",
            "    _delete_arp_spoofing_protection(vifs, current_rules, table='nat',",
            "                                    chain='PREROUTING')",
            "",
            "",
            "def _delete_arp_spoofing_protection(vifs, current_rules, table, chain):",
            "    # delete the jump rule and then delete the whole chain",
            "    jumps = [vif for vif in vifs if vif_jump_present(vif, current_rules)]",
            "    for vif in jumps:",
            "        ebtables(['-D', chain, '-i', vif, '-j',",
            "                  chain_name(vif), '-p', 'ARP'], table=table)",
            "    for vif in vifs:",
            "        chain_delete(chain_name(vif), table, current_rules)",
            "    _delete_mac_spoofing_protection(vifs, current_rules, table=table,",
            "                                    chain=chain)",
            "",
            "",
            "@lockutils.synchronized('ebtables')",
            "def delete_unreferenced_arp_protection(current_vifs):",
            "    # deletes all jump rules and chains that aren't in current_vifs but match",
            "    # the spoof prefix",
            "    current_rules = ebtables(['-L'], table='nat').splitlines()",
            "    to_delete = []",
            "    for line in current_rules:",
            "        # we're looking to find and turn the following:",
            "        # Bridge chain: SPOOF_CHAIN_PREFIXtap199, entries: 0, policy: DROP",
            "        # into 'tap199'",
            "        if line.startswith('Bridge chain: %s' % SPOOF_CHAIN_PREFIX):",
            "            devname = line.split(SPOOF_CHAIN_PREFIX, 1)[1].split(',')[0]",
            "            if devname not in current_vifs:",
            "                to_delete.append(devname)",
            "    LOG.info(\"Clearing orphaned ARP spoofing entries for devices %s\",",
            "             to_delete)",
            "    _delete_arp_spoofing_protection(to_delete, current_rules, table='nat',",
            "                                    chain='PREROUTING')",
            "",
            "",
            "@lockutils.synchronized('ebtables')",
            "def install_arp_spoofing_protection(vif, addresses):",
            "    current_rules = ebtables(['-L']).splitlines()",
            "    _install_arp_spoofing_protection(vif, addresses, current_rules)",
            "",
            "",
            "def _install_arp_spoofing_protection(vif, addresses, current_rules):",
            "    # make a VIF-specific ARP chain so we don't conflict with other rules",
            "    vif_chain = chain_name(vif)",
            "    if not chain_exists(vif_chain, current_rules):",
            "        ebtables(['-N', vif_chain, '-P', 'DROP'])",
            "        # Append a default DROP rule at the end of the chain. This will",
            "        # avoid \"ebtables-nft\" error when listing the chain.",
            "        ebtables(['-A', vif_chain, '-j', 'DROP'])",
            "    else:",
            "        # Flush the chain to clear previous accepts. This will cause dropped",
            "        # ARP packets until the allows are installed, but that's better than",
            "        # leaked spoofed packets and ARP can handle losses.",
            "        ebtables(['-F', vif_chain])",
            "        ebtables(['-A', vif_chain, '-j', 'DROP'])",
            "    for addr in sorted(addresses):",
            "        ebtables(['-I', vif_chain, '-p', 'ARP', '--arp-ip-src', addr,",
            "                  '-j', 'ACCEPT'])",
            "    # check if jump rule already exists, if not, install it",
            "    if not vif_jump_present(vif, current_rules):",
            "        ebtables(['-A', 'PREROUTING', '-i', vif, '-j',",
            "                  vif_chain, '-p', 'ARP'])",
            "",
            "",
            "def chain_exists(chain, current_rules):",
            "    for rule in current_rules:",
            "        if rule.startswith('Bridge chain: %s' % chain):",
            "            return True",
            "    return False",
            "",
            "",
            "def chain_delete(chain, table, current_rules):",
            "    # flush and delete chain if exists",
            "    if chain_exists(chain, current_rules):",
            "        ebtables(['-F', chain], table=table)",
            "        ebtables(['-X', chain], table=table)",
            "",
            "",
            "def vif_jump_present(vif, current_rules):",
            "    searches = (('-i %s' % vif), ('-j %s' % chain_name(vif)), ('-p ARP'))",
            "    for line in current_rules:",
            "        if all(s in line for s in searches):",
            "            return True",
            "    return False",
            "",
            "",
            "def _install_mac_spoofing_protection(vif, port_details, current_rules):",
            "    mac_addresses = {port_details['mac_address']}",
            "    if port_details.get('allowed_address_pairs'):",
            "        mac_addresses |= {p['mac_address']",
            "                          for p in port_details['allowed_address_pairs']}",
            "    mac_addresses = list(mac_addresses)",
            "    vif_chain = _mac_chain_name(vif)",
            "    # mac filter chain for each vif which has a default deny",
            "    if not chain_exists(vif_chain, current_rules):",
            "        ebtables(['-N', vif_chain, '-P', 'DROP'])",
            "        # Append a default DROP rule at the end of the chain. This will",
            "        # avoid \"ebtables-nft\" error when listing the chain.",
            "        ebtables(['-A', vif_chain, '-j', 'DROP'])",
            "",
            "    # check if jump rule already exists, if not, install it",
            "    if not _mac_vif_jump_present(vif, current_rules):",
            "        ebtables(['-I', 'PREROUTING', '-i', vif, '-j', vif_chain])",
            "",
            "    _delete_vif_mac_rules(vif, current_rules)",
            "    # we can't just feed all allowed macs at once because we can exceed",
            "    # the maximum argument size. limit to 500 per rule.",
            "    for chunk in (mac_addresses[i:i + 500]",
            "                  for i in range(0, len(mac_addresses), 500)):",
            "        new_rule = ['-I', vif_chain, '-i', vif,",
            "                    '--among-src', ','.join(sorted(chunk)), '-j', 'RETURN']",
            "        ebtables(new_rule)",
            "",
            "",
            "def _mac_vif_jump_present(vif, current_rules):",
            "    searches = (('-i %s' % vif), ('-j %s' % _mac_chain_name(vif)))",
            "    for line in current_rules:",
            "        if all(s in line for s in searches):",
            "            return True",
            "    return False",
            "",
            "",
            "def _mac_chain_name(vif):",
            "    return '%s%s' % (MAC_CHAIN_PREFIX, vif)",
            "",
            "",
            "def _delete_vif_mac_rules(vif, current_rules):",
            "    chain = _mac_chain_name(vif)",
            "    for rule in current_rules:",
            "        if '-i %s' % vif in rule and '--among-src' in rule:",
            "            ebtables(['-D', chain] + rule.split())",
            "",
            "",
            "def _delete_mac_spoofing_protection(vifs, current_rules, table, chain):",
            "    # delete the jump rule and then delete the whole chain",
            "    jumps = [vif for vif in vifs",
            "             if _mac_vif_jump_present(vif, current_rules)]",
            "    for vif in jumps:",
            "        ebtables(['-D', chain, '-i', vif, '-j',",
            "                  _mac_chain_name(vif)], table=table)",
            "    for vif in vifs:",
            "        chain_delete(_mac_chain_name(vif), table, current_rules)",
            "",
            "",
            "# Used to scope ebtables commands in testing",
            "NAMESPACE = None",
            "",
            "",
            "@tenacity.retry(",
            "    wait=tenacity.wait_exponential(multiplier=0.02),",
            "    retry=tenacity.retry_if_exception(lambda e: e.returncode in [255, 4]),",
            "    reraise=True",
            ")",
            "def ebtables(comm, table='nat'):",
            "    execute = ip_lib.IPWrapper(NAMESPACE).netns.execute",
            "    return execute(['ebtables', '-t', table, '--concurrent'] + comm,",
            "                   run_as_root=True, privsep_exec=True)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "76": [
                "delete_arp_spoofing_protection"
            ],
            "77": [
                "delete_arp_spoofing_protection"
            ],
            "78": [
                "delete_arp_spoofing_protection"
            ],
            "79": [
                "delete_arp_spoofing_protection"
            ],
            "80": [
                "delete_arp_spoofing_protection"
            ],
            "81": [],
            "95": [
                "_delete_unreferenced_arp_protection"
            ],
            "98": [
                "_delete_unreferenced_arp_protection"
            ],
            "110": [
                "_delete_unreferenced_arp_protection"
            ],
            "111": [
                "_delete_unreferenced_arp_protection"
            ],
            "112": [],
            "113": [],
            "114": [],
            "115": [
                "delete_unreferenced_arp_protection"
            ],
            "116": [
                "delete_unreferenced_arp_protection"
            ],
            "117": [
                "delete_unreferenced_arp_protection"
            ],
            "118": [
                "delete_unreferenced_arp_protection"
            ],
            "119": [
                "delete_unreferenced_arp_protection"
            ],
            "120": [
                "delete_unreferenced_arp_protection"
            ],
            "121": [
                "delete_unreferenced_arp_protection"
            ],
            "122": [
                "delete_unreferenced_arp_protection"
            ],
            "136": [
                "_install_arp_spoofing_protection"
            ],
            "137": [
                "_install_arp_spoofing_protection"
            ],
            "138": [
                "_install_arp_spoofing_protection"
            ],
            "139": [
                "_install_arp_spoofing_protection"
            ],
            "141": [
                "_install_arp_spoofing_protection"
            ],
            "183": [
                "_install_mac_spoofing_protection"
            ],
            "188": [
                "_install_mac_spoofing_protection"
            ],
            "191": [
                "_install_mac_spoofing_protection"
            ],
            "230": []
        },
        "addLocation": []
    },
    "neutron/tests/unit/plugins/ml2/drivers/linuxbridge/agent/test_arp_protect.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "                       check_exit_code=True, extra_ok_codes=None,"
            },
            "1": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "                       log_fail_as_error=True, run_as_root=True,"
            },
            "2": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "                       privsep_exec=True),"
            },
            "3": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.ANY,"
            },
            "4": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "             mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                       'neutronMAC-%s' % vif, '-j', 'DROP'],"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                      check_exit_code=True, extra_ok_codes=None,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+                      log_fail_as_error=True, run_as_root=True,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+                      privsep_exec=True),"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+            mock.ANY,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-I',"
            },
            "11": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "                        'PREROUTING', '-i', vif, '-j', mac_chain],"
            },
            "12": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                       check_exit_code=True, extra_ok_codes=None,"
            },
            "13": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                       log_fail_as_error=True, run_as_root=True,"
            },
            "14": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "                       privsep_exec=True),"
            },
            "15": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            mock.ANY,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-I',"
            },
            "18": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "                        mac_chain, '-i', vif,"
            },
            "19": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "                        '--among-src', '%s' % ','.join(sorted(mac_addresses)),"
            },
            "20": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "                        '-j', 'RETURN'],"
            },
            "21": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "                       check_exit_code=True, extra_ok_codes=None,"
            },
            "22": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "                       log_fail_as_error=True, run_as_root=True,"
            },
            "23": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "                       privsep_exec=True),"
            },
            "24": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "             mock.ANY,"
            },
            "25": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.ANY,"
            },
            "26": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "             mock.call(['ebtables', '-t', 'nat', '--concurrent', '-N',"
            },
            "27": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "                        spoof_chain, '-P', 'DROP'],"
            },
            "28": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "                       check_exit_code=True, extra_ok_codes=None,"
            },
            "29": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "                       log_fail_as_error=True, run_as_root=True,"
            },
            "30": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "                       privsep_exec=True),"
            },
            "31": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-F',"
            },
            "32": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       spoof_chain],"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+                       spoof_chain, '-j', 'DROP'],"
            },
            "35": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "                       check_exit_code=True, extra_ok_codes=None,"
            },
            "36": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "                       log_fail_as_error=True, run_as_root=True,"
            },
            "37": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      privsep_exec=True),"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+                      privsep_exec=True)"
            },
            "39": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         ]"
            },
            "40": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         for addr in sorted(ip_addresses):"
            },
            "41": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             expected.extend(["
            },
            "42": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+                mock.call(['ebtables', '-t', 'nat', '--concurrent', '-I',"
            },
            "44": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "                            spoof_chain, '-p', 'ARP',"
            },
            "45": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "                            '--arp-ip-src', addr, '-j', 'ACCEPT'],"
            },
            "46": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "                           check_exit_code=True, extra_ok_codes=None,"
            },
            "47": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "                       check_exit_code=True, extra_ok_codes=None,"
            },
            "48": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "                       log_fail_as_error=True, run_as_root=True,"
            },
            "49": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "                       privsep_exec=True),"
            },
            "50": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-L'],"
            },
            "51": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      check_exit_code=True, extra_ok_codes=None,"
            },
            "52": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      log_fail_as_error=True, run_as_root=True,"
            },
            "53": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      privsep_exec=True),"
            },
            "54": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.ANY,"
            },
            "55": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-D',"
            },
            "56": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       'FORWARD', '-i', VIF, '-j', spoof_chain,"
            },
            "57": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       '-p', 'ARP'],"
            },
            "58": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      check_exit_code=True, extra_ok_codes=None,"
            },
            "59": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      log_fail_as_error=True, run_as_root=True,"
            },
            "60": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      privsep_exec=True),"
            },
            "61": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-F',"
            },
            "62": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       spoof_chain],"
            },
            "63": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      check_exit_code=True, extra_ok_codes=None,"
            },
            "64": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      log_fail_as_error=True, run_as_root=True,"
            },
            "65": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      privsep_exec=True),"
            },
            "66": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-X',"
            },
            "67": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       spoof_chain],"
            },
            "68": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      check_exit_code=True, extra_ok_codes=None,"
            },
            "69": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      log_fail_as_error=True, run_as_root=True,"
            },
            "70": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      privsep_exec=True),"
            },
            "71": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.ANY,"
            },
            "72": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-F',"
            },
            "73": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       mac_chain],"
            },
            "74": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      check_exit_code=True, extra_ok_codes=None,"
            },
            "75": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      log_fail_as_error=True, run_as_root=True,"
            },
            "76": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      privsep_exec=True),"
            },
            "77": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-X',"
            },
            "78": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       mac_chain],"
            },
            "79": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      check_exit_code=True, extra_ok_codes=None,"
            },
            "80": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      log_fail_as_error=True, run_as_root=True,"
            },
            "81": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                      privsep_exec=True),"
            },
            "82": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         ]"
            },
            "83": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         arp_protect.delete_arp_spoofing_protection([VIF])"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2018 Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#    you may not use this file except in compliance with the License.",
            "#    You may obtain a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#    See the License for the specific language governing permissions and",
            "#    limitations under the License.",
            "",
            "from unittest import mock",
            "",
            "from neutron_lib import constants",
            "",
            "from neutron.agent.common import utils",
            "from neutron.plugins.ml2.drivers.linuxbridge.agent import arp_protect",
            "from neutron.tests import base",
            "",
            "",
            "VIF = 'vif_tap0'",
            "PORT_NO_SEC = {'port_security_enabled': False}",
            "PORT_TRUSTED = {'device_owner': constants.DEVICE_OWNER_ROUTER_GW}",
            "PORT = {'fixed_ips': [{'ip_address': '10.1.1.1'}],",
            "        'device_owner': 'nobody',",
            "        'mac_address': '00:11:22:33:44:55'}",
            "PORT_ADDR_PAIR = {'fixed_ips': [{'ip_address': '10.1.1.1'}],",
            "                  'device_owner': 'nobody',",
            "                  'mac_address': '00:11:22:33:44:55',",
            "                  'allowed_address_pairs': [",
            "                      {'mac_address': '00:11:22:33:44:66',",
            "                       'ip_address': '10.1.1.2'}]}",
            "",
            "",
            "class TestLinuxBridgeARPSpoofing(base.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestLinuxBridgeARPSpoofing, self).setUp()",
            "        self.execute = mock.patch.object(utils, \"execute\").start()",
            "",
            "    @mock.patch.object(arp_protect, \"delete_arp_spoofing_protection\")",
            "    def test_port_no_security(self, dasp):",
            "        arp_protect.setup_arp_spoofing_protection(VIF, PORT_NO_SEC)",
            "        dasp.assert_called_with([VIF])",
            "",
            "    @mock.patch.object(arp_protect, \"delete_arp_spoofing_protection\")",
            "    def test_port_trusted(self, dasp):",
            "        arp_protect.setup_arp_spoofing_protection(VIF, PORT_TRUSTED)",
            "        dasp.assert_called_with([VIF])",
            "",
            "    def _test_port_add_arp_spoofing(self, vif, port):",
            "        mac_addresses = {port['mac_address']}",
            "        ip_addresses = {p['ip_address'] for p in port['fixed_ips']}",
            "        if port.get('allowed_address_pairs'):",
            "            mac_addresses |= {p['mac_address']",
            "                              for p in port['allowed_address_pairs']}",
            "            ip_addresses |= {p['ip_address']",
            "                             for p in port['allowed_address_pairs']}",
            "        spoof_chain = arp_protect.SPOOF_CHAIN_PREFIX + vif",
            "        mac_chain = arp_protect.MAC_CHAIN_PREFIX + vif",
            "",
            "        expected = [",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-L'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-N',",
            "                       'neutronMAC-%s' % vif, '-P', 'DROP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',",
            "                       'PREROUTING', '-i', vif, '-j', mac_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',",
            "                       mac_chain, '-i', vif,",
            "                       '--among-src', '%s' % ','.join(sorted(mac_addresses)),",
            "                       '-j', 'RETURN'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-N',",
            "                       spoof_chain, '-P', 'DROP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-F',",
            "                       spoof_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "        ]",
            "        for addr in sorted(ip_addresses):",
            "            expected.extend([",
            "                mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',",
            "                           spoof_chain, '-p', 'ARP',",
            "                           '--arp-ip-src', addr, '-j', 'ACCEPT'],",
            "                          check_exit_code=True, extra_ok_codes=None,",
            "                          log_fail_as_error=True, run_as_root=True,",
            "                          privsep_exec=True),",
            "            ])",
            "        expected.extend([",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',",
            "                       'PREROUTING', '-i', vif, '-j',",
            "                       spoof_chain, '-p', 'ARP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "        ])",
            "",
            "        arp_protect.setup_arp_spoofing_protection(vif, port)",
            "        self.execute.assert_has_calls(expected)",
            "",
            "    def test_port_add_arp_spoofing(self):",
            "        self._test_port_add_arp_spoofing(VIF, PORT)",
            "",
            "    def test_port_add_arp_spoofing_addr_pair(self):",
            "        self._test_port_add_arp_spoofing(VIF, PORT_ADDR_PAIR)",
            "",
            "    @mock.patch.object(arp_protect, \"chain_exists\", return_value=True)",
            "    @mock.patch.object(arp_protect, \"vif_jump_present\", return_value=True)",
            "    def test_port_delete_arp_spoofing(self, ce, vjp):",
            "        spoof_chain = arp_protect.SPOOF_CHAIN_PREFIX + VIF",
            "        mac_chain = arp_protect.MAC_CHAIN_PREFIX + VIF",
            "        expected = [",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-L'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-D',",
            "                       'PREROUTING', '-i', VIF, '-j', spoof_chain,",
            "                       '-p', 'ARP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-F',",
            "                       spoof_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-X',",
            "                       spoof_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-F',",
            "                       mac_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-X',",
            "                       mac_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-L'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-D',",
            "                       'FORWARD', '-i', VIF, '-j', spoof_chain,",
            "                       '-p', 'ARP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-F',",
            "                       spoof_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-X',",
            "                       spoof_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-F',",
            "                       mac_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'filter', '--concurrent', '-X',",
            "                       mac_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "        ]",
            "",
            "        arp_protect.delete_arp_spoofing_protection([VIF])",
            "        self.execute.assert_has_calls(expected)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2018 Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#    you may not use this file except in compliance with the License.",
            "#    You may obtain a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#    See the License for the specific language governing permissions and",
            "#    limitations under the License.",
            "",
            "from unittest import mock",
            "",
            "from neutron_lib import constants",
            "",
            "from neutron.agent.common import utils",
            "from neutron.plugins.ml2.drivers.linuxbridge.agent import arp_protect",
            "from neutron.tests import base",
            "",
            "",
            "VIF = 'vif_tap0'",
            "PORT_NO_SEC = {'port_security_enabled': False}",
            "PORT_TRUSTED = {'device_owner': constants.DEVICE_OWNER_ROUTER_GW}",
            "PORT = {'fixed_ips': [{'ip_address': '10.1.1.1'}],",
            "        'device_owner': 'nobody',",
            "        'mac_address': '00:11:22:33:44:55'}",
            "PORT_ADDR_PAIR = {'fixed_ips': [{'ip_address': '10.1.1.1'}],",
            "                  'device_owner': 'nobody',",
            "                  'mac_address': '00:11:22:33:44:55',",
            "                  'allowed_address_pairs': [",
            "                      {'mac_address': '00:11:22:33:44:66',",
            "                       'ip_address': '10.1.1.2'}]}",
            "",
            "",
            "class TestLinuxBridgeARPSpoofing(base.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestLinuxBridgeARPSpoofing, self).setUp()",
            "        self.execute = mock.patch.object(utils, \"execute\").start()",
            "",
            "    @mock.patch.object(arp_protect, \"delete_arp_spoofing_protection\")",
            "    def test_port_no_security(self, dasp):",
            "        arp_protect.setup_arp_spoofing_protection(VIF, PORT_NO_SEC)",
            "        dasp.assert_called_with([VIF])",
            "",
            "    @mock.patch.object(arp_protect, \"delete_arp_spoofing_protection\")",
            "    def test_port_trusted(self, dasp):",
            "        arp_protect.setup_arp_spoofing_protection(VIF, PORT_TRUSTED)",
            "        dasp.assert_called_with([VIF])",
            "",
            "    def _test_port_add_arp_spoofing(self, vif, port):",
            "        mac_addresses = {port['mac_address']}",
            "        ip_addresses = {p['ip_address'] for p in port['fixed_ips']}",
            "        if port.get('allowed_address_pairs'):",
            "            mac_addresses |= {p['mac_address']",
            "                              for p in port['allowed_address_pairs']}",
            "            ip_addresses |= {p['ip_address']",
            "                             for p in port['allowed_address_pairs']}",
            "        spoof_chain = arp_protect.SPOOF_CHAIN_PREFIX + vif",
            "        mac_chain = arp_protect.MAC_CHAIN_PREFIX + vif",
            "",
            "        expected = [",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-L'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-N',",
            "                       'neutronMAC-%s' % vif, '-P', 'DROP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',",
            "                       'neutronMAC-%s' % vif, '-j', 'DROP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-I',",
            "                       'PREROUTING', '-i', vif, '-j', mac_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-I',",
            "                       mac_chain, '-i', vif,",
            "                       '--among-src', '%s' % ','.join(sorted(mac_addresses)),",
            "                       '-j', 'RETURN'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-N',",
            "                       spoof_chain, '-P', 'DROP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',",
            "                       spoof_chain, '-j', 'DROP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True)",
            "        ]",
            "        for addr in sorted(ip_addresses):",
            "            expected.extend([",
            "                mock.call(['ebtables', '-t', 'nat', '--concurrent', '-I',",
            "                           spoof_chain, '-p', 'ARP',",
            "                           '--arp-ip-src', addr, '-j', 'ACCEPT'],",
            "                          check_exit_code=True, extra_ok_codes=None,",
            "                          log_fail_as_error=True, run_as_root=True,",
            "                          privsep_exec=True),",
            "            ])",
            "        expected.extend([",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-A',",
            "                       'PREROUTING', '-i', vif, '-j',",
            "                       spoof_chain, '-p', 'ARP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "        ])",
            "",
            "        arp_protect.setup_arp_spoofing_protection(vif, port)",
            "        self.execute.assert_has_calls(expected)",
            "",
            "    def test_port_add_arp_spoofing(self):",
            "        self._test_port_add_arp_spoofing(VIF, PORT)",
            "",
            "    def test_port_add_arp_spoofing_addr_pair(self):",
            "        self._test_port_add_arp_spoofing(VIF, PORT_ADDR_PAIR)",
            "",
            "    @mock.patch.object(arp_protect, \"chain_exists\", return_value=True)",
            "    @mock.patch.object(arp_protect, \"vif_jump_present\", return_value=True)",
            "    def test_port_delete_arp_spoofing(self, ce, vjp):",
            "        spoof_chain = arp_protect.SPOOF_CHAIN_PREFIX + VIF",
            "        mac_chain = arp_protect.MAC_CHAIN_PREFIX + VIF",
            "        expected = [",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-L'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-D',",
            "                       'PREROUTING', '-i', VIF, '-j', spoof_chain,",
            "                       '-p', 'ARP'],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-F',",
            "                       spoof_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-X',",
            "                       spoof_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.ANY,",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-F',",
            "                       mac_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "            mock.call(['ebtables', '-t', 'nat', '--concurrent', '-X',",
            "                       mac_chain],",
            "                      check_exit_code=True, extra_ok_codes=None,",
            "                      log_fail_as_error=True, run_as_root=True,",
            "                      privsep_exec=True),",
            "        ]",
            "",
            "        arp_protect.delete_arp_spoofing_protection([VIF])",
            "        self.execute.assert_has_calls(expected)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "78": [
                "TestLinuxBridgeARPSpoofing",
                "_test_port_add_arp_spoofing"
            ],
            "84": [
                "TestLinuxBridgeARPSpoofing",
                "_test_port_add_arp_spoofing"
            ],
            "92": [
                "TestLinuxBridgeARPSpoofing",
                "_test_port_add_arp_spoofing"
            ],
            "98": [
                "TestLinuxBridgeARPSpoofing",
                "_test_port_add_arp_spoofing"
            ],
            "99": [
                "TestLinuxBridgeARPSpoofing",
                "_test_port_add_arp_spoofing"
            ],
            "102": [
                "TestLinuxBridgeARPSpoofing",
                "_test_port_add_arp_spoofing"
            ],
            "106": [
                "TestLinuxBridgeARPSpoofing",
                "_test_port_add_arp_spoofing"
            ],
            "170": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "171": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "172": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "173": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "174": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "175": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "176": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "177": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "178": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "179": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "180": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "181": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "182": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "183": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "184": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "185": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "186": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "187": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "188": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "189": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "190": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "191": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "192": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "193": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "194": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "195": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "196": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "197": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "198": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "199": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "200": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ],
            "201": [
                "TestLinuxBridgeARPSpoofing",
                "test_port_delete_arp_spoofing"
            ]
        },
        "addLocation": []
    }
}