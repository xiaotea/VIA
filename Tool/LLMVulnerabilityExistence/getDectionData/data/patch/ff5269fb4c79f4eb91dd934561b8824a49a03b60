{
    "plone/namedfile/scaling.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from io import BytesIO"
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from plone.memoize import ram"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from plone.namedfile.file import FILECHUNK_CLASSES"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from plone.namedfile.browser import ALLOWED_INLINE_MIMETYPES"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from plone.namedfile.browser import DISALLOWED_INLINE_MIMETYPES"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from plone.namedfile.browser import USE_DENYLIST"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from plone.namedfile.interfaces import IAvailableSizes"
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from plone.namedfile.interfaces import IStableImageScale"
            },
            "8": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from plone.namedfile.utils import getHighPixelDensityScales"
            },
            "9": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     __allow_access_to_unprotected_subobjects__ = 1"
            },
            "10": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     data = None"
            },
            "11": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    # You can control which mimetypes may be shown inline"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    # and which must always be downloaded, for security reasons."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    # Make the configuration available on the class."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    # Then subclasses can override this."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    use_denylist = USE_DENYLIST"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     def __init__(self, context, request, **info):"
            },
            "21": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         self.context = context"
            },
            "22": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         self.request = request"
            },
            "23": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         fieldname = getattr(self.data, \"fieldname\", getattr(self, \"fieldname\", None))"
            },
            "24": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         guarded_getattr(self.context, fieldname)"
            },
            "25": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 151,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+    def _should_force_download(self):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        # If this returns True, the caller should call set_headers with a filename."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        if not hasattr(self.data, \"contentType\"):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            return"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        mimetype = self.data.contentType"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        if self.use_denylist:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            # We explicitly deny a few mimetypes, and allow the rest."
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+            return mimetype in self.disallowed_inline_mimetypes"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        # Use the allowlist."
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        # We only explicitly allow a few mimetypes, and deny the rest."
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        return mimetype not in self.allowed_inline_mimetypes"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+    def set_headers(self, response=None):"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        # set headers for the image"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        image = self.data"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        if response is None:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            response = self.request.response"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        filename = None"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        if self._should_force_download():"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+            # We MUST pass a filename, even a dummy one if needed."
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+            filename = getattr(image, \"filename\", getattr(self, \"filename\", None))"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+            if filename is None:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+                filename = getattr(image, \"fieldname\", getattr(self, \"fieldname\", None))"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+                if filename is None:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+                    filename = \"image.ext\""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        set_headers(image, response, filename=filename)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     def index_html(self):"
            },
            "54": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         \"\"\" download the image \"\"\""
            },
            "55": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         self.validate_access()"
            },
            "56": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        set_headers(self.data, self.request.response)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+        self.set_headers()"
            },
            "58": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         return stream_data(self.data)"
            },
            "59": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     def manage_DAVget(self):"
            },
            "61": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "             without transfer of the image itself"
            },
            "62": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         \"\"\""
            },
            "63": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "         self.validate_access()"
            },
            "64": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        set_headers(self.data, REQUEST.response)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+        self.set_headers(response=REQUEST.response)"
            },
            "66": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         return \"\""
            },
            "67": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 204,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "     HEAD.__roles__ = (\"Anonymous\",)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from AccessControl.ZopeGuards import guarded_getattr",
            "from Acquisition import aq_base",
            "from DateTime import DateTime",
            "from io import BytesIO",
            "from plone.memoize import ram",
            "from plone.namedfile.file import FILECHUNK_CLASSES",
            "from plone.namedfile.interfaces import IAvailableSizes",
            "from plone.namedfile.interfaces import IStableImageScale",
            "from plone.namedfile.utils import getHighPixelDensityScales",
            "from plone.namedfile.utils import set_headers",
            "from plone.namedfile.utils import stream_data",
            "from plone.protect.interfaces import IDisableCSRFProtection",
            "from plone.rfc822.interfaces import IPrimaryFieldInfo",
            "from plone.scale.interfaces import IImageScaleFactory",
            "from plone.scale.interfaces import IScaledImageQuality",
            "from plone.scale.scale import scaleImage",
            "from plone.scale.storage import AnnotationStorage",
            "from Products.CMFPlone.utils import safe_encode",
            "from Products.Five import BrowserView",
            "from xml.sax.saxutils import quoteattr",
            "from zExceptions import Unauthorized",
            "from ZODB.blob import BlobFile",
            "from ZODB.POSException import ConflictError",
            "from zope.component import queryUtility",
            "from zope.deprecation import deprecate",
            "from zope.interface import alsoProvides",
            "from zope.interface import implementer",
            "from zope.publisher.interfaces import IPublishTraverse",
            "from zope.publisher.interfaces import NotFound",
            "from zope.traversing.interfaces import ITraversable",
            "from zope.traversing.interfaces import TraversalError",
            "",
            "import functools",
            "import logging",
            "import six",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "_marker = object()",
            "",
            "",
            "class ImageScale(BrowserView):",
            "    \"\"\" view used for rendering image scales \"\"\"",
            "",
            "    # Grant full access to this view even if the object being viewed is",
            "    # protected",
            "    # (it's okay because we explicitly validate access to the image attribute",
            "    # when we retrieve it)",
            "    __roles__ = (\"Anonymous\",)",
            "    __allow_access_to_unprotected_subobjects__ = 1",
            "    data = None",
            "",
            "    def __init__(self, context, request, **info):",
            "        self.context = context",
            "        self.request = request",
            "        self.__dict__.update(**info)",
            "        if self.data is None:",
            "            self.data = getattr(self.context, self.fieldname)",
            "",
            "        url = self.context.absolute_url()",
            "        extension = self.data.contentType.split(\"/\")[-1].lower()",
            "        if self.data.contentType == \"image/svg+xml\":",
            "            extension = \"svg\"",
            "        if \"uid\" in info:",
            "            name = info[\"uid\"]",
            "        else:",
            "            name = info[\"fieldname\"]",
            "        self.__name__ = u\"{0}.{1}\".format(name, extension)",
            "        self.url = u\"{0}/@@images/{1}\".format(url, self.__name__)",
            "        self.srcset = info.get(\"srcset\", [])",
            "",
            "    def absolute_url(self):",
            "        return self.url",
            "",
            "    def srcset_attribute(self):",
            "        _srcset_attr = []",
            "        extension = self.data.contentType.split(\"/\")[-1].lower()",
            "        for scale in self.srcset:",
            "            _srcset_attr.append(",
            "                u\"{0}/@@images/{1}.{2} {3}x\".format(",
            "                    self.context.absolute_url(), scale[\"uid\"], extension, scale[\"scale\"]",
            "                )",
            "            )",
            "        srcset_attr = \", \".join(_srcset_attr)",
            "        return srcset_attr",
            "",
            "    def tag(",
            "        self,",
            "        height=_marker,",
            "        width=_marker,",
            "        alt=_marker,",
            "        css_class=None,",
            "        title=_marker,",
            "        **kwargs",
            "    ):",
            "        \"\"\"Create a tag including scale",
            "        \"\"\"",
            "        if height is _marker:",
            "            height = getattr(self, \"height\", self.data._height)",
            "        if width is _marker:",
            "            width = getattr(self, \"width\", self.data._width)",
            "",
            "        if alt is _marker:",
            "            alt = self.context.Title()",
            "        if title is _marker:",
            "            title = self.context.Title()",
            "",
            "        values = [",
            "            (\"src\", self.url),",
            "            (\"alt\", alt),",
            "            (\"title\", title),",
            "            (\"height\", height),",
            "            (\"width\", width),",
            "            (\"class\", css_class),",
            "        ]",
            "",
            "        srcset_attr = self.srcset_attribute()",
            "        if srcset_attr:",
            "            values.append((\"srcset\", srcset_attr))",
            "",
            "        values.extend(kwargs.items())",
            "",
            "        parts = [\"<img\"]",
            "        for k, v in values:",
            "            if v is None:",
            "                continue",
            "            if isinstance(v, int):",
            "                v = str(v)",
            "            elif isinstance(v, six.binary_type):",
            "                v = six.text_type(v, \"utf8\")",
            "            parts.append(u\"{0}={1}\".format(k, quoteattr(v)))",
            "        parts.append(\"/>\")",
            "",
            "        return u\" \".join(parts)",
            "",
            "    def validate_access(self):",
            "        fieldname = getattr(self.data, \"fieldname\", getattr(self, \"fieldname\", None))",
            "        guarded_getattr(self.context, fieldname)",
            "",
            "    def index_html(self):",
            "        \"\"\" download the image \"\"\"",
            "        self.validate_access()",
            "        set_headers(self.data, self.request.response)",
            "        return stream_data(self.data)",
            "",
            "    def manage_DAVget(self):",
            "        \"\"\"Get scale via webdav.\"\"\"",
            "        return self.manage_FTPget()",
            "",
            "    def manage_FTPget(self):",
            "        \"\"\"Get scale via ftp.\"\"\"",
            "        return self.index_html()",
            "",
            "    def __call__(self):",
            "        # avoid the need to prefix with nocall: in TAL",
            "        return self",
            "",
            "    def HEAD(self, REQUEST, RESPONSE=None):",
            "        \"\"\" Obtain metainformation about the image implied by the request",
            "            without transfer of the image itself",
            "        \"\"\"",
            "        self.validate_access()",
            "        set_headers(self.data, REQUEST.response)",
            "        return \"\"",
            "",
            "    HEAD.__roles__ = (\"Anonymous\",)",
            "",
            "",
            "@implementer(ITraversable)",
            "class ImmutableTraverser(object):",
            "    def __init__(self, scale):",
            "        self.scale = scale",
            "",
            "    def traverse(self, name, furtherPath):",
            "        if furtherPath:",
            "            raise TraversalError(\"Do not know how to handle further path\")",
            "        else:",
            "            if self.scale:",
            "                return self.scale.tag()",
            "            else:",
            "                raise TraversalError(name)",
            "",
            "",
            "@implementer(IImageScaleFactory)",
            "class DefaultImageScalingFactory(object):",
            "    def __init__(self, context):",
            "        self.context = context",
            "        # fieldname will be set for real in the __call__ method.",
            "        self.fieldname = None",
            "",
            "    def get_original_value(self):",
            "        \"\"\"Get the image value.",
            "",
            "        In most cases this will be a NamedBlobImage field.",
            "        \"\"\"",
            "        if self.fieldname is None:",
            "            primary = IPrimaryFieldInfo(self.context, None)",
            "            if primary is None:",
            "                return",
            "            self.fieldname = primary.fieldname",
            "        return getattr(self.context, self.fieldname, None)",
            "",
            "    def get_raw_data(self, orig_value):",
            "        \"\"\"Get the raw image data.",
            "",
            "        The result may be an open file, in which case it is the responsibility",
            "        of the caller to close it.  Or it may be a string.",
            "        \"\"\"",
            "        orig_data = None",
            "        try:",
            "            orig_data = orig_value.open()",
            "        except AttributeError:",
            "            orig_data = getattr(aq_base(orig_value), \"data\", orig_value)",
            "        if not orig_data:",
            "            return",
            "        # Handle cases where large image data is stored in FileChunks instead",
            "        # of plain string",
            "        if isinstance(orig_data, tuple(FILECHUNK_CLASSES)):",
            "            # Convert data to 8-bit string",
            "            # (FileChunk does not provide read() access)",
            "            orig_data = str(orig_data)",
            "        return orig_data",
            "",
            "    def url(self):",
            "        # url of the context",
            "        return self.context.absolute_url()",
            "",
            "    def get_quality(self):",
            "        \"\"\"Get plone.app.imaging's quality setting\"\"\"",
            "        getScaledImageQuality = queryUtility(IScaledImageQuality)",
            "        if getScaledImageQuality is None:",
            "            return None",
            "        return getScaledImageQuality()",
            "",
            "    def update_parameters(self, **parameters):",
            "        # If quality wasn't in the parameters, try the site's default scaling",
            "        # quality if it exists.",
            "        if \"quality\" not in parameters:",
            "            quality = self.get_quality()",
            "            if quality:",
            "                parameters[\"quality\"] = quality",
            "        return parameters",
            "",
            "    def create_scale(self, data, direction, height, width, **parameters):",
            "        return scaleImage(",
            "            data, direction=direction, height=height, width=width, **parameters",
            "        )",
            "",
            "    def handle_image(",
            "        self, orig_value, orig_data, direction, height, width, **parameters",
            "    ):",
            "        \"\"\"Return a scaled image, its mimetype format, and width and height.\"\"\"",
            "        if getattr(orig_value, \"contentType\", \"\") == \"image/svg+xml\":",
            "            # No need to scale, we can simply use the original data,",
            "            # but report a different width and height.",
            "            if isinstance(orig_data, (six.text_type)):",
            "                orig_data = safe_encode(orig_data)",
            "            if isinstance(orig_data, (bytes)):",
            "                orig_data = BytesIO(orig_data)",
            "            result = orig_data.read(), \"svg+xml\", (width, height)",
            "            return result",
            "        try:",
            "            result = self.create_scale(",
            "                orig_data, direction=direction, height=height, width=width, **parameters",
            "            )",
            "        except (ConflictError, KeyboardInterrupt):",
            "            raise",
            "        except Exception:",
            "            logger.exception(",
            "                'Could not scale \"{0!r}\" of {1!r}'.format(",
            "                    orig_value,",
            "                    self.url(),",
            "                ),",
            "            )",
            "            return",
            "        return result",
            "",
            "    def __call__(",
            "        self,",
            "        fieldname=None,",
            "        direction=\"thumbnail\",",
            "        height=None,",
            "        width=None,",
            "        scale=None,",
            "        **parameters",
            "    ):",
            "",
            "        \"\"\"Factory for image scales`.",
            "",
            "        Note: the 'scale' keyword argument is ignored.",
            "        You should pass a height and width.",
            "        \"\"\"",
            "        # Save self.fieldname for use in self.get_original_value",
            "        # and other methods where we do not pass the fieldname explicitly.",
            "        self.fieldname = fieldname",
            "        orig_value = self.get_original_value()",
            "        if orig_value is None:",
            "            return",
            "",
            "        if height is None and width is None:",
            "            # We don't seem to want an image, so we return nothing",
            "            # as image value (the first argument).",
            "            dummy, format_ = orig_value.contentType.split(\"/\", 1)",
            "            return None, format_, (orig_value._width, orig_value._height)",
            "        if (",
            "            not parameters",
            "            and height",
            "            and width",
            "            and height == getattr(orig_value, \"_height\", None)",
            "            and width == getattr(orig_value, \"_width\", None)",
            "        ):",
            "            # No special wishes, and the original image already has the",
            "            # requested height and width.  Return the original.",
            "            dummy, format_ = orig_value.contentType.split(\"/\", 1)",
            "            return orig_value, format_, (orig_value._width, orig_value._height)",
            "",
            "        orig_data = self.get_raw_data(orig_value)",
            "        if not orig_data:",
            "            return",
            "",
            "        parameters = self.update_parameters(**parameters)",
            "        try:",
            "            result = self.handle_image(",
            "                orig_value, orig_data, direction, height, width, **parameters",
            "            )",
            "        finally:",
            "            # Make sure the file is closed to avoid error:",
            "            # ZODB-5.5.1-py3.7.egg/ZODB/blob.py:339: ResourceWarning:",
            "            # unclosed file <_io.FileIO ... mode='rb' closefd=True>",
            "            if isinstance(orig_data, BlobFile):",
            "                orig_data.close()",
            "        if result is None:",
            "            return",
            "",
            "        # Note: the format may differ from the original.",
            "        # For example a TIFF may have been turned into a PNG.",
            "        data, format_, dimensions = result",
            "        mimetype = \"image/{0}\".format(format_.lower())",
            "        value = orig_value.__class__(",
            "            data, contentType=mimetype, filename=orig_value.filename,",
            "        )",
            "        value.fieldname = self.fieldname",
            "",
            "        return value, format_, dimensions",
            "",
            "",
            "@implementer(ITraversable, IPublishTraverse)",
            "class ImageScaling(BrowserView):",
            "    \"\"\" view used for generating (and storing) image scales \"\"\"",
            "",
            "    # Ignore some stacks to help with accessing via webdav, otherwise you get a",
            "    # 404 NotFound error.",
            "    _ignored_stacks = (\"manage_DAVget\", \"manage_FTPget\")",
            "    _scale_view_class = ImageScale",
            "",
            "    def publishTraverse(self, request, name):",
            "        \"\"\" used for traversal via publisher, i.e. when using as a url \"\"\"",
            "        stack = request.get(\"TraversalRequestNameStack\")",
            "        image = None",
            "        if stack and stack[-1] not in self._ignored_stacks:",
            "            # field and scale name were given...",
            "            scale = stack.pop()",
            "            image = self.scale(name, scale)  # this is an aq-wrapped scale_view",
            "            if image:",
            "                return image",
            "        elif \"-\" in name:",
            "            # we got a uid...",
            "            if \".\" in name:",
            "                name, ext = name.rsplit(\".\", 1)",
            "            storage = AnnotationStorage(self.context)",
            "            info = storage.get(name)",
            "            if info is None:",
            "                raise NotFound(self, name, self.request)",
            "            scale_view = self._scale_view_class(self.context, self.request, **info)",
            "            alsoProvides(scale_view, IStableImageScale)",
            "            return scale_view",
            "        else:",
            "            # otherwise `name` must refer to a field...",
            "            if \".\" in name:",
            "                name, ext = name.rsplit(\".\", 1)",
            "            value = getattr(self.context, name)",
            "            scale_view = self._scale_view_class(",
            "                self.context, self.request, data=value, fieldname=name,",
            "            )",
            "            return scale_view",
            "        raise NotFound(self, name, self.request)",
            "",
            "    def traverse(self, name, furtherPath):",
            "        \"\"\" used for path traversal, i.e. in zope page templates \"\"\"",
            "        # validate access",
            "        value = self.guarded_orig_image(name)",
            "        if not furtherPath:",
            "            image = self._scale_view_class(",
            "                self.context, self.request, data=value, fieldname=name,",
            "            )",
            "        else:",
            "            return ImmutableTraverser(self.scale(name, furtherPath[-1]))",
            "",
            "        if image is not None:",
            "            return image.tag()",
            "        raise TraversalError(self, name)",
            "",
            "    _sizes = {}",
            "",
            "    @deprecate(\"use property available_sizes instead\")",
            "    def getAvailableSizes(self, fieldname=None):",
            "        if fieldname:",
            "            logger.warning(",
            "                \"fieldname was passed to deprecated getAvailableSizes, but \"",
            "                \"will be ignored.\",",
            "            )",
            "        return self.available_sizes",
            "",
            "    @property",
            "    def available_sizes(self):",
            "        # fieldname is ignored by default",
            "        sizes_util = queryUtility(IAvailableSizes)",
            "        if sizes_util is None:",
            "            return self._sizes",
            "        sizes = sizes_util()",
            "        if sizes is None:",
            "            return {}",
            "        return sizes",
            "",
            "    @available_sizes.setter",
            "    def available_sizes(self, value):",
            "        self._sizes = value",
            "",
            "    def getImageSize(self, fieldname=None):",
            "        if fieldname is not None:",
            "            try:",
            "                value = self.guarded_orig_image(fieldname)",
            "            except Unauthorized:",
            "                # This is a corner case that can be seen in some tests,",
            "                # at least plone.app.caching and plone.formwidget.namedfile.",
            "                # When it is *really* unauthorized to get this image,",
            "                # it will go wrong somewhere else.",
            "                value = None",
            "            if value is None:",
            "                return (0, 0)",
            "            return value.getImageSize()",
            "        value = IPrimaryFieldInfo(self.context).value",
            "        return value.getImageSize()",
            "",
            "    def guarded_orig_image(self, fieldname):",
            "        return guarded_getattr(self.context, fieldname, None)",
            "",
            "    @deprecate(\"use getHighPixelDensityScales instead\")",
            "    def getRetinaScales(self):",
            "        return getHighPixelDensityScales()",
            "",
            "    def getHighPixelDensityScales(self):",
            "        return getHighPixelDensityScales()",
            "",
            "    def modified(self, fieldname=None):",
            "        \"\"\"Provide a callable to return the modification time of content",
            "        items, so stored image scales can be invalidated.",
            "        \"\"\"",
            "        context = aq_base(self.context)",
            "        if fieldname is not None:",
            "            field = getattr(context, fieldname, None)",
            "            field_p_mtime = getattr(field, \"_p_mtime\", None)",
            "            date = DateTime(field_p_mtime or context._p_mtime)",
            "        else:",
            "            date = DateTime(context._p_mtime)",
            "        return date.millis()",
            "",
            "    def scale(",
            "        self,",
            "        fieldname=None,",
            "        scale=None,",
            "        height=None,",
            "        width=None,",
            "        direction=\"thumbnail\",",
            "        **parameters",
            "    ):",
            "        if fieldname is None:",
            "            primary_field = IPrimaryFieldInfo(self.context, None)",
            "            if primary_field is None:",
            "                return  # 404",
            "            fieldname = primary_field.fieldname",
            "        if scale is not None:",
            "            if width is not None or height is not None:",
            "                logger.warn(",
            "                    \"A scale name and width/heigth are given. Those are\"",
            "                    \"mutually exclusive: solved by ignoring width/heigth and \"",
            "                    \"taking name\",",
            "                )",
            "            available = self.available_sizes",
            "            if scale not in available:",
            "                return None  # 404",
            "            width, height = available[scale]",
            "        if IDisableCSRFProtection and self.request is not None:",
            "            alsoProvides(self.request, IDisableCSRFProtection)",
            "        storage = AnnotationStorage(",
            "            self.context,",
            "            functools.partial(self.modified, fieldname)",
            "        )",
            "        info = storage.scale(",
            "            fieldname=fieldname,",
            "            height=height,",
            "            width=width,",
            "            direction=direction,",
            "            scale=scale,",
            "            **parameters",
            "        )",
            "        if info is None:",
            "            return  # 404",
            "",
            "        info[\"srcset\"] = self.calculate_srcset(",
            "            fieldname=fieldname,",
            "            height=height,",
            "            width=width,",
            "            direction=direction,",
            "            scale=scale,",
            "            storage=storage,",
            "            **parameters",
            "        )",
            "        info[\"fieldname\"] = fieldname",
            "        scale_view = self._scale_view_class(self.context, self.request, **info)",
            "        return scale_view",
            "",
            "    def calculate_srcset(",
            "        self,",
            "        fieldname=None,",
            "        scale=None,",
            "        height=None,",
            "        width=None,",
            "        direction=\"thumbnail\",",
            "        storage=None,",
            "        **parameters",
            "    ):",
            "        srcset = []",
            "        if storage is None:",
            "            return srcset",
            "        (orig_width, orig_height) = self.getImageSize(fieldname)",
            "        for hdScale in self.getHighPixelDensityScales():",
            "            # Don't create retina scales larger than the source image.",
            "            if (height and orig_height and orig_height < height * hdScale[\"scale\"]) or (",
            "                width and orig_width and orig_width < width * hdScale[\"scale\"]",
            "            ):",
            "                continue",
            "            parameters[\"quality\"] = hdScale[\"quality\"]",
            "            scale_src = storage.scale(",
            "                fieldname=fieldname,",
            "                height=height * hdScale[\"scale\"] if height else height,",
            "                width=width * hdScale[\"scale\"] if width else width,",
            "                direction=direction,",
            "                **parameters",
            "            )",
            "            scale_src[\"scale\"] = hdScale[\"scale\"]",
            "            if scale_src is not None:",
            "                srcset.append(scale_src)",
            "        return srcset",
            "",
            "    def tag(",
            "        self,",
            "        fieldname=None,",
            "        scale=None,",
            "        height=None,",
            "        width=None,",
            "        direction=\"thumbnail\",",
            "        **kwargs",
            "    ):",
            "        scale = self.scale(fieldname, scale, height, width, direction)",
            "        return scale.tag(**kwargs) if scale else None",
            "",
            "",
            "class NavigationRootScaling(ImageScaling):",
            "    def _scale_cachekey(method, self, brain, fieldname, **kwargs):",
            "        return (",
            "            self.context.absolute_url(),",
            "            brain.UID,",
            "            brain.modified,",
            "            fieldname,",
            "            kwargs,",
            "        )",
            "",
            "    @ram.cache(_scale_cachekey)",
            "    def tag(self, brain, fieldname, **kwargs):",
            "        obj = brain.getObject()",
            "        images = obj.restrictedTraverse(\"@@images\")",
            "        tag = images.tag(fieldname, **kwargs)",
            "        return tag"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from AccessControl.ZopeGuards import guarded_getattr",
            "from Acquisition import aq_base",
            "from DateTime import DateTime",
            "from io import BytesIO",
            "from plone.memoize import ram",
            "from plone.namedfile.file import FILECHUNK_CLASSES",
            "from plone.namedfile.browser import ALLOWED_INLINE_MIMETYPES",
            "from plone.namedfile.browser import DISALLOWED_INLINE_MIMETYPES",
            "from plone.namedfile.browser import USE_DENYLIST",
            "from plone.namedfile.interfaces import IAvailableSizes",
            "from plone.namedfile.interfaces import IStableImageScale",
            "from plone.namedfile.utils import getHighPixelDensityScales",
            "from plone.namedfile.utils import set_headers",
            "from plone.namedfile.utils import stream_data",
            "from plone.protect.interfaces import IDisableCSRFProtection",
            "from plone.rfc822.interfaces import IPrimaryFieldInfo",
            "from plone.scale.interfaces import IImageScaleFactory",
            "from plone.scale.interfaces import IScaledImageQuality",
            "from plone.scale.scale import scaleImage",
            "from plone.scale.storage import AnnotationStorage",
            "from Products.CMFPlone.utils import safe_encode",
            "from Products.Five import BrowserView",
            "from xml.sax.saxutils import quoteattr",
            "from zExceptions import Unauthorized",
            "from ZODB.blob import BlobFile",
            "from ZODB.POSException import ConflictError",
            "from zope.component import queryUtility",
            "from zope.deprecation import deprecate",
            "from zope.interface import alsoProvides",
            "from zope.interface import implementer",
            "from zope.publisher.interfaces import IPublishTraverse",
            "from zope.publisher.interfaces import NotFound",
            "from zope.traversing.interfaces import ITraversable",
            "from zope.traversing.interfaces import TraversalError",
            "",
            "import functools",
            "import logging",
            "import six",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "_marker = object()",
            "",
            "",
            "class ImageScale(BrowserView):",
            "    \"\"\" view used for rendering image scales \"\"\"",
            "",
            "    # Grant full access to this view even if the object being viewed is",
            "    # protected",
            "    # (it's okay because we explicitly validate access to the image attribute",
            "    # when we retrieve it)",
            "    __roles__ = (\"Anonymous\",)",
            "    __allow_access_to_unprotected_subobjects__ = 1",
            "    data = None",
            "",
            "    # You can control which mimetypes may be shown inline",
            "    # and which must always be downloaded, for security reasons.",
            "    # Make the configuration available on the class.",
            "    # Then subclasses can override this.",
            "    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES",
            "    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES",
            "    use_denylist = USE_DENYLIST",
            "",
            "    def __init__(self, context, request, **info):",
            "        self.context = context",
            "        self.request = request",
            "        self.__dict__.update(**info)",
            "        if self.data is None:",
            "            self.data = getattr(self.context, self.fieldname)",
            "",
            "        url = self.context.absolute_url()",
            "        extension = self.data.contentType.split(\"/\")[-1].lower()",
            "        if self.data.contentType == \"image/svg+xml\":",
            "            extension = \"svg\"",
            "        if \"uid\" in info:",
            "            name = info[\"uid\"]",
            "        else:",
            "            name = info[\"fieldname\"]",
            "        self.__name__ = u\"{0}.{1}\".format(name, extension)",
            "        self.url = u\"{0}/@@images/{1}\".format(url, self.__name__)",
            "        self.srcset = info.get(\"srcset\", [])",
            "",
            "    def absolute_url(self):",
            "        return self.url",
            "",
            "    def srcset_attribute(self):",
            "        _srcset_attr = []",
            "        extension = self.data.contentType.split(\"/\")[-1].lower()",
            "        for scale in self.srcset:",
            "            _srcset_attr.append(",
            "                u\"{0}/@@images/{1}.{2} {3}x\".format(",
            "                    self.context.absolute_url(), scale[\"uid\"], extension, scale[\"scale\"]",
            "                )",
            "            )",
            "        srcset_attr = \", \".join(_srcset_attr)",
            "        return srcset_attr",
            "",
            "    def tag(",
            "        self,",
            "        height=_marker,",
            "        width=_marker,",
            "        alt=_marker,",
            "        css_class=None,",
            "        title=_marker,",
            "        **kwargs",
            "    ):",
            "        \"\"\"Create a tag including scale",
            "        \"\"\"",
            "        if height is _marker:",
            "            height = getattr(self, \"height\", self.data._height)",
            "        if width is _marker:",
            "            width = getattr(self, \"width\", self.data._width)",
            "",
            "        if alt is _marker:",
            "            alt = self.context.Title()",
            "        if title is _marker:",
            "            title = self.context.Title()",
            "",
            "        values = [",
            "            (\"src\", self.url),",
            "            (\"alt\", alt),",
            "            (\"title\", title),",
            "            (\"height\", height),",
            "            (\"width\", width),",
            "            (\"class\", css_class),",
            "        ]",
            "",
            "        srcset_attr = self.srcset_attribute()",
            "        if srcset_attr:",
            "            values.append((\"srcset\", srcset_attr))",
            "",
            "        values.extend(kwargs.items())",
            "",
            "        parts = [\"<img\"]",
            "        for k, v in values:",
            "            if v is None:",
            "                continue",
            "            if isinstance(v, int):",
            "                v = str(v)",
            "            elif isinstance(v, six.binary_type):",
            "                v = six.text_type(v, \"utf8\")",
            "            parts.append(u\"{0}={1}\".format(k, quoteattr(v)))",
            "        parts.append(\"/>\")",
            "",
            "        return u\" \".join(parts)",
            "",
            "    def validate_access(self):",
            "        fieldname = getattr(self.data, \"fieldname\", getattr(self, \"fieldname\", None))",
            "        guarded_getattr(self.context, fieldname)",
            "",
            "    def _should_force_download(self):",
            "        # If this returns True, the caller should call set_headers with a filename.",
            "        if not hasattr(self.data, \"contentType\"):",
            "            return",
            "        mimetype = self.data.contentType",
            "        if self.use_denylist:",
            "            # We explicitly deny a few mimetypes, and allow the rest.",
            "            return mimetype in self.disallowed_inline_mimetypes",
            "        # Use the allowlist.",
            "        # We only explicitly allow a few mimetypes, and deny the rest.",
            "        return mimetype not in self.allowed_inline_mimetypes",
            "",
            "    def set_headers(self, response=None):",
            "        # set headers for the image",
            "        image = self.data",
            "        if response is None:",
            "            response = self.request.response",
            "        filename = None",
            "        if self._should_force_download():",
            "            # We MUST pass a filename, even a dummy one if needed.",
            "            filename = getattr(image, \"filename\", getattr(self, \"filename\", None))",
            "            if filename is None:",
            "                filename = getattr(image, \"fieldname\", getattr(self, \"fieldname\", None))",
            "                if filename is None:",
            "                    filename = \"image.ext\"",
            "        set_headers(image, response, filename=filename)",
            "",
            "    def index_html(self):",
            "        \"\"\" download the image \"\"\"",
            "        self.validate_access()",
            "        self.set_headers()",
            "        return stream_data(self.data)",
            "",
            "    def manage_DAVget(self):",
            "        \"\"\"Get scale via webdav.\"\"\"",
            "        return self.manage_FTPget()",
            "",
            "    def manage_FTPget(self):",
            "        \"\"\"Get scale via ftp.\"\"\"",
            "        return self.index_html()",
            "",
            "    def __call__(self):",
            "        # avoid the need to prefix with nocall: in TAL",
            "        return self",
            "",
            "    def HEAD(self, REQUEST, RESPONSE=None):",
            "        \"\"\" Obtain metainformation about the image implied by the request",
            "            without transfer of the image itself",
            "        \"\"\"",
            "        self.validate_access()",
            "        self.set_headers(response=REQUEST.response)",
            "        return \"\"",
            "",
            "    HEAD.__roles__ = (\"Anonymous\",)",
            "",
            "",
            "@implementer(ITraversable)",
            "class ImmutableTraverser(object):",
            "    def __init__(self, scale):",
            "        self.scale = scale",
            "",
            "    def traverse(self, name, furtherPath):",
            "        if furtherPath:",
            "            raise TraversalError(\"Do not know how to handle further path\")",
            "        else:",
            "            if self.scale:",
            "                return self.scale.tag()",
            "            else:",
            "                raise TraversalError(name)",
            "",
            "",
            "@implementer(IImageScaleFactory)",
            "class DefaultImageScalingFactory(object):",
            "    def __init__(self, context):",
            "        self.context = context",
            "        # fieldname will be set for real in the __call__ method.",
            "        self.fieldname = None",
            "",
            "    def get_original_value(self):",
            "        \"\"\"Get the image value.",
            "",
            "        In most cases this will be a NamedBlobImage field.",
            "        \"\"\"",
            "        if self.fieldname is None:",
            "            primary = IPrimaryFieldInfo(self.context, None)",
            "            if primary is None:",
            "                return",
            "            self.fieldname = primary.fieldname",
            "        return getattr(self.context, self.fieldname, None)",
            "",
            "    def get_raw_data(self, orig_value):",
            "        \"\"\"Get the raw image data.",
            "",
            "        The result may be an open file, in which case it is the responsibility",
            "        of the caller to close it.  Or it may be a string.",
            "        \"\"\"",
            "        orig_data = None",
            "        try:",
            "            orig_data = orig_value.open()",
            "        except AttributeError:",
            "            orig_data = getattr(aq_base(orig_value), \"data\", orig_value)",
            "        if not orig_data:",
            "            return",
            "        # Handle cases where large image data is stored in FileChunks instead",
            "        # of plain string",
            "        if isinstance(orig_data, tuple(FILECHUNK_CLASSES)):",
            "            # Convert data to 8-bit string",
            "            # (FileChunk does not provide read() access)",
            "            orig_data = str(orig_data)",
            "        return orig_data",
            "",
            "    def url(self):",
            "        # url of the context",
            "        return self.context.absolute_url()",
            "",
            "    def get_quality(self):",
            "        \"\"\"Get plone.app.imaging's quality setting\"\"\"",
            "        getScaledImageQuality = queryUtility(IScaledImageQuality)",
            "        if getScaledImageQuality is None:",
            "            return None",
            "        return getScaledImageQuality()",
            "",
            "    def update_parameters(self, **parameters):",
            "        # If quality wasn't in the parameters, try the site's default scaling",
            "        # quality if it exists.",
            "        if \"quality\" not in parameters:",
            "            quality = self.get_quality()",
            "            if quality:",
            "                parameters[\"quality\"] = quality",
            "        return parameters",
            "",
            "    def create_scale(self, data, direction, height, width, **parameters):",
            "        return scaleImage(",
            "            data, direction=direction, height=height, width=width, **parameters",
            "        )",
            "",
            "    def handle_image(",
            "        self, orig_value, orig_data, direction, height, width, **parameters",
            "    ):",
            "        \"\"\"Return a scaled image, its mimetype format, and width and height.\"\"\"",
            "        if getattr(orig_value, \"contentType\", \"\") == \"image/svg+xml\":",
            "            # No need to scale, we can simply use the original data,",
            "            # but report a different width and height.",
            "            if isinstance(orig_data, (six.text_type)):",
            "                orig_data = safe_encode(orig_data)",
            "            if isinstance(orig_data, (bytes)):",
            "                orig_data = BytesIO(orig_data)",
            "            result = orig_data.read(), \"svg+xml\", (width, height)",
            "            return result",
            "        try:",
            "            result = self.create_scale(",
            "                orig_data, direction=direction, height=height, width=width, **parameters",
            "            )",
            "        except (ConflictError, KeyboardInterrupt):",
            "            raise",
            "        except Exception:",
            "            logger.exception(",
            "                'Could not scale \"{0!r}\" of {1!r}'.format(",
            "                    orig_value,",
            "                    self.url(),",
            "                ),",
            "            )",
            "            return",
            "        return result",
            "",
            "    def __call__(",
            "        self,",
            "        fieldname=None,",
            "        direction=\"thumbnail\",",
            "        height=None,",
            "        width=None,",
            "        scale=None,",
            "        **parameters",
            "    ):",
            "",
            "        \"\"\"Factory for image scales`.",
            "",
            "        Note: the 'scale' keyword argument is ignored.",
            "        You should pass a height and width.",
            "        \"\"\"",
            "        # Save self.fieldname for use in self.get_original_value",
            "        # and other methods where we do not pass the fieldname explicitly.",
            "        self.fieldname = fieldname",
            "        orig_value = self.get_original_value()",
            "        if orig_value is None:",
            "            return",
            "",
            "        if height is None and width is None:",
            "            # We don't seem to want an image, so we return nothing",
            "            # as image value (the first argument).",
            "            dummy, format_ = orig_value.contentType.split(\"/\", 1)",
            "            return None, format_, (orig_value._width, orig_value._height)",
            "        if (",
            "            not parameters",
            "            and height",
            "            and width",
            "            and height == getattr(orig_value, \"_height\", None)",
            "            and width == getattr(orig_value, \"_width\", None)",
            "        ):",
            "            # No special wishes, and the original image already has the",
            "            # requested height and width.  Return the original.",
            "            dummy, format_ = orig_value.contentType.split(\"/\", 1)",
            "            return orig_value, format_, (orig_value._width, orig_value._height)",
            "",
            "        orig_data = self.get_raw_data(orig_value)",
            "        if not orig_data:",
            "            return",
            "",
            "        parameters = self.update_parameters(**parameters)",
            "        try:",
            "            result = self.handle_image(",
            "                orig_value, orig_data, direction, height, width, **parameters",
            "            )",
            "        finally:",
            "            # Make sure the file is closed to avoid error:",
            "            # ZODB-5.5.1-py3.7.egg/ZODB/blob.py:339: ResourceWarning:",
            "            # unclosed file <_io.FileIO ... mode='rb' closefd=True>",
            "            if isinstance(orig_data, BlobFile):",
            "                orig_data.close()",
            "        if result is None:",
            "            return",
            "",
            "        # Note: the format may differ from the original.",
            "        # For example a TIFF may have been turned into a PNG.",
            "        data, format_, dimensions = result",
            "        mimetype = \"image/{0}\".format(format_.lower())",
            "        value = orig_value.__class__(",
            "            data, contentType=mimetype, filename=orig_value.filename,",
            "        )",
            "        value.fieldname = self.fieldname",
            "",
            "        return value, format_, dimensions",
            "",
            "",
            "@implementer(ITraversable, IPublishTraverse)",
            "class ImageScaling(BrowserView):",
            "    \"\"\" view used for generating (and storing) image scales \"\"\"",
            "",
            "    # Ignore some stacks to help with accessing via webdav, otherwise you get a",
            "    # 404 NotFound error.",
            "    _ignored_stacks = (\"manage_DAVget\", \"manage_FTPget\")",
            "    _scale_view_class = ImageScale",
            "",
            "    def publishTraverse(self, request, name):",
            "        \"\"\" used for traversal via publisher, i.e. when using as a url \"\"\"",
            "        stack = request.get(\"TraversalRequestNameStack\")",
            "        image = None",
            "        if stack and stack[-1] not in self._ignored_stacks:",
            "            # field and scale name were given...",
            "            scale = stack.pop()",
            "            image = self.scale(name, scale)  # this is an aq-wrapped scale_view",
            "            if image:",
            "                return image",
            "        elif \"-\" in name:",
            "            # we got a uid...",
            "            if \".\" in name:",
            "                name, ext = name.rsplit(\".\", 1)",
            "            storage = AnnotationStorage(self.context)",
            "            info = storage.get(name)",
            "            if info is None:",
            "                raise NotFound(self, name, self.request)",
            "            scale_view = self._scale_view_class(self.context, self.request, **info)",
            "            alsoProvides(scale_view, IStableImageScale)",
            "            return scale_view",
            "        else:",
            "            # otherwise `name` must refer to a field...",
            "            if \".\" in name:",
            "                name, ext = name.rsplit(\".\", 1)",
            "            value = getattr(self.context, name)",
            "            scale_view = self._scale_view_class(",
            "                self.context, self.request, data=value, fieldname=name,",
            "            )",
            "            return scale_view",
            "        raise NotFound(self, name, self.request)",
            "",
            "    def traverse(self, name, furtherPath):",
            "        \"\"\" used for path traversal, i.e. in zope page templates \"\"\"",
            "        # validate access",
            "        value = self.guarded_orig_image(name)",
            "        if not furtherPath:",
            "            image = self._scale_view_class(",
            "                self.context, self.request, data=value, fieldname=name,",
            "            )",
            "        else:",
            "            return ImmutableTraverser(self.scale(name, furtherPath[-1]))",
            "",
            "        if image is not None:",
            "            return image.tag()",
            "        raise TraversalError(self, name)",
            "",
            "    _sizes = {}",
            "",
            "    @deprecate(\"use property available_sizes instead\")",
            "    def getAvailableSizes(self, fieldname=None):",
            "        if fieldname:",
            "            logger.warning(",
            "                \"fieldname was passed to deprecated getAvailableSizes, but \"",
            "                \"will be ignored.\",",
            "            )",
            "        return self.available_sizes",
            "",
            "    @property",
            "    def available_sizes(self):",
            "        # fieldname is ignored by default",
            "        sizes_util = queryUtility(IAvailableSizes)",
            "        if sizes_util is None:",
            "            return self._sizes",
            "        sizes = sizes_util()",
            "        if sizes is None:",
            "            return {}",
            "        return sizes",
            "",
            "    @available_sizes.setter",
            "    def available_sizes(self, value):",
            "        self._sizes = value",
            "",
            "    def getImageSize(self, fieldname=None):",
            "        if fieldname is not None:",
            "            try:",
            "                value = self.guarded_orig_image(fieldname)",
            "            except Unauthorized:",
            "                # This is a corner case that can be seen in some tests,",
            "                # at least plone.app.caching and plone.formwidget.namedfile.",
            "                # When it is *really* unauthorized to get this image,",
            "                # it will go wrong somewhere else.",
            "                value = None",
            "            if value is None:",
            "                return (0, 0)",
            "            return value.getImageSize()",
            "        value = IPrimaryFieldInfo(self.context).value",
            "        return value.getImageSize()",
            "",
            "    def guarded_orig_image(self, fieldname):",
            "        return guarded_getattr(self.context, fieldname, None)",
            "",
            "    @deprecate(\"use getHighPixelDensityScales instead\")",
            "    def getRetinaScales(self):",
            "        return getHighPixelDensityScales()",
            "",
            "    def getHighPixelDensityScales(self):",
            "        return getHighPixelDensityScales()",
            "",
            "    def modified(self, fieldname=None):",
            "        \"\"\"Provide a callable to return the modification time of content",
            "        items, so stored image scales can be invalidated.",
            "        \"\"\"",
            "        context = aq_base(self.context)",
            "        if fieldname is not None:",
            "            field = getattr(context, fieldname, None)",
            "            field_p_mtime = getattr(field, \"_p_mtime\", None)",
            "            date = DateTime(field_p_mtime or context._p_mtime)",
            "        else:",
            "            date = DateTime(context._p_mtime)",
            "        return date.millis()",
            "",
            "    def scale(",
            "        self,",
            "        fieldname=None,",
            "        scale=None,",
            "        height=None,",
            "        width=None,",
            "        direction=\"thumbnail\",",
            "        **parameters",
            "    ):",
            "        if fieldname is None:",
            "            primary_field = IPrimaryFieldInfo(self.context, None)",
            "            if primary_field is None:",
            "                return  # 404",
            "            fieldname = primary_field.fieldname",
            "        if scale is not None:",
            "            if width is not None or height is not None:",
            "                logger.warn(",
            "                    \"A scale name and width/heigth are given. Those are\"",
            "                    \"mutually exclusive: solved by ignoring width/heigth and \"",
            "                    \"taking name\",",
            "                )",
            "            available = self.available_sizes",
            "            if scale not in available:",
            "                return None  # 404",
            "            width, height = available[scale]",
            "        if IDisableCSRFProtection and self.request is not None:",
            "            alsoProvides(self.request, IDisableCSRFProtection)",
            "        storage = AnnotationStorage(",
            "            self.context,",
            "            functools.partial(self.modified, fieldname)",
            "        )",
            "        info = storage.scale(",
            "            fieldname=fieldname,",
            "            height=height,",
            "            width=width,",
            "            direction=direction,",
            "            scale=scale,",
            "            **parameters",
            "        )",
            "        if info is None:",
            "            return  # 404",
            "",
            "        info[\"srcset\"] = self.calculate_srcset(",
            "            fieldname=fieldname,",
            "            height=height,",
            "            width=width,",
            "            direction=direction,",
            "            scale=scale,",
            "            storage=storage,",
            "            **parameters",
            "        )",
            "        info[\"fieldname\"] = fieldname",
            "        scale_view = self._scale_view_class(self.context, self.request, **info)",
            "        return scale_view",
            "",
            "    def calculate_srcset(",
            "        self,",
            "        fieldname=None,",
            "        scale=None,",
            "        height=None,",
            "        width=None,",
            "        direction=\"thumbnail\",",
            "        storage=None,",
            "        **parameters",
            "    ):",
            "        srcset = []",
            "        if storage is None:",
            "            return srcset",
            "        (orig_width, orig_height) = self.getImageSize(fieldname)",
            "        for hdScale in self.getHighPixelDensityScales():",
            "            # Don't create retina scales larger than the source image.",
            "            if (height and orig_height and orig_height < height * hdScale[\"scale\"]) or (",
            "                width and orig_width and orig_width < width * hdScale[\"scale\"]",
            "            ):",
            "                continue",
            "            parameters[\"quality\"] = hdScale[\"quality\"]",
            "            scale_src = storage.scale(",
            "                fieldname=fieldname,",
            "                height=height * hdScale[\"scale\"] if height else height,",
            "                width=width * hdScale[\"scale\"] if width else width,",
            "                direction=direction,",
            "                **parameters",
            "            )",
            "            scale_src[\"scale\"] = hdScale[\"scale\"]",
            "            if scale_src is not None:",
            "                srcset.append(scale_src)",
            "        return srcset",
            "",
            "    def tag(",
            "        self,",
            "        fieldname=None,",
            "        scale=None,",
            "        height=None,",
            "        width=None,",
            "        direction=\"thumbnail\",",
            "        **kwargs",
            "    ):",
            "        scale = self.scale(fieldname, scale, height, width, direction)",
            "        return scale.tag(**kwargs) if scale else None",
            "",
            "",
            "class NavigationRootScaling(ImageScaling):",
            "    def _scale_cachekey(method, self, brain, fieldname, **kwargs):",
            "        return (",
            "            self.context.absolute_url(),",
            "            brain.UID,",
            "            brain.modified,",
            "            fieldname,",
            "            kwargs,",
            "        )",
            "",
            "    @ram.cache(_scale_cachekey)",
            "    def tag(self, brain, fieldname, **kwargs):",
            "        obj = brain.getObject()",
            "        images = obj.restrictedTraverse(\"@@images\")",
            "        tag = images.tag(fieldname, **kwargs)",
            "        return tag"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "144": [
                "ImageScale",
                "index_html"
            ],
            "164": [
                "ImageScale",
                "HEAD"
            ]
        },
        "addLocation": [
            "plone.namedfile.scaling.ImageScale.index_html",
            "plone.namedfile.tests.test_display_file.ISchema",
            "plone.namedfile.scaling.ImageScale.self",
            "plone.namedfile.scaling.ImageScaling._scale_view_class",
            "plone.namedfile.scaling.ImageScale.HEAD",
            "plone.namedfile.scaling.ImageScale.__call__"
        ]
    },
    "plone/namedfile/tests/test_display_file.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from plone.app.testing import SITE_OWNER_PASSWORD"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from plone.namedfile import field"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from plone.namedfile import file"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from plone.namedfile.interfaces import IAvailableSizes"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from plone.namedfile.interfaces import IImageScaleTraversable"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from plone.namedfile.tests import getFile"
            },
            "7": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from plone.testing.zope import Browser"
            },
            "8": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from Products.CMFPlone.utils import safe_unicode"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+from zope.annotation import IAnnotations"
            },
            "10": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from zope.annotation import IAttributeAnnotatable"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from zope.component import getSiteManager"
            },
            "12": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from zope.interface import implementer"
            },
            "13": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import os"
            },
            "15": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     return browser.headers.get(name, None)"
            },
            "16": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+def custom_available_sizes():"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    # Define available image scales."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    return {\"custom\": (10, 10)}"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " class TestAttackVectorNamedImage(unittest.TestCase):"
            },
            "24": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING"
            },
            "25": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     field_class = file.NamedImage"
            },
            "26": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         item = DummyContent()"
            },
            "27": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         self.layer[\"app\"]._setOb(\"item\", item)"
            },
            "28": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         self.item = self.layer[\"app\"].item"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        sm = getSiteManager()"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        sm.registerUtility(component=custom_available_sizes, provided=IAvailableSizes)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    def tearDown(self):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        sm = getSiteManager()"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        sm.unregisterUtility(provided=IAvailableSizes)"
            },
            "35": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     def get_admin_browser(self):"
            },
            "37": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         browser = Browser(self.layer[\"app\"])"
            },
            "38": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         self.assertIn(\"attachment\", header)"
            },
            "39": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         self.assertIn(\"filename\", header)"
            },
            "40": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    def assert_scale_view_works(self, base_url):"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        # Test that accessing a scale view shows the image inline."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        browser = self.get_anon_browser()"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        browser.open(base_url + \"/@@images/{}\".format(self.field_name))"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        self.assertIsNone(get_disposition_header(browser))"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        # Note: the 'custom' scale is defined in an adapter above."
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        self.assertIsNone(get_disposition_header(browser))"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        self.assertIsNone(get_disposition_header(browser))"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    def assert_scale_view_is_download(self, base_url):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        # Test that accessing a scale view turns into a download."
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        browser = self.get_anon_browser()"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        browser.open(base_url + \"/@@images/{}\".format(self.field_name))"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        header = get_disposition_header(browser)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        self.assertIsNotNone(header)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        self.assertIn(\"attachment\", header)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        self.assertIn(\"filename\", header)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        header = get_disposition_header(browser)"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        self.assertIsNotNone(header)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        self.assertIn(\"attachment\", header)"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        self.assertIn(\"filename\", header)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        header = get_disposition_header(browser)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        self.assertIsNotNone(header)"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        self.assertIn(\"attachment\", header)"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        self.assertIn(\"filename\", header)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "     def test_png_image(self):"
            },
            "78": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         setattr(self.item, self.field_name, self._named_file(\"image.png\"))"
            },
            "79": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         transaction.commit()"
            },
            "80": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         base_url = self.item.absolute_url()"
            },
            "81": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         self.assert_download_works(base_url)"
            },
            "82": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         self.assert_display_inline_works(base_url)"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        if self.field_name == \"image\":"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            self.assert_scale_view_works(base_url)"
            },
            "85": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "     def test_svg_image(self):"
            },
            "87": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         setattr(self.item, self.field_name, self._named_file(\"image.svg\"))"
            },
            "88": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         transaction.commit()"
            },
            "89": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         base_url = self.item.absolute_url()"
            },
            "90": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         self.assert_download_works(base_url)"
            },
            "91": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         self.assert_display_inline_is_download(base_url)"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        if self.field_name == \"image\":"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            self.assert_scale_view_is_download(base_url)"
            },
            "94": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     def test_filename_none(self):"
            },
            "96": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # A 'None' filename None probably does not happen during normal upload,"
            },
            "97": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # but if an attacker manages this, even @@download will show inline."
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        # A 'None' filename probably does not happen during normal upload,"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        # but if an attacker manages this, even @@download would show inline."
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        # We prevent this."
            },
            "101": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         data = self._named_file(\"image.svg\")"
            },
            "102": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         data.filename = None"
            },
            "103": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         setattr(self.item, self.field_name, data)"
            },
            "104": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         transaction.commit()"
            },
            "105": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         base_url = self.item.absolute_url()"
            },
            "106": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         self.assert_download_works(base_url)"
            },
            "107": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         self.assert_display_inline_is_download(base_url)"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+        if self.field_name == \"image\":"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+            self.assert_scale_view_is_download(base_url)"
            },
            "110": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " "
            },
            "111": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     def test_filename_empty(self):"
            },
            "112": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         # An empty filename is probably no problem, but let's check."
            },
            "113": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "         base_url = self.item.absolute_url()"
            },
            "114": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "         self.assert_download_works(base_url)"
            },
            "115": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         self.assert_display_inline_is_download(base_url)"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        if self.field_name == \"image\":"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            self.assert_scale_view_is_download(base_url)"
            },
            "118": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 196,
                "PatchRowcode": " "
            },
            "119": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 197,
                "PatchRowcode": " "
            },
            "120": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 198,
                "PatchRowcode": " class TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from OFS.SimpleItem import SimpleItem",
            "from plone.app.testing import SITE_OWNER_NAME",
            "from plone.app.testing import SITE_OWNER_PASSWORD",
            "from plone.namedfile import field",
            "from plone.namedfile import file",
            "from plone.namedfile.interfaces import IImageScaleTraversable",
            "from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING",
            "from plone.namedfile.tests import getFile",
            "from plone.testing.zope import Browser",
            "from Products.CMFPlone.utils import safe_unicode",
            "from zope.annotation import IAttributeAnnotatable",
            "from zope.interface import implementer",
            "",
            "import os",
            "import transaction",
            "import unittest",
            "",
            "",
            "class ISchema(IImageScaleTraversable):",
            "    image = field.NamedImage()",
            "    blob_image = field.NamedBlobImage()",
            "    file = field.NamedFile()",
            "    blob_file = field.NamedBlobFile()",
            "",
            "",
            "@implementer(IAttributeAnnotatable, ISchema)",
            "class DummyContent(SimpleItem):",
            "    # Adapted from test_scaling_functional.py",
            "    image = None",
            "    blob_image = None",
            "    file = None",
            "    blob_file = None",
            "    # modified = DateTime",
            "    id = __name__ = \"item\"",
            "    title = \"foo\"",
            "",
            "    def Title(self):",
            "        return self.title",
            "",
            "",
            "def get_disposition_header(browser):",
            "    # Could be CamelCase or all lowercase.",
            "    name = \"Content-Disposition\"",
            "    if name in browser.headers.keys():",
            "        return browser.headers.get(name)",
            "    name = name.lower()",
            "    return browser.headers.get(name, None)",
            "",
            "",
            "class TestAttackVectorNamedImage(unittest.TestCase):",
            "    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING",
            "    field_class = file.NamedImage",
            "    field_name = \"image\"",
            "",
            "    def setUp(self):",
            "        self.portal = self.layer[\"app\"]",
            "        item = DummyContent()",
            "        self.layer[\"app\"]._setOb(\"item\", item)",
            "        self.item = self.layer[\"app\"].item",
            "",
            "    def get_admin_browser(self):",
            "        browser = Browser(self.layer[\"app\"])",
            "        browser.handleErrors = False",
            "        browser.addHeader(",
            "            \"Authorization\",",
            "            \"Basic {0}:{1}\".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),",
            "        )",
            "        return browser",
            "",
            "    def get_anon_browser(self):",
            "        browser = Browser(self.layer[\"app\"])",
            "        browser.handleErrors = False",
            "        return browser",
            "",
            "    def _named_file(self, name):",
            "        data = getFile(name)",
            "        return self.field_class(data, filename=safe_unicode(name))",
            "",
            "    def assert_download_works(self, base_url):",
            "        browser = self.get_anon_browser()",
            "        browser.open(base_url + \"/@@download/{0}\".format(self.field_name))",
            "        header = get_disposition_header(browser)",
            "        self.assertIsNotNone(header)",
            "        self.assertIn(\"attachment\", header)",
            "        self.assertIn(\"filename\", header)",
            "",
            "    def assert_display_inline_works(self, base_url):",
            "        # Test that displaying this file inline works.",
            "        browser = self.get_anon_browser()",
            "        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))",
            "        self.assertIsNone(get_disposition_header(browser))",
            "",
            "    def assert_display_inline_is_download(self, base_url):",
            "        # Test that displaying this file inline turns into a download.",
            "        browser = self.get_anon_browser()",
            "        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))",
            "        header = get_disposition_header(browser)",
            "        self.assertIsNotNone(header)",
            "        self.assertIn(\"attachment\", header)",
            "        self.assertIn(\"filename\", header)",
            "",
            "    def test_png_image(self):",
            "        setattr(self.item, self.field_name, self._named_file(\"image.png\"))",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_works(base_url)",
            "",
            "    def test_svg_image(self):",
            "        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_is_download(base_url)",
            "",
            "    def test_filename_none(self):",
            "        # A 'None' filename None probably does not happen during normal upload,",
            "        # but if an attacker manages this, even @@download will show inline.",
            "        data = self._named_file(\"image.svg\")",
            "        data.filename = None",
            "        setattr(self.item, self.field_name, data)",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_is_download(base_url)",
            "",
            "    def test_filename_empty(self):",
            "        # An empty filename is probably no problem, but let's check.",
            "        data = self._named_file(\"image.svg\")",
            "        data.filename = u\"\"",
            "        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_is_download(base_url)",
            "",
            "",
            "class TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):",
            "    field_class = file.NamedBlobImage",
            "",
            "",
            "class TestAttackVectorNamedFile(TestAttackVectorNamedImage):",
            "    field_class = file.NamedFile",
            "    field_name = \"file\"",
            "",
            "    def test_html_file(self):",
            "        data = self.field_class(",
            "            \"<h1>Attacker</h1>\", filename=safe_unicode(\"attacker.html\")",
            "        )",
            "        setattr(self.item, self.field_name, data)",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_is_download(base_url)",
            "",
            "    def test_pdf(self):",
            "        # By popular request we allow PDF.",
            "        setattr(self.item, self.field_name, self._named_file(\"file.pdf\"))",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_works(base_url)",
            "",
            "",
            "class TestAttackVectorNamedBlobFile(TestAttackVectorNamedFile):",
            "    field_class = file.NamedBlobFile"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from OFS.SimpleItem import SimpleItem",
            "from plone.app.testing import SITE_OWNER_NAME",
            "from plone.app.testing import SITE_OWNER_PASSWORD",
            "from plone.namedfile import field",
            "from plone.namedfile import file",
            "from plone.namedfile.interfaces import IAvailableSizes",
            "from plone.namedfile.interfaces import IImageScaleTraversable",
            "from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING",
            "from plone.namedfile.tests import getFile",
            "from plone.testing.zope import Browser",
            "from Products.CMFPlone.utils import safe_unicode",
            "from zope.annotation import IAnnotations",
            "from zope.annotation import IAttributeAnnotatable",
            "from zope.component import getSiteManager",
            "from zope.interface import implementer",
            "",
            "import os",
            "import transaction",
            "import unittest",
            "",
            "",
            "class ISchema(IImageScaleTraversable):",
            "    image = field.NamedImage()",
            "    blob_image = field.NamedBlobImage()",
            "    file = field.NamedFile()",
            "    blob_file = field.NamedBlobFile()",
            "",
            "",
            "@implementer(IAttributeAnnotatable, ISchema)",
            "class DummyContent(SimpleItem):",
            "    # Adapted from test_scaling_functional.py",
            "    image = None",
            "    blob_image = None",
            "    file = None",
            "    blob_file = None",
            "    # modified = DateTime",
            "    id = __name__ = \"item\"",
            "    title = \"foo\"",
            "",
            "    def Title(self):",
            "        return self.title",
            "",
            "",
            "def get_disposition_header(browser):",
            "    # Could be CamelCase or all lowercase.",
            "    name = \"Content-Disposition\"",
            "    if name in browser.headers.keys():",
            "        return browser.headers.get(name)",
            "    name = name.lower()",
            "    return browser.headers.get(name, None)",
            "",
            "",
            "def custom_available_sizes():",
            "    # Define available image scales.",
            "    return {\"custom\": (10, 10)}",
            "",
            "",
            "class TestAttackVectorNamedImage(unittest.TestCase):",
            "    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING",
            "    field_class = file.NamedImage",
            "    field_name = \"image\"",
            "",
            "    def setUp(self):",
            "        self.portal = self.layer[\"app\"]",
            "        item = DummyContent()",
            "        self.layer[\"app\"]._setOb(\"item\", item)",
            "        self.item = self.layer[\"app\"].item",
            "        sm = getSiteManager()",
            "        sm.registerUtility(component=custom_available_sizes, provided=IAvailableSizes)",
            "",
            "    def tearDown(self):",
            "        sm = getSiteManager()",
            "        sm.unregisterUtility(provided=IAvailableSizes)",
            "",
            "    def get_admin_browser(self):",
            "        browser = Browser(self.layer[\"app\"])",
            "        browser.handleErrors = False",
            "        browser.addHeader(",
            "            \"Authorization\",",
            "            \"Basic {0}:{1}\".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),",
            "        )",
            "        return browser",
            "",
            "    def get_anon_browser(self):",
            "        browser = Browser(self.layer[\"app\"])",
            "        browser.handleErrors = False",
            "        return browser",
            "",
            "    def _named_file(self, name):",
            "        data = getFile(name)",
            "        return self.field_class(data, filename=safe_unicode(name))",
            "",
            "    def assert_download_works(self, base_url):",
            "        browser = self.get_anon_browser()",
            "        browser.open(base_url + \"/@@download/{0}\".format(self.field_name))",
            "        header = get_disposition_header(browser)",
            "        self.assertIsNotNone(header)",
            "        self.assertIn(\"attachment\", header)",
            "        self.assertIn(\"filename\", header)",
            "",
            "    def assert_display_inline_works(self, base_url):",
            "        # Test that displaying this file inline works.",
            "        browser = self.get_anon_browser()",
            "        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))",
            "        self.assertIsNone(get_disposition_header(browser))",
            "",
            "    def assert_display_inline_is_download(self, base_url):",
            "        # Test that displaying this file inline turns into a download.",
            "        browser = self.get_anon_browser()",
            "        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))",
            "        header = get_disposition_header(browser)",
            "        self.assertIsNotNone(header)",
            "        self.assertIn(\"attachment\", header)",
            "        self.assertIn(\"filename\", header)",
            "",
            "    def assert_scale_view_works(self, base_url):",
            "        # Test that accessing a scale view shows the image inline.",
            "        browser = self.get_anon_browser()",
            "        browser.open(base_url + \"/@@images/{}\".format(self.field_name))",
            "        self.assertIsNone(get_disposition_header(browser))",
            "",
            "        # Note: the 'custom' scale is defined in an adapter above.",
            "        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))",
            "        self.assertIsNone(get_disposition_header(browser))",
            "",
            "        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]",
            "        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))",
            "        self.assertIsNone(get_disposition_header(browser))",
            "",
            "    def assert_scale_view_is_download(self, base_url):",
            "        # Test that accessing a scale view turns into a download.",
            "        browser = self.get_anon_browser()",
            "        browser.open(base_url + \"/@@images/{}\".format(self.field_name))",
            "        header = get_disposition_header(browser)",
            "        self.assertIsNotNone(header)",
            "        self.assertIn(\"attachment\", header)",
            "        self.assertIn(\"filename\", header)",
            "",
            "        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))",
            "        header = get_disposition_header(browser)",
            "        self.assertIsNotNone(header)",
            "        self.assertIn(\"attachment\", header)",
            "        self.assertIn(\"filename\", header)",
            "",
            "        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]",
            "        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))",
            "        header = get_disposition_header(browser)",
            "        self.assertIsNotNone(header)",
            "        self.assertIn(\"attachment\", header)",
            "        self.assertIn(\"filename\", header)",
            "",
            "    def test_png_image(self):",
            "        setattr(self.item, self.field_name, self._named_file(\"image.png\"))",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_works(base_url)",
            "        if self.field_name == \"image\":",
            "            self.assert_scale_view_works(base_url)",
            "",
            "    def test_svg_image(self):",
            "        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_is_download(base_url)",
            "        if self.field_name == \"image\":",
            "            self.assert_scale_view_is_download(base_url)",
            "",
            "    def test_filename_none(self):",
            "        # A 'None' filename probably does not happen during normal upload,",
            "        # but if an attacker manages this, even @@download would show inline.",
            "        # We prevent this.",
            "        data = self._named_file(\"image.svg\")",
            "        data.filename = None",
            "        setattr(self.item, self.field_name, data)",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_is_download(base_url)",
            "        if self.field_name == \"image\":",
            "            self.assert_scale_view_is_download(base_url)",
            "",
            "    def test_filename_empty(self):",
            "        # An empty filename is probably no problem, but let's check.",
            "        data = self._named_file(\"image.svg\")",
            "        data.filename = u\"\"",
            "        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_is_download(base_url)",
            "        if self.field_name == \"image\":",
            "            self.assert_scale_view_is_download(base_url)",
            "",
            "",
            "class TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):",
            "    field_class = file.NamedBlobImage",
            "",
            "",
            "class TestAttackVectorNamedFile(TestAttackVectorNamedImage):",
            "    field_class = file.NamedFile",
            "    field_name = \"file\"",
            "",
            "    def test_html_file(self):",
            "        data = self.field_class(",
            "            \"<h1>Attacker</h1>\", filename=safe_unicode(\"attacker.html\")",
            "        )",
            "        setattr(self.item, self.field_name, data)",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_is_download(base_url)",
            "",
            "    def test_pdf(self):",
            "        # By popular request we allow PDF.",
            "        setattr(self.item, self.field_name, self._named_file(\"file.pdf\"))",
            "        transaction.commit()",
            "        base_url = self.item.absolute_url()",
            "        self.assert_download_works(base_url)",
            "        self.assert_display_inline_works(base_url)",
            "",
            "",
            "class TestAttackVectorNamedBlobFile(TestAttackVectorNamedFile):",
            "    field_class = file.NamedBlobFile"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "118": [
                "TestAttackVectorNamedImage",
                "test_filename_none"
            ],
            "119": [
                "TestAttackVectorNamedImage",
                "test_filename_none"
            ]
        },
        "addLocation": []
    }
}