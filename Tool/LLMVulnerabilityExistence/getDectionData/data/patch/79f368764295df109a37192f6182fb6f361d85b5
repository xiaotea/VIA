{
    "django/utils/html.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from urllib.parse import parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.utils.encoding import punycode"
            },
            "3": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.functional import Promise, keep_lazy, keep_lazy_text"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from django.utils.functional import Promise, cached_property, keep_lazy, keep_lazy_text"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS"
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from django.utils.regex_helper import _lazy_re_compile"
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from django.utils.safestring import SafeData, SafeString, mark_safe"
            },
            "8": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "     return urlunsplit((scheme, netloc, path, query, fragment))"
            },
            "9": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 226,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+class CountsDict(dict):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+    def __init__(self, *args, word, **kwargs):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        super().__init__(*args, *kwargs)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        self.word = word"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+    def __missing__(self, key):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        self[key] = self.word.count(key)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        return self[key]"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " class Urlizer:"
            },
            "22": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "     \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "     Convert any URLs in text into clickable links."
            },
            "24": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "             return x"
            },
            "25": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "         return \"%s\u2026\" % x[: max(0, limit - 1)]"
            },
            "26": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 342,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+    @cached_property"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+    def wrapping_punctuation_openings(self):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+        return \"\".join(dict(self.wrapping_punctuation).keys())"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+    @cached_property"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+    def trailing_punctuation_chars_no_semicolon(self):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+        return self.trailing_punctuation_chars.replace(\";\", \"\")"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+    @cached_property"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+    def trailing_punctuation_chars_has_semicolon(self):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+        return \";\" in self.trailing_punctuation_chars"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "     def trim_punctuation(self, word):"
            },
            "40": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         \"\"\""
            },
            "41": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "         Trim trailing and wrapping punctuation from `word`. Return the items of"
            },
            "42": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "         the new state."
            },
            "43": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "         \"\"\""
            },
            "44": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        lead, middle, trail = \"\", word, \"\""
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+        # Strip all opening wrapping punctuation."
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+        middle = word.lstrip(self.wrapping_punctuation_openings)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        lead = word[: len(word) - len(middle)]"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+        trail = \"\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "         # Continue trimming until middle remains unchanged."
            },
            "51": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "         trimmed_something = True"
            },
            "52": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        while trimmed_something:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+        counts = CountsDict(word=middle)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+        while trimmed_something and middle:"
            },
            "55": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "             trimmed_something = False"
            },
            "56": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "             # Trim wrapping punctuation."
            },
            "57": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "             for opening, closing in self.wrapping_punctuation:"
            },
            "58": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if middle.startswith(opening):"
            },
            "59": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    middle = middle[len(opening) :]"
            },
            "60": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    lead += opening"
            },
            "61": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    trimmed_something = True"
            },
            "62": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # Keep parentheses at the end only if they're balanced."
            },
            "63": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if ("
            },
            "64": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    middle.endswith(closing)"
            },
            "65": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    and middle.count(closing) == middle.count(opening) + 1"
            },
            "66": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                ):"
            },
            "67": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    middle = middle[: -len(closing)]"
            },
            "68": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    trail = closing + trail"
            },
            "69": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    trimmed_something = True"
            },
            "70": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Trim trailing punctuation (after trimming wrapping punctuation,"
            },
            "71": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # as encoded entities contain ';'). Unescape entities to avoid"
            },
            "72": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # breaking them by removing ';'."
            },
            "73": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            middle_unescaped = html.unescape(middle)"
            },
            "74": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            stripped = middle_unescaped.rstrip(self.trailing_punctuation_chars)"
            },
            "75": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if middle_unescaped != stripped:"
            },
            "76": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                punctuation_count = len(middle_unescaped) - len(stripped)"
            },
            "77": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                trail = middle[-punctuation_count:] + trail"
            },
            "78": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                middle = middle[:-punctuation_count]"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+                if counts[opening] < counts[closing]:"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+                    rstripped = middle.rstrip(closing)"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+                    if rstripped != middle:"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+                        strip = counts[closing] - counts[opening]"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+                        trail = middle[-strip:]"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+                        middle = middle[:-strip]"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+                        trimmed_something = True"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+                        counts[closing] -= strip"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+            rstripped = middle.rstrip(self.trailing_punctuation_chars_no_semicolon)"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+            if rstripped != middle:"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+                trail = middle[len(rstripped) :] + trail"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+                middle = rstripped"
            },
            "92": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "                 trimmed_something = True"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+            if self.trailing_punctuation_chars_has_semicolon and middle.endswith(\";\"):"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+                # Only strip if not part of an HTML entity."
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+                amp = middle.rfind(\"&\")"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+                if amp == -1:"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+                    can_strip = True"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+                else:"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+                    potential_entity = middle[amp:]"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+                    escaped = html.unescape(potential_entity)"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+                    can_strip = (escaped == potential_entity) or escaped.endswith(\";\")"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+                if can_strip:"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+                    rstripped = middle.rstrip(\";\")"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+                    amount_stripped = len(middle) - len(rstripped)"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+                    if amp > -1 and amount_stripped > 1:"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+                        # Leave a trailing semicolon as might be an entity."
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+                        trail = middle[len(rstripped) + 1 :] + trail"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+                        middle = rstripped + \";\""
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+                    else:"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+                        trail = middle[len(rstripped) :] + trail"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+                        middle = rstripped"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+                    trimmed_something = True"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+"
            },
            "116": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "         return lead, middle, trail"
            },
            "117": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 410,
                "PatchRowcode": " "
            },
            "118": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 411,
                "PatchRowcode": "     @staticmethod"
            }
        },
        "frontPatchFile": [
            "\"\"\"HTML utilities suitable for global use.\"\"\"",
            "",
            "import html",
            "import json",
            "import re",
            "from html.parser import HTMLParser",
            "from urllib.parse import parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit",
            "",
            "from django.utils.encoding import punycode",
            "from django.utils.functional import Promise, keep_lazy, keep_lazy_text",
            "from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS",
            "from django.utils.regex_helper import _lazy_re_compile",
            "from django.utils.safestring import SafeData, SafeString, mark_safe",
            "from django.utils.text import normalize_newlines",
            "",
            "",
            "@keep_lazy(SafeString)",
            "def escape(text):",
            "    \"\"\"",
            "    Return the given text with ampersands, quotes and angle brackets encoded",
            "    for use in HTML.",
            "",
            "    Always escape input, even if it's already escaped and marked as such.",
            "    This may result in double-escaping. If this is a concern, use",
            "    conditional_escape() instead.",
            "    \"\"\"",
            "    return SafeString(html.escape(str(text)))",
            "",
            "",
            "_js_escapes = {",
            "    ord(\"\\\\\"): \"\\\\u005C\",",
            "    ord(\"'\"): \"\\\\u0027\",",
            "    ord('\"'): \"\\\\u0022\",",
            "    ord(\">\"): \"\\\\u003E\",",
            "    ord(\"<\"): \"\\\\u003C\",",
            "    ord(\"&\"): \"\\\\u0026\",",
            "    ord(\"=\"): \"\\\\u003D\",",
            "    ord(\"-\"): \"\\\\u002D\",",
            "    ord(\";\"): \"\\\\u003B\",",
            "    ord(\"`\"): \"\\\\u0060\",",
            "    ord(\"\\u2028\"): \"\\\\u2028\",",
            "    ord(\"\\u2029\"): \"\\\\u2029\",",
            "}",
            "",
            "# Escape every ASCII character with a value less than 32.",
            "_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))",
            "",
            "",
            "@keep_lazy(SafeString)",
            "def escapejs(value):",
            "    \"\"\"Hex encode characters for use in JavaScript strings.\"\"\"",
            "    return mark_safe(str(value).translate(_js_escapes))",
            "",
            "",
            "_json_script_escapes = {",
            "    ord(\">\"): \"\\\\u003E\",",
            "    ord(\"<\"): \"\\\\u003C\",",
            "    ord(\"&\"): \"\\\\u0026\",",
            "}",
            "",
            "",
            "def json_script(value, element_id=None, encoder=None):",
            "    \"\"\"",
            "    Escape all the HTML/XML special characters with their unicode escapes, so",
            "    value is safe to be output anywhere except for inside a tag attribute. Wrap",
            "    the escaped JSON in a script tag.",
            "    \"\"\"",
            "    from django.core.serializers.json import DjangoJSONEncoder",
            "",
            "    json_str = json.dumps(value, cls=encoder or DjangoJSONEncoder).translate(",
            "        _json_script_escapes",
            "    )",
            "    if element_id:",
            "        template = '<script id=\"{}\" type=\"application/json\">{}</script>'",
            "        args = (element_id, mark_safe(json_str))",
            "    else:",
            "        template = '<script type=\"application/json\">{}</script>'",
            "        args = (mark_safe(json_str),)",
            "    return format_html(template, *args)",
            "",
            "",
            "def conditional_escape(text):",
            "    \"\"\"",
            "    Similar to escape(), except that it doesn't operate on pre-escaped strings.",
            "",
            "    This function relies on the __html__ convention used both by Django's",
            "    SafeData class and by third-party libraries like markupsafe.",
            "    \"\"\"",
            "    if isinstance(text, Promise):",
            "        text = str(text)",
            "    if hasattr(text, \"__html__\"):",
            "        return text.__html__()",
            "    else:",
            "        return escape(text)",
            "",
            "",
            "def format_html(format_string, *args, **kwargs):",
            "    \"\"\"",
            "    Similar to str.format, but pass all arguments through conditional_escape(),",
            "    and call mark_safe() on the result. This function should be used instead",
            "    of str.format or % interpolation to build up small HTML fragments.",
            "    \"\"\"",
            "    args_safe = map(conditional_escape, args)",
            "    kwargs_safe = {k: conditional_escape(v) for (k, v) in kwargs.items()}",
            "    return mark_safe(format_string.format(*args_safe, **kwargs_safe))",
            "",
            "",
            "def format_html_join(sep, format_string, args_generator):",
            "    \"\"\"",
            "    A wrapper of format_html, for the common case of a group of arguments that",
            "    need to be formatted using the same format string, and then joined using",
            "    'sep'. 'sep' is also passed through conditional_escape.",
            "",
            "    'args_generator' should be an iterator that returns the sequence of 'args'",
            "    that will be passed to format_html.",
            "",
            "    Example:",
            "",
            "      format_html_join('\\n', \"<li>{} {}</li>\", ((u.first_name, u.last_name)",
            "                                                  for u in users))",
            "    \"\"\"",
            "    return mark_safe(",
            "        conditional_escape(sep).join(",
            "            format_html(format_string, *args) for args in args_generator",
            "        )",
            "    )",
            "",
            "",
            "@keep_lazy_text",
            "def linebreaks(value, autoescape=False):",
            "    \"\"\"Convert newlines into <p> and <br>s.\"\"\"",
            "    value = normalize_newlines(value)",
            "    paras = re.split(\"\\n{2,}\", str(value))",
            "    if autoescape:",
            "        paras = [\"<p>%s</p>\" % escape(p).replace(\"\\n\", \"<br>\") for p in paras]",
            "    else:",
            "        paras = [\"<p>%s</p>\" % p.replace(\"\\n\", \"<br>\") for p in paras]",
            "    return \"\\n\\n\".join(paras)",
            "",
            "",
            "class MLStripper(HTMLParser):",
            "    def __init__(self):",
            "        super().__init__(convert_charrefs=False)",
            "        self.reset()",
            "        self.fed = []",
            "",
            "    def handle_data(self, d):",
            "        self.fed.append(d)",
            "",
            "    def handle_entityref(self, name):",
            "        self.fed.append(\"&%s;\" % name)",
            "",
            "    def handle_charref(self, name):",
            "        self.fed.append(\"&#%s;\" % name)",
            "",
            "    def get_data(self):",
            "        return \"\".join(self.fed)",
            "",
            "",
            "def _strip_once(value):",
            "    \"\"\"",
            "    Internal tag stripping utility used by strip_tags.",
            "    \"\"\"",
            "    s = MLStripper()",
            "    s.feed(value)",
            "    s.close()",
            "    return s.get_data()",
            "",
            "",
            "@keep_lazy_text",
            "def strip_tags(value):",
            "    \"\"\"Return the given HTML with all tags stripped.\"\"\"",
            "    # Note: in typical case this loop executes _strip_once once. Loop condition",
            "    # is redundant, but helps to reduce number of executions of _strip_once.",
            "    value = str(value)",
            "    while \"<\" in value and \">\" in value:",
            "        new_value = _strip_once(value)",
            "        if value.count(\"<\") == new_value.count(\"<\"):",
            "            # _strip_once wasn't able to detect more tags.",
            "            break",
            "        value = new_value",
            "    return value",
            "",
            "",
            "@keep_lazy_text",
            "def strip_spaces_between_tags(value):",
            "    \"\"\"Return the given HTML with spaces between tags removed.\"\"\"",
            "    return re.sub(r\">\\s+<\", \"><\", str(value))",
            "",
            "",
            "def smart_urlquote(url):",
            "    \"\"\"Quote a URL if it isn't already quoted.\"\"\"",
            "",
            "    def unquote_quote(segment):",
            "        segment = unquote(segment)",
            "        # Tilde is part of RFC 3986 Section 2.3 Unreserved Characters,",
            "        # see also https://bugs.python.org/issue16285",
            "        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + \"~\")",
            "",
            "    # Handle IDN before quoting.",
            "    try:",
            "        scheme, netloc, path, query, fragment = urlsplit(url)",
            "    except ValueError:",
            "        # invalid IPv6 URL (normally square brackets in hostname part).",
            "        return unquote_quote(url)",
            "",
            "    try:",
            "        netloc = punycode(netloc)  # IDN -> ACE",
            "    except UnicodeError:  # invalid domain part",
            "        return unquote_quote(url)",
            "",
            "    if query:",
            "        # Separately unquoting key/value, so as to not mix querystring separators",
            "        # included in query values. See #22267.",
            "        query_parts = [",
            "            (unquote(q[0]), unquote(q[1]))",
            "            for q in parse_qsl(query, keep_blank_values=True)",
            "        ]",
            "        # urlencode will take care of quoting",
            "        query = urlencode(query_parts)",
            "",
            "    path = unquote_quote(path)",
            "    fragment = unquote_quote(fragment)",
            "",
            "    return urlunsplit((scheme, netloc, path, query, fragment))",
            "",
            "",
            "class Urlizer:",
            "    \"\"\"",
            "    Convert any URLs in text into clickable links.",
            "",
            "    Work on http://, https://, www. links, and also on links ending in one of",
            "    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).",
            "    Links can have trailing punctuation (periods, commas, close-parens) and",
            "    leading punctuation (opening parens) and it'll still do the right thing.",
            "    \"\"\"",
            "",
            "    trailing_punctuation_chars = \".,:;!\"",
            "    wrapping_punctuation = [(\"(\", \")\"), (\"[\", \"]\")]",
            "",
            "    simple_url_re = _lazy_re_compile(r\"^https?://\\[?\\w\", re.IGNORECASE)",
            "    simple_url_2_re = _lazy_re_compile(",
            "        r\"^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$\", re.IGNORECASE",
            "    )",
            "    word_split_re = _lazy_re_compile(r\"\"\"([\\s<>\"']+)\"\"\")",
            "",
            "    mailto_template = \"mailto:{local}@{domain}\"",
            "    url_template = '<a href=\"{href}\"{attrs}>{url}</a>'",
            "",
            "    def __call__(self, text, trim_url_limit=None, nofollow=False, autoescape=False):",
            "        \"\"\"",
            "        If trim_url_limit is not None, truncate the URLs in the link text",
            "        longer than this limit to trim_url_limit - 1 characters and append an",
            "        ellipsis.",
            "",
            "        If nofollow is True, give the links a rel=\"nofollow\" attribute.",
            "",
            "        If autoescape is True, autoescape the link text and URLs.",
            "        \"\"\"",
            "        safe_input = isinstance(text, SafeData)",
            "",
            "        words = self.word_split_re.split(str(text))",
            "        return \"\".join(",
            "            [",
            "                self.handle_word(",
            "                    word,",
            "                    safe_input=safe_input,",
            "                    trim_url_limit=trim_url_limit,",
            "                    nofollow=nofollow,",
            "                    autoescape=autoescape,",
            "                )",
            "                for word in words",
            "            ]",
            "        )",
            "",
            "    def handle_word(",
            "        self,",
            "        word,",
            "        *,",
            "        safe_input,",
            "        trim_url_limit=None,",
            "        nofollow=False,",
            "        autoescape=False,",
            "    ):",
            "        if \".\" in word or \"@\" in word or \":\" in word:",
            "            # lead: Punctuation trimmed from the beginning of the word.",
            "            # middle: State of the word.",
            "            # trail: Punctuation trimmed from the end of the word.",
            "            lead, middle, trail = self.trim_punctuation(word)",
            "            # Make URL we want to point to.",
            "            url = None",
            "            nofollow_attr = ' rel=\"nofollow\"' if nofollow else \"\"",
            "            if self.simple_url_re.match(middle):",
            "                url = smart_urlquote(html.unescape(middle))",
            "            elif self.simple_url_2_re.match(middle):",
            "                url = smart_urlquote(\"http://%s\" % html.unescape(middle))",
            "            elif \":\" not in middle and self.is_email_simple(middle):",
            "                local, domain = middle.rsplit(\"@\", 1)",
            "                try:",
            "                    domain = punycode(domain)",
            "                except UnicodeError:",
            "                    return word",
            "                url = self.mailto_template.format(local=local, domain=domain)",
            "                nofollow_attr = \"\"",
            "            # Make link.",
            "            if url:",
            "                trimmed = self.trim_url(middle, limit=trim_url_limit)",
            "                if autoescape and not safe_input:",
            "                    lead, trail = escape(lead), escape(trail)",
            "                    trimmed = escape(trimmed)",
            "                middle = self.url_template.format(",
            "                    href=escape(url),",
            "                    attrs=nofollow_attr,",
            "                    url=trimmed,",
            "                )",
            "                return mark_safe(f\"{lead}{middle}{trail}\")",
            "            else:",
            "                if safe_input:",
            "                    return mark_safe(word)",
            "                elif autoescape:",
            "                    return escape(word)",
            "        elif safe_input:",
            "            return mark_safe(word)",
            "        elif autoescape:",
            "            return escape(word)",
            "        return word",
            "",
            "    def trim_url(self, x, *, limit):",
            "        if limit is None or len(x) <= limit:",
            "            return x",
            "        return \"%s\u2026\" % x[: max(0, limit - 1)]",
            "",
            "    def trim_punctuation(self, word):",
            "        \"\"\"",
            "        Trim trailing and wrapping punctuation from `word`. Return the items of",
            "        the new state.",
            "        \"\"\"",
            "        lead, middle, trail = \"\", word, \"\"",
            "        # Continue trimming until middle remains unchanged.",
            "        trimmed_something = True",
            "        while trimmed_something:",
            "            trimmed_something = False",
            "            # Trim wrapping punctuation.",
            "            for opening, closing in self.wrapping_punctuation:",
            "                if middle.startswith(opening):",
            "                    middle = middle[len(opening) :]",
            "                    lead += opening",
            "                    trimmed_something = True",
            "                # Keep parentheses at the end only if they're balanced.",
            "                if (",
            "                    middle.endswith(closing)",
            "                    and middle.count(closing) == middle.count(opening) + 1",
            "                ):",
            "                    middle = middle[: -len(closing)]",
            "                    trail = closing + trail",
            "                    trimmed_something = True",
            "            # Trim trailing punctuation (after trimming wrapping punctuation,",
            "            # as encoded entities contain ';'). Unescape entities to avoid",
            "            # breaking them by removing ';'.",
            "            middle_unescaped = html.unescape(middle)",
            "            stripped = middle_unescaped.rstrip(self.trailing_punctuation_chars)",
            "            if middle_unescaped != stripped:",
            "                punctuation_count = len(middle_unescaped) - len(stripped)",
            "                trail = middle[-punctuation_count:] + trail",
            "                middle = middle[:-punctuation_count]",
            "                trimmed_something = True",
            "        return lead, middle, trail",
            "",
            "    @staticmethod",
            "    def is_email_simple(value):",
            "        \"\"\"Return True if value looks like an email address.\"\"\"",
            "        # An @ must be in the middle of the value.",
            "        if \"@\" not in value or value.startswith(\"@\") or value.endswith(\"@\"):",
            "            return False",
            "        try:",
            "            p1, p2 = value.split(\"@\")",
            "        except ValueError:",
            "            # value contains more than one @.",
            "            return False",
            "        # Dot must be in p2 (e.g. example.com)",
            "        if \".\" not in p2 or p2.startswith(\".\"):",
            "            return False",
            "        return True",
            "",
            "",
            "urlizer = Urlizer()",
            "",
            "",
            "@keep_lazy_text",
            "def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):",
            "    return urlizer(",
            "        text, trim_url_limit=trim_url_limit, nofollow=nofollow, autoescape=autoescape",
            "    )",
            "",
            "",
            "def avoid_wrapping(value):",
            "    \"\"\"",
            "    Avoid text wrapping in the middle of a phrase by adding non-breaking",
            "    spaces where there previously were normal spaces.",
            "    \"\"\"",
            "    return value.replace(\" \", \"\\xa0\")",
            "",
            "",
            "def html_safe(klass):",
            "    \"\"\"",
            "    A decorator that defines the __html__ method. This helps non-Django",
            "    templates to detect classes whose __str__ methods return SafeString.",
            "    \"\"\"",
            "    if \"__html__\" in klass.__dict__:",
            "        raise ValueError(",
            "            \"can't apply @html_safe to %s because it defines \"",
            "            \"__html__().\" % klass.__name__",
            "        )",
            "    if \"__str__\" not in klass.__dict__:",
            "        raise ValueError(",
            "            \"can't apply @html_safe to %s because it doesn't \"",
            "            \"define __str__().\" % klass.__name__",
            "        )",
            "    klass_str = klass.__str__",
            "    klass.__str__ = lambda self: mark_safe(klass_str(self))",
            "    klass.__html__ = lambda self: str(self)",
            "    return klass"
        ],
        "afterPatchFile": [
            "\"\"\"HTML utilities suitable for global use.\"\"\"",
            "",
            "import html",
            "import json",
            "import re",
            "from html.parser import HTMLParser",
            "from urllib.parse import parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit",
            "",
            "from django.utils.encoding import punycode",
            "from django.utils.functional import Promise, cached_property, keep_lazy, keep_lazy_text",
            "from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS",
            "from django.utils.regex_helper import _lazy_re_compile",
            "from django.utils.safestring import SafeData, SafeString, mark_safe",
            "from django.utils.text import normalize_newlines",
            "",
            "",
            "@keep_lazy(SafeString)",
            "def escape(text):",
            "    \"\"\"",
            "    Return the given text with ampersands, quotes and angle brackets encoded",
            "    for use in HTML.",
            "",
            "    Always escape input, even if it's already escaped and marked as such.",
            "    This may result in double-escaping. If this is a concern, use",
            "    conditional_escape() instead.",
            "    \"\"\"",
            "    return SafeString(html.escape(str(text)))",
            "",
            "",
            "_js_escapes = {",
            "    ord(\"\\\\\"): \"\\\\u005C\",",
            "    ord(\"'\"): \"\\\\u0027\",",
            "    ord('\"'): \"\\\\u0022\",",
            "    ord(\">\"): \"\\\\u003E\",",
            "    ord(\"<\"): \"\\\\u003C\",",
            "    ord(\"&\"): \"\\\\u0026\",",
            "    ord(\"=\"): \"\\\\u003D\",",
            "    ord(\"-\"): \"\\\\u002D\",",
            "    ord(\";\"): \"\\\\u003B\",",
            "    ord(\"`\"): \"\\\\u0060\",",
            "    ord(\"\\u2028\"): \"\\\\u2028\",",
            "    ord(\"\\u2029\"): \"\\\\u2029\",",
            "}",
            "",
            "# Escape every ASCII character with a value less than 32.",
            "_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))",
            "",
            "",
            "@keep_lazy(SafeString)",
            "def escapejs(value):",
            "    \"\"\"Hex encode characters for use in JavaScript strings.\"\"\"",
            "    return mark_safe(str(value).translate(_js_escapes))",
            "",
            "",
            "_json_script_escapes = {",
            "    ord(\">\"): \"\\\\u003E\",",
            "    ord(\"<\"): \"\\\\u003C\",",
            "    ord(\"&\"): \"\\\\u0026\",",
            "}",
            "",
            "",
            "def json_script(value, element_id=None, encoder=None):",
            "    \"\"\"",
            "    Escape all the HTML/XML special characters with their unicode escapes, so",
            "    value is safe to be output anywhere except for inside a tag attribute. Wrap",
            "    the escaped JSON in a script tag.",
            "    \"\"\"",
            "    from django.core.serializers.json import DjangoJSONEncoder",
            "",
            "    json_str = json.dumps(value, cls=encoder or DjangoJSONEncoder).translate(",
            "        _json_script_escapes",
            "    )",
            "    if element_id:",
            "        template = '<script id=\"{}\" type=\"application/json\">{}</script>'",
            "        args = (element_id, mark_safe(json_str))",
            "    else:",
            "        template = '<script type=\"application/json\">{}</script>'",
            "        args = (mark_safe(json_str),)",
            "    return format_html(template, *args)",
            "",
            "",
            "def conditional_escape(text):",
            "    \"\"\"",
            "    Similar to escape(), except that it doesn't operate on pre-escaped strings.",
            "",
            "    This function relies on the __html__ convention used both by Django's",
            "    SafeData class and by third-party libraries like markupsafe.",
            "    \"\"\"",
            "    if isinstance(text, Promise):",
            "        text = str(text)",
            "    if hasattr(text, \"__html__\"):",
            "        return text.__html__()",
            "    else:",
            "        return escape(text)",
            "",
            "",
            "def format_html(format_string, *args, **kwargs):",
            "    \"\"\"",
            "    Similar to str.format, but pass all arguments through conditional_escape(),",
            "    and call mark_safe() on the result. This function should be used instead",
            "    of str.format or % interpolation to build up small HTML fragments.",
            "    \"\"\"",
            "    args_safe = map(conditional_escape, args)",
            "    kwargs_safe = {k: conditional_escape(v) for (k, v) in kwargs.items()}",
            "    return mark_safe(format_string.format(*args_safe, **kwargs_safe))",
            "",
            "",
            "def format_html_join(sep, format_string, args_generator):",
            "    \"\"\"",
            "    A wrapper of format_html, for the common case of a group of arguments that",
            "    need to be formatted using the same format string, and then joined using",
            "    'sep'. 'sep' is also passed through conditional_escape.",
            "",
            "    'args_generator' should be an iterator that returns the sequence of 'args'",
            "    that will be passed to format_html.",
            "",
            "    Example:",
            "",
            "      format_html_join('\\n', \"<li>{} {}</li>\", ((u.first_name, u.last_name)",
            "                                                  for u in users))",
            "    \"\"\"",
            "    return mark_safe(",
            "        conditional_escape(sep).join(",
            "            format_html(format_string, *args) for args in args_generator",
            "        )",
            "    )",
            "",
            "",
            "@keep_lazy_text",
            "def linebreaks(value, autoescape=False):",
            "    \"\"\"Convert newlines into <p> and <br>s.\"\"\"",
            "    value = normalize_newlines(value)",
            "    paras = re.split(\"\\n{2,}\", str(value))",
            "    if autoescape:",
            "        paras = [\"<p>%s</p>\" % escape(p).replace(\"\\n\", \"<br>\") for p in paras]",
            "    else:",
            "        paras = [\"<p>%s</p>\" % p.replace(\"\\n\", \"<br>\") for p in paras]",
            "    return \"\\n\\n\".join(paras)",
            "",
            "",
            "class MLStripper(HTMLParser):",
            "    def __init__(self):",
            "        super().__init__(convert_charrefs=False)",
            "        self.reset()",
            "        self.fed = []",
            "",
            "    def handle_data(self, d):",
            "        self.fed.append(d)",
            "",
            "    def handle_entityref(self, name):",
            "        self.fed.append(\"&%s;\" % name)",
            "",
            "    def handle_charref(self, name):",
            "        self.fed.append(\"&#%s;\" % name)",
            "",
            "    def get_data(self):",
            "        return \"\".join(self.fed)",
            "",
            "",
            "def _strip_once(value):",
            "    \"\"\"",
            "    Internal tag stripping utility used by strip_tags.",
            "    \"\"\"",
            "    s = MLStripper()",
            "    s.feed(value)",
            "    s.close()",
            "    return s.get_data()",
            "",
            "",
            "@keep_lazy_text",
            "def strip_tags(value):",
            "    \"\"\"Return the given HTML with all tags stripped.\"\"\"",
            "    # Note: in typical case this loop executes _strip_once once. Loop condition",
            "    # is redundant, but helps to reduce number of executions of _strip_once.",
            "    value = str(value)",
            "    while \"<\" in value and \">\" in value:",
            "        new_value = _strip_once(value)",
            "        if value.count(\"<\") == new_value.count(\"<\"):",
            "            # _strip_once wasn't able to detect more tags.",
            "            break",
            "        value = new_value",
            "    return value",
            "",
            "",
            "@keep_lazy_text",
            "def strip_spaces_between_tags(value):",
            "    \"\"\"Return the given HTML with spaces between tags removed.\"\"\"",
            "    return re.sub(r\">\\s+<\", \"><\", str(value))",
            "",
            "",
            "def smart_urlquote(url):",
            "    \"\"\"Quote a URL if it isn't already quoted.\"\"\"",
            "",
            "    def unquote_quote(segment):",
            "        segment = unquote(segment)",
            "        # Tilde is part of RFC 3986 Section 2.3 Unreserved Characters,",
            "        # see also https://bugs.python.org/issue16285",
            "        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + \"~\")",
            "",
            "    # Handle IDN before quoting.",
            "    try:",
            "        scheme, netloc, path, query, fragment = urlsplit(url)",
            "    except ValueError:",
            "        # invalid IPv6 URL (normally square brackets in hostname part).",
            "        return unquote_quote(url)",
            "",
            "    try:",
            "        netloc = punycode(netloc)  # IDN -> ACE",
            "    except UnicodeError:  # invalid domain part",
            "        return unquote_quote(url)",
            "",
            "    if query:",
            "        # Separately unquoting key/value, so as to not mix querystring separators",
            "        # included in query values. See #22267.",
            "        query_parts = [",
            "            (unquote(q[0]), unquote(q[1]))",
            "            for q in parse_qsl(query, keep_blank_values=True)",
            "        ]",
            "        # urlencode will take care of quoting",
            "        query = urlencode(query_parts)",
            "",
            "    path = unquote_quote(path)",
            "    fragment = unquote_quote(fragment)",
            "",
            "    return urlunsplit((scheme, netloc, path, query, fragment))",
            "",
            "",
            "class CountsDict(dict):",
            "    def __init__(self, *args, word, **kwargs):",
            "        super().__init__(*args, *kwargs)",
            "        self.word = word",
            "",
            "    def __missing__(self, key):",
            "        self[key] = self.word.count(key)",
            "        return self[key]",
            "",
            "",
            "class Urlizer:",
            "    \"\"\"",
            "    Convert any URLs in text into clickable links.",
            "",
            "    Work on http://, https://, www. links, and also on links ending in one of",
            "    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).",
            "    Links can have trailing punctuation (periods, commas, close-parens) and",
            "    leading punctuation (opening parens) and it'll still do the right thing.",
            "    \"\"\"",
            "",
            "    trailing_punctuation_chars = \".,:;!\"",
            "    wrapping_punctuation = [(\"(\", \")\"), (\"[\", \"]\")]",
            "",
            "    simple_url_re = _lazy_re_compile(r\"^https?://\\[?\\w\", re.IGNORECASE)",
            "    simple_url_2_re = _lazy_re_compile(",
            "        r\"^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$\", re.IGNORECASE",
            "    )",
            "    word_split_re = _lazy_re_compile(r\"\"\"([\\s<>\"']+)\"\"\")",
            "",
            "    mailto_template = \"mailto:{local}@{domain}\"",
            "    url_template = '<a href=\"{href}\"{attrs}>{url}</a>'",
            "",
            "    def __call__(self, text, trim_url_limit=None, nofollow=False, autoescape=False):",
            "        \"\"\"",
            "        If trim_url_limit is not None, truncate the URLs in the link text",
            "        longer than this limit to trim_url_limit - 1 characters and append an",
            "        ellipsis.",
            "",
            "        If nofollow is True, give the links a rel=\"nofollow\" attribute.",
            "",
            "        If autoescape is True, autoescape the link text and URLs.",
            "        \"\"\"",
            "        safe_input = isinstance(text, SafeData)",
            "",
            "        words = self.word_split_re.split(str(text))",
            "        return \"\".join(",
            "            [",
            "                self.handle_word(",
            "                    word,",
            "                    safe_input=safe_input,",
            "                    trim_url_limit=trim_url_limit,",
            "                    nofollow=nofollow,",
            "                    autoescape=autoescape,",
            "                )",
            "                for word in words",
            "            ]",
            "        )",
            "",
            "    def handle_word(",
            "        self,",
            "        word,",
            "        *,",
            "        safe_input,",
            "        trim_url_limit=None,",
            "        nofollow=False,",
            "        autoescape=False,",
            "    ):",
            "        if \".\" in word or \"@\" in word or \":\" in word:",
            "            # lead: Punctuation trimmed from the beginning of the word.",
            "            # middle: State of the word.",
            "            # trail: Punctuation trimmed from the end of the word.",
            "            lead, middle, trail = self.trim_punctuation(word)",
            "            # Make URL we want to point to.",
            "            url = None",
            "            nofollow_attr = ' rel=\"nofollow\"' if nofollow else \"\"",
            "            if self.simple_url_re.match(middle):",
            "                url = smart_urlquote(html.unescape(middle))",
            "            elif self.simple_url_2_re.match(middle):",
            "                url = smart_urlquote(\"http://%s\" % html.unescape(middle))",
            "            elif \":\" not in middle and self.is_email_simple(middle):",
            "                local, domain = middle.rsplit(\"@\", 1)",
            "                try:",
            "                    domain = punycode(domain)",
            "                except UnicodeError:",
            "                    return word",
            "                url = self.mailto_template.format(local=local, domain=domain)",
            "                nofollow_attr = \"\"",
            "            # Make link.",
            "            if url:",
            "                trimmed = self.trim_url(middle, limit=trim_url_limit)",
            "                if autoescape and not safe_input:",
            "                    lead, trail = escape(lead), escape(trail)",
            "                    trimmed = escape(trimmed)",
            "                middle = self.url_template.format(",
            "                    href=escape(url),",
            "                    attrs=nofollow_attr,",
            "                    url=trimmed,",
            "                )",
            "                return mark_safe(f\"{lead}{middle}{trail}\")",
            "            else:",
            "                if safe_input:",
            "                    return mark_safe(word)",
            "                elif autoescape:",
            "                    return escape(word)",
            "        elif safe_input:",
            "            return mark_safe(word)",
            "        elif autoescape:",
            "            return escape(word)",
            "        return word",
            "",
            "    def trim_url(self, x, *, limit):",
            "        if limit is None or len(x) <= limit:",
            "            return x",
            "        return \"%s\u2026\" % x[: max(0, limit - 1)]",
            "",
            "    @cached_property",
            "    def wrapping_punctuation_openings(self):",
            "        return \"\".join(dict(self.wrapping_punctuation).keys())",
            "",
            "    @cached_property",
            "    def trailing_punctuation_chars_no_semicolon(self):",
            "        return self.trailing_punctuation_chars.replace(\";\", \"\")",
            "",
            "    @cached_property",
            "    def trailing_punctuation_chars_has_semicolon(self):",
            "        return \";\" in self.trailing_punctuation_chars",
            "",
            "    def trim_punctuation(self, word):",
            "        \"\"\"",
            "        Trim trailing and wrapping punctuation from `word`. Return the items of",
            "        the new state.",
            "        \"\"\"",
            "        # Strip all opening wrapping punctuation.",
            "        middle = word.lstrip(self.wrapping_punctuation_openings)",
            "        lead = word[: len(word) - len(middle)]",
            "        trail = \"\"",
            "",
            "        # Continue trimming until middle remains unchanged.",
            "        trimmed_something = True",
            "        counts = CountsDict(word=middle)",
            "        while trimmed_something and middle:",
            "            trimmed_something = False",
            "            # Trim wrapping punctuation.",
            "            for opening, closing in self.wrapping_punctuation:",
            "                if counts[opening] < counts[closing]:",
            "                    rstripped = middle.rstrip(closing)",
            "                    if rstripped != middle:",
            "                        strip = counts[closing] - counts[opening]",
            "                        trail = middle[-strip:]",
            "                        middle = middle[:-strip]",
            "                        trimmed_something = True",
            "                        counts[closing] -= strip",
            "",
            "            rstripped = middle.rstrip(self.trailing_punctuation_chars_no_semicolon)",
            "            if rstripped != middle:",
            "                trail = middle[len(rstripped) :] + trail",
            "                middle = rstripped",
            "                trimmed_something = True",
            "",
            "            if self.trailing_punctuation_chars_has_semicolon and middle.endswith(\";\"):",
            "                # Only strip if not part of an HTML entity.",
            "                amp = middle.rfind(\"&\")",
            "                if amp == -1:",
            "                    can_strip = True",
            "                else:",
            "                    potential_entity = middle[amp:]",
            "                    escaped = html.unescape(potential_entity)",
            "                    can_strip = (escaped == potential_entity) or escaped.endswith(\";\")",
            "",
            "                if can_strip:",
            "                    rstripped = middle.rstrip(\";\")",
            "                    amount_stripped = len(middle) - len(rstripped)",
            "                    if amp > -1 and amount_stripped > 1:",
            "                        # Leave a trailing semicolon as might be an entity.",
            "                        trail = middle[len(rstripped) + 1 :] + trail",
            "                        middle = rstripped + \";\"",
            "                    else:",
            "                        trail = middle[len(rstripped) :] + trail",
            "                        middle = rstripped",
            "                    trimmed_something = True",
            "",
            "        return lead, middle, trail",
            "",
            "    @staticmethod",
            "    def is_email_simple(value):",
            "        \"\"\"Return True if value looks like an email address.\"\"\"",
            "        # An @ must be in the middle of the value.",
            "        if \"@\" not in value or value.startswith(\"@\") or value.endswith(\"@\"):",
            "            return False",
            "        try:",
            "            p1, p2 = value.split(\"@\")",
            "        except ValueError:",
            "            # value contains more than one @.",
            "            return False",
            "        # Dot must be in p2 (e.g. example.com)",
            "        if \".\" not in p2 or p2.startswith(\".\"):",
            "            return False",
            "        return True",
            "",
            "",
            "urlizer = Urlizer()",
            "",
            "",
            "@keep_lazy_text",
            "def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):",
            "    return urlizer(",
            "        text, trim_url_limit=trim_url_limit, nofollow=nofollow, autoescape=autoescape",
            "    )",
            "",
            "",
            "def avoid_wrapping(value):",
            "    \"\"\"",
            "    Avoid text wrapping in the middle of a phrase by adding non-breaking",
            "    spaces where there previously were normal spaces.",
            "    \"\"\"",
            "    return value.replace(\" \", \"\\xa0\")",
            "",
            "",
            "def html_safe(klass):",
            "    \"\"\"",
            "    A decorator that defines the __html__ method. This helps non-Django",
            "    templates to detect classes whose __str__ methods return SafeString.",
            "    \"\"\"",
            "    if \"__html__\" in klass.__dict__:",
            "        raise ValueError(",
            "            \"can't apply @html_safe to %s because it defines \"",
            "            \"__html__().\" % klass.__name__",
            "        )",
            "    if \"__str__\" not in klass.__dict__:",
            "        raise ValueError(",
            "            \"can't apply @html_safe to %s because it doesn't \"",
            "            \"define __str__().\" % klass.__name__",
            "        )",
            "    klass_str = klass.__str__",
            "    klass.__str__ = lambda self: mark_safe(klass_str(self))",
            "    klass.__html__ = lambda self: str(self)",
            "    return klass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "10": [],
            "338": [
                "Urlizer",
                "trim_punctuation"
            ],
            "341": [
                "Urlizer",
                "trim_punctuation"
            ],
            "345": [
                "Urlizer",
                "trim_punctuation"
            ],
            "346": [
                "Urlizer",
                "trim_punctuation"
            ],
            "347": [
                "Urlizer",
                "trim_punctuation"
            ],
            "348": [
                "Urlizer",
                "trim_punctuation"
            ],
            "349": [
                "Urlizer",
                "trim_punctuation"
            ],
            "350": [
                "Urlizer",
                "trim_punctuation"
            ],
            "351": [
                "Urlizer",
                "trim_punctuation"
            ],
            "352": [
                "Urlizer",
                "trim_punctuation"
            ],
            "353": [
                "Urlizer",
                "trim_punctuation"
            ],
            "354": [
                "Urlizer",
                "trim_punctuation"
            ],
            "355": [
                "Urlizer",
                "trim_punctuation"
            ],
            "356": [
                "Urlizer",
                "trim_punctuation"
            ],
            "357": [
                "Urlizer",
                "trim_punctuation"
            ],
            "358": [
                "Urlizer",
                "trim_punctuation"
            ],
            "359": [
                "Urlizer",
                "trim_punctuation"
            ],
            "360": [
                "Urlizer",
                "trim_punctuation"
            ],
            "361": [
                "Urlizer",
                "trim_punctuation"
            ],
            "362": [
                "Urlizer",
                "trim_punctuation"
            ],
            "363": [
                "Urlizer",
                "trim_punctuation"
            ],
            "364": [
                "Urlizer",
                "trim_punctuation"
            ],
            "365": [
                "Urlizer",
                "trim_punctuation"
            ]
        },
        "addLocation": []
    }
}