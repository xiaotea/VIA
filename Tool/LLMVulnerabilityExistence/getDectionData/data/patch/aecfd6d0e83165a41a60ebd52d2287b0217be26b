{
    "vantage6-server/vantage6/server/globals.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " # default password policies"
            },
            "1": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " DEFAULT_MAX_FAILED_ATTEMPTS = 5"
            },
            "2": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " DEFAULT_INACTIVATION_MINUTES = 15"
            },
            "3": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES = 60"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+DEFAULT_BETWEEN_USER_EMAILS_MINUTES = 60"
            }
        },
        "frontPatchFile": [
            "from pathlib import Path",
            "",
            "from vantage6.common.globals import APPNAME",
            "",
            "#",
            "#   INSTALLATION SETTINGS",
            "#",
            "PACKAGE_FOLDER = Path(__file__).parent.parent.parent",
            "",
            "DATA_FOLDER = PACKAGE_FOLDER / APPNAME / \"server\" / \"_data\"",
            "",
            "SERVER_MODULE_NAME = APPNAME + \"-server\"",
            "",
            "#",
            "#   RUNTIME SETTINGS",
            "#",
            "",
            "# Expiretime of JWT tokens",
            "ACCESS_TOKEN_EXPIRES_HOURS = 6",
            "",
            "# minimum validity of JWT Tokens in seconds",
            "MIN_TOKEN_VALIDITY_SECONDS = 1800",
            "",
            "# Expiration time of refresh tokens",
            "REFRESH_TOKENS_EXPIRE_HOURS = 48",
            "",
            "# Minimum time in seconds that a refresh token must be valid *longer than* the",
            "# access token. This is to prevent the access token from expiring before the",
            "# refresh token.",
            "MIN_REFRESH_TOKEN_EXPIRY_DELTA = 1",
            "",
            "# Which resources should be initialized. These names correspond to the",
            "# file-names in the resource directory",
            "RESOURCES = [",
            "    \"node\",",
            "    \"collaboration\",",
            "    \"organization\",",
            "    \"task\",",
            "    \"run\",",
            "    \"token\",",
            "    \"user\",",
            "    \"version\",",
            "    \"recover\",",
            "    \"role\",",
            "    \"rule\",",
            "    \"health\",",
            "    \"vpn\",",
            "    \"port\",",
            "    \"event\",",
            "    \"ui.column\",",
            "]",
            "",
            "# Super user information. This user is only created if it is not in the",
            "# database yet at startup time.",
            "SUPER_USER_INFO = {\"username\": \"root\", \"password\": \"root\"}",
            "",
            "# default support email address to make users aware of",
            "DEFAULT_SUPPORT_EMAIL_ADDRESS = \"support@vantage6.ai\"",
            "",
            "# default email address used in 'from' header",
            "DEFAULT_EMAIL_FROM_ADDRESS = \"noreply@vantage6.ai\"",
            "",
            "# default time that token is valid in minutes",
            "DEFAULT_EMAILED_TOKEN_VALIDITY_MINUTES = 60",
            "",
            "# pagination settings",
            "DEFAULT_PAGE = 1",
            "DEFAULT_PAGE_SIZE = 10",
            "",
            "# default password policies",
            "DEFAULT_MAX_FAILED_ATTEMPTS = 5",
            "DEFAULT_INACTIVATION_MINUTES = 15",
            "DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES = 60"
        ],
        "afterPatchFile": [
            "from pathlib import Path",
            "",
            "from vantage6.common.globals import APPNAME",
            "",
            "#",
            "#   INSTALLATION SETTINGS",
            "#",
            "PACKAGE_FOLDER = Path(__file__).parent.parent.parent",
            "",
            "DATA_FOLDER = PACKAGE_FOLDER / APPNAME / \"server\" / \"_data\"",
            "",
            "SERVER_MODULE_NAME = APPNAME + \"-server\"",
            "",
            "#",
            "#   RUNTIME SETTINGS",
            "#",
            "",
            "# Expiretime of JWT tokens",
            "ACCESS_TOKEN_EXPIRES_HOURS = 6",
            "",
            "# minimum validity of JWT Tokens in seconds",
            "MIN_TOKEN_VALIDITY_SECONDS = 1800",
            "",
            "# Expiration time of refresh tokens",
            "REFRESH_TOKENS_EXPIRE_HOURS = 48",
            "",
            "# Minimum time in seconds that a refresh token must be valid *longer than* the",
            "# access token. This is to prevent the access token from expiring before the",
            "# refresh token.",
            "MIN_REFRESH_TOKEN_EXPIRY_DELTA = 1",
            "",
            "# Which resources should be initialized. These names correspond to the",
            "# file-names in the resource directory",
            "RESOURCES = [",
            "    \"node\",",
            "    \"collaboration\",",
            "    \"organization\",",
            "    \"task\",",
            "    \"run\",",
            "    \"token\",",
            "    \"user\",",
            "    \"version\",",
            "    \"recover\",",
            "    \"role\",",
            "    \"rule\",",
            "    \"health\",",
            "    \"vpn\",",
            "    \"port\",",
            "    \"event\",",
            "    \"ui.column\",",
            "]",
            "",
            "# Super user information. This user is only created if it is not in the",
            "# database yet at startup time.",
            "SUPER_USER_INFO = {\"username\": \"root\", \"password\": \"root\"}",
            "",
            "# default support email address to make users aware of",
            "DEFAULT_SUPPORT_EMAIL_ADDRESS = \"support@vantage6.ai\"",
            "",
            "# default email address used in 'from' header",
            "DEFAULT_EMAIL_FROM_ADDRESS = \"noreply@vantage6.ai\"",
            "",
            "# default time that token is valid in minutes",
            "DEFAULT_EMAILED_TOKEN_VALIDITY_MINUTES = 60",
            "",
            "# pagination settings",
            "DEFAULT_PAGE = 1",
            "DEFAULT_PAGE_SIZE = 10",
            "",
            "# default password policies",
            "DEFAULT_MAX_FAILED_ATTEMPTS = 5",
            "DEFAULT_INACTIVATION_MINUTES = 15",
            "DEFAULT_BETWEEN_USER_EMAILS_MINUTES = 60"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "73": [
                "DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES"
            ]
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/model/user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     last_login_attempt = Column(DateTime)"
            },
            "1": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     otp_secret = Column(String(32))"
            },
            "2": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     last_email_failed_login_sent = Column(DateTime)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    last_email_recover_password_sent = Column(DateTime)"
            },
            "4": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     # relationships"
            },
            "6": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     organization = relationship(\"Organization\", back_populates=\"users\")"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "import bcrypt",
            "import datetime as dt",
            "",
            "from sqlalchemy import Column, String, Integer, ForeignKey, DateTime",
            "from sqlalchemy.orm import relationship, validates",
            "",
            "from vantage6.server.model.base import DatabaseSessionManager",
            "from vantage6.server.model.authenticatable import Authenticatable",
            "from vantage6.server.model.rule import Operation, Rule, Scope",
            "from vantage6.server.model.common.utils import validate_password",
            "",
            "",
            "class User(Authenticatable):",
            "    \"\"\"",
            "    Table to keep track of Users (persons) that can access the system.",
            "",
            "    Users always belong to an organization and can have certain",
            "    rights within an organization.",
            "",
            "    Attributes",
            "    ----------",
            "    username : str",
            "        Username of the user",
            "    password : str",
            "        Password of the user",
            "    firstname : str",
            "        First name of the user",
            "    lastname : str",
            "        Last name of the user",
            "    email : str",
            "        Email address of the user",
            "    organization_id : int",
            "        Foreign key to the organization to which the user belongs",
            "    failed_login_attempts : int",
            "        Number of failed login attempts",
            "    last_login_attempt : datetime.datetime",
            "        Date and time of the last login attempt",
            "    otp_secret : str",
            "        Secret key for one time passwords",
            "    organization : :class:`~.model.organization.Organization`",
            "        Organization to which the user belongs",
            "    roles : list[:class:`~.model.role.Role`]",
            "        Roles that the user has",
            "    rules : list[:class:`~.model.rule.Rule`]",
            "        Rules that the user has",
            "    created_tasks : list[:class:`~.model.task.Task`]",
            "        Tasks that the user has created",
            "    \"\"\"",
            "",
            "    _hidden_attributes = [\"password\"]",
            "",
            "    # overwrite id with linked id to the authenticatable",
            "    id = Column(Integer, ForeignKey(\"authenticatable.id\"), primary_key=True)",
            "    __mapper_args__ = {",
            "        \"polymorphic_identity\": \"user\",",
            "    }",
            "",
            "    # fields",
            "    username = Column(String, unique=True)",
            "    password = Column(String)",
            "    firstname = Column(String)",
            "    lastname = Column(String)",
            "    email = Column(String, unique=True)",
            "    organization_id = Column(Integer, ForeignKey(\"organization.id\"))",
            "    failed_login_attempts = Column(Integer, default=0)",
            "    last_login_attempt = Column(DateTime)",
            "    otp_secret = Column(String(32))",
            "    last_email_failed_login_sent = Column(DateTime)",
            "",
            "    # relationships",
            "    organization = relationship(\"Organization\", back_populates=\"users\")",
            "    roles = relationship(\"Role\", back_populates=\"users\", secondary=\"Permission\")",
            "    rules = relationship(\"Rule\", back_populates=\"users\", secondary=\"UserPermission\")",
            "    created_tasks = relationship(\"Task\", back_populates=\"init_user\")",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        String representation of the user.",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            String representation of the user",
            "        \"\"\"",
            "        organization = self.organization.name if self.organization else \"None\"",
            "        return (",
            "            f\"<User \"",
            "            f\"id={self.id}, username='{self.username}', roles='{self.roles}', \"",
            "            f\"organization='{organization}'\"",
            "            f\">\"",
            "        )",
            "",
            "    @validates(\"password\")",
            "    def _validate_password(self, key: str, password: str) -> str:",
            "        \"\"\"",
            "        Validate the password of the user by hashing it, as it is also hashed",
            "        in the database.",
            "",
            "        Parameters",
            "        ----------",
            "        key: str",
            "            Name of the attribute (in this case 'password')",
            "        password: str",
            "            Password of the user",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            Hashed password",
            "        \"\"\"",
            "        return self.hash(password)",
            "",
            "    def set_password(self, pw: str) -> str | None:",
            "        \"\"\"",
            "        Set the password of the current user. This function doesn't save the",
            "        new password to the database",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            The new password",
            "",
            "        Returns",
            "        -------",
            "        str | None",
            "            If the new password fails to pass the checks, a message is",
            "            returned. Else, none is returned",
            "        \"\"\"",
            "        try:",
            "            validate_password(pw)",
            "        except ValueError as e:",
            "            return str(e)",
            "",
            "        self.password = pw",
            "        self.save()",
            "",
            "    def check_password(self, pw: str) -> bool:",
            "        \"\"\"",
            "        Check if the password is correct",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            Password to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not the password is correct",
            "        \"\"\"",
            "        if self.password is not None:",
            "            expected_hash = self.password.encode(\"utf8\")",
            "            return bcrypt.checkpw(pw.encode(\"utf8\"), expected_hash)",
            "        return False",
            "",
            "    def is_blocked(",
            "        self, max_failed_attempts: int, inactivation_in_minutes: int",
            "    ) -> tuple[bool, int | None]:",
            "        \"\"\"",
            "        Check if user can login or if they are temporarily blocked because they",
            "        entered a wrong password too often",
            "",
            "        Parameters",
            "        ----------",
            "        max_failed_attempts: int",
            "            Maximum number of attempts to login before temporary deactivation",
            "        inactivation_in_minutes: int",
            "            How many minutes an account is deactivated",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is blocked temporarily",
            "        int | None",
            "            How many minutes user is still blocked for",
            "        \"\"\"",
            "        td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)",
            "        td_last_login = (",
            "            dt.datetime.now() - self.last_login_attempt",
            "            if self.last_login_attempt",
            "            else None",
            "        )",
            "        has_max_attempts = (",
            "            self.failed_login_attempts >= max_failed_attempts",
            "            if self.failed_login_attempts",
            "            else False",
            "        )",
            "        if has_max_attempts and td_last_login < td_max_blocked:",
            "            minutes_remaining = (td_max_blocked - td_last_login).seconds // 60 + 1",
            "            return True, minutes_remaining",
            "        else:",
            "            return False, None",
            "",
            "    @classmethod",
            "    def get_by_username(cls, username: str) -> User:",
            "        \"\"\"",
            "        Get a user by their username",
            "",
            "        Parameters",
            "        ----------",
            "        username: str",
            "            Username of the user",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            User with the given username",
            "",
            "        Raises",
            "        ------",
            "        NoResultFound",
            "            If no user with the given username exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(username=username).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_first_user(cls) -> User:",
            "        \"\"\"",
            "        Get a random user by their username.",
            "",
            "        This function is used to prevent an attacker from finding out which",
            "        usernames exist.",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            A random user that is in the database",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).order_by(cls.id).first()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_by_email(cls, email: str) -> User:",
            "        \"\"\"",
            "        Get a user by their email",
            "",
            "        Parameters",
            "        ----------",
            "        email: str",
            "            Email of the user",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            User with the given email",
            "",
            "        Raises",
            "        ------",
            "        NoResultFound",
            "            If no user with the given email exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(email=email).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def username_exists(cls, username) -> bool:",
            "        \"\"\"",
            "        Check if a user with the given username exists",
            "",
            "        Parameters",
            "        ----------",
            "        username: str",
            "            Username to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not a user with the given username exists",
            "        \"\"\"",
            "        return cls.exists(field=\"username\", value=username)",
            "",
            "    def can(self, resource: str, scope: Scope, operation: Operation) -> bool:",
            "        \"\"\"",
            "        Check if user is allowed to execute a certain action",
            "",
            "        Parameters",
            "        ---------",
            "        resource: str",
            "            The resource type on which the action is to be performed",
            "        scope: Scope",
            "            The scope within which the user wants to perform an action",
            "        operation: Operation",
            "            The operation a user wants to execute",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is allowed to execute the requested operation",
            "            on the resource",
            "        \"\"\"",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        return rule in self.rules or any(rule in role.rules for role in self.roles)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "import bcrypt",
            "import datetime as dt",
            "",
            "from sqlalchemy import Column, String, Integer, ForeignKey, DateTime",
            "from sqlalchemy.orm import relationship, validates",
            "",
            "from vantage6.server.model.base import DatabaseSessionManager",
            "from vantage6.server.model.authenticatable import Authenticatable",
            "from vantage6.server.model.rule import Operation, Rule, Scope",
            "from vantage6.server.model.common.utils import validate_password",
            "",
            "",
            "class User(Authenticatable):",
            "    \"\"\"",
            "    Table to keep track of Users (persons) that can access the system.",
            "",
            "    Users always belong to an organization and can have certain",
            "    rights within an organization.",
            "",
            "    Attributes",
            "    ----------",
            "    username : str",
            "        Username of the user",
            "    password : str",
            "        Password of the user",
            "    firstname : str",
            "        First name of the user",
            "    lastname : str",
            "        Last name of the user",
            "    email : str",
            "        Email address of the user",
            "    organization_id : int",
            "        Foreign key to the organization to which the user belongs",
            "    failed_login_attempts : int",
            "        Number of failed login attempts",
            "    last_login_attempt : datetime.datetime",
            "        Date and time of the last login attempt",
            "    otp_secret : str",
            "        Secret key for one time passwords",
            "    organization : :class:`~.model.organization.Organization`",
            "        Organization to which the user belongs",
            "    roles : list[:class:`~.model.role.Role`]",
            "        Roles that the user has",
            "    rules : list[:class:`~.model.rule.Rule`]",
            "        Rules that the user has",
            "    created_tasks : list[:class:`~.model.task.Task`]",
            "        Tasks that the user has created",
            "    \"\"\"",
            "",
            "    _hidden_attributes = [\"password\"]",
            "",
            "    # overwrite id with linked id to the authenticatable",
            "    id = Column(Integer, ForeignKey(\"authenticatable.id\"), primary_key=True)",
            "    __mapper_args__ = {",
            "        \"polymorphic_identity\": \"user\",",
            "    }",
            "",
            "    # fields",
            "    username = Column(String, unique=True)",
            "    password = Column(String)",
            "    firstname = Column(String)",
            "    lastname = Column(String)",
            "    email = Column(String, unique=True)",
            "    organization_id = Column(Integer, ForeignKey(\"organization.id\"))",
            "    failed_login_attempts = Column(Integer, default=0)",
            "    last_login_attempt = Column(DateTime)",
            "    otp_secret = Column(String(32))",
            "    last_email_failed_login_sent = Column(DateTime)",
            "    last_email_recover_password_sent = Column(DateTime)",
            "",
            "    # relationships",
            "    organization = relationship(\"Organization\", back_populates=\"users\")",
            "    roles = relationship(\"Role\", back_populates=\"users\", secondary=\"Permission\")",
            "    rules = relationship(\"Rule\", back_populates=\"users\", secondary=\"UserPermission\")",
            "    created_tasks = relationship(\"Task\", back_populates=\"init_user\")",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        String representation of the user.",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            String representation of the user",
            "        \"\"\"",
            "        organization = self.organization.name if self.organization else \"None\"",
            "        return (",
            "            f\"<User \"",
            "            f\"id={self.id}, username='{self.username}', roles='{self.roles}', \"",
            "            f\"organization='{organization}'\"",
            "            f\">\"",
            "        )",
            "",
            "    @validates(\"password\")",
            "    def _validate_password(self, key: str, password: str) -> str:",
            "        \"\"\"",
            "        Validate the password of the user by hashing it, as it is also hashed",
            "        in the database.",
            "",
            "        Parameters",
            "        ----------",
            "        key: str",
            "            Name of the attribute (in this case 'password')",
            "        password: str",
            "            Password of the user",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            Hashed password",
            "        \"\"\"",
            "        return self.hash(password)",
            "",
            "    def set_password(self, pw: str) -> str | None:",
            "        \"\"\"",
            "        Set the password of the current user. This function doesn't save the",
            "        new password to the database",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            The new password",
            "",
            "        Returns",
            "        -------",
            "        str | None",
            "            If the new password fails to pass the checks, a message is",
            "            returned. Else, none is returned",
            "        \"\"\"",
            "        try:",
            "            validate_password(pw)",
            "        except ValueError as e:",
            "            return str(e)",
            "",
            "        self.password = pw",
            "        self.save()",
            "",
            "    def check_password(self, pw: str) -> bool:",
            "        \"\"\"",
            "        Check if the password is correct",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            Password to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not the password is correct",
            "        \"\"\"",
            "        if self.password is not None:",
            "            expected_hash = self.password.encode(\"utf8\")",
            "            return bcrypt.checkpw(pw.encode(\"utf8\"), expected_hash)",
            "        return False",
            "",
            "    def is_blocked(",
            "        self, max_failed_attempts: int, inactivation_in_minutes: int",
            "    ) -> tuple[bool, int | None]:",
            "        \"\"\"",
            "        Check if user can login or if they are temporarily blocked because they",
            "        entered a wrong password too often",
            "",
            "        Parameters",
            "        ----------",
            "        max_failed_attempts: int",
            "            Maximum number of attempts to login before temporary deactivation",
            "        inactivation_in_minutes: int",
            "            How many minutes an account is deactivated",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is blocked temporarily",
            "        int | None",
            "            How many minutes user is still blocked for",
            "        \"\"\"",
            "        td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)",
            "        td_last_login = (",
            "            dt.datetime.now() - self.last_login_attempt",
            "            if self.last_login_attempt",
            "            else None",
            "        )",
            "        has_max_attempts = (",
            "            self.failed_login_attempts >= max_failed_attempts",
            "            if self.failed_login_attempts",
            "            else False",
            "        )",
            "        if has_max_attempts and td_last_login < td_max_blocked:",
            "            minutes_remaining = (td_max_blocked - td_last_login).seconds // 60 + 1",
            "            return True, minutes_remaining",
            "        else:",
            "            return False, None",
            "",
            "    @classmethod",
            "    def get_by_username(cls, username: str) -> User:",
            "        \"\"\"",
            "        Get a user by their username",
            "",
            "        Parameters",
            "        ----------",
            "        username: str",
            "            Username of the user",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            User with the given username",
            "",
            "        Raises",
            "        ------",
            "        NoResultFound",
            "            If no user with the given username exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(username=username).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_first_user(cls) -> User:",
            "        \"\"\"",
            "        Get a random user by their username.",
            "",
            "        This function is used to prevent an attacker from finding out which",
            "        usernames exist.",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            A random user that is in the database",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).order_by(cls.id).first()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_by_email(cls, email: str) -> User:",
            "        \"\"\"",
            "        Get a user by their email",
            "",
            "        Parameters",
            "        ----------",
            "        email: str",
            "            Email of the user",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            User with the given email",
            "",
            "        Raises",
            "        ------",
            "        NoResultFound",
            "            If no user with the given email exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(email=email).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def username_exists(cls, username) -> bool:",
            "        \"\"\"",
            "        Check if a user with the given username exists",
            "",
            "        Parameters",
            "        ----------",
            "        username: str",
            "            Username to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not a user with the given username exists",
            "        \"\"\"",
            "        return cls.exists(field=\"username\", value=username)",
            "",
            "    def can(self, resource: str, scope: Scope, operation: Operation) -> bool:",
            "        \"\"\"",
            "        Check if user is allowed to execute a certain action",
            "",
            "        Parameters",
            "        ---------",
            "        resource: str",
            "            The resource type on which the action is to be performed",
            "        scope: Scope",
            "            The scope within which the user wants to perform an action",
            "        operation: Operation",
            "            The operation a user wants to execute",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is allowed to execute the requested operation",
            "            on the resource",
            "        \"\"\"",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        return rule in self.rules or any(rule in role.rules for role in self.roles)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "vantage6-server.vantage6.server.model.user.User.__mapper_args__",
            "vantage6-server.vantage6.server.model.user.User.self",
            "vantage6-server.vantage6.server.model.user.User._hidden_attributes"
        ]
    },
    "vantage6-server/vantage6/server/resource/common/auth_helper.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     DEFAULT_SUPPORT_EMAIL_ADDRESS,"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     DEFAULT_MAX_FAILED_ATTEMPTS,"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     DEFAULT_INACTIVATION_MINUTES,"
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    DEFAULT_BETWEEN_USER_EMAILS_MINUTES,"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     DEFAULT_EMAIL_FROM_ADDRESS,"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " )"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from vantage6.server.model.user import User"
            },
            "8": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "     # check that email has not already been sent recently"
            },
            "9": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "     password_policy = config.get(\"password_policy\", {})"
            },
            "10": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "     minutes_between_blocked_emails = password_policy.get("
            },
            "11": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"between_email_blocked_login_minutes\","
            },
            "12": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        \"between_user_emails_minutes\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        DEFAULT_BETWEEN_USER_EMAILS_MINUTES,"
            },
            "15": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "     )"
            },
            "16": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "     email_sent_recently = user.last_email_failed_login_sent and ("
            },
            "17": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         dt.datetime.now()"
            }
        },
        "frontPatchFile": [
            "import sys",
            "import logging",
            "import datetime as dt",
            "import pyotp",
            "",
            "from http import HTTPStatus",
            "from flask import request, render_template, current_app, Flask",
            "from flask_mail import Mail",
            "from threading import Thread",
            "",
            "from vantage6.common.globals import APPNAME, MAIN_VERSION_NAME",
            "from vantage6.server.globals import (",
            "    DEFAULT_SUPPORT_EMAIL_ADDRESS,",
            "    DEFAULT_MAX_FAILED_ATTEMPTS,",
            "    DEFAULT_INACTIVATION_MINUTES,",
            "    DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES,",
            "    DEFAULT_EMAIL_FROM_ADDRESS,",
            ")",
            "from vantage6.server.model.user import User",
            "",
            "module_name = __name__.split(\".\")[-1]",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "def user_login(",
            "    config: dict, username: str, password: str, mail: Mail",
            ") -> tuple[dict | User, HTTPStatus]:",
            "    \"\"\"",
            "    Returns user a message in case of failed login attempt.",
            "",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    username: str",
            "        Username of user to be logged in",
            "    password: str",
            "        Password of user to be logged in",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "",
            "    Returns",
            "    -------",
            "    :class:`~vantage6.server.model.user.User` or dict:",
            "        User SQLAlchemy model if user is logged in, otherwise dictionary with",
            "        error message",
            "    HTTPStatus:",
            "        Status code that the current request should return",
            "    \"\"\"",
            "    log.info(\"Trying to login '%s'\", username)",
            "    failed_login_msg = \"Failed to login\"",
            "",
            "    # check if username exists. If it does not, we continue anyway, to prevent",
            "    # that an attacker can find out which usernames exist via a timing attack.",
            "    # In that case, we fetch the first user as random user.",
            "    username_exists = User.username_exists(username)",
            "    random_username = User.get_first_user().username",
            "    user = (",
            "        User.get_by_username(username)",
            "        if username_exists",
            "        else User.get_by_username(random_username)",
            "    )",
            "",
            "    password_policy = config.get(\"password_policy\", {})",
            "    max_failed_attempts = password_policy.get(",
            "        \"max_failed_attempts\", DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "    inactivation_time = password_policy.get(",
            "        \"inactivation_minutes\", DEFAULT_INACTIVATION_MINUTES",
            "    )",
            "",
            "    is_blocked, min_rem = user.is_blocked(max_failed_attempts, inactivation_time)",
            "",
            "    if user.check_password(password) and not is_blocked and username_exists:",
            "        # Note: above the username_exists is checked to prevent that an",
            "        # attacker happens to get the correct password for the random user",
            "        # that is returned when the username does not exist. Note also that",
            "        # the password is checked first to keep the timing equal for both.",
            "        user.failed_login_attempts = 0",
            "        user.save()",
            "        return user, HTTPStatus.OK",
            "",
            "    # Handle database updates required upon failed login in a separate thread",
            "    # to ensure similar response times",
            "    # pylint: disable=W0212",
            "    t1 = Thread(",
            "        target=__handle_failed_login,",
            "        args=(",
            "            current_app._get_current_object(),",
            "            username_exists,",
            "            username,",
            "            password_policy,",
            "            is_blocked,",
            "            min_rem,",
            "            mail,",
            "            config,",
            "            request.access_route[-1],",
            "        ),",
            "    )",
            "    t1.start()",
            "",
            "    return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED",
            "",
            "",
            "def __handle_failed_login(",
            "    app: Flask,",
            "    user_exists: bool,",
            "    username: str,",
            "    password_policy: dict,",
            "    is_blocked: bool,",
            "    min_rem: int,",
            "    mail: Mail,",
            "    config: dict,",
            "    ip: str,",
            ") -> None:",
            "    \"\"\"",
            "    When a user login fails, this function is called to update the database",
            "    with the failed login attempt and send an email to the user if necessary.",
            "",
            "    Note that this function is called in a separate thread to keep response",
            "    times for login attempts similar in all cases. Therefore, this function",
            "    calls `sys.exit()` to terminate the thread.",
            "",
            "    Parameters",
            "    ----------",
            "    app: flask.Flask",
            "        The current Flask app",
            "    user_exists: bool",
            "        Whether user exists or not",
            "    username: str",
            "        Username of the user that failed to login",
            "    password_policy: dict",
            "        Dictionary with password policy settings.",
            "    min_rem: int",
            "        Number of minutes remaining before the account is unlocked",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    ip: str",
            "        IP address from where the login attempt was made",
            "    \"\"\"",
            "    if not user_exists:",
            "        sys.exit()",
            "    # get user object again (required because we are in a new thread)",
            "    user = User.get_by_username(username)",
            "",
            "    max_failed_attempts = password_policy.get(",
            "        \"max_failed_attempts\", DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "",
            "    if is_blocked:",
            "        # alert the user via email that they are blocked",
            "        __notify_user_blocked(app, user, min_rem, mail, config, ip)",
            "        sys.exit()",
            "    elif (",
            "        not user.failed_login_attempts",
            "        or user.failed_login_attempts >= max_failed_attempts",
            "    ):",
            "        # set failed login attempts to 1 if first failed login attempt or if",
            "        # user got unblocked after being blocked previously",
            "        user.failed_login_attempts = 1",
            "    else:",
            "        user.failed_login_attempts += 1",
            "    user.last_login_attempt = dt.datetime.now()",
            "    user.save()",
            "    sys.exit()",
            "",
            "",
            "def __notify_user_blocked(",
            "    app: Flask, user: User, min_rem: int, mail: Mail, config: dict, ip: str",
            ") -> None:",
            "    \"\"\"",
            "    Sends an email to the user when their account is locked.",
            "",
            "    This function also checks that emails are not sent too often to the same",
            "    user.",
            "",
            "    Parameters",
            "    ----------",
            "    app: flask.Flask",
            "        The current Flask app",
            "    user: :class:`~vantage6.server.model.user.User`",
            "        User who is temporarily blocked",
            "    min_rem: int",
            "        Number of minutes remaining before the account is unlocked",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    ip: str",
            "        IP address from where the login attempt was made",
            "    \"\"\"",
            "    log.info(\"User %s is locked. Sending them an email.\", user.username)",
            "",
            "    # check that email has not already been sent recently",
            "    password_policy = config.get(\"password_policy\", {})",
            "    minutes_between_blocked_emails = password_policy.get(",
            "        \"between_email_blocked_login_minutes\",",
            "        DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES,",
            "    )",
            "    email_sent_recently = user.last_email_failed_login_sent and (",
            "        dt.datetime.now()",
            "        < user.last_email_failed_login_sent",
            "        + dt.timedelta(minutes=minutes_between_blocked_emails)",
            "    )",
            "    if email_sent_recently:",
            "        return",
            "",
            "    # send email",
            "    smtp_settings = config.get(\"smtp\", {})",
            "    email_from = smtp_settings.get(\"email_from\", DEFAULT_EMAIL_FROM_ADDRESS)",
            "    support_email = config.get(\"support_email\", DEFAULT_SUPPORT_EMAIL_ADDRESS)",
            "",
            "    max_failed_attempts = password_policy.get(",
            "        \"max_failed_attempts\", DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "    template_vars = {",
            "        \"firstname\": user.firstname if user.firstname else user.username,",
            "        \"number_of_allowed_attempts\": max_failed_attempts,",
            "        \"ip\": ip,",
            "        \"time\": dt.datetime.now(dt.timezone.utc),",
            "        \"time_remaining\": min_rem,",
            "        \"support_email\": support_email,",
            "    }",
            "",
            "    with app.app_context():",
            "        mail.send_email(",
            "            \"Failed login attempts on your vantage6 account\",",
            "            sender=email_from,",
            "            recipients=[user.email],",
            "            text_body=render_template(\"mail/blocked_account.txt\", **template_vars),",
            "            html_body=render_template(\"mail/blocked_account.html\", **template_vars),",
            "        )",
            "",
            "    # Update latest email sent timestamp",
            "    user.last_email_failed_login_sent = dt.datetime.now()",
            "    user.save()",
            "",
            "",
            "def create_qr_uri(user: User) -> dict:",
            "    \"\"\"",
            "    Create the URI to generate a QR code for authenticator apps",
            "",
            "    Parameters",
            "    ----------",
            "    user: :class:`~vantage6.server.model.user.User`",
            "        User for whom two-factor authentication is to be set up",
            "",
            "    Returns",
            "    -------",
            "    dict",
            "        Dictionary with information on the TOTP secret required to generate",
            "        a QR code or to enter it manually in an authenticator app",
            "    \"\"\"",
            "    otp_secret = pyotp.random_base32()",
            "    qr_uri = pyotp.totp.TOTP(otp_secret).provisioning_uri(",
            "        name=user.username, issuer_name=f\"{APPNAME} ({MAIN_VERSION_NAME})\"",
            "    )",
            "    user.otp_secret = otp_secret",
            "    user.save()",
            "    return {",
            "        \"qr_uri\": qr_uri,",
            "        \"otp_secret\": otp_secret,",
            "        \"msg\": (",
            "            \"Two-factor authentication is obligatory on this server. \"",
            "            \"Please visualize the QR code to set up authentication.\"",
            "        ),",
            "    }"
        ],
        "afterPatchFile": [
            "import sys",
            "import logging",
            "import datetime as dt",
            "import pyotp",
            "",
            "from http import HTTPStatus",
            "from flask import request, render_template, current_app, Flask",
            "from flask_mail import Mail",
            "from threading import Thread",
            "",
            "from vantage6.common.globals import APPNAME, MAIN_VERSION_NAME",
            "from vantage6.server.globals import (",
            "    DEFAULT_SUPPORT_EMAIL_ADDRESS,",
            "    DEFAULT_MAX_FAILED_ATTEMPTS,",
            "    DEFAULT_INACTIVATION_MINUTES,",
            "    DEFAULT_BETWEEN_USER_EMAILS_MINUTES,",
            "    DEFAULT_EMAIL_FROM_ADDRESS,",
            ")",
            "from vantage6.server.model.user import User",
            "",
            "module_name = __name__.split(\".\")[-1]",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "def user_login(",
            "    config: dict, username: str, password: str, mail: Mail",
            ") -> tuple[dict | User, HTTPStatus]:",
            "    \"\"\"",
            "    Returns user a message in case of failed login attempt.",
            "",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    username: str",
            "        Username of user to be logged in",
            "    password: str",
            "        Password of user to be logged in",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "",
            "    Returns",
            "    -------",
            "    :class:`~vantage6.server.model.user.User` or dict:",
            "        User SQLAlchemy model if user is logged in, otherwise dictionary with",
            "        error message",
            "    HTTPStatus:",
            "        Status code that the current request should return",
            "    \"\"\"",
            "    log.info(\"Trying to login '%s'\", username)",
            "    failed_login_msg = \"Failed to login\"",
            "",
            "    # check if username exists. If it does not, we continue anyway, to prevent",
            "    # that an attacker can find out which usernames exist via a timing attack.",
            "    # In that case, we fetch the first user as random user.",
            "    username_exists = User.username_exists(username)",
            "    random_username = User.get_first_user().username",
            "    user = (",
            "        User.get_by_username(username)",
            "        if username_exists",
            "        else User.get_by_username(random_username)",
            "    )",
            "",
            "    password_policy = config.get(\"password_policy\", {})",
            "    max_failed_attempts = password_policy.get(",
            "        \"max_failed_attempts\", DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "    inactivation_time = password_policy.get(",
            "        \"inactivation_minutes\", DEFAULT_INACTIVATION_MINUTES",
            "    )",
            "",
            "    is_blocked, min_rem = user.is_blocked(max_failed_attempts, inactivation_time)",
            "",
            "    if user.check_password(password) and not is_blocked and username_exists:",
            "        # Note: above the username_exists is checked to prevent that an",
            "        # attacker happens to get the correct password for the random user",
            "        # that is returned when the username does not exist. Note also that",
            "        # the password is checked first to keep the timing equal for both.",
            "        user.failed_login_attempts = 0",
            "        user.save()",
            "        return user, HTTPStatus.OK",
            "",
            "    # Handle database updates required upon failed login in a separate thread",
            "    # to ensure similar response times",
            "    # pylint: disable=W0212",
            "    t1 = Thread(",
            "        target=__handle_failed_login,",
            "        args=(",
            "            current_app._get_current_object(),",
            "            username_exists,",
            "            username,",
            "            password_policy,",
            "            is_blocked,",
            "            min_rem,",
            "            mail,",
            "            config,",
            "            request.access_route[-1],",
            "        ),",
            "    )",
            "    t1.start()",
            "",
            "    return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED",
            "",
            "",
            "def __handle_failed_login(",
            "    app: Flask,",
            "    user_exists: bool,",
            "    username: str,",
            "    password_policy: dict,",
            "    is_blocked: bool,",
            "    min_rem: int,",
            "    mail: Mail,",
            "    config: dict,",
            "    ip: str,",
            ") -> None:",
            "    \"\"\"",
            "    When a user login fails, this function is called to update the database",
            "    with the failed login attempt and send an email to the user if necessary.",
            "",
            "    Note that this function is called in a separate thread to keep response",
            "    times for login attempts similar in all cases. Therefore, this function",
            "    calls `sys.exit()` to terminate the thread.",
            "",
            "    Parameters",
            "    ----------",
            "    app: flask.Flask",
            "        The current Flask app",
            "    user_exists: bool",
            "        Whether user exists or not",
            "    username: str",
            "        Username of the user that failed to login",
            "    password_policy: dict",
            "        Dictionary with password policy settings.",
            "    min_rem: int",
            "        Number of minutes remaining before the account is unlocked",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    ip: str",
            "        IP address from where the login attempt was made",
            "    \"\"\"",
            "    if not user_exists:",
            "        sys.exit()",
            "    # get user object again (required because we are in a new thread)",
            "    user = User.get_by_username(username)",
            "",
            "    max_failed_attempts = password_policy.get(",
            "        \"max_failed_attempts\", DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "",
            "    if is_blocked:",
            "        # alert the user via email that they are blocked",
            "        __notify_user_blocked(app, user, min_rem, mail, config, ip)",
            "        sys.exit()",
            "    elif (",
            "        not user.failed_login_attempts",
            "        or user.failed_login_attempts >= max_failed_attempts",
            "    ):",
            "        # set failed login attempts to 1 if first failed login attempt or if",
            "        # user got unblocked after being blocked previously",
            "        user.failed_login_attempts = 1",
            "    else:",
            "        user.failed_login_attempts += 1",
            "    user.last_login_attempt = dt.datetime.now()",
            "    user.save()",
            "    sys.exit()",
            "",
            "",
            "def __notify_user_blocked(",
            "    app: Flask, user: User, min_rem: int, mail: Mail, config: dict, ip: str",
            ") -> None:",
            "    \"\"\"",
            "    Sends an email to the user when their account is locked.",
            "",
            "    This function also checks that emails are not sent too often to the same",
            "    user.",
            "",
            "    Parameters",
            "    ----------",
            "    app: flask.Flask",
            "        The current Flask app",
            "    user: :class:`~vantage6.server.model.user.User`",
            "        User who is temporarily blocked",
            "    min_rem: int",
            "        Number of minutes remaining before the account is unlocked",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    ip: str",
            "        IP address from where the login attempt was made",
            "    \"\"\"",
            "    log.info(\"User %s is locked. Sending them an email.\", user.username)",
            "",
            "    # check that email has not already been sent recently",
            "    password_policy = config.get(\"password_policy\", {})",
            "    minutes_between_blocked_emails = password_policy.get(",
            "        \"between_user_emails_minutes\",",
            "        DEFAULT_BETWEEN_USER_EMAILS_MINUTES,",
            "    )",
            "    email_sent_recently = user.last_email_failed_login_sent and (",
            "        dt.datetime.now()",
            "        < user.last_email_failed_login_sent",
            "        + dt.timedelta(minutes=minutes_between_blocked_emails)",
            "    )",
            "    if email_sent_recently:",
            "        return",
            "",
            "    # send email",
            "    smtp_settings = config.get(\"smtp\", {})",
            "    email_from = smtp_settings.get(\"email_from\", DEFAULT_EMAIL_FROM_ADDRESS)",
            "    support_email = config.get(\"support_email\", DEFAULT_SUPPORT_EMAIL_ADDRESS)",
            "",
            "    max_failed_attempts = password_policy.get(",
            "        \"max_failed_attempts\", DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "    template_vars = {",
            "        \"firstname\": user.firstname if user.firstname else user.username,",
            "        \"number_of_allowed_attempts\": max_failed_attempts,",
            "        \"ip\": ip,",
            "        \"time\": dt.datetime.now(dt.timezone.utc),",
            "        \"time_remaining\": min_rem,",
            "        \"support_email\": support_email,",
            "    }",
            "",
            "    with app.app_context():",
            "        mail.send_email(",
            "            \"Failed login attempts on your vantage6 account\",",
            "            sender=email_from,",
            "            recipients=[user.email],",
            "            text_body=render_template(\"mail/blocked_account.txt\", **template_vars),",
            "            html_body=render_template(\"mail/blocked_account.html\", **template_vars),",
            "        )",
            "",
            "    # Update latest email sent timestamp",
            "    user.last_email_failed_login_sent = dt.datetime.now()",
            "    user.save()",
            "",
            "",
            "def create_qr_uri(user: User) -> dict:",
            "    \"\"\"",
            "    Create the URI to generate a QR code for authenticator apps",
            "",
            "    Parameters",
            "    ----------",
            "    user: :class:`~vantage6.server.model.user.User`",
            "        User for whom two-factor authentication is to be set up",
            "",
            "    Returns",
            "    -------",
            "    dict",
            "        Dictionary with information on the TOTP secret required to generate",
            "        a QR code or to enter it manually in an authenticator app",
            "    \"\"\"",
            "    otp_secret = pyotp.random_base32()",
            "    qr_uri = pyotp.totp.TOTP(otp_secret).provisioning_uri(",
            "        name=user.username, issuer_name=f\"{APPNAME} ({MAIN_VERSION_NAME})\"",
            "    )",
            "    user.otp_secret = otp_secret",
            "    user.save()",
            "    return {",
            "        \"qr_uri\": qr_uri,",
            "        \"otp_secret\": otp_secret,",
            "        \"msg\": (",
            "            \"Two-factor authentication is obligatory on this server. \"",
            "            \"Please visualize the QR code to set up authentication.\"",
            "        ),",
            "    }"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": [],
            "200": [
                "__notify_user_blocked"
            ],
            "201": [
                "__notify_user_blocked"
            ]
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/resource/common/input_schema.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         _validate_password(password)"
            },
            "1": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+class BasicAuthInputSchema(Schema):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    \"\"\"Schema for validating input for basic authentication using a username and password.\"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+    username = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_NAME))"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    # Note that we don't inherit from _PasswordValidationSchema here and"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+    # don't validate password in case the password does not fulfill the"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    # password policy. This is e.g. the case with the default root user created"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    # when the server is started for the first time."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    password = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_PW))"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " class CollaborationInputSchema(_NameValidationSchema):"
            },
            "15": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     \"\"\"Schema for validating input for a creating a collaboration.\"\"\""
            },
            "16": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "     reset_token = fields.String(required=True, validate=Length(max=_MAX_LEN_STR_LONG))"
            },
            "18": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 300,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 301,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class Recover2FAInputSchema(Schema):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+class Recover2FAInputSchema(BasicAuthInputSchema):"
            },
            "22": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "     \"\"\"Schema for validating input for recovering 2FA.\"\"\""
            },
            "23": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 304,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    email = fields.Email()"
            },
            "25": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    username = fields.String(validate=Length(max=_MAX_LEN_NAME))"
            },
            "26": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_PW))"
            },
            "27": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "28": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @validates_schema"
            },
            "29": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def validate_email_or_username(self, data: dict, **kwargs) -> None:"
            },
            "30": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "31": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Validate the input, which should contain either an email or username."
            },
            "32": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "33": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Parameters"
            },
            "34": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ----------"
            },
            "35": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        data : dict"
            },
            "36": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            The input data. Should contain an email or username."
            },
            "37": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "38": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Raises"
            },
            "39": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ------"
            },
            "40": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ValidationError"
            },
            "41": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            If the input does not contain an email or username."
            },
            "42": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "43": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not (\"email\" in data or \"username\" in data):"
            },
            "44": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ValidationError(\"Email or username is required\")"
            },
            "45": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "46": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 305,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 306,
                "PatchRowcode": " class Reset2FAInputSchema(Schema):"
            },
            "48": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     \"\"\"Schema for validating input for resetting 2FA.\"\"\""
            },
            "49": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 427,
                "PatchRowcode": "                     f\"are {allowed_keys}.\""
            },
            "50": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 428,
                "PatchRowcode": "                 )"
            },
            "51": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 429,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "53": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class TokenUserInputSchema(Schema):"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 430,
                "PatchRowcode": "+class TokenUserInputSchema(BasicAuthInputSchema):"
            },
            "55": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 431,
                "PatchRowcode": "     \"\"\"Schema for validating input for creating a token for a user.\"\"\""
            },
            "56": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 432,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    username = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_NAME))"
            },
            "58": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Note that we don't inherit from _PasswordValidationSchema here and"
            },
            "59": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # don't validate password in case the password does not fulfill the"
            },
            "60": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # password policy. This is e.g. the case with the default root user created"
            },
            "61": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # when the server is started for the first time."
            },
            "62": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_PW))"
            },
            "63": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "     mfa_code = fields.String(validate=Length(max=10))"
            },
            "64": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 434,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 435,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import uuid",
            "import ipaddress",
            "",
            "from marshmallow import Schema, fields, ValidationError, validates, validates_schema",
            "from marshmallow.validate import Length, Range, OneOf",
            "",
            "from vantage6.common.task_status import TaskStatus",
            "from vantage6.server.default_roles import DefaultRole",
            "from vantage6.server.model.common.utils import validate_password",
            "",
            "_MAX_LEN_STR_SHORT = 128",
            "_MAX_LEN_STR_LONG = 1024",
            "_MAX_LEN_PW = 128",
            "_MAX_LEN_NAME = 128",
            "",
            "",
            "def _validate_name(name: str) -> None:",
            "    \"\"\"",
            "    Validate a name field in the request input.",
            "",
            "    Parameters",
            "    ----------",
            "    name : str",
            "        Name to validate.",
            "",
            "    Raises",
            "    ------",
            "    ValidationError",
            "        If the name is empty, too long or numerical",
            "    \"\"\"",
            "    if not len(name):",
            "        raise ValidationError(\"Name cannot be empty\")",
            "    if name.isnumeric():",
            "        raise ValidationError(\"Name cannot a number\")",
            "    if len(name) > _MAX_LEN_NAME:",
            "        raise ValidationError(f\"Name cannot be longer than {_MAX_LEN_NAME} characters\")",
            "",
            "",
            "def _validate_password(password: str) -> None:",
            "    \"\"\"",
            "    Check if the password is strong enough.",
            "",
            "    Parameters",
            "    ----------",
            "    password : str",
            "        Password to validate.",
            "",
            "    Raises",
            "    ------",
            "    ValidationError",
            "        If the password is not strong enough.",
            "    \"\"\"",
            "    try:",
            "        validate_password(password)",
            "    except ValueError as e:",
            "        raise ValidationError(str(e))",
            "",
            "",
            "class _OnlyIdSchema(Schema):",
            "    \"\"\"Schema for validating POST requests that only require an ID field.\"\"\"",
            "",
            "    id = fields.Integer(required=True, validate=Range(min=1))",
            "",
            "",
            "class _NameValidationSchema(Schema):",
            "    \"\"\"Schema for validating POST requests with a name field.\"\"\"",
            "",
            "    name = fields.String(required=True)",
            "",
            "    @validates(\"name\")",
            "    def validate_name(self, name: str):",
            "        \"\"\"",
            "        Validate the name in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        name : str",
            "            Name to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the name is empty, too long or numerical",
            "        \"\"\"",
            "        _validate_name(name)",
            "",
            "",
            "class _PasswordValidationSchema(Schema):",
            "    \"\"\"Schema that contains password validation function\"\"\"",
            "",
            "    password = fields.String(required=True)",
            "",
            "    @validates(\"password\")",
            "    def _validate_password(self, password: str):",
            "        \"\"\"",
            "        Check if the password is strong enough.",
            "",
            "        Parameters",
            "        ----------",
            "        password : str",
            "            Password to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the password is not strong enough.",
            "        \"\"\"",
            "        _validate_password(password)",
            "",
            "",
            "class ChangePasswordInputSchema(Schema):",
            "    \"\"\"Schema for validating input for changing a password.\"\"\"",
            "",
            "    # validation for current password is not necessary, as it is checked in the",
            "    # authentication process",
            "    current_password = fields.String(required=True, validate=Length(max=_MAX_LEN_PW))",
            "    new_password = fields.String(required=True)",
            "",
            "    @validates(\"new_password\")",
            "    def validate_password(self, password: str):",
            "        \"\"\"",
            "        Check if the password is strong enough.",
            "",
            "        Parameters",
            "        ----------",
            "        password : str",
            "            Password to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the password is not strong enough.",
            "        \"\"\"",
            "        _validate_password(password)",
            "",
            "",
            "class CollaborationInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for a creating a collaboration.\"\"\"",
            "",
            "    organization_ids = fields.List(fields.Integer(), required=True)",
            "    encrypted = fields.Boolean(required=True)",
            "",
            "    @validates(\"organization_ids\")",
            "    def validate_organization_ids(self, organization_ids):",
            "        \"\"\"",
            "        Validate the organization ids in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        organization_ids : list[int]",
            "            List of organization ids to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the organization ids are not valid.",
            "        \"\"\"",
            "        if not all(i > 0 for i in organization_ids):",
            "            raise ValidationError(\"Organization ids must be greater than 0\")",
            "        if not len(organization_ids) == len(set(organization_ids)):",
            "            raise ValidationError(\"Organization ids must be unique\")",
            "        if not len(organization_ids):",
            "            raise ValidationError(\"At least one organization id is required\")",
            "",
            "",
            "class CollaborationAddOrganizationSchema(_OnlyIdSchema):",
            "    \"\"\"",
            "    Schema for validating requests that add an organization to a collaboration.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class CollaborationAddNodeSchema(_OnlyIdSchema):",
            "    \"\"\"Schema for validating requests that add a node to a collaboration.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class KillTaskInputSchema(_OnlyIdSchema):",
            "    \"\"\"Schema for validating input for killing a task.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class KillNodeTasksInputSchema(_OnlyIdSchema):",
            "    \"\"\"Schema for validating input for killing tasks on a node.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class NodeInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for a creating a node.\"\"\"",
            "",
            "    # overwrite name attr as it is not required for a node",
            "    name = fields.String(required=False)",
            "    collaboration_id = fields.Integer(required=True, validate=Range(min=1))",
            "    organization_id = fields.Integer(validate=Range(min=1))",
            "    ip = fields.String()",
            "    clear_ip = fields.Boolean()",
            "",
            "    @validates(\"ip\")",
            "    def validate_ip(self, ip: str):",
            "        \"\"\"",
            "        Validate IP address in request body.",
            "",
            "        Parameters",
            "        ----------",
            "        ip : str",
            "            IP address to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the IP address is not valid.",
            "        \"\"\"",
            "        try:",
            "            ipaddress.ip_address(ip)",
            "        except ValueError:",
            "            raise ValidationError(\"IP address is not valid\")",
            "",
            "",
            "class OrganizationInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for a creating an organization.\"\"\"",
            "",
            "    address1 = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    address2 = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    zipcode = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    country = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    domain = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    public_key = fields.String()",
            "",
            "",
            "class PortInputSchema(Schema):",
            "    \"\"\"Schema for validating input for a creating a port.\"\"\"",
            "",
            "    port = fields.Integer(required=True)",
            "    run_id = fields.Integer(required=True, validate=Range(min=1))",
            "    label = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT), allow_none=True)",
            "",
            "    @validates(\"port\")",
            "    def validate_port(self, port):",
            "        \"\"\"",
            "        Validate the port in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        port : int",
            "            Port to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the port is not valid.",
            "        \"\"\"",
            "        if not 1 <= port <= 65535:",
            "            raise ValidationError(\"Port must be between 1 and 65535\")",
            "",
            "",
            "class RecoverPasswordInputSchema(Schema):",
            "    \"\"\"Schema for validating input for recovering a password.\"\"\"",
            "",
            "    email = fields.Email()",
            "    username = fields.String(validate=Length(max=_MAX_LEN_NAME))",
            "",
            "    @validates_schema",
            "    def validate_email_or_username(self, data: dict, **kwargs) -> None:",
            "        \"\"\"",
            "        Validate the input, which should contain either an email or username.",
            "",
            "        Parameters",
            "        ----------",
            "        data : dict",
            "            The input data. Should contain an email or username.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the input does not contain an email or username.",
            "        \"\"\"",
            "        if not (\"email\" in data or \"username\" in data):",
            "            raise ValidationError(\"Email or username is required\")",
            "",
            "",
            "class ResetPasswordInputSchema(_PasswordValidationSchema):",
            "    \"\"\"Schema for validating input for resetting a password.\"\"\"",
            "",
            "    reset_token = fields.String(required=True, validate=Length(max=_MAX_LEN_STR_LONG))",
            "",
            "",
            "class Recover2FAInputSchema(Schema):",
            "    \"\"\"Schema for validating input for recovering 2FA.\"\"\"",
            "",
            "    email = fields.Email()",
            "    username = fields.String(validate=Length(max=_MAX_LEN_NAME))",
            "    password = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_PW))",
            "",
            "    @validates_schema",
            "    def validate_email_or_username(self, data: dict, **kwargs) -> None:",
            "        \"\"\"",
            "        Validate the input, which should contain either an email or username.",
            "",
            "        Parameters",
            "        ----------",
            "        data : dict",
            "            The input data. Should contain an email or username.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the input does not contain an email or username.",
            "        \"\"\"",
            "        if not (\"email\" in data or \"username\" in data):",
            "            raise ValidationError(\"Email or username is required\")",
            "",
            "",
            "class Reset2FAInputSchema(Schema):",
            "    \"\"\"Schema for validating input for resetting 2FA.\"\"\"",
            "",
            "    reset_token = fields.String(required=True, validate=Length(max=_MAX_LEN_STR_LONG))",
            "",
            "",
            "class ResetAPIKeyInputSchema(_OnlyIdSchema):",
            "    \"\"\"Schema for validating input for resetting an API key.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class RoleInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for creating a role.\"\"\"",
            "",
            "    description = fields.String(validate=Length(max=_MAX_LEN_STR_LONG))",
            "    rules = fields.List(fields.Integer(validate=Range(min=1)), required=True)",
            "    organization_id = fields.Integer(validate=Range(min=1))",
            "",
            "    @validates(\"name\")",
            "    def validate_name(self, name: str):",
            "        \"\"\"",
            "        Validate that role name is not one of the default roles.",
            "",
            "        Parameters",
            "        ----------",
            "        name : str",
            "            Role name to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the role name is one of the default roles.",
            "        \"\"\"",
            "        if name in [role for role in DefaultRole]:",
            "            raise ValidationError(\"Role name cannot be one of the default roles\")",
            "",
            "",
            "class RunInputSchema(Schema):",
            "    \"\"\"Schema for validating input for patching an algorithm run.\"\"\"",
            "",
            "    started_at = fields.DateTime()",
            "    finished_at = fields.DateTime()",
            "    log = fields.String()",
            "    result = fields.String()",
            "    status = fields.String(validate=OneOf([s.value for s in TaskStatus]))",
            "",
            "",
            "class TaskInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for creating a task.\"\"\"",
            "",
            "    # overwrite name attr as it is not required for a task",
            "    name = fields.String(required=False)",
            "    description = fields.String(validate=Length(max=_MAX_LEN_STR_LONG))",
            "    image = fields.String(required=True, validate=Length(min=1))",
            "    collaboration_id = fields.Integer(required=True, validate=Range(min=1))",
            "    organizations = fields.List(fields.Dict(), required=True)",
            "    databases = fields.List(fields.Dict(), allow_none=True)",
            "",
            "    @validates(\"organizations\")",
            "    def validate_organizations(self, organizations: list[dict]):",
            "        \"\"\"",
            "        Validate the organizations in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        organizations : list[dict]",
            "            List of organizations to validate. Each organization must have at",
            "            least an organization id.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the organizations are not valid.",
            "        \"\"\"",
            "        if not len(organizations):",
            "            raise ValidationError(\"At least one organization is required\")",
            "        for organization in organizations:",
            "            if \"id\" not in organization:",
            "                raise ValidationError(",
            "                    \"Organization id is required for each organization\"",
            "                )",
            "",
            "    @validates(\"databases\")",
            "    def validate_databases(self, databases: list[dict]):",
            "        \"\"\"",
            "        Validate the databases in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        databases : list[dict]",
            "            List of databases to validate. Each database must have at",
            "            least a database label.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the databases are not valid.",
            "        \"\"\"",
            "        if databases is None:",
            "            return  # some algorithms don't use any database",
            "        for database in databases:",
            "            if \"label\" not in database:",
            "                raise ValidationError(\"Database label is required for each database\")",
            "            if \"preprocessing\" in database:",
            "                if not isinstance(database[\"preprocessing\"], list):",
            "                    raise ValidationError(",
            "                        \"Database preprocessing must be a list of dictionaries\"",
            "                    )",
            "                # TODO we may add further validation on the preprocessing",
            "                # parameters when that is completed",
            "                for prepro in database[\"preprocessing\"]:",
            "                    if \"function\" not in prepro:",
            "                        raise ValidationError(",
            "                            f\"Database preprocessing {prepro} is missing a \"",
            "                            \"'function'\"",
            "                        )",
            "            allowed_keys = {\"label\", \"preprocessing\", \"query\", \"sheet_name\"}",
            "            if not set(database.keys()).issubset(set(allowed_keys)):",
            "                raise ValidationError(",
            "                    f\"Database {database} contains unknown keys. Allowed keys \"",
            "                    f\"are {allowed_keys}.\"",
            "                )",
            "",
            "",
            "class TokenUserInputSchema(Schema):",
            "    \"\"\"Schema for validating input for creating a token for a user.\"\"\"",
            "",
            "    username = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_NAME))",
            "    # Note that we don't inherit from _PasswordValidationSchema here and",
            "    # don't validate password in case the password does not fulfill the",
            "    # password policy. This is e.g. the case with the default root user created",
            "    # when the server is started for the first time.",
            "    password = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_PW))",
            "    mfa_code = fields.String(validate=Length(max=10))",
            "",
            "",
            "class TokenNodeInputSchema(Schema):",
            "    \"\"\"Schema for validating input for creating a token for a node.\"\"\"",
            "",
            "    api_key = fields.String(required=True)",
            "",
            "    @validates(\"api_key\")",
            "    def validate_api_key(self, api_key: str):",
            "        \"\"\"",
            "        Validate the API key in the input. The API key should be a valid UUID",
            "",
            "        Parameters",
            "        ----------",
            "        api_key : str",
            "            API key to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the API key is not valid.",
            "        \"\"\"",
            "        try:",
            "            uuid.UUID(api_key)",
            "        except ValueError:",
            "            raise ValidationError(\"API key is not a valid UUID\")",
            "",
            "",
            "class TokenAlgorithmInputSchema(Schema):",
            "    \"\"\"Schema for validating input for creating a token for an algorithm.\"\"\"",
            "",
            "    task_id = fields.Integer(required=True, validate=Range(min=1))",
            "    image = fields.String(required=True, validate=Length(min=1))",
            "",
            "",
            "class UserInputSchema(_PasswordValidationSchema):",
            "    \"\"\"Schema for validating input for creating a user.\"\"\"",
            "",
            "    username = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_NAME))",
            "    email = fields.Email(required=True)",
            "    firstname = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    lastname = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    organization_id = fields.Integer(validate=Range(min=1))",
            "    roles = fields.List(fields.Integer(validate=Range(min=1)))",
            "    rules = fields.List(fields.Integer(validate=Range(min=1)))",
            "",
            "    @validates(\"username\")",
            "    def validate_username(self, username: str):",
            "        \"\"\"",
            "        Check if the username is appropriate",
            "",
            "        Parameters",
            "        ----------",
            "        username : str",
            "            Username to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the username is too short, too long or numeric.",
            "        \"\"\"",
            "        _validate_name(username)",
            "",
            "",
            "class VPNConfigUpdateInputSchema(Schema):",
            "    \"\"\"Schema for validating input for updating a VPN configuration.\"\"\"",
            "",
            "    vpn_config = fields.String(required=True)",
            "",
            "",
            "class ColumnNameInputSchema(Schema):",
            "    \"\"\"Schema for validating input for collecting database column names.\"\"\"",
            "",
            "    db_label = fields.String(required=True)",
            "    collaboration_id = fields.Integer(required=True, validate=Range(min=1))",
            "    organizations = fields.List(fields.Dict(), required=True)",
            "    sheet_name = fields.String(required=False)",
            "    query = fields.String(required=False)",
            "",
            "    @validates(\"organizations\")",
            "    def validate_organizations(self, organizations: list[dict]):",
            "        \"\"\"",
            "        Validate the organizations in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        organizations : list[dict]",
            "            List of organizations to validate. Each organization must have at",
            "            least an organization id.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the organizations are not valid.",
            "        \"\"\"",
            "        if not len(organizations):",
            "            raise ValidationError(\"At least one organization is required\")",
            "        for organization in organizations:",
            "            if \"id\" not in organization:",
            "                raise ValidationError(",
            "                    \"Organization id is required for each organization\"",
            "                )"
        ],
        "afterPatchFile": [
            "import uuid",
            "import ipaddress",
            "",
            "from marshmallow import Schema, fields, ValidationError, validates, validates_schema",
            "from marshmallow.validate import Length, Range, OneOf",
            "",
            "from vantage6.common.task_status import TaskStatus",
            "from vantage6.server.default_roles import DefaultRole",
            "from vantage6.server.model.common.utils import validate_password",
            "",
            "_MAX_LEN_STR_SHORT = 128",
            "_MAX_LEN_STR_LONG = 1024",
            "_MAX_LEN_PW = 128",
            "_MAX_LEN_NAME = 128",
            "",
            "",
            "def _validate_name(name: str) -> None:",
            "    \"\"\"",
            "    Validate a name field in the request input.",
            "",
            "    Parameters",
            "    ----------",
            "    name : str",
            "        Name to validate.",
            "",
            "    Raises",
            "    ------",
            "    ValidationError",
            "        If the name is empty, too long or numerical",
            "    \"\"\"",
            "    if not len(name):",
            "        raise ValidationError(\"Name cannot be empty\")",
            "    if name.isnumeric():",
            "        raise ValidationError(\"Name cannot a number\")",
            "    if len(name) > _MAX_LEN_NAME:",
            "        raise ValidationError(f\"Name cannot be longer than {_MAX_LEN_NAME} characters\")",
            "",
            "",
            "def _validate_password(password: str) -> None:",
            "    \"\"\"",
            "    Check if the password is strong enough.",
            "",
            "    Parameters",
            "    ----------",
            "    password : str",
            "        Password to validate.",
            "",
            "    Raises",
            "    ------",
            "    ValidationError",
            "        If the password is not strong enough.",
            "    \"\"\"",
            "    try:",
            "        validate_password(password)",
            "    except ValueError as e:",
            "        raise ValidationError(str(e))",
            "",
            "",
            "class _OnlyIdSchema(Schema):",
            "    \"\"\"Schema for validating POST requests that only require an ID field.\"\"\"",
            "",
            "    id = fields.Integer(required=True, validate=Range(min=1))",
            "",
            "",
            "class _NameValidationSchema(Schema):",
            "    \"\"\"Schema for validating POST requests with a name field.\"\"\"",
            "",
            "    name = fields.String(required=True)",
            "",
            "    @validates(\"name\")",
            "    def validate_name(self, name: str):",
            "        \"\"\"",
            "        Validate the name in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        name : str",
            "            Name to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the name is empty, too long or numerical",
            "        \"\"\"",
            "        _validate_name(name)",
            "",
            "",
            "class _PasswordValidationSchema(Schema):",
            "    \"\"\"Schema that contains password validation function\"\"\"",
            "",
            "    password = fields.String(required=True)",
            "",
            "    @validates(\"password\")",
            "    def _validate_password(self, password: str):",
            "        \"\"\"",
            "        Check if the password is strong enough.",
            "",
            "        Parameters",
            "        ----------",
            "        password : str",
            "            Password to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the password is not strong enough.",
            "        \"\"\"",
            "        _validate_password(password)",
            "",
            "",
            "class ChangePasswordInputSchema(Schema):",
            "    \"\"\"Schema for validating input for changing a password.\"\"\"",
            "",
            "    # validation for current password is not necessary, as it is checked in the",
            "    # authentication process",
            "    current_password = fields.String(required=True, validate=Length(max=_MAX_LEN_PW))",
            "    new_password = fields.String(required=True)",
            "",
            "    @validates(\"new_password\")",
            "    def validate_password(self, password: str):",
            "        \"\"\"",
            "        Check if the password is strong enough.",
            "",
            "        Parameters",
            "        ----------",
            "        password : str",
            "            Password to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the password is not strong enough.",
            "        \"\"\"",
            "        _validate_password(password)",
            "",
            "",
            "class BasicAuthInputSchema(Schema):",
            "    \"\"\"Schema for validating input for basic authentication using a username and password.\"\"\"",
            "",
            "    username = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_NAME))",
            "    # Note that we don't inherit from _PasswordValidationSchema here and",
            "    # don't validate password in case the password does not fulfill the",
            "    # password policy. This is e.g. the case with the default root user created",
            "    # when the server is started for the first time.",
            "    password = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_PW))",
            "",
            "",
            "class CollaborationInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for a creating a collaboration.\"\"\"",
            "",
            "    organization_ids = fields.List(fields.Integer(), required=True)",
            "    encrypted = fields.Boolean(required=True)",
            "",
            "    @validates(\"organization_ids\")",
            "    def validate_organization_ids(self, organization_ids):",
            "        \"\"\"",
            "        Validate the organization ids in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        organization_ids : list[int]",
            "            List of organization ids to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the organization ids are not valid.",
            "        \"\"\"",
            "        if not all(i > 0 for i in organization_ids):",
            "            raise ValidationError(\"Organization ids must be greater than 0\")",
            "        if not len(organization_ids) == len(set(organization_ids)):",
            "            raise ValidationError(\"Organization ids must be unique\")",
            "        if not len(organization_ids):",
            "            raise ValidationError(\"At least one organization id is required\")",
            "",
            "",
            "class CollaborationAddOrganizationSchema(_OnlyIdSchema):",
            "    \"\"\"",
            "    Schema for validating requests that add an organization to a collaboration.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class CollaborationAddNodeSchema(_OnlyIdSchema):",
            "    \"\"\"Schema for validating requests that add a node to a collaboration.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class KillTaskInputSchema(_OnlyIdSchema):",
            "    \"\"\"Schema for validating input for killing a task.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class KillNodeTasksInputSchema(_OnlyIdSchema):",
            "    \"\"\"Schema for validating input for killing tasks on a node.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class NodeInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for a creating a node.\"\"\"",
            "",
            "    # overwrite name attr as it is not required for a node",
            "    name = fields.String(required=False)",
            "    collaboration_id = fields.Integer(required=True, validate=Range(min=1))",
            "    organization_id = fields.Integer(validate=Range(min=1))",
            "    ip = fields.String()",
            "    clear_ip = fields.Boolean()",
            "",
            "    @validates(\"ip\")",
            "    def validate_ip(self, ip: str):",
            "        \"\"\"",
            "        Validate IP address in request body.",
            "",
            "        Parameters",
            "        ----------",
            "        ip : str",
            "            IP address to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the IP address is not valid.",
            "        \"\"\"",
            "        try:",
            "            ipaddress.ip_address(ip)",
            "        except ValueError:",
            "            raise ValidationError(\"IP address is not valid\")",
            "",
            "",
            "class OrganizationInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for a creating an organization.\"\"\"",
            "",
            "    address1 = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    address2 = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    zipcode = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    country = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    domain = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    public_key = fields.String()",
            "",
            "",
            "class PortInputSchema(Schema):",
            "    \"\"\"Schema for validating input for a creating a port.\"\"\"",
            "",
            "    port = fields.Integer(required=True)",
            "    run_id = fields.Integer(required=True, validate=Range(min=1))",
            "    label = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT), allow_none=True)",
            "",
            "    @validates(\"port\")",
            "    def validate_port(self, port):",
            "        \"\"\"",
            "        Validate the port in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        port : int",
            "            Port to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the port is not valid.",
            "        \"\"\"",
            "        if not 1 <= port <= 65535:",
            "            raise ValidationError(\"Port must be between 1 and 65535\")",
            "",
            "",
            "class RecoverPasswordInputSchema(Schema):",
            "    \"\"\"Schema for validating input for recovering a password.\"\"\"",
            "",
            "    email = fields.Email()",
            "    username = fields.String(validate=Length(max=_MAX_LEN_NAME))",
            "",
            "    @validates_schema",
            "    def validate_email_or_username(self, data: dict, **kwargs) -> None:",
            "        \"\"\"",
            "        Validate the input, which should contain either an email or username.",
            "",
            "        Parameters",
            "        ----------",
            "        data : dict",
            "            The input data. Should contain an email or username.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the input does not contain an email or username.",
            "        \"\"\"",
            "        if not (\"email\" in data or \"username\" in data):",
            "            raise ValidationError(\"Email or username is required\")",
            "",
            "",
            "class ResetPasswordInputSchema(_PasswordValidationSchema):",
            "    \"\"\"Schema for validating input for resetting a password.\"\"\"",
            "",
            "    reset_token = fields.String(required=True, validate=Length(max=_MAX_LEN_STR_LONG))",
            "",
            "",
            "class Recover2FAInputSchema(BasicAuthInputSchema):",
            "    \"\"\"Schema for validating input for recovering 2FA.\"\"\"",
            "",
            "",
            "class Reset2FAInputSchema(Schema):",
            "    \"\"\"Schema for validating input for resetting 2FA.\"\"\"",
            "",
            "    reset_token = fields.String(required=True, validate=Length(max=_MAX_LEN_STR_LONG))",
            "",
            "",
            "class ResetAPIKeyInputSchema(_OnlyIdSchema):",
            "    \"\"\"Schema for validating input for resetting an API key.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class RoleInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for creating a role.\"\"\"",
            "",
            "    description = fields.String(validate=Length(max=_MAX_LEN_STR_LONG))",
            "    rules = fields.List(fields.Integer(validate=Range(min=1)), required=True)",
            "    organization_id = fields.Integer(validate=Range(min=1))",
            "",
            "    @validates(\"name\")",
            "    def validate_name(self, name: str):",
            "        \"\"\"",
            "        Validate that role name is not one of the default roles.",
            "",
            "        Parameters",
            "        ----------",
            "        name : str",
            "            Role name to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the role name is one of the default roles.",
            "        \"\"\"",
            "        if name in [role for role in DefaultRole]:",
            "            raise ValidationError(\"Role name cannot be one of the default roles\")",
            "",
            "",
            "class RunInputSchema(Schema):",
            "    \"\"\"Schema for validating input for patching an algorithm run.\"\"\"",
            "",
            "    started_at = fields.DateTime()",
            "    finished_at = fields.DateTime()",
            "    log = fields.String()",
            "    result = fields.String()",
            "    status = fields.String(validate=OneOf([s.value for s in TaskStatus]))",
            "",
            "",
            "class TaskInputSchema(_NameValidationSchema):",
            "    \"\"\"Schema for validating input for creating a task.\"\"\"",
            "",
            "    # overwrite name attr as it is not required for a task",
            "    name = fields.String(required=False)",
            "    description = fields.String(validate=Length(max=_MAX_LEN_STR_LONG))",
            "    image = fields.String(required=True, validate=Length(min=1))",
            "    collaboration_id = fields.Integer(required=True, validate=Range(min=1))",
            "    organizations = fields.List(fields.Dict(), required=True)",
            "    databases = fields.List(fields.Dict(), allow_none=True)",
            "",
            "    @validates(\"organizations\")",
            "    def validate_organizations(self, organizations: list[dict]):",
            "        \"\"\"",
            "        Validate the organizations in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        organizations : list[dict]",
            "            List of organizations to validate. Each organization must have at",
            "            least an organization id.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the organizations are not valid.",
            "        \"\"\"",
            "        if not len(organizations):",
            "            raise ValidationError(\"At least one organization is required\")",
            "        for organization in organizations:",
            "            if \"id\" not in organization:",
            "                raise ValidationError(",
            "                    \"Organization id is required for each organization\"",
            "                )",
            "",
            "    @validates(\"databases\")",
            "    def validate_databases(self, databases: list[dict]):",
            "        \"\"\"",
            "        Validate the databases in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        databases : list[dict]",
            "            List of databases to validate. Each database must have at",
            "            least a database label.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the databases are not valid.",
            "        \"\"\"",
            "        if databases is None:",
            "            return  # some algorithms don't use any database",
            "        for database in databases:",
            "            if \"label\" not in database:",
            "                raise ValidationError(\"Database label is required for each database\")",
            "            if \"preprocessing\" in database:",
            "                if not isinstance(database[\"preprocessing\"], list):",
            "                    raise ValidationError(",
            "                        \"Database preprocessing must be a list of dictionaries\"",
            "                    )",
            "                # TODO we may add further validation on the preprocessing",
            "                # parameters when that is completed",
            "                for prepro in database[\"preprocessing\"]:",
            "                    if \"function\" not in prepro:",
            "                        raise ValidationError(",
            "                            f\"Database preprocessing {prepro} is missing a \"",
            "                            \"'function'\"",
            "                        )",
            "            allowed_keys = {\"label\", \"preprocessing\", \"query\", \"sheet_name\"}",
            "            if not set(database.keys()).issubset(set(allowed_keys)):",
            "                raise ValidationError(",
            "                    f\"Database {database} contains unknown keys. Allowed keys \"",
            "                    f\"are {allowed_keys}.\"",
            "                )",
            "",
            "class TokenUserInputSchema(BasicAuthInputSchema):",
            "    \"\"\"Schema for validating input for creating a token for a user.\"\"\"",
            "",
            "    mfa_code = fields.String(validate=Length(max=10))",
            "",
            "",
            "class TokenNodeInputSchema(Schema):",
            "    \"\"\"Schema for validating input for creating a token for a node.\"\"\"",
            "",
            "    api_key = fields.String(required=True)",
            "",
            "    @validates(\"api_key\")",
            "    def validate_api_key(self, api_key: str):",
            "        \"\"\"",
            "        Validate the API key in the input. The API key should be a valid UUID",
            "",
            "        Parameters",
            "        ----------",
            "        api_key : str",
            "            API key to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the API key is not valid.",
            "        \"\"\"",
            "        try:",
            "            uuid.UUID(api_key)",
            "        except ValueError:",
            "            raise ValidationError(\"API key is not a valid UUID\")",
            "",
            "",
            "class TokenAlgorithmInputSchema(Schema):",
            "    \"\"\"Schema for validating input for creating a token for an algorithm.\"\"\"",
            "",
            "    task_id = fields.Integer(required=True, validate=Range(min=1))",
            "    image = fields.String(required=True, validate=Length(min=1))",
            "",
            "",
            "class UserInputSchema(_PasswordValidationSchema):",
            "    \"\"\"Schema for validating input for creating a user.\"\"\"",
            "",
            "    username = fields.String(required=True, validate=Length(min=1, max=_MAX_LEN_NAME))",
            "    email = fields.Email(required=True)",
            "    firstname = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    lastname = fields.String(validate=Length(max=_MAX_LEN_STR_SHORT))",
            "    organization_id = fields.Integer(validate=Range(min=1))",
            "    roles = fields.List(fields.Integer(validate=Range(min=1)))",
            "    rules = fields.List(fields.Integer(validate=Range(min=1)))",
            "",
            "    @validates(\"username\")",
            "    def validate_username(self, username: str):",
            "        \"\"\"",
            "        Check if the username is appropriate",
            "",
            "        Parameters",
            "        ----------",
            "        username : str",
            "            Username to validate.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the username is too short, too long or numeric.",
            "        \"\"\"",
            "        _validate_name(username)",
            "",
            "",
            "class VPNConfigUpdateInputSchema(Schema):",
            "    \"\"\"Schema for validating input for updating a VPN configuration.\"\"\"",
            "",
            "    vpn_config = fields.String(required=True)",
            "",
            "",
            "class ColumnNameInputSchema(Schema):",
            "    \"\"\"Schema for validating input for collecting database column names.\"\"\"",
            "",
            "    db_label = fields.String(required=True)",
            "    collaboration_id = fields.Integer(required=True, validate=Range(min=1))",
            "    organizations = fields.List(fields.Dict(), required=True)",
            "    sheet_name = fields.String(required=False)",
            "    query = fields.String(required=False)",
            "",
            "    @validates(\"organizations\")",
            "    def validate_organizations(self, organizations: list[dict]):",
            "        \"\"\"",
            "        Validate the organizations in the input.",
            "",
            "        Parameters",
            "        ----------",
            "        organizations : list[dict]",
            "            List of organizations to validate. Each organization must have at",
            "            least an organization id.",
            "",
            "        Raises",
            "        ------",
            "        ValidationError",
            "            If the organizations are not valid.",
            "        \"\"\"",
            "        if not len(organizations):",
            "            raise ValidationError(\"At least one organization is required\")",
            "        for organization in organizations:",
            "            if \"id\" not in organization:",
            "                raise ValidationError(",
            "                    \"Organization id is required for each organization\"",
            "                )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "291": [
                "Recover2FAInputSchema"
            ],
            "294": [
                "Recover2FAInputSchema"
            ],
            "295": [
                "Recover2FAInputSchema"
            ],
            "296": [
                "Recover2FAInputSchema"
            ],
            "297": [
                "Recover2FAInputSchema"
            ],
            "298": [
                "Recover2FAInputSchema"
            ],
            "299": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "300": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "301": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "302": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "303": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "304": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "305": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "306": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "307": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "308": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "309": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "310": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "311": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "312": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "313": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "314": [
                "Recover2FAInputSchema",
                "validate_email_or_username"
            ],
            "315": [],
            "441": [],
            "442": [
                "TokenUserInputSchema"
            ],
            "445": [
                "TokenUserInputSchema"
            ],
            "446": [
                "TokenUserInputSchema"
            ],
            "447": [
                "TokenUserInputSchema"
            ],
            "448": [
                "TokenUserInputSchema"
            ],
            "449": [
                "TokenUserInputSchema"
            ],
            "450": [
                "TokenUserInputSchema"
            ]
        },
        "addLocation": []
    }
}