{
    "ellipticcurve/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ellipticcurve.utils.compatibility import *"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ellipticcurve.privateKey import PrivateKey"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ellipticcurve.publicKey import PublicKey"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ellipticcurve.signature import Signature"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ellipticcurve.utils.file import File"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ellipticcurve.ecdsa import Ecdsa"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from .utils.compatibility import *"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from .privateKey import PrivateKey"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from .publicKey import PublicKey"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from .signature import Signature"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from .utils.file import File"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from .ecdsa import Ecdsa"
            }
        },
        "frontPatchFile": [
            "from ellipticcurve.utils.compatibility import *",
            "from ellipticcurve.privateKey import PrivateKey",
            "from ellipticcurve.publicKey import PublicKey",
            "from ellipticcurve.signature import Signature",
            "from ellipticcurve.utils.file import File",
            "from ellipticcurve.ecdsa import Ecdsa"
        ],
        "afterPatchFile": [
            "from .utils.compatibility import *",
            "from .privateKey import PrivateKey",
            "from .publicKey import PublicKey",
            "from .signature import Signature",
            "from .utils.file import File",
            "from .ecdsa import Ecdsa"
        ],
        "action": [
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "1": [],
            "2": [],
            "3": [],
            "4": [],
            "5": [],
            "6": []
        },
        "addLocation": []
    },
    "ellipticcurve/ecdsa.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         curve = publicKey.curve"
            },
            "1": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         r = signature.r"
            },
            "2": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         s = signature.s"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        if not 1 <= r <= curve.N - 1:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+            return False"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        if not 1 <= s <= curve.N - 1:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            return False"
            },
            "7": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         inv = Math.inv(s, curve.N)"
            },
            "8": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         u1 = Math.multiply(curve.G, n=(numberMessage * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)"
            },
            "9": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         u2 = Math.multiply(publicKey.point, n=(r * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)"
            }
        },
        "frontPatchFile": [
            "from hashlib import sha256",
            "from .signature import Signature",
            "from .math import Math",
            "from .utils.integer import RandomInteger",
            "from .utils.binary import numberFromByteString",
            "from .utils.compatibility import *",
            "",
            "",
            "class Ecdsa:",
            "",
            "    @classmethod",
            "    def sign(cls, message, privateKey, hashfunc=sha256):",
            "        byteMessage = hashfunc(toBytes(message)).digest()",
            "        numberMessage = numberFromByteString(byteMessage)",
            "        curve = privateKey.curve",
            "",
            "        r, s, randSignPoint = 0, 0, None",
            "        while r == 0 or s == 0:",
            "            randNum = RandomInteger.between(1, curve.N - 1)",
            "            randSignPoint = Math.multiply(curve.G, n=randNum, A=curve.A, P=curve.P, N=curve.N)",
            "            r = randSignPoint.x % curve.N",
            "            s = ((numberMessage + r * privateKey.secret) * (Math.inv(randNum, curve.N))) % curve.N",
            "        recoveryId = randSignPoint.y & 1",
            "        if randSignPoint.y > curve.N:",
            "            recoveryId += 2",
            "",
            "        return Signature(r=r, s=s, recoveryId=recoveryId)",
            "",
            "    @classmethod",
            "    def verify(cls, message, signature, publicKey, hashfunc=sha256):",
            "        byteMessage = hashfunc(toBytes(message)).digest()",
            "        numberMessage = numberFromByteString(byteMessage)",
            "        curve = publicKey.curve",
            "        r = signature.r",
            "        s = signature.s",
            "        inv = Math.inv(s, curve.N)",
            "        u1 = Math.multiply(curve.G, n=(numberMessage * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)",
            "        u2 = Math.multiply(publicKey.point, n=(r * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)",
            "        add = Math.add(u1, u2, A=curve.A, P=curve.P)",
            "        modX = add.x % curve.N",
            "        return r == modX"
        ],
        "afterPatchFile": [
            "from hashlib import sha256",
            "from .signature import Signature",
            "from .math import Math",
            "from .utils.integer import RandomInteger",
            "from .utils.binary import numberFromByteString",
            "from .utils.compatibility import *",
            "",
            "",
            "class Ecdsa:",
            "",
            "    @classmethod",
            "    def sign(cls, message, privateKey, hashfunc=sha256):",
            "        byteMessage = hashfunc(toBytes(message)).digest()",
            "        numberMessage = numberFromByteString(byteMessage)",
            "        curve = privateKey.curve",
            "",
            "        r, s, randSignPoint = 0, 0, None",
            "        while r == 0 or s == 0:",
            "            randNum = RandomInteger.between(1, curve.N - 1)",
            "            randSignPoint = Math.multiply(curve.G, n=randNum, A=curve.A, P=curve.P, N=curve.N)",
            "            r = randSignPoint.x % curve.N",
            "            s = ((numberMessage + r * privateKey.secret) * (Math.inv(randNum, curve.N))) % curve.N",
            "        recoveryId = randSignPoint.y & 1",
            "        if randSignPoint.y > curve.N:",
            "            recoveryId += 2",
            "",
            "        return Signature(r=r, s=s, recoveryId=recoveryId)",
            "",
            "    @classmethod",
            "    def verify(cls, message, signature, publicKey, hashfunc=sha256):",
            "        byteMessage = hashfunc(toBytes(message)).digest()",
            "        numberMessage = numberFromByteString(byteMessage)",
            "        curve = publicKey.curve",
            "        r = signature.r",
            "        s = signature.s",
            "        if not 1 <= r <= curve.N - 1:",
            "            return False",
            "        if not 1 <= s <= curve.N - 1:",
            "            return False",
            "        inv = Math.inv(s, curve.N)",
            "        u1 = Math.multiply(curve.G, n=(numberMessage * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)",
            "        u2 = Math.multiply(publicKey.point, n=(r * inv) % curve.N, N=curve.N, A=curve.A, P=curve.P)",
            "        add = Math.add(u1, u2, A=curve.A, P=curve.P)",
            "        modX = add.x % curve.N",
            "        return r == modX"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.ansible.modules.cloud.google.gcp_compute_region_disk.create"
        ]
    }
}