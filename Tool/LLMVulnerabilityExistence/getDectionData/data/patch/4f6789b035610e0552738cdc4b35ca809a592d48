{
    "src/waitress/channel.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         if self.will_close:"
            },
            "1": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "             self.handle_close()"
            },
            "2": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _flush_exception(self, flush):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+    def _flush_exception(self, flush, do_close=True):"
            },
            "5": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         if flush:"
            },
            "6": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "             try:"
            },
            "7": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return (flush(), False)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+                return (flush(do_close=do_close), False)"
            },
            "9": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "             except OSError:"
            },
            "10": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                 if self.adj.log_socket_errors:"
            },
            "11": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "                     self.logger.exception(\"Socket error\")"
            },
            "12": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         return True"
            },
            "14": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 242,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _flush_some_if_lockable(self):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+    def _flush_some_if_lockable(self, do_close=True):"
            },
            "17": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         # Since our task may be appending to the outbuf, we try to acquire"
            },
            "18": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         # the lock, but we don't block if we can't."
            },
            "19": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 246,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "         if self.outbuf_lock.acquire(False):"
            },
            "21": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "             try:"
            },
            "22": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self._flush_some()"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+                self._flush_some(do_close=do_close)"
            },
            "24": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 250,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "                 if self.total_outbufs_len < self.adj.outbuf_high_watermark:"
            },
            "26": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "                     self.outbuf_lock.notify()"
            },
            "27": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "             finally:"
            },
            "28": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "                 self.outbuf_lock.release()"
            },
            "29": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 255,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _flush_some(self):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+    def _flush_some(self, do_close=True):"
            },
            "32": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         # Send as much data as possible to our client"
            },
            "33": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 258,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "         sent = 0"
            },
            "35": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 267,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "             while outbuflen > 0:"
            },
            "37": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "                 chunk = outbuf.get(self.sendbuf_len)"
            },
            "38": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                num_sent = self.send(chunk)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+                num_sent = self.send(chunk, do_close=do_close)"
            },
            "40": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 271,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "                 if num_sent:"
            },
            "42": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "                     outbuf.skip(num_sent, True)"
            },
            "43": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "                 self.total_outbufs_len += num_bytes"
            },
            "44": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 375,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "                 if self.total_outbufs_len >= self.adj.send_bytes:"
            },
            "46": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    (flushed, exception) = self._flush_exception(self._flush_some)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+                    (flushed, exception) = self._flush_exception("
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+                        self._flush_some, do_close=False"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+                    )"
            },
            "50": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 380,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "                     if ("
            },
            "52": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "                         exception"
            },
            "53": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 394,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "         if self.total_outbufs_len > self.adj.outbuf_high_watermark:"
            },
            "55": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "             with self.outbuf_lock:"
            },
            "56": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                (_, exception) = self._flush_exception(self._flush_some)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+                (_, exception) = self._flush_exception(self._flush_some, do_close=False)"
            },
            "58": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 398,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "                 if exception:"
            },
            "60": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "                     # An exception happened while flushing, wake up the main"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001, 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "import socket",
            "import threading",
            "import time",
            "import traceback",
            "",
            "from waitress.buffers import OverflowableBuffer, ReadOnlyFileBasedBuffer",
            "from waitress.parser import HTTPRequestParser",
            "from waitress.task import ErrorTask, WSGITask",
            "from waitress.utilities import InternalServerError",
            "",
            "from . import wasyncore",
            "",
            "",
            "class ClientDisconnected(Exception):",
            "    \"\"\"Raised when attempting to write to a closed socket.\"\"\"",
            "",
            "",
            "class HTTPChannel(wasyncore.dispatcher):",
            "    \"\"\"",
            "    Setting self.requests = [somerequest] prevents more requests from being",
            "    received until the out buffers have been flushed.",
            "",
            "    Setting self.requests = [] allows more requests to be received.",
            "    \"\"\"",
            "",
            "    task_class = WSGITask",
            "    error_task_class = ErrorTask",
            "    parser_class = HTTPRequestParser",
            "",
            "    # A request that has not been received yet completely is stored here",
            "    request = None",
            "    last_activity = 0  # Time of last activity",
            "    will_close = False  # set to True to close the socket.",
            "    close_when_flushed = False  # set to True to close the socket when flushed",
            "    sent_continue = False  # used as a latch after sending 100 continue",
            "    total_outbufs_len = 0  # total bytes ready to send",
            "    current_outbuf_count = 0  # total bytes written to current outbuf",
            "",
            "    #",
            "    # ASYNCHRONOUS METHODS (including __init__)",
            "    #",
            "",
            "    def __init__(self, server, sock, addr, adj, map=None):",
            "        self.server = server",
            "        self.adj = adj",
            "        self.outbufs = [OverflowableBuffer(adj.outbuf_overflow)]",
            "        self.creation_time = self.last_activity = time.time()",
            "        self.sendbuf_len = sock.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)",
            "",
            "        # requests_lock used to push/pop requests and modify the request that is",
            "        # currently being created",
            "        self.requests_lock = threading.Lock()",
            "        # outbuf_lock used to access any outbuf (expected to use an RLock)",
            "        self.outbuf_lock = threading.Condition()",
            "",
            "        wasyncore.dispatcher.__init__(self, sock, map=map)",
            "",
            "        # Don't let wasyncore.dispatcher throttle self.addr on us.",
            "        self.addr = addr",
            "        self.requests = []",
            "",
            "    def check_client_disconnected(self):",
            "        \"\"\"",
            "        This method is inserted into the environment of any created task so it",
            "        may occasionally check if the client has disconnected and interrupt",
            "        execution.",
            "        \"\"\"",
            "",
            "        return not self.connected",
            "",
            "    def writable(self):",
            "        # if there's data in the out buffer or we've been instructed to close",
            "        # the channel (possibly by our server maintenance logic), run",
            "        # handle_write",
            "",
            "        return self.total_outbufs_len or self.will_close or self.close_when_flushed",
            "",
            "    def handle_write(self):",
            "        # Precondition: there's data in the out buffer to be sent, or",
            "        # there's a pending will_close request",
            "",
            "        if not self.connected:",
            "            # we dont want to close the channel twice",
            "",
            "            return",
            "",
            "        # try to flush any pending output",
            "",
            "        if not self.requests:",
            "            # 1. There are no running tasks, so we don't need to try to lock",
            "            #    the outbuf before sending",
            "            # 2. The data in the out buffer should be sent as soon as possible",
            "            #    because it's either data left over from task output",
            "            #    or a 100 Continue line sent within \"received\".",
            "            flush = self._flush_some",
            "        elif self.total_outbufs_len >= self.adj.send_bytes:",
            "            # 1. There's a running task, so we need to try to lock",
            "            #    the outbuf before sending",
            "            # 2. Only try to send if the data in the out buffer is larger",
            "            #    than self.adj_bytes to avoid TCP fragmentation",
            "            flush = self._flush_some_if_lockable",
            "        else:",
            "            # 1. There's not enough data in the out buffer to bother to send",
            "            #    right now.",
            "            flush = None",
            "",
            "        self._flush_exception(flush)",
            "",
            "        if self.close_when_flushed and not self.total_outbufs_len:",
            "            self.close_when_flushed = False",
            "            self.will_close = True",
            "",
            "        if self.will_close:",
            "            self.handle_close()",
            "",
            "    def _flush_exception(self, flush):",
            "        if flush:",
            "            try:",
            "                return (flush(), False)",
            "            except OSError:",
            "                if self.adj.log_socket_errors:",
            "                    self.logger.exception(\"Socket error\")",
            "                self.will_close = True",
            "",
            "                return (False, True)",
            "            except Exception:  # pragma: nocover",
            "                self.logger.exception(\"Unexpected exception when flushing\")",
            "                self.will_close = True",
            "",
            "                return (False, True)",
            "",
            "    def readable(self):",
            "        # We might want to read more requests. We can only do this if:",
            "        # 1. We're not already about to close the connection.",
            "        # 2. We're not waiting to flush remaining data before closing the",
            "        #    connection",
            "        # 3. There are not too many tasks already queued",
            "        # 4. There's no data in the output buffer that needs to be sent",
            "        #    before we potentially create a new task.",
            "",
            "        return not (",
            "            self.will_close",
            "            or self.close_when_flushed",
            "            or len(self.requests) > self.adj.channel_request_lookahead",
            "            or self.total_outbufs_len",
            "        )",
            "",
            "    def handle_read(self):",
            "        try:",
            "            data = self.recv(self.adj.recv_bytes)",
            "        except OSError:",
            "            if self.adj.log_socket_errors:",
            "                self.logger.exception(\"Socket error\")",
            "            self.handle_close()",
            "",
            "            return",
            "",
            "        if data:",
            "            self.last_activity = time.time()",
            "            self.received(data)",
            "        else:",
            "            # Client disconnected.",
            "            self.connected = False",
            "",
            "    def send_continue(self):",
            "        \"\"\"",
            "        Send a 100-Continue header to the client. This is either called from",
            "        receive (if no requests are running and the client expects it) or at",
            "        the end of service (if no more requests are queued and a request has",
            "        been read partially that expects it).",
            "        \"\"\"",
            "        self.request.expect_continue = False",
            "        outbuf_payload = b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"",
            "        num_bytes = len(outbuf_payload)",
            "        with self.outbuf_lock:",
            "            self.outbufs[-1].append(outbuf_payload)",
            "            self.current_outbuf_count += num_bytes",
            "            self.total_outbufs_len += num_bytes",
            "            self.sent_continue = True",
            "            self._flush_some()",
            "        self.request.completed = False",
            "",
            "    def received(self, data):",
            "        \"\"\"",
            "        Receives input asynchronously and assigns one or more requests to the",
            "        channel.",
            "        \"\"\"",
            "",
            "        if not data:",
            "            return False",
            "",
            "        with self.requests_lock:",
            "            while data:",
            "                if self.request is None:",
            "                    self.request = self.parser_class(self.adj)",
            "                n = self.request.received(data)",
            "",
            "                # if there are requests queued, we can not send the continue",
            "                # header yet since the responses need to be kept in order",
            "",
            "                if (",
            "                    self.request.expect_continue",
            "                    and self.request.headers_finished",
            "                    and not self.requests",
            "                    and not self.sent_continue",
            "                ):",
            "                    self.send_continue()",
            "",
            "                if self.request.completed:",
            "                    # The request (with the body) is ready to use.",
            "                    self.sent_continue = False",
            "",
            "                    if not self.request.empty:",
            "                        self.requests.append(self.request)",
            "",
            "                        if len(self.requests) == 1:",
            "                            # self.requests was empty before so the main thread",
            "                            # is in charge of starting the task. Otherwise,",
            "                            # service() will add a new task after each request",
            "                            # has been processed",
            "                            self.server.add_task(self)",
            "                    self.request = None",
            "",
            "                if n >= len(data):",
            "                    break",
            "                data = data[n:]",
            "",
            "        return True",
            "",
            "    def _flush_some_if_lockable(self):",
            "        # Since our task may be appending to the outbuf, we try to acquire",
            "        # the lock, but we don't block if we can't.",
            "",
            "        if self.outbuf_lock.acquire(False):",
            "            try:",
            "                self._flush_some()",
            "",
            "                if self.total_outbufs_len < self.adj.outbuf_high_watermark:",
            "                    self.outbuf_lock.notify()",
            "            finally:",
            "                self.outbuf_lock.release()",
            "",
            "    def _flush_some(self):",
            "        # Send as much data as possible to our client",
            "",
            "        sent = 0",
            "        dobreak = False",
            "",
            "        while True:",
            "            outbuf = self.outbufs[0]",
            "            # use outbuf.__len__ rather than len(outbuf) FBO of not getting",
            "            # OverflowError on 32-bit Python",
            "            outbuflen = outbuf.__len__()",
            "",
            "            while outbuflen > 0:",
            "                chunk = outbuf.get(self.sendbuf_len)",
            "                num_sent = self.send(chunk)",
            "",
            "                if num_sent:",
            "                    outbuf.skip(num_sent, True)",
            "                    outbuflen -= num_sent",
            "                    sent += num_sent",
            "                    self.total_outbufs_len -= num_sent",
            "                else:",
            "                    # failed to write anything, break out entirely",
            "                    dobreak = True",
            "",
            "                    break",
            "            else:",
            "                # self.outbufs[-1] must always be a writable outbuf",
            "",
            "                if len(self.outbufs) > 1:",
            "                    toclose = self.outbufs.pop(0)",
            "                    try:",
            "                        toclose.close()",
            "                    except Exception:",
            "                        self.logger.exception(\"Unexpected error when closing an outbuf\")",
            "                else:",
            "                    # caught up, done flushing for now",
            "                    dobreak = True",
            "",
            "            if dobreak:",
            "                break",
            "",
            "        if sent:",
            "            self.last_activity = time.time()",
            "",
            "            return True",
            "",
            "        return False",
            "",
            "    def handle_close(self):",
            "        with self.outbuf_lock:",
            "            for outbuf in self.outbufs:",
            "                try:",
            "                    outbuf.close()",
            "                except Exception:",
            "                    self.logger.exception(",
            "                        \"Unknown exception while trying to close outbuf\"",
            "                    )",
            "            self.total_outbufs_len = 0",
            "            self.connected = False",
            "            self.outbuf_lock.notify()",
            "        wasyncore.dispatcher.close(self)",
            "",
            "    def add_channel(self, map=None):",
            "        \"\"\"See wasyncore.dispatcher",
            "",
            "        This hook keeps track of opened channels.",
            "        \"\"\"",
            "        wasyncore.dispatcher.add_channel(self, map)",
            "        self.server.active_channels[self._fileno] = self",
            "",
            "    def del_channel(self, map=None):",
            "        \"\"\"See wasyncore.dispatcher",
            "",
            "        This hook keeps track of closed channels.",
            "        \"\"\"",
            "        fd = self._fileno  # next line sets this to None",
            "        wasyncore.dispatcher.del_channel(self, map)",
            "        ac = self.server.active_channels",
            "",
            "        if fd in ac:",
            "            del ac[fd]",
            "",
            "    #",
            "    # SYNCHRONOUS METHODS",
            "    #",
            "",
            "    def write_soon(self, data):",
            "        if not self.connected:",
            "            # if the socket is closed then interrupt the task so that it",
            "            # can cleanup possibly before the app_iter is exhausted",
            "            raise ClientDisconnected",
            "",
            "        if data:",
            "            # the async mainloop might be popping data off outbuf; we can",
            "            # block here waiting for it because we're in a task thread",
            "            with self.outbuf_lock:",
            "                self._flush_outbufs_below_high_watermark()",
            "",
            "                if not self.connected:",
            "                    raise ClientDisconnected",
            "                num_bytes = len(data)",
            "",
            "                if data.__class__ is ReadOnlyFileBasedBuffer:",
            "                    # they used wsgi.file_wrapper",
            "                    self.outbufs.append(data)",
            "                    nextbuf = OverflowableBuffer(self.adj.outbuf_overflow)",
            "                    self.outbufs.append(nextbuf)",
            "                    self.current_outbuf_count = 0",
            "                else:",
            "                    if self.current_outbuf_count >= self.adj.outbuf_high_watermark:",
            "                        # rotate to a new buffer if the current buffer has hit",
            "                        # the watermark to avoid it growing unbounded",
            "                        nextbuf = OverflowableBuffer(self.adj.outbuf_overflow)",
            "                        self.outbufs.append(nextbuf)",
            "                        self.current_outbuf_count = 0",
            "                    self.outbufs[-1].append(data)",
            "                    self.current_outbuf_count += num_bytes",
            "                self.total_outbufs_len += num_bytes",
            "",
            "                if self.total_outbufs_len >= self.adj.send_bytes:",
            "                    (flushed, exception) = self._flush_exception(self._flush_some)",
            "",
            "                    if (",
            "                        exception",
            "                        or not flushed",
            "                        or self.total_outbufs_len >= self.adj.send_bytes",
            "                    ):",
            "                        self.server.pull_trigger()",
            "",
            "            return num_bytes",
            "",
            "        return 0",
            "",
            "    def _flush_outbufs_below_high_watermark(self):",
            "        # check first to avoid locking if possible",
            "",
            "        if self.total_outbufs_len > self.adj.outbuf_high_watermark:",
            "            with self.outbuf_lock:",
            "                (_, exception) = self._flush_exception(self._flush_some)",
            "",
            "                if exception:",
            "                    # An exception happened while flushing, wake up the main",
            "                    # thread, then wait for it to decide what to do next",
            "                    # (probably close the socket, and then just return)",
            "                    self.server.pull_trigger()",
            "                    self.outbuf_lock.wait()",
            "",
            "                    return",
            "",
            "                while (",
            "                    self.connected",
            "                    and self.total_outbufs_len > self.adj.outbuf_high_watermark",
            "                ):",
            "                    self.server.pull_trigger()",
            "                    self.outbuf_lock.wait()",
            "",
            "    def service(self):",
            "        \"\"\"Execute one request. If there are more, we add another task to the",
            "        server at the end.\"\"\"",
            "",
            "        request = self.requests[0]",
            "",
            "        if request.error:",
            "            task = self.error_task_class(self, request)",
            "        else:",
            "            task = self.task_class(self, request)",
            "",
            "        try:",
            "            if self.connected:",
            "                task.service()",
            "            else:",
            "                task.close_on_finish = True",
            "        except ClientDisconnected:",
            "            self.logger.info(\"Client disconnected while serving %s\" % task.request.path)",
            "            task.close_on_finish = True",
            "        except Exception:",
            "            self.logger.exception(\"Exception while serving %s\" % task.request.path)",
            "",
            "            if not task.wrote_header:",
            "                if self.adj.expose_tracebacks:",
            "                    body = traceback.format_exc()",
            "                else:",
            "                    body = \"The server encountered an unexpected internal server error\"",
            "                req_version = request.version",
            "                req_headers = request.headers",
            "                err_request = self.parser_class(self.adj)",
            "                err_request.error = InternalServerError(body)",
            "                # copy some original request attributes to fulfill",
            "                # HTTP 1.1 requirements",
            "                err_request.version = req_version",
            "                try:",
            "                    err_request.headers[\"CONNECTION\"] = req_headers[\"CONNECTION\"]",
            "                except KeyError:",
            "                    pass",
            "                task = self.error_task_class(self, err_request)",
            "                try:",
            "                    task.service()  # must not fail",
            "                except ClientDisconnected:",
            "                    task.close_on_finish = True",
            "            else:",
            "                task.close_on_finish = True",
            "",
            "        if task.close_on_finish:",
            "            with self.requests_lock:",
            "                self.close_when_flushed = True",
            "",
            "                for request in self.requests:",
            "                    request.close()",
            "                self.requests = []",
            "        else:",
            "            # before processing a new request, ensure there is not too",
            "            # much data in the outbufs waiting to be flushed",
            "            # NB: currently readable() returns False while we are",
            "            # flushing data so we know no new requests will come in",
            "            # that we need to account for, otherwise it'd be better",
            "            # to do this check at the start of the request instead of",
            "            # at the end to account for consecutive service() calls",
            "",
            "            if len(self.requests) > 1:",
            "                self._flush_outbufs_below_high_watermark()",
            "",
            "            # this is a little hacky but basically it's forcing the",
            "            # next request to create a new outbuf to avoid sharing",
            "            # outbufs across requests which can cause outbufs to",
            "            # not be deallocated regularly when a connection is open",
            "            # for a long time",
            "",
            "            if self.current_outbuf_count > 0:",
            "                self.current_outbuf_count = self.adj.outbuf_high_watermark",
            "",
            "            request.close()",
            "",
            "            # Add new task to process the next request",
            "            with self.requests_lock:",
            "                self.requests.pop(0)",
            "",
            "                if self.connected and self.requests:",
            "                    self.server.add_task(self)",
            "                elif (",
            "                    self.connected",
            "                    and self.request is not None",
            "                    and self.request.expect_continue",
            "                    and self.request.headers_finished",
            "                    and not self.sent_continue",
            "                ):",
            "                    # A request waits for a signal to continue, but we could",
            "                    # not send it until now because requests were being",
            "                    # processed and the output needs to be kept in order",
            "                    self.send_continue()",
            "",
            "        if self.connected:",
            "            self.server.pull_trigger()",
            "",
            "        self.last_activity = time.time()",
            "",
            "    def cancel(self):",
            "        \"\"\"Cancels all pending / active requests\"\"\"",
            "        self.will_close = True",
            "        self.connected = False",
            "        self.last_activity = time.time()",
            "        self.requests = []"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001, 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "import socket",
            "import threading",
            "import time",
            "import traceback",
            "",
            "from waitress.buffers import OverflowableBuffer, ReadOnlyFileBasedBuffer",
            "from waitress.parser import HTTPRequestParser",
            "from waitress.task import ErrorTask, WSGITask",
            "from waitress.utilities import InternalServerError",
            "",
            "from . import wasyncore",
            "",
            "",
            "class ClientDisconnected(Exception):",
            "    \"\"\"Raised when attempting to write to a closed socket.\"\"\"",
            "",
            "",
            "class HTTPChannel(wasyncore.dispatcher):",
            "    \"\"\"",
            "    Setting self.requests = [somerequest] prevents more requests from being",
            "    received until the out buffers have been flushed.",
            "",
            "    Setting self.requests = [] allows more requests to be received.",
            "    \"\"\"",
            "",
            "    task_class = WSGITask",
            "    error_task_class = ErrorTask",
            "    parser_class = HTTPRequestParser",
            "",
            "    # A request that has not been received yet completely is stored here",
            "    request = None",
            "    last_activity = 0  # Time of last activity",
            "    will_close = False  # set to True to close the socket.",
            "    close_when_flushed = False  # set to True to close the socket when flushed",
            "    sent_continue = False  # used as a latch after sending 100 continue",
            "    total_outbufs_len = 0  # total bytes ready to send",
            "    current_outbuf_count = 0  # total bytes written to current outbuf",
            "",
            "    #",
            "    # ASYNCHRONOUS METHODS (including __init__)",
            "    #",
            "",
            "    def __init__(self, server, sock, addr, adj, map=None):",
            "        self.server = server",
            "        self.adj = adj",
            "        self.outbufs = [OverflowableBuffer(adj.outbuf_overflow)]",
            "        self.creation_time = self.last_activity = time.time()",
            "        self.sendbuf_len = sock.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)",
            "",
            "        # requests_lock used to push/pop requests and modify the request that is",
            "        # currently being created",
            "        self.requests_lock = threading.Lock()",
            "        # outbuf_lock used to access any outbuf (expected to use an RLock)",
            "        self.outbuf_lock = threading.Condition()",
            "",
            "        wasyncore.dispatcher.__init__(self, sock, map=map)",
            "",
            "        # Don't let wasyncore.dispatcher throttle self.addr on us.",
            "        self.addr = addr",
            "        self.requests = []",
            "",
            "    def check_client_disconnected(self):",
            "        \"\"\"",
            "        This method is inserted into the environment of any created task so it",
            "        may occasionally check if the client has disconnected and interrupt",
            "        execution.",
            "        \"\"\"",
            "",
            "        return not self.connected",
            "",
            "    def writable(self):",
            "        # if there's data in the out buffer or we've been instructed to close",
            "        # the channel (possibly by our server maintenance logic), run",
            "        # handle_write",
            "",
            "        return self.total_outbufs_len or self.will_close or self.close_when_flushed",
            "",
            "    def handle_write(self):",
            "        # Precondition: there's data in the out buffer to be sent, or",
            "        # there's a pending will_close request",
            "",
            "        if not self.connected:",
            "            # we dont want to close the channel twice",
            "",
            "            return",
            "",
            "        # try to flush any pending output",
            "",
            "        if not self.requests:",
            "            # 1. There are no running tasks, so we don't need to try to lock",
            "            #    the outbuf before sending",
            "            # 2. The data in the out buffer should be sent as soon as possible",
            "            #    because it's either data left over from task output",
            "            #    or a 100 Continue line sent within \"received\".",
            "            flush = self._flush_some",
            "        elif self.total_outbufs_len >= self.adj.send_bytes:",
            "            # 1. There's a running task, so we need to try to lock",
            "            #    the outbuf before sending",
            "            # 2. Only try to send if the data in the out buffer is larger",
            "            #    than self.adj_bytes to avoid TCP fragmentation",
            "            flush = self._flush_some_if_lockable",
            "        else:",
            "            # 1. There's not enough data in the out buffer to bother to send",
            "            #    right now.",
            "            flush = None",
            "",
            "        self._flush_exception(flush)",
            "",
            "        if self.close_when_flushed and not self.total_outbufs_len:",
            "            self.close_when_flushed = False",
            "            self.will_close = True",
            "",
            "        if self.will_close:",
            "            self.handle_close()",
            "",
            "    def _flush_exception(self, flush, do_close=True):",
            "        if flush:",
            "            try:",
            "                return (flush(do_close=do_close), False)",
            "            except OSError:",
            "                if self.adj.log_socket_errors:",
            "                    self.logger.exception(\"Socket error\")",
            "                self.will_close = True",
            "",
            "                return (False, True)",
            "            except Exception:  # pragma: nocover",
            "                self.logger.exception(\"Unexpected exception when flushing\")",
            "                self.will_close = True",
            "",
            "                return (False, True)",
            "",
            "    def readable(self):",
            "        # We might want to read more requests. We can only do this if:",
            "        # 1. We're not already about to close the connection.",
            "        # 2. We're not waiting to flush remaining data before closing the",
            "        #    connection",
            "        # 3. There are not too many tasks already queued",
            "        # 4. There's no data in the output buffer that needs to be sent",
            "        #    before we potentially create a new task.",
            "",
            "        return not (",
            "            self.will_close",
            "            or self.close_when_flushed",
            "            or len(self.requests) > self.adj.channel_request_lookahead",
            "            or self.total_outbufs_len",
            "        )",
            "",
            "    def handle_read(self):",
            "        try:",
            "            data = self.recv(self.adj.recv_bytes)",
            "        except OSError:",
            "            if self.adj.log_socket_errors:",
            "                self.logger.exception(\"Socket error\")",
            "            self.handle_close()",
            "",
            "            return",
            "",
            "        if data:",
            "            self.last_activity = time.time()",
            "            self.received(data)",
            "        else:",
            "            # Client disconnected.",
            "            self.connected = False",
            "",
            "    def send_continue(self):",
            "        \"\"\"",
            "        Send a 100-Continue header to the client. This is either called from",
            "        receive (if no requests are running and the client expects it) or at",
            "        the end of service (if no more requests are queued and a request has",
            "        been read partially that expects it).",
            "        \"\"\"",
            "        self.request.expect_continue = False",
            "        outbuf_payload = b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"",
            "        num_bytes = len(outbuf_payload)",
            "        with self.outbuf_lock:",
            "            self.outbufs[-1].append(outbuf_payload)",
            "            self.current_outbuf_count += num_bytes",
            "            self.total_outbufs_len += num_bytes",
            "            self.sent_continue = True",
            "            self._flush_some()",
            "        self.request.completed = False",
            "",
            "    def received(self, data):",
            "        \"\"\"",
            "        Receives input asynchronously and assigns one or more requests to the",
            "        channel.",
            "        \"\"\"",
            "",
            "        if not data:",
            "            return False",
            "",
            "        with self.requests_lock:",
            "            while data:",
            "                if self.request is None:",
            "                    self.request = self.parser_class(self.adj)",
            "                n = self.request.received(data)",
            "",
            "                # if there are requests queued, we can not send the continue",
            "                # header yet since the responses need to be kept in order",
            "",
            "                if (",
            "                    self.request.expect_continue",
            "                    and self.request.headers_finished",
            "                    and not self.requests",
            "                    and not self.sent_continue",
            "                ):",
            "                    self.send_continue()",
            "",
            "                if self.request.completed:",
            "                    # The request (with the body) is ready to use.",
            "                    self.sent_continue = False",
            "",
            "                    if not self.request.empty:",
            "                        self.requests.append(self.request)",
            "",
            "                        if len(self.requests) == 1:",
            "                            # self.requests was empty before so the main thread",
            "                            # is in charge of starting the task. Otherwise,",
            "                            # service() will add a new task after each request",
            "                            # has been processed",
            "                            self.server.add_task(self)",
            "                    self.request = None",
            "",
            "                if n >= len(data):",
            "                    break",
            "                data = data[n:]",
            "",
            "        return True",
            "",
            "    def _flush_some_if_lockable(self, do_close=True):",
            "        # Since our task may be appending to the outbuf, we try to acquire",
            "        # the lock, but we don't block if we can't.",
            "",
            "        if self.outbuf_lock.acquire(False):",
            "            try:",
            "                self._flush_some(do_close=do_close)",
            "",
            "                if self.total_outbufs_len < self.adj.outbuf_high_watermark:",
            "                    self.outbuf_lock.notify()",
            "            finally:",
            "                self.outbuf_lock.release()",
            "",
            "    def _flush_some(self, do_close=True):",
            "        # Send as much data as possible to our client",
            "",
            "        sent = 0",
            "        dobreak = False",
            "",
            "        while True:",
            "            outbuf = self.outbufs[0]",
            "            # use outbuf.__len__ rather than len(outbuf) FBO of not getting",
            "            # OverflowError on 32-bit Python",
            "            outbuflen = outbuf.__len__()",
            "",
            "            while outbuflen > 0:",
            "                chunk = outbuf.get(self.sendbuf_len)",
            "                num_sent = self.send(chunk, do_close=do_close)",
            "",
            "                if num_sent:",
            "                    outbuf.skip(num_sent, True)",
            "                    outbuflen -= num_sent",
            "                    sent += num_sent",
            "                    self.total_outbufs_len -= num_sent",
            "                else:",
            "                    # failed to write anything, break out entirely",
            "                    dobreak = True",
            "",
            "                    break",
            "            else:",
            "                # self.outbufs[-1] must always be a writable outbuf",
            "",
            "                if len(self.outbufs) > 1:",
            "                    toclose = self.outbufs.pop(0)",
            "                    try:",
            "                        toclose.close()",
            "                    except Exception:",
            "                        self.logger.exception(\"Unexpected error when closing an outbuf\")",
            "                else:",
            "                    # caught up, done flushing for now",
            "                    dobreak = True",
            "",
            "            if dobreak:",
            "                break",
            "",
            "        if sent:",
            "            self.last_activity = time.time()",
            "",
            "            return True",
            "",
            "        return False",
            "",
            "    def handle_close(self):",
            "        with self.outbuf_lock:",
            "            for outbuf in self.outbufs:",
            "                try:",
            "                    outbuf.close()",
            "                except Exception:",
            "                    self.logger.exception(",
            "                        \"Unknown exception while trying to close outbuf\"",
            "                    )",
            "            self.total_outbufs_len = 0",
            "            self.connected = False",
            "            self.outbuf_lock.notify()",
            "        wasyncore.dispatcher.close(self)",
            "",
            "    def add_channel(self, map=None):",
            "        \"\"\"See wasyncore.dispatcher",
            "",
            "        This hook keeps track of opened channels.",
            "        \"\"\"",
            "        wasyncore.dispatcher.add_channel(self, map)",
            "        self.server.active_channels[self._fileno] = self",
            "",
            "    def del_channel(self, map=None):",
            "        \"\"\"See wasyncore.dispatcher",
            "",
            "        This hook keeps track of closed channels.",
            "        \"\"\"",
            "        fd = self._fileno  # next line sets this to None",
            "        wasyncore.dispatcher.del_channel(self, map)",
            "        ac = self.server.active_channels",
            "",
            "        if fd in ac:",
            "            del ac[fd]",
            "",
            "    #",
            "    # SYNCHRONOUS METHODS",
            "    #",
            "",
            "    def write_soon(self, data):",
            "        if not self.connected:",
            "            # if the socket is closed then interrupt the task so that it",
            "            # can cleanup possibly before the app_iter is exhausted",
            "            raise ClientDisconnected",
            "",
            "        if data:",
            "            # the async mainloop might be popping data off outbuf; we can",
            "            # block here waiting for it because we're in a task thread",
            "            with self.outbuf_lock:",
            "                self._flush_outbufs_below_high_watermark()",
            "",
            "                if not self.connected:",
            "                    raise ClientDisconnected",
            "                num_bytes = len(data)",
            "",
            "                if data.__class__ is ReadOnlyFileBasedBuffer:",
            "                    # they used wsgi.file_wrapper",
            "                    self.outbufs.append(data)",
            "                    nextbuf = OverflowableBuffer(self.adj.outbuf_overflow)",
            "                    self.outbufs.append(nextbuf)",
            "                    self.current_outbuf_count = 0",
            "                else:",
            "                    if self.current_outbuf_count >= self.adj.outbuf_high_watermark:",
            "                        # rotate to a new buffer if the current buffer has hit",
            "                        # the watermark to avoid it growing unbounded",
            "                        nextbuf = OverflowableBuffer(self.adj.outbuf_overflow)",
            "                        self.outbufs.append(nextbuf)",
            "                        self.current_outbuf_count = 0",
            "                    self.outbufs[-1].append(data)",
            "                    self.current_outbuf_count += num_bytes",
            "                self.total_outbufs_len += num_bytes",
            "",
            "                if self.total_outbufs_len >= self.adj.send_bytes:",
            "                    (flushed, exception) = self._flush_exception(",
            "                        self._flush_some, do_close=False",
            "                    )",
            "",
            "                    if (",
            "                        exception",
            "                        or not flushed",
            "                        or self.total_outbufs_len >= self.adj.send_bytes",
            "                    ):",
            "                        self.server.pull_trigger()",
            "",
            "            return num_bytes",
            "",
            "        return 0",
            "",
            "    def _flush_outbufs_below_high_watermark(self):",
            "        # check first to avoid locking if possible",
            "",
            "        if self.total_outbufs_len > self.adj.outbuf_high_watermark:",
            "            with self.outbuf_lock:",
            "                (_, exception) = self._flush_exception(self._flush_some, do_close=False)",
            "",
            "                if exception:",
            "                    # An exception happened while flushing, wake up the main",
            "                    # thread, then wait for it to decide what to do next",
            "                    # (probably close the socket, and then just return)",
            "                    self.server.pull_trigger()",
            "                    self.outbuf_lock.wait()",
            "",
            "                    return",
            "",
            "                while (",
            "                    self.connected",
            "                    and self.total_outbufs_len > self.adj.outbuf_high_watermark",
            "                ):",
            "                    self.server.pull_trigger()",
            "                    self.outbuf_lock.wait()",
            "",
            "    def service(self):",
            "        \"\"\"Execute one request. If there are more, we add another task to the",
            "        server at the end.\"\"\"",
            "",
            "        request = self.requests[0]",
            "",
            "        if request.error:",
            "            task = self.error_task_class(self, request)",
            "        else:",
            "            task = self.task_class(self, request)",
            "",
            "        try:",
            "            if self.connected:",
            "                task.service()",
            "            else:",
            "                task.close_on_finish = True",
            "        except ClientDisconnected:",
            "            self.logger.info(\"Client disconnected while serving %s\" % task.request.path)",
            "            task.close_on_finish = True",
            "        except Exception:",
            "            self.logger.exception(\"Exception while serving %s\" % task.request.path)",
            "",
            "            if not task.wrote_header:",
            "                if self.adj.expose_tracebacks:",
            "                    body = traceback.format_exc()",
            "                else:",
            "                    body = \"The server encountered an unexpected internal server error\"",
            "                req_version = request.version",
            "                req_headers = request.headers",
            "                err_request = self.parser_class(self.adj)",
            "                err_request.error = InternalServerError(body)",
            "                # copy some original request attributes to fulfill",
            "                # HTTP 1.1 requirements",
            "                err_request.version = req_version",
            "                try:",
            "                    err_request.headers[\"CONNECTION\"] = req_headers[\"CONNECTION\"]",
            "                except KeyError:",
            "                    pass",
            "                task = self.error_task_class(self, err_request)",
            "                try:",
            "                    task.service()  # must not fail",
            "                except ClientDisconnected:",
            "                    task.close_on_finish = True",
            "            else:",
            "                task.close_on_finish = True",
            "",
            "        if task.close_on_finish:",
            "            with self.requests_lock:",
            "                self.close_when_flushed = True",
            "",
            "                for request in self.requests:",
            "                    request.close()",
            "                self.requests = []",
            "        else:",
            "            # before processing a new request, ensure there is not too",
            "            # much data in the outbufs waiting to be flushed",
            "            # NB: currently readable() returns False while we are",
            "            # flushing data so we know no new requests will come in",
            "            # that we need to account for, otherwise it'd be better",
            "            # to do this check at the start of the request instead of",
            "            # at the end to account for consecutive service() calls",
            "",
            "            if len(self.requests) > 1:",
            "                self._flush_outbufs_below_high_watermark()",
            "",
            "            # this is a little hacky but basically it's forcing the",
            "            # next request to create a new outbuf to avoid sharing",
            "            # outbufs across requests which can cause outbufs to",
            "            # not be deallocated regularly when a connection is open",
            "            # for a long time",
            "",
            "            if self.current_outbuf_count > 0:",
            "                self.current_outbuf_count = self.adj.outbuf_high_watermark",
            "",
            "            request.close()",
            "",
            "            # Add new task to process the next request",
            "            with self.requests_lock:",
            "                self.requests.pop(0)",
            "",
            "                if self.connected and self.requests:",
            "                    self.server.add_task(self)",
            "                elif (",
            "                    self.connected",
            "                    and self.request is not None",
            "                    and self.request.expect_continue",
            "                    and self.request.headers_finished",
            "                    and not self.sent_continue",
            "                ):",
            "                    # A request waits for a signal to continue, but we could",
            "                    # not send it until now because requests were being",
            "                    # processed and the output needs to be kept in order",
            "                    self.send_continue()",
            "",
            "        if self.connected:",
            "            self.server.pull_trigger()",
            "",
            "        self.last_activity = time.time()",
            "",
            "    def cancel(self):",
            "        \"\"\"Cancels all pending / active requests\"\"\"",
            "        self.will_close = True",
            "        self.connected = False",
            "        self.last_activity = time.time()",
            "        self.requests = []"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "129": [
                "HTTPChannel",
                "_flush_exception"
            ],
            "132": [
                "HTTPChannel",
                "_flush_exception"
            ],
            "243": [
                "HTTPChannel",
                "_flush_some_if_lockable"
            ],
            "249": [
                "HTTPChannel",
                "_flush_some_if_lockable"
            ],
            "256": [
                "HTTPChannel",
                "_flush_some"
            ],
            "270": [
                "HTTPChannel",
                "_flush_some"
            ],
            "377": [
                "HTTPChannel",
                "write_soon"
            ],
            "395": [
                "HTTPChannel",
                "_flush_outbufs_below_high_watermark"
            ]
        },
        "addLocation": []
    },
    "src/waitress/wasyncore.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": 426,
                "PatchRowcode": "         else:"
            },
            "1": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 427,
                "PatchRowcode": "             return conn, addr"
            },
            "2": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 428,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def send(self, data):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+    def send(self, data, do_close=True):"
            },
            "5": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": 430,
                "PatchRowcode": "         try:"
            },
            "6": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 431,
                "PatchRowcode": "             result = self.socket.send(data)"
            },
            "7": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "             return result"
            },
            "8": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "         except OSError as why:"
            },
            "9": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "             if why.args[0] == EWOULDBLOCK:"
            },
            "10": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "                 return 0"
            },
            "11": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "             elif why.args[0] in _DISCONNECTED:"
            },
            "12": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.handle_close()"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+                if do_close:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+                    self.handle_close()"
            },
            "15": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "                 return 0"
            },
            "16": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 440,
                "PatchRowcode": "             else:"
            },
            "17": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "                 raise"
            }
        },
        "frontPatchFile": [
            "# -*- Mode: Python -*-",
            "#   Id: asyncore.py,v 2.51 2000/09/07 22:29:26 rushing Exp",
            "#   Author: Sam Rushing <rushing@nightmare.com>",
            "",
            "# ======================================================================",
            "# Copyright 1996 by Sam Rushing",
            "#",
            "#                         All Rights Reserved",
            "#",
            "# Permission to use, copy, modify, and distribute this software and",
            "# its documentation for any purpose and without fee is hereby",
            "# granted, provided that the above copyright notice appear in all",
            "# copies and that both that copyright notice and this permission",
            "# notice appear in supporting documentation, and that the name of Sam",
            "# Rushing not be used in advertising or publicity pertaining to",
            "# distribution of the software without specific, written prior",
            "# permission.",
            "#",
            "# SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
            "# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN",
            "# NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
            "# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
            "# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,",
            "# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN",
            "# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
            "# ======================================================================",
            "",
            "\"\"\"Basic infrastructure for asynchronous socket service clients and servers.",
            "",
            "There are only two ways to have a program on a single processor do \"more",
            "than one thing at a time\".  Multi-threaded programming is the simplest and",
            "most popular way to do it, but there is another very different technique,",
            "that lets you have nearly all the advantages of multi-threading, without",
            "actually using multiple threads. it's really only practical if your program",
            "is largely I/O bound. If your program is CPU bound, then pre-emptive",
            "scheduled threads are probably what you really need. Network servers are",
            "rarely CPU-bound, however.",
            "",
            "If your operating system supports the select() system call in its I/O",
            "library (and nearly all do), then you can use it to juggle multiple",
            "communication channels at once; doing other work while your I/O is taking",
            "place in the \"background.\"  Although this strategy can seem strange and",
            "complex, especially at first, it is in many ways easier to understand and",
            "control than multi-threaded programming. The module documented here solves",
            "many of the difficult problems for you, making the task of building",
            "sophisticated high-performance network servers and clients a snap.",
            "",
            "NB: this is a fork of asyncore from the stdlib that we've (the waitress",
            "developers) named 'wasyncore' to ensure forward compatibility, as asyncore",
            "in the stdlib will be dropped soon.  It is neither a copy of the 2.7 asyncore",
            "nor the 3.X asyncore; it is a version compatible with either 2.7 or 3.X.",
            "\"\"\"",
            "",
            "from errno import (",
            "    EAGAIN,",
            "    EALREADY,",
            "    EBADF,",
            "    ECONNABORTED,",
            "    ECONNRESET,",
            "    EINPROGRESS,",
            "    EINTR,",
            "    EINVAL,",
            "    EISCONN,",
            "    ENOTCONN,",
            "    EPIPE,",
            "    ESHUTDOWN,",
            "    EWOULDBLOCK,",
            "    errorcode,",
            ")",
            "import logging",
            "import os",
            "import select",
            "import socket",
            "import sys",
            "import time",
            "import warnings",
            "",
            "from . import compat, utilities",
            "",
            "_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE, EBADF})",
            "",
            "try:",
            "    socket_map",
            "except NameError:",
            "    socket_map = {}",
            "",
            "",
            "def _strerror(err):",
            "    try:",
            "        return os.strerror(err)",
            "    except (TypeError, ValueError, OverflowError, NameError):",
            "        return \"Unknown error %s\" % err",
            "",
            "",
            "class ExitNow(Exception):",
            "    pass",
            "",
            "",
            "_reraised_exceptions = (ExitNow, KeyboardInterrupt, SystemExit)",
            "",
            "",
            "def read(obj):",
            "    try:",
            "        obj.handle_read_event()",
            "    except _reraised_exceptions:",
            "        raise",
            "    except:",
            "        obj.handle_error()",
            "",
            "",
            "def write(obj):",
            "    try:",
            "        obj.handle_write_event()",
            "    except _reraised_exceptions:",
            "        raise",
            "    except:",
            "        obj.handle_error()",
            "",
            "",
            "def _exception(obj):",
            "    try:",
            "        obj.handle_expt_event()",
            "    except _reraised_exceptions:",
            "        raise",
            "    except:",
            "        obj.handle_error()",
            "",
            "",
            "def readwrite(obj, flags):",
            "    try:",
            "        if flags & select.POLLIN:",
            "            obj.handle_read_event()",
            "        if flags & select.POLLOUT:",
            "            obj.handle_write_event()",
            "        if flags & select.POLLPRI:",
            "            obj.handle_expt_event()",
            "        if flags & (select.POLLHUP | select.POLLERR | select.POLLNVAL):",
            "            obj.handle_close()",
            "    except OSError as e:",
            "        if e.args[0] not in _DISCONNECTED:",
            "            obj.handle_error()",
            "        else:",
            "            obj.handle_close()",
            "    except _reraised_exceptions:",
            "        raise",
            "    except:",
            "        obj.handle_error()",
            "",
            "",
            "def poll(timeout=0.0, map=None):",
            "    if map is None:  # pragma: no cover",
            "        map = socket_map",
            "    if map:",
            "        r = []",
            "        w = []",
            "        e = []",
            "        for fd, obj in list(map.items()):  # list() call FBO py3",
            "            is_r = obj.readable()",
            "            is_w = obj.writable()",
            "            if is_r:",
            "                r.append(fd)",
            "            # accepting sockets should not be writable",
            "            if is_w and not obj.accepting:",
            "                w.append(fd)",
            "            if is_r or is_w:",
            "                e.append(fd)",
            "        if [] == r == w == e:",
            "            time.sleep(timeout)",
            "            return",
            "",
            "        try:",
            "            r, w, e = select.select(r, w, e, timeout)",
            "        except OSError as err:",
            "            if err.args[0] != EINTR:",
            "                raise",
            "            else:",
            "                return",
            "",
            "        for fd in r:",
            "            obj = map.get(fd)",
            "            if obj is None:  # pragma: no cover",
            "                continue",
            "            read(obj)",
            "",
            "        for fd in w:",
            "            obj = map.get(fd)",
            "            if obj is None:  # pragma: no cover",
            "                continue",
            "            write(obj)",
            "",
            "        for fd in e:",
            "            obj = map.get(fd)",
            "            if obj is None:  # pragma: no cover",
            "                continue",
            "            _exception(obj)",
            "",
            "",
            "def poll2(timeout=0.0, map=None):",
            "    # Use the poll() support added to the select module in Python 2.0",
            "    if map is None:  # pragma: no cover",
            "        map = socket_map",
            "    if timeout is not None:",
            "        # timeout is in milliseconds",
            "        timeout = int(timeout * 1000)",
            "    pollster = select.poll()",
            "    if map:",
            "        for fd, obj in list(map.items()):",
            "            flags = 0",
            "            if obj.readable():",
            "                flags |= select.POLLIN | select.POLLPRI",
            "            # accepting sockets should not be writable",
            "            if obj.writable() and not obj.accepting:",
            "                flags |= select.POLLOUT",
            "            if flags:",
            "                pollster.register(fd, flags)",
            "",
            "        try:",
            "            r = pollster.poll(timeout)",
            "        except OSError as err:",
            "            if err.args[0] != EINTR:",
            "                raise",
            "            r = []",
            "",
            "        for fd, flags in r:",
            "            obj = map.get(fd)",
            "            if obj is None:  # pragma: no cover",
            "                continue",
            "            readwrite(obj, flags)",
            "",
            "",
            "poll3 = poll2  # Alias for backward compatibility",
            "",
            "",
            "def loop(timeout=30.0, use_poll=False, map=None, count=None):",
            "    if map is None:  # pragma: no cover",
            "        map = socket_map",
            "",
            "    if use_poll and hasattr(select, \"poll\"):",
            "        poll_fun = poll2",
            "    else:",
            "        poll_fun = poll",
            "",
            "    if count is None:  # pragma: no cover",
            "        while map:",
            "            poll_fun(timeout, map)",
            "",
            "    else:",
            "        while map and count > 0:",
            "            poll_fun(timeout, map)",
            "            count = count - 1",
            "",
            "",
            "def compact_traceback():",
            "    t, v, tb = sys.exc_info()",
            "    tbinfo = []",
            "    if not tb:  # pragma: no cover",
            "        raise AssertionError(\"traceback does not exist\")",
            "    while tb:",
            "        tbinfo.append(",
            "            (",
            "                tb.tb_frame.f_code.co_filename,",
            "                tb.tb_frame.f_code.co_name,",
            "                str(tb.tb_lineno),",
            "            )",
            "        )",
            "        tb = tb.tb_next",
            "",
            "    # just to be safe",
            "    del tb",
            "",
            "    file, function, line = tbinfo[-1]",
            "    info = \" \".join([\"[%s|%s|%s]\" % x for x in tbinfo])",
            "    return (file, function, line), t, v, info",
            "",
            "",
            "class dispatcher:",
            "",
            "    debug = False",
            "    connected = False",
            "    accepting = False",
            "    connecting = False",
            "    closing = False",
            "    addr = None",
            "    ignore_log_types = frozenset({\"warning\"})",
            "    logger = utilities.logger",
            "    compact_traceback = staticmethod(compact_traceback)  # for testing",
            "",
            "    def __init__(self, sock=None, map=None):",
            "        if map is None:  # pragma: no cover",
            "            self._map = socket_map",
            "        else:",
            "            self._map = map",
            "",
            "        self._fileno = None",
            "",
            "        if sock:",
            "            # Set to nonblocking just to make sure for cases where we",
            "            # get a socket from a blocking source.",
            "            sock.setblocking(0)",
            "            self.set_socket(sock, map)",
            "            self.connected = True",
            "            # The constructor no longer requires that the socket",
            "            # passed be connected.",
            "            try:",
            "                self.addr = sock.getpeername()",
            "            except OSError as err:",
            "                if err.args[0] in (ENOTCONN, EINVAL):",
            "                    # To handle the case where we got an unconnected",
            "                    # socket.",
            "                    self.connected = False",
            "                else:",
            "                    # The socket is broken in some unknown way, alert",
            "                    # the user and remove it from the map (to prevent",
            "                    # polling of broken sockets).",
            "                    self.del_channel(map)",
            "                    raise",
            "        else:",
            "            self.socket = None",
            "",
            "    def __repr__(self):",
            "        status = [self.__class__.__module__ + \".\" + self.__class__.__qualname__]",
            "        if self.accepting and self.addr:",
            "            status.append(\"listening\")",
            "        elif self.connected:",
            "            status.append(\"connected\")",
            "        if self.addr is not None:",
            "            try:",
            "                status.append(\"%s:%d\" % self.addr)",
            "            except TypeError:  # pragma: no cover",
            "                status.append(repr(self.addr))",
            "        return \"<{} at {:#x}>\".format(\" \".join(status), id(self))",
            "",
            "    __str__ = __repr__",
            "",
            "    def add_channel(self, map=None):",
            "        # self.log_info('adding channel %s' % self)",
            "        if map is None:",
            "            map = self._map",
            "        map[self._fileno] = self",
            "",
            "    def del_channel(self, map=None):",
            "        fd = self._fileno",
            "        if map is None:",
            "            map = self._map",
            "        if fd in map:",
            "            # self.log_info('closing channel %d:%s' % (fd, self))",
            "            del map[fd]",
            "        self._fileno = None",
            "",
            "    def create_socket(self, family=socket.AF_INET, type=socket.SOCK_STREAM):",
            "        self.family_and_type = family, type",
            "        sock = socket.socket(family, type)",
            "        sock.setblocking(0)",
            "        self.set_socket(sock)",
            "",
            "    def set_socket(self, sock, map=None):",
            "        self.socket = sock",
            "        self._fileno = sock.fileno()",
            "        self.add_channel(map)",
            "",
            "    def set_reuse_addr(self):",
            "        # try to re-use a server port if possible",
            "        try:",
            "            self.socket.setsockopt(",
            "                socket.SOL_SOCKET,",
            "                socket.SO_REUSEADDR,",
            "                self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) | 1,",
            "            )",
            "        except OSError:",
            "            pass",
            "",
            "    # ==================================================",
            "    # predicates for select()",
            "    # these are used as filters for the lists of sockets",
            "    # to pass to select().",
            "    # ==================================================",
            "",
            "    def readable(self):",
            "        return True",
            "",
            "    def writable(self):",
            "        return True",
            "",
            "    # ==================================================",
            "    # socket object methods.",
            "    # ==================================================",
            "",
            "    def listen(self, num):",
            "        self.accepting = True",
            "        if os.name == \"nt\" and num > 5:  # pragma: no cover",
            "            num = 5",
            "        return self.socket.listen(num)",
            "",
            "    def bind(self, addr):",
            "        self.addr = addr",
            "        return self.socket.bind(addr)",
            "",
            "    def connect(self, address):",
            "        self.connected = False",
            "        self.connecting = True",
            "        err = self.socket.connect_ex(address)",
            "        if (",
            "            err in (EINPROGRESS, EALREADY, EWOULDBLOCK)",
            "            or err == EINVAL",
            "            and os.name == \"nt\"",
            "        ):  # pragma: no cover",
            "            self.addr = address",
            "            return",
            "        if err in (0, EISCONN):",
            "            self.addr = address",
            "            self.handle_connect_event()",
            "        else:",
            "            raise OSError(err, errorcode[err])",
            "",
            "    def accept(self):",
            "        # XXX can return either an address pair or None",
            "        try:",
            "            conn, addr = self.socket.accept()",
            "        except TypeError:",
            "            return None",
            "        except OSError as why:",
            "            if why.args[0] in (EWOULDBLOCK, ECONNABORTED, EAGAIN):",
            "                return None",
            "            else:",
            "                raise",
            "        else:",
            "            return conn, addr",
            "",
            "    def send(self, data):",
            "        try:",
            "            result = self.socket.send(data)",
            "            return result",
            "        except OSError as why:",
            "            if why.args[0] == EWOULDBLOCK:",
            "                return 0",
            "            elif why.args[0] in _DISCONNECTED:",
            "                self.handle_close()",
            "                return 0",
            "            else:",
            "                raise",
            "",
            "    def recv(self, buffer_size):",
            "        try:",
            "            data = self.socket.recv(buffer_size)",
            "            if not data:",
            "                # a closed connection is indicated by signaling",
            "                # a read condition, and having recv() return 0.",
            "                self.handle_close()",
            "                return b\"\"",
            "            else:",
            "                return data",
            "        except OSError as why:",
            "            # winsock sometimes raises ENOTCONN",
            "            if why.args[0] in _DISCONNECTED:",
            "                self.handle_close()",
            "                return b\"\"",
            "            else:",
            "                raise",
            "",
            "    def close(self):",
            "        self.connected = False",
            "        self.accepting = False",
            "        self.connecting = False",
            "        self.del_channel()",
            "        if self.socket is not None:",
            "            try:",
            "                self.socket.close()",
            "            except OSError as why:",
            "                if why.args[0] not in (ENOTCONN, EBADF):",
            "                    raise",
            "",
            "    # log and log_info may be overridden to provide more sophisticated",
            "    # logging and warning methods. In general, log is for 'hit' logging",
            "    # and 'log_info' is for informational, warning and error logging.",
            "",
            "    def log(self, message):",
            "        self.logger.log(logging.DEBUG, message)",
            "",
            "    def log_info(self, message, type=\"info\"):",
            "        severity = {",
            "            \"info\": logging.INFO,",
            "            \"warning\": logging.WARN,",
            "            \"error\": logging.ERROR,",
            "        }",
            "        self.logger.log(severity.get(type, logging.INFO), message)",
            "",
            "    def handle_read_event(self):",
            "        if self.accepting:",
            "            # accepting sockets are never connected, they \"spawn\" new",
            "            # sockets that are connected",
            "            self.handle_accept()",
            "        elif not self.connected:",
            "            if self.connecting:",
            "                self.handle_connect_event()",
            "            self.handle_read()",
            "        else:",
            "            self.handle_read()",
            "",
            "    def handle_connect_event(self):",
            "        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)",
            "        if err != 0:",
            "            raise OSError(err, _strerror(err))",
            "        self.handle_connect()",
            "        self.connected = True",
            "        self.connecting = False",
            "",
            "    def handle_write_event(self):",
            "        if self.accepting:",
            "            # Accepting sockets shouldn't get a write event.",
            "            # We will pretend it didn't happen.",
            "            return",
            "",
            "        if not self.connected:",
            "            if self.connecting:",
            "                self.handle_connect_event()",
            "        self.handle_write()",
            "",
            "    def handle_expt_event(self):",
            "        # handle_expt_event() is called if there might be an error on the",
            "        # socket, or if there is OOB data",
            "        # check for the error condition first",
            "        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)",
            "        if err != 0:",
            "            # we can get here when select.select() says that there is an",
            "            # exceptional condition on the socket",
            "            # since there is an error, we'll go ahead and close the socket",
            "            # like we would in a subclassed handle_read() that received no",
            "            # data",
            "            self.handle_close()",
            "        else:",
            "            self.handle_expt()",
            "",
            "    def handle_error(self):",
            "        nil, t, v, tbinfo = self.compact_traceback()",
            "",
            "        # sometimes a user repr method will crash.",
            "        try:",
            "            self_repr = repr(self)",
            "        except:  # pragma: no cover",
            "            self_repr = \"<__repr__(self) failed for object at %0x>\" % id(self)",
            "",
            "        self.log_info(",
            "            \"uncaptured python exception, closing channel %s (%s:%s %s)\"",
            "            % (self_repr, t, v, tbinfo),",
            "            \"error\",",
            "        )",
            "        self.handle_close()",
            "",
            "    def handle_expt(self):",
            "        self.log_info(\"unhandled incoming priority event\", \"warning\")",
            "",
            "    def handle_read(self):",
            "        self.log_info(\"unhandled read event\", \"warning\")",
            "",
            "    def handle_write(self):",
            "        self.log_info(\"unhandled write event\", \"warning\")",
            "",
            "    def handle_connect(self):",
            "        self.log_info(\"unhandled connect event\", \"warning\")",
            "",
            "    def handle_accept(self):",
            "        pair = self.accept()",
            "        if pair is not None:",
            "            self.handle_accepted(*pair)",
            "",
            "    def handle_accepted(self, sock, addr):",
            "        sock.close()",
            "        self.log_info(\"unhandled accepted event\", \"warning\")",
            "",
            "    def handle_close(self):",
            "        self.log_info(\"unhandled close event\", \"warning\")",
            "        self.close()",
            "",
            "",
            "# ---------------------------------------------------------------------------",
            "# adds simple buffered output capability, useful for simple clients.",
            "# [for more sophisticated usage use asynchat.async_chat]",
            "# ---------------------------------------------------------------------------",
            "",
            "",
            "class dispatcher_with_send(dispatcher):",
            "    def __init__(self, sock=None, map=None):",
            "        dispatcher.__init__(self, sock, map)",
            "        self.out_buffer = b\"\"",
            "",
            "    def initiate_send(self):",
            "        num_sent = 0",
            "        num_sent = dispatcher.send(self, self.out_buffer[:65536])",
            "        self.out_buffer = self.out_buffer[num_sent:]",
            "",
            "    handle_write = initiate_send",
            "",
            "    def writable(self):",
            "        return (not self.connected) or len(self.out_buffer)",
            "",
            "    def send(self, data):",
            "        if self.debug:  # pragma: no cover",
            "            self.log_info(\"sending %s\" % repr(data))",
            "        self.out_buffer = self.out_buffer + data",
            "        self.initiate_send()",
            "",
            "",
            "def close_all(map=None, ignore_all=False):",
            "    if map is None:  # pragma: no cover",
            "        map = socket_map",
            "    for x in list(map.values()):  # list() FBO py3",
            "        try:",
            "            x.close()",
            "        except OSError as x:",
            "            if x.args[0] == EBADF:",
            "                pass",
            "            elif not ignore_all:",
            "                raise",
            "        except _reraised_exceptions:",
            "            raise",
            "        except:",
            "            if not ignore_all:",
            "                raise",
            "    map.clear()",
            "",
            "",
            "# Asynchronous File I/O:",
            "#",
            "# After a little research (reading man pages on various unixen, and",
            "# digging through the linux kernel), I've determined that select()",
            "# isn't meant for doing asynchronous file i/o.",
            "# Heartening, though - reading linux/mm/filemap.c shows that linux",
            "# supports asynchronous read-ahead.  So _MOST_ of the time, the data",
            "# will be sitting in memory for us already when we go to read it.",
            "#",
            "# What other OS's (besides NT) support async file i/o?  [VMS?]",
            "#",
            "# Regardless, this is useful for pipes, and stdin/stdout...",
            "",
            "if os.name == \"posix\":",
            "",
            "    class file_wrapper:",
            "        # Here we override just enough to make a file",
            "        # look like a socket for the purposes of asyncore.",
            "        # The passed fd is automatically os.dup()'d",
            "",
            "        def __init__(self, fd):",
            "            self.fd = os.dup(fd)",
            "",
            "        def __del__(self):",
            "            if self.fd >= 0:",
            "                warnings.warn(\"unclosed file %r\" % self, ResourceWarning)",
            "            self.close()",
            "",
            "        def recv(self, *args):",
            "            return os.read(self.fd, *args)",
            "",
            "        def send(self, *args):",
            "            return os.write(self.fd, *args)",
            "",
            "        def getsockopt(self, level, optname, buflen=None):  # pragma: no cover",
            "            if level == socket.SOL_SOCKET and optname == socket.SO_ERROR and not buflen:",
            "                return 0",
            "            raise NotImplementedError(",
            "                \"Only asyncore specific behaviour \" \"implemented.\"",
            "            )",
            "",
            "        read = recv",
            "        write = send",
            "",
            "        def close(self):",
            "            if self.fd < 0:",
            "                return",
            "            fd = self.fd",
            "            self.fd = -1",
            "            os.close(fd)",
            "",
            "        def fileno(self):",
            "            return self.fd",
            "",
            "    class file_dispatcher(dispatcher):",
            "        def __init__(self, fd, map=None):",
            "            dispatcher.__init__(self, None, map)",
            "            self.connected = True",
            "            try:",
            "                fd = fd.fileno()",
            "            except AttributeError:",
            "                pass",
            "            self.set_file(fd)",
            "            # set it to non-blocking mode",
            "            os.set_blocking(fd, False)",
            "",
            "        def set_file(self, fd):",
            "            self.socket = file_wrapper(fd)",
            "            self._fileno = self.socket.fileno()",
            "            self.add_channel()"
        ],
        "afterPatchFile": [
            "# -*- Mode: Python -*-",
            "#   Id: asyncore.py,v 2.51 2000/09/07 22:29:26 rushing Exp",
            "#   Author: Sam Rushing <rushing@nightmare.com>",
            "",
            "# ======================================================================",
            "# Copyright 1996 by Sam Rushing",
            "#",
            "#                         All Rights Reserved",
            "#",
            "# Permission to use, copy, modify, and distribute this software and",
            "# its documentation for any purpose and without fee is hereby",
            "# granted, provided that the above copyright notice appear in all",
            "# copies and that both that copyright notice and this permission",
            "# notice appear in supporting documentation, and that the name of Sam",
            "# Rushing not be used in advertising or publicity pertaining to",
            "# distribution of the software without specific, written prior",
            "# permission.",
            "#",
            "# SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
            "# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN",
            "# NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
            "# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
            "# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,",
            "# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN",
            "# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
            "# ======================================================================",
            "",
            "\"\"\"Basic infrastructure for asynchronous socket service clients and servers.",
            "",
            "There are only two ways to have a program on a single processor do \"more",
            "than one thing at a time\".  Multi-threaded programming is the simplest and",
            "most popular way to do it, but there is another very different technique,",
            "that lets you have nearly all the advantages of multi-threading, without",
            "actually using multiple threads. it's really only practical if your program",
            "is largely I/O bound. If your program is CPU bound, then pre-emptive",
            "scheduled threads are probably what you really need. Network servers are",
            "rarely CPU-bound, however.",
            "",
            "If your operating system supports the select() system call in its I/O",
            "library (and nearly all do), then you can use it to juggle multiple",
            "communication channels at once; doing other work while your I/O is taking",
            "place in the \"background.\"  Although this strategy can seem strange and",
            "complex, especially at first, it is in many ways easier to understand and",
            "control than multi-threaded programming. The module documented here solves",
            "many of the difficult problems for you, making the task of building",
            "sophisticated high-performance network servers and clients a snap.",
            "",
            "NB: this is a fork of asyncore from the stdlib that we've (the waitress",
            "developers) named 'wasyncore' to ensure forward compatibility, as asyncore",
            "in the stdlib will be dropped soon.  It is neither a copy of the 2.7 asyncore",
            "nor the 3.X asyncore; it is a version compatible with either 2.7 or 3.X.",
            "\"\"\"",
            "",
            "from errno import (",
            "    EAGAIN,",
            "    EALREADY,",
            "    EBADF,",
            "    ECONNABORTED,",
            "    ECONNRESET,",
            "    EINPROGRESS,",
            "    EINTR,",
            "    EINVAL,",
            "    EISCONN,",
            "    ENOTCONN,",
            "    EPIPE,",
            "    ESHUTDOWN,",
            "    EWOULDBLOCK,",
            "    errorcode,",
            ")",
            "import logging",
            "import os",
            "import select",
            "import socket",
            "import sys",
            "import time",
            "import warnings",
            "",
            "from . import compat, utilities",
            "",
            "_DISCONNECTED = frozenset({ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED, EPIPE, EBADF})",
            "",
            "try:",
            "    socket_map",
            "except NameError:",
            "    socket_map = {}",
            "",
            "",
            "def _strerror(err):",
            "    try:",
            "        return os.strerror(err)",
            "    except (TypeError, ValueError, OverflowError, NameError):",
            "        return \"Unknown error %s\" % err",
            "",
            "",
            "class ExitNow(Exception):",
            "    pass",
            "",
            "",
            "_reraised_exceptions = (ExitNow, KeyboardInterrupt, SystemExit)",
            "",
            "",
            "def read(obj):",
            "    try:",
            "        obj.handle_read_event()",
            "    except _reraised_exceptions:",
            "        raise",
            "    except:",
            "        obj.handle_error()",
            "",
            "",
            "def write(obj):",
            "    try:",
            "        obj.handle_write_event()",
            "    except _reraised_exceptions:",
            "        raise",
            "    except:",
            "        obj.handle_error()",
            "",
            "",
            "def _exception(obj):",
            "    try:",
            "        obj.handle_expt_event()",
            "    except _reraised_exceptions:",
            "        raise",
            "    except:",
            "        obj.handle_error()",
            "",
            "",
            "def readwrite(obj, flags):",
            "    try:",
            "        if flags & select.POLLIN:",
            "            obj.handle_read_event()",
            "        if flags & select.POLLOUT:",
            "            obj.handle_write_event()",
            "        if flags & select.POLLPRI:",
            "            obj.handle_expt_event()",
            "        if flags & (select.POLLHUP | select.POLLERR | select.POLLNVAL):",
            "            obj.handle_close()",
            "    except OSError as e:",
            "        if e.args[0] not in _DISCONNECTED:",
            "            obj.handle_error()",
            "        else:",
            "            obj.handle_close()",
            "    except _reraised_exceptions:",
            "        raise",
            "    except:",
            "        obj.handle_error()",
            "",
            "",
            "def poll(timeout=0.0, map=None):",
            "    if map is None:  # pragma: no cover",
            "        map = socket_map",
            "    if map:",
            "        r = []",
            "        w = []",
            "        e = []",
            "        for fd, obj in list(map.items()):  # list() call FBO py3",
            "            is_r = obj.readable()",
            "            is_w = obj.writable()",
            "            if is_r:",
            "                r.append(fd)",
            "            # accepting sockets should not be writable",
            "            if is_w and not obj.accepting:",
            "                w.append(fd)",
            "            if is_r or is_w:",
            "                e.append(fd)",
            "        if [] == r == w == e:",
            "            time.sleep(timeout)",
            "            return",
            "",
            "        try:",
            "            r, w, e = select.select(r, w, e, timeout)",
            "        except OSError as err:",
            "            if err.args[0] != EINTR:",
            "                raise",
            "            else:",
            "                return",
            "",
            "        for fd in r:",
            "            obj = map.get(fd)",
            "            if obj is None:  # pragma: no cover",
            "                continue",
            "            read(obj)",
            "",
            "        for fd in w:",
            "            obj = map.get(fd)",
            "            if obj is None:  # pragma: no cover",
            "                continue",
            "            write(obj)",
            "",
            "        for fd in e:",
            "            obj = map.get(fd)",
            "            if obj is None:  # pragma: no cover",
            "                continue",
            "            _exception(obj)",
            "",
            "",
            "def poll2(timeout=0.0, map=None):",
            "    # Use the poll() support added to the select module in Python 2.0",
            "    if map is None:  # pragma: no cover",
            "        map = socket_map",
            "    if timeout is not None:",
            "        # timeout is in milliseconds",
            "        timeout = int(timeout * 1000)",
            "    pollster = select.poll()",
            "    if map:",
            "        for fd, obj in list(map.items()):",
            "            flags = 0",
            "            if obj.readable():",
            "                flags |= select.POLLIN | select.POLLPRI",
            "            # accepting sockets should not be writable",
            "            if obj.writable() and not obj.accepting:",
            "                flags |= select.POLLOUT",
            "            if flags:",
            "                pollster.register(fd, flags)",
            "",
            "        try:",
            "            r = pollster.poll(timeout)",
            "        except OSError as err:",
            "            if err.args[0] != EINTR:",
            "                raise",
            "            r = []",
            "",
            "        for fd, flags in r:",
            "            obj = map.get(fd)",
            "            if obj is None:  # pragma: no cover",
            "                continue",
            "            readwrite(obj, flags)",
            "",
            "",
            "poll3 = poll2  # Alias for backward compatibility",
            "",
            "",
            "def loop(timeout=30.0, use_poll=False, map=None, count=None):",
            "    if map is None:  # pragma: no cover",
            "        map = socket_map",
            "",
            "    if use_poll and hasattr(select, \"poll\"):",
            "        poll_fun = poll2",
            "    else:",
            "        poll_fun = poll",
            "",
            "    if count is None:  # pragma: no cover",
            "        while map:",
            "            poll_fun(timeout, map)",
            "",
            "    else:",
            "        while map and count > 0:",
            "            poll_fun(timeout, map)",
            "            count = count - 1",
            "",
            "",
            "def compact_traceback():",
            "    t, v, tb = sys.exc_info()",
            "    tbinfo = []",
            "    if not tb:  # pragma: no cover",
            "        raise AssertionError(\"traceback does not exist\")",
            "    while tb:",
            "        tbinfo.append(",
            "            (",
            "                tb.tb_frame.f_code.co_filename,",
            "                tb.tb_frame.f_code.co_name,",
            "                str(tb.tb_lineno),",
            "            )",
            "        )",
            "        tb = tb.tb_next",
            "",
            "    # just to be safe",
            "    del tb",
            "",
            "    file, function, line = tbinfo[-1]",
            "    info = \" \".join([\"[%s|%s|%s]\" % x for x in tbinfo])",
            "    return (file, function, line), t, v, info",
            "",
            "",
            "class dispatcher:",
            "",
            "    debug = False",
            "    connected = False",
            "    accepting = False",
            "    connecting = False",
            "    closing = False",
            "    addr = None",
            "    ignore_log_types = frozenset({\"warning\"})",
            "    logger = utilities.logger",
            "    compact_traceback = staticmethod(compact_traceback)  # for testing",
            "",
            "    def __init__(self, sock=None, map=None):",
            "        if map is None:  # pragma: no cover",
            "            self._map = socket_map",
            "        else:",
            "            self._map = map",
            "",
            "        self._fileno = None",
            "",
            "        if sock:",
            "            # Set to nonblocking just to make sure for cases where we",
            "            # get a socket from a blocking source.",
            "            sock.setblocking(0)",
            "            self.set_socket(sock, map)",
            "            self.connected = True",
            "            # The constructor no longer requires that the socket",
            "            # passed be connected.",
            "            try:",
            "                self.addr = sock.getpeername()",
            "            except OSError as err:",
            "                if err.args[0] in (ENOTCONN, EINVAL):",
            "                    # To handle the case where we got an unconnected",
            "                    # socket.",
            "                    self.connected = False",
            "                else:",
            "                    # The socket is broken in some unknown way, alert",
            "                    # the user and remove it from the map (to prevent",
            "                    # polling of broken sockets).",
            "                    self.del_channel(map)",
            "                    raise",
            "        else:",
            "            self.socket = None",
            "",
            "    def __repr__(self):",
            "        status = [self.__class__.__module__ + \".\" + self.__class__.__qualname__]",
            "        if self.accepting and self.addr:",
            "            status.append(\"listening\")",
            "        elif self.connected:",
            "            status.append(\"connected\")",
            "        if self.addr is not None:",
            "            try:",
            "                status.append(\"%s:%d\" % self.addr)",
            "            except TypeError:  # pragma: no cover",
            "                status.append(repr(self.addr))",
            "        return \"<{} at {:#x}>\".format(\" \".join(status), id(self))",
            "",
            "    __str__ = __repr__",
            "",
            "    def add_channel(self, map=None):",
            "        # self.log_info('adding channel %s' % self)",
            "        if map is None:",
            "            map = self._map",
            "        map[self._fileno] = self",
            "",
            "    def del_channel(self, map=None):",
            "        fd = self._fileno",
            "        if map is None:",
            "            map = self._map",
            "        if fd in map:",
            "            # self.log_info('closing channel %d:%s' % (fd, self))",
            "            del map[fd]",
            "        self._fileno = None",
            "",
            "    def create_socket(self, family=socket.AF_INET, type=socket.SOCK_STREAM):",
            "        self.family_and_type = family, type",
            "        sock = socket.socket(family, type)",
            "        sock.setblocking(0)",
            "        self.set_socket(sock)",
            "",
            "    def set_socket(self, sock, map=None):",
            "        self.socket = sock",
            "        self._fileno = sock.fileno()",
            "        self.add_channel(map)",
            "",
            "    def set_reuse_addr(self):",
            "        # try to re-use a server port if possible",
            "        try:",
            "            self.socket.setsockopt(",
            "                socket.SOL_SOCKET,",
            "                socket.SO_REUSEADDR,",
            "                self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) | 1,",
            "            )",
            "        except OSError:",
            "            pass",
            "",
            "    # ==================================================",
            "    # predicates for select()",
            "    # these are used as filters for the lists of sockets",
            "    # to pass to select().",
            "    # ==================================================",
            "",
            "    def readable(self):",
            "        return True",
            "",
            "    def writable(self):",
            "        return True",
            "",
            "    # ==================================================",
            "    # socket object methods.",
            "    # ==================================================",
            "",
            "    def listen(self, num):",
            "        self.accepting = True",
            "        if os.name == \"nt\" and num > 5:  # pragma: no cover",
            "            num = 5",
            "        return self.socket.listen(num)",
            "",
            "    def bind(self, addr):",
            "        self.addr = addr",
            "        return self.socket.bind(addr)",
            "",
            "    def connect(self, address):",
            "        self.connected = False",
            "        self.connecting = True",
            "        err = self.socket.connect_ex(address)",
            "        if (",
            "            err in (EINPROGRESS, EALREADY, EWOULDBLOCK)",
            "            or err == EINVAL",
            "            and os.name == \"nt\"",
            "        ):  # pragma: no cover",
            "            self.addr = address",
            "            return",
            "        if err in (0, EISCONN):",
            "            self.addr = address",
            "            self.handle_connect_event()",
            "        else:",
            "            raise OSError(err, errorcode[err])",
            "",
            "    def accept(self):",
            "        # XXX can return either an address pair or None",
            "        try:",
            "            conn, addr = self.socket.accept()",
            "        except TypeError:",
            "            return None",
            "        except OSError as why:",
            "            if why.args[0] in (EWOULDBLOCK, ECONNABORTED, EAGAIN):",
            "                return None",
            "            else:",
            "                raise",
            "        else:",
            "            return conn, addr",
            "",
            "    def send(self, data, do_close=True):",
            "        try:",
            "            result = self.socket.send(data)",
            "            return result",
            "        except OSError as why:",
            "            if why.args[0] == EWOULDBLOCK:",
            "                return 0",
            "            elif why.args[0] in _DISCONNECTED:",
            "                if do_close:",
            "                    self.handle_close()",
            "                return 0",
            "            else:",
            "                raise",
            "",
            "    def recv(self, buffer_size):",
            "        try:",
            "            data = self.socket.recv(buffer_size)",
            "            if not data:",
            "                # a closed connection is indicated by signaling",
            "                # a read condition, and having recv() return 0.",
            "                self.handle_close()",
            "                return b\"\"",
            "            else:",
            "                return data",
            "        except OSError as why:",
            "            # winsock sometimes raises ENOTCONN",
            "            if why.args[0] in _DISCONNECTED:",
            "                self.handle_close()",
            "                return b\"\"",
            "            else:",
            "                raise",
            "",
            "    def close(self):",
            "        self.connected = False",
            "        self.accepting = False",
            "        self.connecting = False",
            "        self.del_channel()",
            "        if self.socket is not None:",
            "            try:",
            "                self.socket.close()",
            "            except OSError as why:",
            "                if why.args[0] not in (ENOTCONN, EBADF):",
            "                    raise",
            "",
            "    # log and log_info may be overridden to provide more sophisticated",
            "    # logging and warning methods. In general, log is for 'hit' logging",
            "    # and 'log_info' is for informational, warning and error logging.",
            "",
            "    def log(self, message):",
            "        self.logger.log(logging.DEBUG, message)",
            "",
            "    def log_info(self, message, type=\"info\"):",
            "        severity = {",
            "            \"info\": logging.INFO,",
            "            \"warning\": logging.WARN,",
            "            \"error\": logging.ERROR,",
            "        }",
            "        self.logger.log(severity.get(type, logging.INFO), message)",
            "",
            "    def handle_read_event(self):",
            "        if self.accepting:",
            "            # accepting sockets are never connected, they \"spawn\" new",
            "            # sockets that are connected",
            "            self.handle_accept()",
            "        elif not self.connected:",
            "            if self.connecting:",
            "                self.handle_connect_event()",
            "            self.handle_read()",
            "        else:",
            "            self.handle_read()",
            "",
            "    def handle_connect_event(self):",
            "        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)",
            "        if err != 0:",
            "            raise OSError(err, _strerror(err))",
            "        self.handle_connect()",
            "        self.connected = True",
            "        self.connecting = False",
            "",
            "    def handle_write_event(self):",
            "        if self.accepting:",
            "            # Accepting sockets shouldn't get a write event.",
            "            # We will pretend it didn't happen.",
            "            return",
            "",
            "        if not self.connected:",
            "            if self.connecting:",
            "                self.handle_connect_event()",
            "        self.handle_write()",
            "",
            "    def handle_expt_event(self):",
            "        # handle_expt_event() is called if there might be an error on the",
            "        # socket, or if there is OOB data",
            "        # check for the error condition first",
            "        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)",
            "        if err != 0:",
            "            # we can get here when select.select() says that there is an",
            "            # exceptional condition on the socket",
            "            # since there is an error, we'll go ahead and close the socket",
            "            # like we would in a subclassed handle_read() that received no",
            "            # data",
            "            self.handle_close()",
            "        else:",
            "            self.handle_expt()",
            "",
            "    def handle_error(self):",
            "        nil, t, v, tbinfo = self.compact_traceback()",
            "",
            "        # sometimes a user repr method will crash.",
            "        try:",
            "            self_repr = repr(self)",
            "        except:  # pragma: no cover",
            "            self_repr = \"<__repr__(self) failed for object at %0x>\" % id(self)",
            "",
            "        self.log_info(",
            "            \"uncaptured python exception, closing channel %s (%s:%s %s)\"",
            "            % (self_repr, t, v, tbinfo),",
            "            \"error\",",
            "        )",
            "        self.handle_close()",
            "",
            "    def handle_expt(self):",
            "        self.log_info(\"unhandled incoming priority event\", \"warning\")",
            "",
            "    def handle_read(self):",
            "        self.log_info(\"unhandled read event\", \"warning\")",
            "",
            "    def handle_write(self):",
            "        self.log_info(\"unhandled write event\", \"warning\")",
            "",
            "    def handle_connect(self):",
            "        self.log_info(\"unhandled connect event\", \"warning\")",
            "",
            "    def handle_accept(self):",
            "        pair = self.accept()",
            "        if pair is not None:",
            "            self.handle_accepted(*pair)",
            "",
            "    def handle_accepted(self, sock, addr):",
            "        sock.close()",
            "        self.log_info(\"unhandled accepted event\", \"warning\")",
            "",
            "    def handle_close(self):",
            "        self.log_info(\"unhandled close event\", \"warning\")",
            "        self.close()",
            "",
            "",
            "# ---------------------------------------------------------------------------",
            "# adds simple buffered output capability, useful for simple clients.",
            "# [for more sophisticated usage use asynchat.async_chat]",
            "# ---------------------------------------------------------------------------",
            "",
            "",
            "class dispatcher_with_send(dispatcher):",
            "    def __init__(self, sock=None, map=None):",
            "        dispatcher.__init__(self, sock, map)",
            "        self.out_buffer = b\"\"",
            "",
            "    def initiate_send(self):",
            "        num_sent = 0",
            "        num_sent = dispatcher.send(self, self.out_buffer[:65536])",
            "        self.out_buffer = self.out_buffer[num_sent:]",
            "",
            "    handle_write = initiate_send",
            "",
            "    def writable(self):",
            "        return (not self.connected) or len(self.out_buffer)",
            "",
            "    def send(self, data):",
            "        if self.debug:  # pragma: no cover",
            "            self.log_info(\"sending %s\" % repr(data))",
            "        self.out_buffer = self.out_buffer + data",
            "        self.initiate_send()",
            "",
            "",
            "def close_all(map=None, ignore_all=False):",
            "    if map is None:  # pragma: no cover",
            "        map = socket_map",
            "    for x in list(map.values()):  # list() FBO py3",
            "        try:",
            "            x.close()",
            "        except OSError as x:",
            "            if x.args[0] == EBADF:",
            "                pass",
            "            elif not ignore_all:",
            "                raise",
            "        except _reraised_exceptions:",
            "            raise",
            "        except:",
            "            if not ignore_all:",
            "                raise",
            "    map.clear()",
            "",
            "",
            "# Asynchronous File I/O:",
            "#",
            "# After a little research (reading man pages on various unixen, and",
            "# digging through the linux kernel), I've determined that select()",
            "# isn't meant for doing asynchronous file i/o.",
            "# Heartening, though - reading linux/mm/filemap.c shows that linux",
            "# supports asynchronous read-ahead.  So _MOST_ of the time, the data",
            "# will be sitting in memory for us already when we go to read it.",
            "#",
            "# What other OS's (besides NT) support async file i/o?  [VMS?]",
            "#",
            "# Regardless, this is useful for pipes, and stdin/stdout...",
            "",
            "if os.name == \"posix\":",
            "",
            "    class file_wrapper:",
            "        # Here we override just enough to make a file",
            "        # look like a socket for the purposes of asyncore.",
            "        # The passed fd is automatically os.dup()'d",
            "",
            "        def __init__(self, fd):",
            "            self.fd = os.dup(fd)",
            "",
            "        def __del__(self):",
            "            if self.fd >= 0:",
            "                warnings.warn(\"unclosed file %r\" % self, ResourceWarning)",
            "            self.close()",
            "",
            "        def recv(self, *args):",
            "            return os.read(self.fd, *args)",
            "",
            "        def send(self, *args):",
            "            return os.write(self.fd, *args)",
            "",
            "        def getsockopt(self, level, optname, buflen=None):  # pragma: no cover",
            "            if level == socket.SOL_SOCKET and optname == socket.SO_ERROR and not buflen:",
            "                return 0",
            "            raise NotImplementedError(",
            "                \"Only asyncore specific behaviour \" \"implemented.\"",
            "            )",
            "",
            "        read = recv",
            "        write = send",
            "",
            "        def close(self):",
            "            if self.fd < 0:",
            "                return",
            "            fd = self.fd",
            "            self.fd = -1",
            "            os.close(fd)",
            "",
            "        def fileno(self):",
            "            return self.fd",
            "",
            "    class file_dispatcher(dispatcher):",
            "        def __init__(self, fd, map=None):",
            "            dispatcher.__init__(self, None, map)",
            "            self.connected = True",
            "            try:",
            "                fd = fd.fileno()",
            "            except AttributeError:",
            "                pass",
            "            self.set_file(fd)",
            "            # set it to non-blocking mode",
            "            os.set_blocking(fd, False)",
            "",
            "        def set_file(self, fd):",
            "            self.socket = file_wrapper(fd)",
            "            self._fileno = self.socket.fileno()",
            "            self.add_channel()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "429": [
                "dispatcher",
                "send"
            ],
            "437": [
                "dispatcher",
                "send"
            ]
        },
        "addLocation": []
    }
}