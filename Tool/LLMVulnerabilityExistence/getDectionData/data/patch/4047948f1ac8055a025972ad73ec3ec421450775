{
    "os_brick/initiator/connectors/scaleio.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import requests"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+import six"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from six.moves import configparser"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from six.moves import urllib"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from oslo_concurrency import lockutils"
            },
            "8": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " LOG = logging.getLogger(__name__)"
            },
            "10": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " DEVICE_SCAN_ATTEMPTS_DEFAULT = 3"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+CONNECTOR_CONF_PATH = '/opt/emc/scaleio/openstack/connector.conf'"
            },
            "12": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " synchronized = lockutils.synchronized_with_prefix('os-brick-')"
            },
            "13": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     VOLUME_NOT_MAPPED_ERROR = 84"
            },
            "16": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     VOLUME_ALREADY_MAPPED_ERROR = 81"
            },
            "17": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     GET_GUID_CMD = ['/opt/emc/scaleio/sdc/bin/drv_cfg', '--query_guid']"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    GET_PASSWORD_CMD = ['cat', CONNECTOR_CONF_PATH]"
            },
            "19": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     def __init__(self, root_helper, driver=None,"
            },
            "21": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "                  device_scan_attempts=initiator.DEVICE_SCAN_ATTEMPTS_DEFAULT,"
            },
            "22": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "                  {'volume_id': volume_id})"
            },
            "23": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         return volume_id"
            },
            "24": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+    def _get_connector_password(self, config_group):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+        LOG.info(\"Get ScaleIO connector password from configuration file\")"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        if not os.path.isfile(CONNECTOR_CONF_PATH):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            msg = (\"ScaleIO connector configuration file \""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                   \"is not found in path %s.\" % CONNECTOR_CONF_PATH)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+            raise exception.BrickException(message=msg)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        try:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+            (out, err) = self._execute(*self.GET_PASSWORD_CMD,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+                                       run_as_root=True,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+                                       root_helper=self._root_helper)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+            conf = configparser.ConfigParser()"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+            conf.readfp(six.StringIO(out))"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+            return conf[config_group][\"san_password\"]"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+        except putils.ProcessExecutionError as e:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+            msg = _(\"Error reading ScaleIO connector \""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+                    \"configuration file: %s\") % e.stderr"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+            LOG.error(msg)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+            raise exception.BrickException(message=msg)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        except Exception as e:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+            msg = _(\"Error getting ScaleIO connector password from \""
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+                    \"configuration file: %s\") % e"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+            LOG.error(msg)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+            raise exception.BrickException(message=msg)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "     def _check_response(self, response, request, is_get_request=True,"
            },
            "52": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "                         params=None):"
            },
            "53": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         if response.status_code == 401 or response.status_code == 403:"
            },
            "54": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "         self.server_ip = connection_properties['serverIP']"
            },
            "55": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         self.server_port = connection_properties['serverPort']"
            },
            "56": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "         self.server_username = connection_properties['serverUsername']"
            },
            "57": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.server_password = connection_properties['serverPassword']"
            },
            "58": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.server_token = connection_properties['serverToken']"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+        self.server_password = self._get_connector_password("
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+            connection_properties['config_group'],"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        )"
            },
            "62": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "         self.iops_limit = connection_properties['iopsLimit']"
            },
            "63": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "         self.bandwidth_limit = connection_properties['bandwidthLimit']"
            },
            "64": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "         device_info = {'type': 'block',"
            }
        },
        "frontPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import json",
            "import os",
            "import requests",
            "from six.moves import urllib",
            "",
            "from oslo_concurrency import lockutils",
            "from oslo_concurrency import processutils as putils",
            "from oslo_log import log as logging",
            "",
            "from os_brick import exception",
            "from os_brick.i18n import _",
            "from os_brick import initiator",
            "from os_brick.initiator.connectors import base",
            "from os_brick import utils",
            "",
            "LOG = logging.getLogger(__name__)",
            "DEVICE_SCAN_ATTEMPTS_DEFAULT = 3",
            "synchronized = lockutils.synchronized_with_prefix('os-brick-')",
            "",
            "",
            "class ScaleIOConnector(base.BaseLinuxConnector):",
            "    \"\"\"Class implements the connector driver for ScaleIO.\"\"\"",
            "",
            "    OK_STATUS_CODE = 200",
            "    VOLUME_NOT_MAPPED_ERROR = 84",
            "    VOLUME_ALREADY_MAPPED_ERROR = 81",
            "    GET_GUID_CMD = ['/opt/emc/scaleio/sdc/bin/drv_cfg', '--query_guid']",
            "",
            "    def __init__(self, root_helper, driver=None,",
            "                 device_scan_attempts=initiator.DEVICE_SCAN_ATTEMPTS_DEFAULT,",
            "                 *args, **kwargs):",
            "        super(ScaleIOConnector, self).__init__(",
            "            root_helper,",
            "            driver=driver,",
            "            device_scan_attempts=device_scan_attempts,",
            "            *args, **kwargs",
            "        )",
            "",
            "        self.local_sdc_ip = None",
            "        self.server_ip = None",
            "        self.server_port = None",
            "        self.server_username = None",
            "        self.server_password = None",
            "        self.server_token = None",
            "        self.volume_id = None",
            "        self.volume_name = None",
            "        self.volume_path = None",
            "        self.iops_limit = None",
            "        self.bandwidth_limit = None",
            "",
            "    @staticmethod",
            "    def get_connector_properties(root_helper, *args, **kwargs):",
            "        \"\"\"The ScaleIO connector properties.\"\"\"",
            "        return {}",
            "",
            "    def get_search_path(self):",
            "        return \"/dev/disk/by-id\"",
            "",
            "    def get_volume_paths(self, connection_properties):",
            "        self.get_config(connection_properties)",
            "        volume_paths = []",
            "        device_paths = [self._find_volume_path()]",
            "        for path in device_paths:",
            "            if os.path.exists(path):",
            "                volume_paths.append(path)",
            "        return volume_paths",
            "",
            "    def _find_volume_path(self):",
            "        LOG.info(",
            "            \"Looking for volume %(volume_id)s, maximum tries: %(tries)s\",",
            "            {'volume_id': self.volume_id, 'tries': self.device_scan_attempts}",
            "        )",
            "",
            "        # look for the volume in /dev/disk/by-id directory",
            "        by_id_path = self.get_search_path()",
            "",
            "        disk_filename = self._wait_for_volume_path(by_id_path)",
            "        full_disk_name = (\"%(path)s/%(filename)s\" %",
            "                          {'path': by_id_path, 'filename': disk_filename})",
            "        LOG.info(\"Full disk name is %(full_path)s\",",
            "                 {'full_path': full_disk_name})",
            "        return full_disk_name",
            "",
            "    # NOTE: Usually 3 retries is enough to find the volume.",
            "    # If there are network issues, it could take much longer. Set",
            "    # the max retries to 15 to make sure we can find the volume.",
            "    @utils.retry(exceptions=exception.BrickException,",
            "                 retries=15,",
            "                 backoff_rate=1)",
            "    def _wait_for_volume_path(self, path):",
            "        if not os.path.isdir(path):",
            "            msg = (",
            "                _(\"ScaleIO volume %(volume_id)s not found at \"",
            "                  \"expected path.\") % {'volume_id': self.volume_id}",
            "            )",
            "",
            "            LOG.debug(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        disk_filename = None",
            "        filenames = os.listdir(path)",
            "        LOG.info(",
            "            \"Files found in %(path)s path: %(files)s \",",
            "            {'path': path, 'files': filenames}",
            "        )",
            "",
            "        for filename in filenames:",
            "            if (filename.startswith(\"emc-vol\") and",
            "                    filename.endswith(self.volume_id)):",
            "                disk_filename = filename",
            "                break",
            "",
            "        if not disk_filename:",
            "            msg = (_(\"ScaleIO volume %(volume_id)s not found.\") %",
            "                   {'volume_id': self.volume_id})",
            "            LOG.debug(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        return disk_filename",
            "",
            "    def _get_client_id(self):",
            "        request = (",
            "            \"https://%(server_ip)s:%(server_port)s/\"",
            "            \"api/types/Client/instances/getByIp::%(sdc_ip)s/\" %",
            "            {",
            "                'server_ip': self.server_ip,",
            "                'server_port': self.server_port,",
            "                'sdc_ip': self.local_sdc_ip",
            "            }",
            "        )",
            "",
            "        LOG.info(\"ScaleIO get client id by ip request: %(request)s\",",
            "                 {'request': request})",
            "",
            "        r = requests.get(",
            "            request,",
            "            auth=(self.server_username, self.server_token),",
            "            verify=False",
            "        )",
            "",
            "        r = self._check_response(r, request)",
            "        sdc_id = r.json()",
            "        if not sdc_id:",
            "            msg = (_(\"Client with ip %(sdc_ip)s was not found.\") %",
            "                   {'sdc_ip': self.local_sdc_ip})",
            "            raise exception.BrickException(message=msg)",
            "",
            "        if r.status_code != 200 and \"errorCode\" in sdc_id:",
            "            msg = (_(\"Error getting sdc id from ip %(sdc_ip)s: %(err)s\") %",
            "                   {'sdc_ip': self.local_sdc_ip, 'err': sdc_id['message']})",
            "",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        LOG.info(\"ScaleIO sdc id is %(sdc_id)s.\",",
            "                 {'sdc_id': sdc_id})",
            "        return sdc_id",
            "",
            "    def _get_volume_id(self):",
            "        volname_encoded = urllib.parse.quote(self.volume_name, '')",
            "        volname_double_encoded = urllib.parse.quote(volname_encoded, '')",
            "        LOG.debug(_(",
            "            \"Volume name after double encoding is %(volume_name)s.\"),",
            "            {'volume_name': volname_double_encoded}",
            "        )",
            "",
            "        request = (",
            "            \"https://%(server_ip)s:%(server_port)s/api/types/Volume/instances\"",
            "            \"/getByName::%(encoded_volume_name)s\" %",
            "            {",
            "                'server_ip': self.server_ip,",
            "                'server_port': self.server_port,",
            "                'encoded_volume_name': volname_double_encoded",
            "            }",
            "        )",
            "",
            "        LOG.info(",
            "            \"ScaleIO get volume id by name request: %(request)s\",",
            "            {'request': request}",
            "        )",
            "",
            "        r = requests.get(request,",
            "                         auth=(self.server_username, self.server_token),",
            "                         verify=False)",
            "",
            "        r = self._check_response(r, request)",
            "",
            "        volume_id = r.json()",
            "        if not volume_id:",
            "            msg = (_(\"Volume with name %(volume_name)s wasn't found.\") %",
            "                   {'volume_name': self.volume_name})",
            "",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        if r.status_code != self.OK_STATUS_CODE and \"errorCode\" in volume_id:",
            "            msg = (",
            "                _(\"Error getting volume id from name %(volume_name)s: \"",
            "                  \"%(err)s\") %",
            "                {'volume_name': self.volume_name, 'err': volume_id['message']}",
            "            )",
            "",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        LOG.info(\"ScaleIO volume id is %(volume_id)s.\",",
            "                 {'volume_id': volume_id})",
            "        return volume_id",
            "",
            "    def _check_response(self, response, request, is_get_request=True,",
            "                        params=None):",
            "        if response.status_code == 401 or response.status_code == 403:",
            "            LOG.info(\"Token is invalid, \"",
            "                     \"going to re-login to get a new one\")",
            "",
            "            login_request = (",
            "                \"https://%(server_ip)s:%(server_port)s/api/login\" %",
            "                {'server_ip': self.server_ip, 'server_port': self.server_port}",
            "            )",
            "",
            "            r = requests.get(",
            "                login_request,",
            "                auth=(self.server_username, self.server_password),",
            "                verify=False",
            "            )",
            "",
            "            token = r.json()",
            "            # repeat request with valid token",
            "            LOG.debug(_(\"Going to perform request %(request)s again \"",
            "                        \"with valid token\"), {'request': request})",
            "",
            "            if is_get_request:",
            "                res = requests.get(request,",
            "                                   auth=(self.server_username, token),",
            "                                   verify=False)",
            "            else:",
            "                headers = {'content-type': 'application/json'}",
            "                res = requests.post(",
            "                    request,",
            "                    data=json.dumps(params),",
            "                    headers=headers,",
            "                    auth=(self.server_username, token),",
            "                    verify=False",
            "                )",
            "",
            "            self.server_token = token",
            "            return res",
            "",
            "        return response",
            "",
            "    def get_config(self, connection_properties):",
            "        self.local_sdc_ip = connection_properties['hostIP']",
            "        self.volume_name = connection_properties['scaleIO_volname']",
            "        self.volume_id = connection_properties['scaleIO_volume_id']",
            "        self.server_ip = connection_properties['serverIP']",
            "        self.server_port = connection_properties['serverPort']",
            "        self.server_username = connection_properties['serverUsername']",
            "        self.server_password = connection_properties['serverPassword']",
            "        self.server_token = connection_properties['serverToken']",
            "        self.iops_limit = connection_properties['iopsLimit']",
            "        self.bandwidth_limit = connection_properties['bandwidthLimit']",
            "        device_info = {'type': 'block',",
            "                       'path': self.volume_path}",
            "        return device_info",
            "",
            "    @utils.trace",
            "    @lockutils.synchronized('scaleio', 'scaleio-')",
            "    def connect_volume(self, connection_properties):",
            "        \"\"\"Connect the volume.",
            "",
            "        :param connection_properties: The dictionary that describes all",
            "                                      of the target volume attributes.",
            "        :type connection_properties: dict",
            "        :returns: dict",
            "        \"\"\"",
            "        device_info = self.get_config(connection_properties)",
            "        LOG.debug(",
            "            _(",
            "                \"scaleIO Volume name: %(volume_name)s, SDC IP: %(sdc_ip)s, \"",
            "                \"REST Server IP: %(server_ip)s, \"",
            "                \"REST Server username: %(username)s, \"",
            "                \"iops limit:%(iops_limit)s, \"",
            "                \"bandwidth limit: %(bandwidth_limit)s.\"",
            "            ), {",
            "                'volume_name': self.volume_name,",
            "                'volume_id': self.volume_id,",
            "                'sdc_ip': self.local_sdc_ip,",
            "                'server_ip': self.server_ip,",
            "                'username': self.server_username,",
            "                'iops_limit': self.iops_limit,",
            "                'bandwidth_limit': self.bandwidth_limit",
            "            }",
            "        )",
            "",
            "        LOG.info(\"ScaleIO sdc query guid command: %(cmd)s\",",
            "                 {'cmd': self.GET_GUID_CMD})",
            "",
            "        try:",
            "            (out, err) = self._execute(*self.GET_GUID_CMD, run_as_root=True,",
            "                                       root_helper=self._root_helper)",
            "",
            "            LOG.info(\"Map volume %(cmd)s: stdout=%(out)s \"",
            "                     \"stderr=%(err)s\",",
            "                     {'cmd': self.GET_GUID_CMD, 'out': out, 'err': err})",
            "",
            "        except putils.ProcessExecutionError as e:",
            "            msg = (_(\"Error querying sdc guid: %(err)s\") % {'err': e.stderr})",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        guid = out",
            "        LOG.info(\"Current sdc guid: %(guid)s\", {'guid': guid})",
            "        params = {'guid': guid, 'allowMultipleMappings': 'TRUE'}",
            "        self.volume_id = self.volume_id or self._get_volume_id()",
            "",
            "        headers = {'content-type': 'application/json'}",
            "        request = (",
            "            \"https://%(server_ip)s:%(server_port)s/api/instances/\"",
            "            \"Volume::%(volume_id)s/action/addMappedSdc\" %",
            "            {'server_ip': self.server_ip, 'server_port': self.server_port,",
            "             'volume_id': self.volume_id}",
            "        )",
            "",
            "        LOG.info(\"map volume request: %(request)s\", {'request': request})",
            "        r = requests.post(",
            "            request,",
            "            data=json.dumps(params),",
            "            headers=headers,",
            "            auth=(self.server_username, self.server_token),",
            "            verify=False",
            "        )",
            "",
            "        r = self._check_response(r, request, False, params)",
            "        if r.status_code != self.OK_STATUS_CODE:",
            "            response = r.json()",
            "            error_code = response['errorCode']",
            "            if error_code == self.VOLUME_ALREADY_MAPPED_ERROR:",
            "                LOG.warning(",
            "                    \"Ignoring error mapping volume %(volume_name)s: \"",
            "                    \"volume already mapped.\",",
            "                    {'volume_name': self.volume_name}",
            "                )",
            "            else:",
            "                msg = (",
            "                    _(\"Error mapping volume %(volume_name)s: %(err)s\") %",
            "                    {'volume_name': self.volume_name,",
            "                     'err': response['message']}",
            "                )",
            "",
            "                LOG.error(msg)",
            "                raise exception.BrickException(message=msg)",
            "",
            "        self.volume_path = self._find_volume_path()",
            "        device_info['path'] = self.volume_path",
            "",
            "        # Set QoS settings after map was performed",
            "        if self.iops_limit is not None or self.bandwidth_limit is not None:",
            "            params = {'guid': guid}",
            "            if self.bandwidth_limit is not None:",
            "                params['bandwidthLimitInKbps'] = self.bandwidth_limit",
            "            if self.iops_limit is not None:",
            "                params['iopsLimit'] = self.iops_limit",
            "",
            "            request = (",
            "                \"https://%(server_ip)s:%(server_port)s/api/instances/\"",
            "                \"Volume::%(volume_id)s/action/setMappedSdcLimits\" %",
            "                {'server_ip': self.server_ip, 'server_port': self.server_port,",
            "                 'volume_id': self.volume_id}",
            "            )",
            "",
            "            LOG.info(\"Set client limit request: %(request)s\",",
            "                     {'request': request})",
            "",
            "            r = requests.post(",
            "                request,",
            "                data=json.dumps(params),",
            "                headers=headers,",
            "                auth=(self.server_username, self.server_token),",
            "                verify=False",
            "            )",
            "            r = self._check_response(r, request, False, params)",
            "            if r.status_code != self.OK_STATUS_CODE:",
            "                response = r.json()",
            "                LOG.info(\"Set client limit response: %(response)s\",",
            "                         {'response': response})",
            "                msg = (",
            "                    _(\"Error setting client limits for volume \"",
            "                      \"%(volume_name)s: %(err)s\") %",
            "                    {'volume_name': self.volume_name,",
            "                     'err': response['message']}",
            "                )",
            "",
            "                LOG.error(msg)",
            "",
            "        return device_info",
            "",
            "    @utils.trace",
            "    @lockutils.synchronized('scaleio', 'scaleio-')",
            "    def disconnect_volume(self, connection_properties, device_info,",
            "                          force=False, ignore_errors=False):",
            "        \"\"\"Disconnect the ScaleIO volume.",
            "",
            "        :param connection_properties: The dictionary that describes all",
            "                                      of the target volume attributes.",
            "        :type connection_properties: dict",
            "        :param device_info: historical difference, but same as connection_props",
            "        :type device_info: dict",
            "        \"\"\"",
            "        self.get_config(connection_properties)",
            "        self.volume_id = self.volume_id or self._get_volume_id()",
            "        LOG.info(",
            "            \"ScaleIO disconnect volume in ScaleIO brick volume driver.\"",
            "        )",
            "",
            "        LOG.debug(",
            "            _(\"ScaleIO Volume name: %(volume_name)s, SDC IP: %(sdc_ip)s, \"",
            "              \"REST Server IP: %(server_ip)s\"),",
            "            {'volume_name': self.volume_name, 'sdc_ip': self.local_sdc_ip,",
            "             'server_ip': self.server_ip}",
            "        )",
            "",
            "        LOG.info(\"ScaleIO sdc query guid command: %(cmd)s\",",
            "                 {'cmd': self.GET_GUID_CMD})",
            "",
            "        try:",
            "            (out, err) = self._execute(*self.GET_GUID_CMD, run_as_root=True,",
            "                                       root_helper=self._root_helper)",
            "            LOG.info(",
            "                \"Unmap volume %(cmd)s: stdout=%(out)s stderr=%(err)s\",",
            "                {'cmd': self.GET_GUID_CMD, 'out': out, 'err': err}",
            "            )",
            "",
            "        except putils.ProcessExecutionError as e:",
            "            msg = _(\"Error querying sdc guid: %(err)s\") % {'err': e.stderr}",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        guid = out",
            "        LOG.info(\"Current sdc guid: %(guid)s\", {'guid': guid})",
            "",
            "        params = {'guid': guid}",
            "        headers = {'content-type': 'application/json'}",
            "        request = (",
            "            \"https://%(server_ip)s:%(server_port)s/api/instances/\"",
            "            \"Volume::%(volume_id)s/action/removeMappedSdc\" %",
            "            {'server_ip': self.server_ip, 'server_port': self.server_port,",
            "             'volume_id': self.volume_id}",
            "        )",
            "",
            "        LOG.info(\"Unmap volume request: %(request)s\",",
            "                 {'request': request})",
            "        r = requests.post(",
            "            request,",
            "            data=json.dumps(params),",
            "            headers=headers,",
            "            auth=(self.server_username, self.server_token),",
            "            verify=False",
            "        )",
            "",
            "        r = self._check_response(r, request, False, params)",
            "        if r.status_code != self.OK_STATUS_CODE:",
            "            response = r.json()",
            "            error_code = response['errorCode']",
            "            if error_code == self.VOLUME_NOT_MAPPED_ERROR:",
            "                LOG.warning(",
            "                    \"Ignoring error unmapping volume %(volume_id)s: \"",
            "                    \"volume not mapped.\", {'volume_id': self.volume_name}",
            "                )",
            "            else:",
            "                msg = (_(\"Error unmapping volume %(volume_id)s: %(err)s\") %",
            "                       {'volume_id': self.volume_name,",
            "                        'err': response['message']})",
            "                LOG.error(msg)",
            "                raise exception.BrickException(message=msg)",
            "",
            "    def extend_volume(self, connection_properties):",
            "        # TODO(walter-boring): is this possible?",
            "        raise NotImplementedError"
        ],
        "afterPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import json",
            "import os",
            "import requests",
            "import six",
            "from six.moves import configparser",
            "from six.moves import urllib",
            "",
            "from oslo_concurrency import lockutils",
            "from oslo_concurrency import processutils as putils",
            "from oslo_log import log as logging",
            "",
            "from os_brick import exception",
            "from os_brick.i18n import _",
            "from os_brick import initiator",
            "from os_brick.initiator.connectors import base",
            "from os_brick import utils",
            "",
            "LOG = logging.getLogger(__name__)",
            "DEVICE_SCAN_ATTEMPTS_DEFAULT = 3",
            "CONNECTOR_CONF_PATH = '/opt/emc/scaleio/openstack/connector.conf'",
            "synchronized = lockutils.synchronized_with_prefix('os-brick-')",
            "",
            "",
            "class ScaleIOConnector(base.BaseLinuxConnector):",
            "    \"\"\"Class implements the connector driver for ScaleIO.\"\"\"",
            "",
            "    OK_STATUS_CODE = 200",
            "    VOLUME_NOT_MAPPED_ERROR = 84",
            "    VOLUME_ALREADY_MAPPED_ERROR = 81",
            "    GET_GUID_CMD = ['/opt/emc/scaleio/sdc/bin/drv_cfg', '--query_guid']",
            "    GET_PASSWORD_CMD = ['cat', CONNECTOR_CONF_PATH]",
            "",
            "    def __init__(self, root_helper, driver=None,",
            "                 device_scan_attempts=initiator.DEVICE_SCAN_ATTEMPTS_DEFAULT,",
            "                 *args, **kwargs):",
            "        super(ScaleIOConnector, self).__init__(",
            "            root_helper,",
            "            driver=driver,",
            "            device_scan_attempts=device_scan_attempts,",
            "            *args, **kwargs",
            "        )",
            "",
            "        self.local_sdc_ip = None",
            "        self.server_ip = None",
            "        self.server_port = None",
            "        self.server_username = None",
            "        self.server_password = None",
            "        self.server_token = None",
            "        self.volume_id = None",
            "        self.volume_name = None",
            "        self.volume_path = None",
            "        self.iops_limit = None",
            "        self.bandwidth_limit = None",
            "",
            "    @staticmethod",
            "    def get_connector_properties(root_helper, *args, **kwargs):",
            "        \"\"\"The ScaleIO connector properties.\"\"\"",
            "        return {}",
            "",
            "    def get_search_path(self):",
            "        return \"/dev/disk/by-id\"",
            "",
            "    def get_volume_paths(self, connection_properties):",
            "        self.get_config(connection_properties)",
            "        volume_paths = []",
            "        device_paths = [self._find_volume_path()]",
            "        for path in device_paths:",
            "            if os.path.exists(path):",
            "                volume_paths.append(path)",
            "        return volume_paths",
            "",
            "    def _find_volume_path(self):",
            "        LOG.info(",
            "            \"Looking for volume %(volume_id)s, maximum tries: %(tries)s\",",
            "            {'volume_id': self.volume_id, 'tries': self.device_scan_attempts}",
            "        )",
            "",
            "        # look for the volume in /dev/disk/by-id directory",
            "        by_id_path = self.get_search_path()",
            "",
            "        disk_filename = self._wait_for_volume_path(by_id_path)",
            "        full_disk_name = (\"%(path)s/%(filename)s\" %",
            "                          {'path': by_id_path, 'filename': disk_filename})",
            "        LOG.info(\"Full disk name is %(full_path)s\",",
            "                 {'full_path': full_disk_name})",
            "        return full_disk_name",
            "",
            "    # NOTE: Usually 3 retries is enough to find the volume.",
            "    # If there are network issues, it could take much longer. Set",
            "    # the max retries to 15 to make sure we can find the volume.",
            "    @utils.retry(exceptions=exception.BrickException,",
            "                 retries=15,",
            "                 backoff_rate=1)",
            "    def _wait_for_volume_path(self, path):",
            "        if not os.path.isdir(path):",
            "            msg = (",
            "                _(\"ScaleIO volume %(volume_id)s not found at \"",
            "                  \"expected path.\") % {'volume_id': self.volume_id}",
            "            )",
            "",
            "            LOG.debug(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        disk_filename = None",
            "        filenames = os.listdir(path)",
            "        LOG.info(",
            "            \"Files found in %(path)s path: %(files)s \",",
            "            {'path': path, 'files': filenames}",
            "        )",
            "",
            "        for filename in filenames:",
            "            if (filename.startswith(\"emc-vol\") and",
            "                    filename.endswith(self.volume_id)):",
            "                disk_filename = filename",
            "                break",
            "",
            "        if not disk_filename:",
            "            msg = (_(\"ScaleIO volume %(volume_id)s not found.\") %",
            "                   {'volume_id': self.volume_id})",
            "            LOG.debug(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        return disk_filename",
            "",
            "    def _get_client_id(self):",
            "        request = (",
            "            \"https://%(server_ip)s:%(server_port)s/\"",
            "            \"api/types/Client/instances/getByIp::%(sdc_ip)s/\" %",
            "            {",
            "                'server_ip': self.server_ip,",
            "                'server_port': self.server_port,",
            "                'sdc_ip': self.local_sdc_ip",
            "            }",
            "        )",
            "",
            "        LOG.info(\"ScaleIO get client id by ip request: %(request)s\",",
            "                 {'request': request})",
            "",
            "        r = requests.get(",
            "            request,",
            "            auth=(self.server_username, self.server_token),",
            "            verify=False",
            "        )",
            "",
            "        r = self._check_response(r, request)",
            "        sdc_id = r.json()",
            "        if not sdc_id:",
            "            msg = (_(\"Client with ip %(sdc_ip)s was not found.\") %",
            "                   {'sdc_ip': self.local_sdc_ip})",
            "            raise exception.BrickException(message=msg)",
            "",
            "        if r.status_code != 200 and \"errorCode\" in sdc_id:",
            "            msg = (_(\"Error getting sdc id from ip %(sdc_ip)s: %(err)s\") %",
            "                   {'sdc_ip': self.local_sdc_ip, 'err': sdc_id['message']})",
            "",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        LOG.info(\"ScaleIO sdc id is %(sdc_id)s.\",",
            "                 {'sdc_id': sdc_id})",
            "        return sdc_id",
            "",
            "    def _get_volume_id(self):",
            "        volname_encoded = urllib.parse.quote(self.volume_name, '')",
            "        volname_double_encoded = urllib.parse.quote(volname_encoded, '')",
            "        LOG.debug(_(",
            "            \"Volume name after double encoding is %(volume_name)s.\"),",
            "            {'volume_name': volname_double_encoded}",
            "        )",
            "",
            "        request = (",
            "            \"https://%(server_ip)s:%(server_port)s/api/types/Volume/instances\"",
            "            \"/getByName::%(encoded_volume_name)s\" %",
            "            {",
            "                'server_ip': self.server_ip,",
            "                'server_port': self.server_port,",
            "                'encoded_volume_name': volname_double_encoded",
            "            }",
            "        )",
            "",
            "        LOG.info(",
            "            \"ScaleIO get volume id by name request: %(request)s\",",
            "            {'request': request}",
            "        )",
            "",
            "        r = requests.get(request,",
            "                         auth=(self.server_username, self.server_token),",
            "                         verify=False)",
            "",
            "        r = self._check_response(r, request)",
            "",
            "        volume_id = r.json()",
            "        if not volume_id:",
            "            msg = (_(\"Volume with name %(volume_name)s wasn't found.\") %",
            "                   {'volume_name': self.volume_name})",
            "",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        if r.status_code != self.OK_STATUS_CODE and \"errorCode\" in volume_id:",
            "            msg = (",
            "                _(\"Error getting volume id from name %(volume_name)s: \"",
            "                  \"%(err)s\") %",
            "                {'volume_name': self.volume_name, 'err': volume_id['message']}",
            "            )",
            "",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        LOG.info(\"ScaleIO volume id is %(volume_id)s.\",",
            "                 {'volume_id': volume_id})",
            "        return volume_id",
            "",
            "    def _get_connector_password(self, config_group):",
            "        LOG.info(\"Get ScaleIO connector password from configuration file\")",
            "",
            "        if not os.path.isfile(CONNECTOR_CONF_PATH):",
            "            msg = (\"ScaleIO connector configuration file \"",
            "                   \"is not found in path %s.\" % CONNECTOR_CONF_PATH)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        try:",
            "            (out, err) = self._execute(*self.GET_PASSWORD_CMD,",
            "                                       run_as_root=True,",
            "                                       root_helper=self._root_helper)",
            "            conf = configparser.ConfigParser()",
            "            conf.readfp(six.StringIO(out))",
            "            return conf[config_group][\"san_password\"]",
            "        except putils.ProcessExecutionError as e:",
            "            msg = _(\"Error reading ScaleIO connector \"",
            "                    \"configuration file: %s\") % e.stderr",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "        except Exception as e:",
            "            msg = _(\"Error getting ScaleIO connector password from \"",
            "                    \"configuration file: %s\") % e",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "    def _check_response(self, response, request, is_get_request=True,",
            "                        params=None):",
            "        if response.status_code == 401 or response.status_code == 403:",
            "            LOG.info(\"Token is invalid, \"",
            "                     \"going to re-login to get a new one\")",
            "",
            "            login_request = (",
            "                \"https://%(server_ip)s:%(server_port)s/api/login\" %",
            "                {'server_ip': self.server_ip, 'server_port': self.server_port}",
            "            )",
            "",
            "            r = requests.get(",
            "                login_request,",
            "                auth=(self.server_username, self.server_password),",
            "                verify=False",
            "            )",
            "",
            "            token = r.json()",
            "            # repeat request with valid token",
            "            LOG.debug(_(\"Going to perform request %(request)s again \"",
            "                        \"with valid token\"), {'request': request})",
            "",
            "            if is_get_request:",
            "                res = requests.get(request,",
            "                                   auth=(self.server_username, token),",
            "                                   verify=False)",
            "            else:",
            "                headers = {'content-type': 'application/json'}",
            "                res = requests.post(",
            "                    request,",
            "                    data=json.dumps(params),",
            "                    headers=headers,",
            "                    auth=(self.server_username, token),",
            "                    verify=False",
            "                )",
            "",
            "            self.server_token = token",
            "            return res",
            "",
            "        return response",
            "",
            "    def get_config(self, connection_properties):",
            "        self.local_sdc_ip = connection_properties['hostIP']",
            "        self.volume_name = connection_properties['scaleIO_volname']",
            "        self.volume_id = connection_properties['scaleIO_volume_id']",
            "        self.server_ip = connection_properties['serverIP']",
            "        self.server_port = connection_properties['serverPort']",
            "        self.server_username = connection_properties['serverUsername']",
            "        self.server_password = self._get_connector_password(",
            "            connection_properties['config_group'],",
            "        )",
            "        self.iops_limit = connection_properties['iopsLimit']",
            "        self.bandwidth_limit = connection_properties['bandwidthLimit']",
            "        device_info = {'type': 'block',",
            "                       'path': self.volume_path}",
            "        return device_info",
            "",
            "    @utils.trace",
            "    @lockutils.synchronized('scaleio', 'scaleio-')",
            "    def connect_volume(self, connection_properties):",
            "        \"\"\"Connect the volume.",
            "",
            "        :param connection_properties: The dictionary that describes all",
            "                                      of the target volume attributes.",
            "        :type connection_properties: dict",
            "        :returns: dict",
            "        \"\"\"",
            "        device_info = self.get_config(connection_properties)",
            "        LOG.debug(",
            "            _(",
            "                \"scaleIO Volume name: %(volume_name)s, SDC IP: %(sdc_ip)s, \"",
            "                \"REST Server IP: %(server_ip)s, \"",
            "                \"REST Server username: %(username)s, \"",
            "                \"iops limit:%(iops_limit)s, \"",
            "                \"bandwidth limit: %(bandwidth_limit)s.\"",
            "            ), {",
            "                'volume_name': self.volume_name,",
            "                'volume_id': self.volume_id,",
            "                'sdc_ip': self.local_sdc_ip,",
            "                'server_ip': self.server_ip,",
            "                'username': self.server_username,",
            "                'iops_limit': self.iops_limit,",
            "                'bandwidth_limit': self.bandwidth_limit",
            "            }",
            "        )",
            "",
            "        LOG.info(\"ScaleIO sdc query guid command: %(cmd)s\",",
            "                 {'cmd': self.GET_GUID_CMD})",
            "",
            "        try:",
            "            (out, err) = self._execute(*self.GET_GUID_CMD, run_as_root=True,",
            "                                       root_helper=self._root_helper)",
            "",
            "            LOG.info(\"Map volume %(cmd)s: stdout=%(out)s \"",
            "                     \"stderr=%(err)s\",",
            "                     {'cmd': self.GET_GUID_CMD, 'out': out, 'err': err})",
            "",
            "        except putils.ProcessExecutionError as e:",
            "            msg = (_(\"Error querying sdc guid: %(err)s\") % {'err': e.stderr})",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        guid = out",
            "        LOG.info(\"Current sdc guid: %(guid)s\", {'guid': guid})",
            "        params = {'guid': guid, 'allowMultipleMappings': 'TRUE'}",
            "        self.volume_id = self.volume_id or self._get_volume_id()",
            "",
            "        headers = {'content-type': 'application/json'}",
            "        request = (",
            "            \"https://%(server_ip)s:%(server_port)s/api/instances/\"",
            "            \"Volume::%(volume_id)s/action/addMappedSdc\" %",
            "            {'server_ip': self.server_ip, 'server_port': self.server_port,",
            "             'volume_id': self.volume_id}",
            "        )",
            "",
            "        LOG.info(\"map volume request: %(request)s\", {'request': request})",
            "        r = requests.post(",
            "            request,",
            "            data=json.dumps(params),",
            "            headers=headers,",
            "            auth=(self.server_username, self.server_token),",
            "            verify=False",
            "        )",
            "",
            "        r = self._check_response(r, request, False, params)",
            "        if r.status_code != self.OK_STATUS_CODE:",
            "            response = r.json()",
            "            error_code = response['errorCode']",
            "            if error_code == self.VOLUME_ALREADY_MAPPED_ERROR:",
            "                LOG.warning(",
            "                    \"Ignoring error mapping volume %(volume_name)s: \"",
            "                    \"volume already mapped.\",",
            "                    {'volume_name': self.volume_name}",
            "                )",
            "            else:",
            "                msg = (",
            "                    _(\"Error mapping volume %(volume_name)s: %(err)s\") %",
            "                    {'volume_name': self.volume_name,",
            "                     'err': response['message']}",
            "                )",
            "",
            "                LOG.error(msg)",
            "                raise exception.BrickException(message=msg)",
            "",
            "        self.volume_path = self._find_volume_path()",
            "        device_info['path'] = self.volume_path",
            "",
            "        # Set QoS settings after map was performed",
            "        if self.iops_limit is not None or self.bandwidth_limit is not None:",
            "            params = {'guid': guid}",
            "            if self.bandwidth_limit is not None:",
            "                params['bandwidthLimitInKbps'] = self.bandwidth_limit",
            "            if self.iops_limit is not None:",
            "                params['iopsLimit'] = self.iops_limit",
            "",
            "            request = (",
            "                \"https://%(server_ip)s:%(server_port)s/api/instances/\"",
            "                \"Volume::%(volume_id)s/action/setMappedSdcLimits\" %",
            "                {'server_ip': self.server_ip, 'server_port': self.server_port,",
            "                 'volume_id': self.volume_id}",
            "            )",
            "",
            "            LOG.info(\"Set client limit request: %(request)s\",",
            "                     {'request': request})",
            "",
            "            r = requests.post(",
            "                request,",
            "                data=json.dumps(params),",
            "                headers=headers,",
            "                auth=(self.server_username, self.server_token),",
            "                verify=False",
            "            )",
            "            r = self._check_response(r, request, False, params)",
            "            if r.status_code != self.OK_STATUS_CODE:",
            "                response = r.json()",
            "                LOG.info(\"Set client limit response: %(response)s\",",
            "                         {'response': response})",
            "                msg = (",
            "                    _(\"Error setting client limits for volume \"",
            "                      \"%(volume_name)s: %(err)s\") %",
            "                    {'volume_name': self.volume_name,",
            "                     'err': response['message']}",
            "                )",
            "",
            "                LOG.error(msg)",
            "",
            "        return device_info",
            "",
            "    @utils.trace",
            "    @lockutils.synchronized('scaleio', 'scaleio-')",
            "    def disconnect_volume(self, connection_properties, device_info,",
            "                          force=False, ignore_errors=False):",
            "        \"\"\"Disconnect the ScaleIO volume.",
            "",
            "        :param connection_properties: The dictionary that describes all",
            "                                      of the target volume attributes.",
            "        :type connection_properties: dict",
            "        :param device_info: historical difference, but same as connection_props",
            "        :type device_info: dict",
            "        \"\"\"",
            "        self.get_config(connection_properties)",
            "        self.volume_id = self.volume_id or self._get_volume_id()",
            "        LOG.info(",
            "            \"ScaleIO disconnect volume in ScaleIO brick volume driver.\"",
            "        )",
            "",
            "        LOG.debug(",
            "            _(\"ScaleIO Volume name: %(volume_name)s, SDC IP: %(sdc_ip)s, \"",
            "              \"REST Server IP: %(server_ip)s\"),",
            "            {'volume_name': self.volume_name, 'sdc_ip': self.local_sdc_ip,",
            "             'server_ip': self.server_ip}",
            "        )",
            "",
            "        LOG.info(\"ScaleIO sdc query guid command: %(cmd)s\",",
            "                 {'cmd': self.GET_GUID_CMD})",
            "",
            "        try:",
            "            (out, err) = self._execute(*self.GET_GUID_CMD, run_as_root=True,",
            "                                       root_helper=self._root_helper)",
            "            LOG.info(",
            "                \"Unmap volume %(cmd)s: stdout=%(out)s stderr=%(err)s\",",
            "                {'cmd': self.GET_GUID_CMD, 'out': out, 'err': err}",
            "            )",
            "",
            "        except putils.ProcessExecutionError as e:",
            "            msg = _(\"Error querying sdc guid: %(err)s\") % {'err': e.stderr}",
            "            LOG.error(msg)",
            "            raise exception.BrickException(message=msg)",
            "",
            "        guid = out",
            "        LOG.info(\"Current sdc guid: %(guid)s\", {'guid': guid})",
            "",
            "        params = {'guid': guid}",
            "        headers = {'content-type': 'application/json'}",
            "        request = (",
            "            \"https://%(server_ip)s:%(server_port)s/api/instances/\"",
            "            \"Volume::%(volume_id)s/action/removeMappedSdc\" %",
            "            {'server_ip': self.server_ip, 'server_port': self.server_port,",
            "             'volume_id': self.volume_id}",
            "        )",
            "",
            "        LOG.info(\"Unmap volume request: %(request)s\",",
            "                 {'request': request})",
            "        r = requests.post(",
            "            request,",
            "            data=json.dumps(params),",
            "            headers=headers,",
            "            auth=(self.server_username, self.server_token),",
            "            verify=False",
            "        )",
            "",
            "        r = self._check_response(r, request, False, params)",
            "        if r.status_code != self.OK_STATUS_CODE:",
            "            response = r.json()",
            "            error_code = response['errorCode']",
            "            if error_code == self.VOLUME_NOT_MAPPED_ERROR:",
            "                LOG.warning(",
            "                    \"Ignoring error unmapping volume %(volume_id)s: \"",
            "                    \"volume not mapped.\", {'volume_id': self.volume_name}",
            "                )",
            "            else:",
            "                msg = (_(\"Error unmapping volume %(volume_id)s: %(err)s\") %",
            "                       {'volume_id': self.volume_name,",
            "                        'err': response['message']})",
            "                LOG.error(msg)",
            "                raise exception.BrickException(message=msg)",
            "",
            "    def extend_volume(self, connection_properties):",
            "        # TODO(walter-boring): is this possible?",
            "        raise NotImplementedError"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "272": [
                "ScaleIOConnector",
                "get_config"
            ],
            "273": [
                "ScaleIOConnector",
                "get_config"
            ]
        },
        "addLocation": [
            "os_brick.initiator.connectors.scaleio.ScaleIOConnector.GET_GUID_CMD",
            "os_brick.initiator.connectors.scaleio.ScaleIOConnector.get_config",
            "src.pyload.core.database.user_database",
            "os_brick.initiator.connectors.scaleio.ScaleIOConnector.self"
        ]
    },
    "os_brick/tests/initiator/connectors/test_scaleio.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             'scaleIO_volume_id': self.vol['provider_id'],"
            },
            "1": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             'serverPort': 443,"
            },
            "2": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             'serverUsername': 'test',"
            },
            "3": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'serverPassword': 'fake',"
            },
            "4": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'serverToken': 'fake_token',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            'config_group': 'test',"
            },
            "6": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             'iopsLimit': None,"
            },
            "7": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "             'bandwidthLimit': None"
            },
            "8": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         }"
            },
            "9": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         self.mock_object(os, 'listdir',"
            },
            "10": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "                          return_value=[\"emc-vol-{}\".format(self.vol['id'])])"
            },
            "11": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        self.get_password_mock = self.mock_object(scaleio.ScaleIOConnector,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                                                  '_get_connector_password',"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                                                  return_value='fake_password')"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         # The actual ScaleIO connector"
            },
            "17": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         self.connector = scaleio.ScaleIOConnector("
            },
            "18": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "             'sudo', execute=self.fake_execute)"
            },
            "19": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     def test_connect_volume(self):"
            },
            "20": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         \"\"\"Successful connect to volume\"\"\""
            },
            "21": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         self.connector.connect_volume(self.fake_connection_properties)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        self.get_password_mock.assert_called_once()"
            },
            "23": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     def test_connect_with_bandwidth_limit(self):"
            },
            "25": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         \"\"\"Successful connect to volume with bandwidth limit\"\"\""
            }
        },
        "frontPatchFile": [
            "# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import json",
            "import mock",
            "import os",
            "import requests",
            "import six",
            "",
            "from oslo_concurrency import processutils as putils",
            "",
            "from os_brick import exception",
            "from os_brick.initiator.connectors import scaleio",
            "from os_brick.tests.initiator import test_connector",
            "",
            "",
            "class ScaleIOConnectorTestCase(test_connector.ConnectorTestCase):",
            "    \"\"\"Test cases for ScaleIO connector.\"\"\"",
            "",
            "    # Fake volume information",
            "    vol = {",
            "        'id': 'vol1',",
            "        'name': 'test_volume',",
            "        'provider_id': 'vol1'",
            "    }",
            "",
            "    # Fake SDC GUID",
            "    fake_guid = 'FAKE_GUID'",
            "",
            "    def setUp(self):",
            "        super(ScaleIOConnectorTestCase, self).setUp()",
            "",
            "        self.fake_connection_properties = {",
            "            'hostIP': test_connector.MY_IP,",
            "            'serverIP': test_connector.MY_IP,",
            "            'scaleIO_volname': self.vol['name'],",
            "            'scaleIO_volume_id': self.vol['provider_id'],",
            "            'serverPort': 443,",
            "            'serverUsername': 'test',",
            "            'serverPassword': 'fake',",
            "            'serverToken': 'fake_token',",
            "            'iopsLimit': None,",
            "            'bandwidthLimit': None",
            "        }",
            "",
            "        # Formatting string for REST API calls",
            "        self.action_format = \"instances/Volume::{}/action/{{}}\".format(",
            "            self.vol['id'])",
            "        self.get_volume_api = 'types/Volume/instances/getByName::{}'.format(",
            "            self.vol['name'])",
            "",
            "        # Map of REST API calls to responses",
            "        self.mock_calls = {",
            "            self.get_volume_api:",
            "                self.MockHTTPSResponse(json.dumps(self.vol['id'])),",
            "            self.action_format.format('addMappedSdc'):",
            "                self.MockHTTPSResponse(''),",
            "            self.action_format.format('setMappedSdcLimits'):",
            "                self.MockHTTPSResponse(''),",
            "            self.action_format.format('removeMappedSdc'):",
            "                self.MockHTTPSResponse(''),",
            "        }",
            "",
            "        # Default error REST response",
            "        self.error_404 = self.MockHTTPSResponse(content=dict(",
            "            errorCode=0,",
            "            message='HTTP 404',",
            "        ), status_code=404)",
            "",
            "        # Patch the request and os calls to fake versions",
            "        self.mock_object(requests, 'get', self.handle_scaleio_request)",
            "        self.mock_object(requests, 'post', self.handle_scaleio_request)",
            "        self.mock_object(os.path, 'isdir', return_value=True)",
            "        self.mock_object(os, 'listdir',",
            "                         return_value=[\"emc-vol-{}\".format(self.vol['id'])])",
            "",
            "        # The actual ScaleIO connector",
            "        self.connector = scaleio.ScaleIOConnector(",
            "            'sudo', execute=self.fake_execute)",
            "",
            "    class MockHTTPSResponse(requests.Response):",
            "        \"\"\"Mock HTTP Response",
            "",
            "        Defines the https replies from the mocked calls to do_request()",
            "        \"\"\"",
            "        def __init__(self, content, status_code=200):",
            "            super(ScaleIOConnectorTestCase.MockHTTPSResponse,",
            "                  self).__init__()",
            "",
            "            self._content = content",
            "            self.encoding = 'UTF-8'",
            "            self.status_code = status_code",
            "",
            "        def json(self, **kwargs):",
            "            if isinstance(self._content, six.string_types):",
            "                return super(ScaleIOConnectorTestCase.MockHTTPSResponse,",
            "                             self).json(**kwargs)",
            "",
            "            return self._content",
            "",
            "        @property",
            "        def text(self):",
            "            if not isinstance(self._content, six.string_types):",
            "                return json.dumps(self._content)",
            "",
            "            self._content = self._content.encode('utf-8')",
            "            return super(ScaleIOConnectorTestCase.MockHTTPSResponse,",
            "                         self).text",
            "",
            "    def fake_execute(self, *cmd, **kwargs):",
            "        \"\"\"Fakes the rootwrap call\"\"\"",
            "        return self.fake_guid, None",
            "",
            "    def fake_missing_execute(self, *cmd, **kwargs):",
            "        \"\"\"Error when trying to call rootwrap drv_cfg\"\"\"",
            "        raise putils.ProcessExecutionError(\"Test missing drv_cfg.\")",
            "",
            "    def handle_scaleio_request(self, url, *args, **kwargs):",
            "        \"\"\"Fake REST server\"\"\"",
            "        api_call = url.split(':', 2)[2].split('/', 1)[1].replace('api/', '')",
            "",
            "        if 'setMappedSdcLimits' in api_call:",
            "            self.assertNotIn(\"iops_limit\", kwargs['data'])",
            "            if \"iopsLimit\" not in kwargs['data']:",
            "                self.assertIn(\"bandwidthLimitInKbps\",",
            "                              kwargs['data'])",
            "            elif \"bandwidthLimitInKbps\" not in kwargs['data']:",
            "                self.assertIn(\"iopsLimit\", kwargs['data'])",
            "            else:",
            "                self.assertIn(\"bandwidthLimitInKbps\",",
            "                              kwargs['data'])",
            "                self.assertIn(\"iopsLimit\", kwargs['data'])",
            "",
            "        try:",
            "            return self.mock_calls[api_call]",
            "        except KeyError:",
            "            return self.error_404",
            "",
            "    def test_get_search_path(self):",
            "        expected = \"/dev/disk/by-id\"",
            "        actual = self.connector.get_search_path()",
            "        self.assertEqual(expected, actual)",
            "",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    @mock.patch.object(scaleio.ScaleIOConnector, '_wait_for_volume_path')",
            "    def test_get_volume_paths(self, mock_wait_for_path, mock_exists):",
            "        mock_wait_for_path.return_value = \"emc-vol-vol1\"",
            "        expected = ['/dev/disk/by-id/emc-vol-vol1']",
            "        actual = self.connector.get_volume_paths(",
            "            self.fake_connection_properties)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_get_connector_properties(self):",
            "        props = scaleio.ScaleIOConnector.get_connector_properties(",
            "            'sudo', multipath=True, enforce_multipath=True)",
            "",
            "        expected_props = {}",
            "        self.assertEqual(expected_props, props)",
            "",
            "    def test_connect_volume(self):",
            "        \"\"\"Successful connect to volume\"\"\"",
            "        self.connector.connect_volume(self.fake_connection_properties)",
            "",
            "    def test_connect_with_bandwidth_limit(self):",
            "        \"\"\"Successful connect to volume with bandwidth limit\"\"\"",
            "        self.fake_connection_properties['bandwidthLimit'] = '500'",
            "        self.test_connect_volume()",
            "",
            "    def test_connect_with_iops_limit(self):",
            "        \"\"\"Successful connect to volume with iops limit\"\"\"",
            "        self.fake_connection_properties['iopsLimit'] = '80'",
            "        self.test_connect_volume()",
            "",
            "    def test_connect_with_iops_and_bandwidth_limits(self):",
            "        \"\"\"Successful connect with iops and bandwidth limits\"\"\"",
            "        self.fake_connection_properties['bandwidthLimit'] = '500'",
            "        self.fake_connection_properties['iopsLimit'] = '80'",
            "        self.test_connect_volume()",
            "",
            "    def test_disconnect_volume(self):",
            "        \"\"\"Successful disconnect from volume\"\"\"",
            "        self.connector.disconnect_volume(self.fake_connection_properties, None)",
            "",
            "    def test_error_id(self):",
            "        \"\"\"Fail to connect with bad volume name\"\"\"",
            "        self.fake_connection_properties['scaleIO_volume_id'] = 'bad_id'",
            "        self.mock_calls[self.get_volume_api] = self.MockHTTPSResponse(",
            "            dict(errorCode='404', message='Test volume not found'), 404)",
            "",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    def test_error_no_volume_id(self):",
            "        \"\"\"Faile to connect with no volume id\"\"\"",
            "        self.fake_connection_properties['scaleIO_volume_id'] = None",
            "        self.mock_calls[self.get_volume_api] = self.MockHTTPSResponse(",
            "            'null', 200)",
            "",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    def test_error_bad_login(self):",
            "        \"\"\"Fail to connect with bad authentication\"\"\"",
            "        self.mock_calls[self.get_volume_api] = self.MockHTTPSResponse(",
            "            'null', 401)",
            "",
            "        self.mock_calls['login'] = self.MockHTTPSResponse('null', 401)",
            "        self.mock_calls[self.action_format.format(",
            "            'addMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=401, message='bad login'), 401)",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    def test_error_bad_drv_cfg(self):",
            "        \"\"\"Fail to connect with missing rootwrap executable\"\"\"",
            "        self.connector.set_execute(self.fake_missing_execute)",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    def test_error_map_volume(self):",
            "        \"\"\"Fail to connect with REST API failure\"\"\"",
            "        self.mock_calls[self.action_format.format(",
            "            'addMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=self.connector.VOLUME_NOT_MAPPED_ERROR,",
            "                 message='Test error map volume'), 500)",
            "",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    @mock.patch('time.sleep')",
            "    def test_error_path_not_found(self, sleep_mock):",
            "        \"\"\"Timeout waiting for volume to map to local file system\"\"\"",
            "        self.mock_object(os, 'listdir', return_value=[\"emc-vol-no-volume\"])",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "        self.assertTrue(sleep_mock.called)",
            "",
            "    def test_map_volume_already_mapped(self):",
            "        \"\"\"Ignore REST API failure for volume already mapped\"\"\"",
            "        self.mock_calls[self.action_format.format(",
            "            'addMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=self.connector.VOLUME_ALREADY_MAPPED_ERROR,",
            "                 message='Test error map volume'), 500)",
            "",
            "        self.test_connect_volume()",
            "",
            "    def test_error_disconnect_volume(self):",
            "        \"\"\"Fail to disconnect with REST API failure\"\"\"",
            "        self.mock_calls[self.action_format.format(",
            "            'removeMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=self.connector.VOLUME_ALREADY_MAPPED_ERROR,",
            "                 message='Test error map volume'), 500)",
            "",
            "        self.assertRaises(exception.BrickException,",
            "                          self.test_disconnect_volume)",
            "",
            "    def test_disconnect_volume_not_mapped(self):",
            "        \"\"\"Ignore REST API failure for volume not mapped\"\"\"",
            "        self.mock_calls[self.action_format.format(",
            "            'removeMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=self.connector.VOLUME_NOT_MAPPED_ERROR,",
            "                 message='Test error map volume'), 500)",
            "",
            "        self.test_disconnect_volume()",
            "",
            "    def test_extend_volume(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.connector.extend_volume,",
            "                          self.fake_connection_properties)"
        ],
        "afterPatchFile": [
            "# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import json",
            "import mock",
            "import os",
            "import requests",
            "import six",
            "",
            "from oslo_concurrency import processutils as putils",
            "",
            "from os_brick import exception",
            "from os_brick.initiator.connectors import scaleio",
            "from os_brick.tests.initiator import test_connector",
            "",
            "",
            "class ScaleIOConnectorTestCase(test_connector.ConnectorTestCase):",
            "    \"\"\"Test cases for ScaleIO connector.\"\"\"",
            "",
            "    # Fake volume information",
            "    vol = {",
            "        'id': 'vol1',",
            "        'name': 'test_volume',",
            "        'provider_id': 'vol1'",
            "    }",
            "",
            "    # Fake SDC GUID",
            "    fake_guid = 'FAKE_GUID'",
            "",
            "    def setUp(self):",
            "        super(ScaleIOConnectorTestCase, self).setUp()",
            "",
            "        self.fake_connection_properties = {",
            "            'hostIP': test_connector.MY_IP,",
            "            'serverIP': test_connector.MY_IP,",
            "            'scaleIO_volname': self.vol['name'],",
            "            'scaleIO_volume_id': self.vol['provider_id'],",
            "            'serverPort': 443,",
            "            'serverUsername': 'test',",
            "            'config_group': 'test',",
            "            'iopsLimit': None,",
            "            'bandwidthLimit': None",
            "        }",
            "",
            "        # Formatting string for REST API calls",
            "        self.action_format = \"instances/Volume::{}/action/{{}}\".format(",
            "            self.vol['id'])",
            "        self.get_volume_api = 'types/Volume/instances/getByName::{}'.format(",
            "            self.vol['name'])",
            "",
            "        # Map of REST API calls to responses",
            "        self.mock_calls = {",
            "            self.get_volume_api:",
            "                self.MockHTTPSResponse(json.dumps(self.vol['id'])),",
            "            self.action_format.format('addMappedSdc'):",
            "                self.MockHTTPSResponse(''),",
            "            self.action_format.format('setMappedSdcLimits'):",
            "                self.MockHTTPSResponse(''),",
            "            self.action_format.format('removeMappedSdc'):",
            "                self.MockHTTPSResponse(''),",
            "        }",
            "",
            "        # Default error REST response",
            "        self.error_404 = self.MockHTTPSResponse(content=dict(",
            "            errorCode=0,",
            "            message='HTTP 404',",
            "        ), status_code=404)",
            "",
            "        # Patch the request and os calls to fake versions",
            "        self.mock_object(requests, 'get', self.handle_scaleio_request)",
            "        self.mock_object(requests, 'post', self.handle_scaleio_request)",
            "        self.mock_object(os.path, 'isdir', return_value=True)",
            "        self.mock_object(os, 'listdir',",
            "                         return_value=[\"emc-vol-{}\".format(self.vol['id'])])",
            "",
            "        self.get_password_mock = self.mock_object(scaleio.ScaleIOConnector,",
            "                                                  '_get_connector_password',",
            "                                                  return_value='fake_password')",
            "",
            "        # The actual ScaleIO connector",
            "        self.connector = scaleio.ScaleIOConnector(",
            "            'sudo', execute=self.fake_execute)",
            "",
            "    class MockHTTPSResponse(requests.Response):",
            "        \"\"\"Mock HTTP Response",
            "",
            "        Defines the https replies from the mocked calls to do_request()",
            "        \"\"\"",
            "        def __init__(self, content, status_code=200):",
            "            super(ScaleIOConnectorTestCase.MockHTTPSResponse,",
            "                  self).__init__()",
            "",
            "            self._content = content",
            "            self.encoding = 'UTF-8'",
            "            self.status_code = status_code",
            "",
            "        def json(self, **kwargs):",
            "            if isinstance(self._content, six.string_types):",
            "                return super(ScaleIOConnectorTestCase.MockHTTPSResponse,",
            "                             self).json(**kwargs)",
            "",
            "            return self._content",
            "",
            "        @property",
            "        def text(self):",
            "            if not isinstance(self._content, six.string_types):",
            "                return json.dumps(self._content)",
            "",
            "            self._content = self._content.encode('utf-8')",
            "            return super(ScaleIOConnectorTestCase.MockHTTPSResponse,",
            "                         self).text",
            "",
            "    def fake_execute(self, *cmd, **kwargs):",
            "        \"\"\"Fakes the rootwrap call\"\"\"",
            "        return self.fake_guid, None",
            "",
            "    def fake_missing_execute(self, *cmd, **kwargs):",
            "        \"\"\"Error when trying to call rootwrap drv_cfg\"\"\"",
            "        raise putils.ProcessExecutionError(\"Test missing drv_cfg.\")",
            "",
            "    def handle_scaleio_request(self, url, *args, **kwargs):",
            "        \"\"\"Fake REST server\"\"\"",
            "        api_call = url.split(':', 2)[2].split('/', 1)[1].replace('api/', '')",
            "",
            "        if 'setMappedSdcLimits' in api_call:",
            "            self.assertNotIn(\"iops_limit\", kwargs['data'])",
            "            if \"iopsLimit\" not in kwargs['data']:",
            "                self.assertIn(\"bandwidthLimitInKbps\",",
            "                              kwargs['data'])",
            "            elif \"bandwidthLimitInKbps\" not in kwargs['data']:",
            "                self.assertIn(\"iopsLimit\", kwargs['data'])",
            "            else:",
            "                self.assertIn(\"bandwidthLimitInKbps\",",
            "                              kwargs['data'])",
            "                self.assertIn(\"iopsLimit\", kwargs['data'])",
            "",
            "        try:",
            "            return self.mock_calls[api_call]",
            "        except KeyError:",
            "            return self.error_404",
            "",
            "    def test_get_search_path(self):",
            "        expected = \"/dev/disk/by-id\"",
            "        actual = self.connector.get_search_path()",
            "        self.assertEqual(expected, actual)",
            "",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    @mock.patch.object(scaleio.ScaleIOConnector, '_wait_for_volume_path')",
            "    def test_get_volume_paths(self, mock_wait_for_path, mock_exists):",
            "        mock_wait_for_path.return_value = \"emc-vol-vol1\"",
            "        expected = ['/dev/disk/by-id/emc-vol-vol1']",
            "        actual = self.connector.get_volume_paths(",
            "            self.fake_connection_properties)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_get_connector_properties(self):",
            "        props = scaleio.ScaleIOConnector.get_connector_properties(",
            "            'sudo', multipath=True, enforce_multipath=True)",
            "",
            "        expected_props = {}",
            "        self.assertEqual(expected_props, props)",
            "",
            "    def test_connect_volume(self):",
            "        \"\"\"Successful connect to volume\"\"\"",
            "        self.connector.connect_volume(self.fake_connection_properties)",
            "        self.get_password_mock.assert_called_once()",
            "",
            "    def test_connect_with_bandwidth_limit(self):",
            "        \"\"\"Successful connect to volume with bandwidth limit\"\"\"",
            "        self.fake_connection_properties['bandwidthLimit'] = '500'",
            "        self.test_connect_volume()",
            "",
            "    def test_connect_with_iops_limit(self):",
            "        \"\"\"Successful connect to volume with iops limit\"\"\"",
            "        self.fake_connection_properties['iopsLimit'] = '80'",
            "        self.test_connect_volume()",
            "",
            "    def test_connect_with_iops_and_bandwidth_limits(self):",
            "        \"\"\"Successful connect with iops and bandwidth limits\"\"\"",
            "        self.fake_connection_properties['bandwidthLimit'] = '500'",
            "        self.fake_connection_properties['iopsLimit'] = '80'",
            "        self.test_connect_volume()",
            "",
            "    def test_disconnect_volume(self):",
            "        \"\"\"Successful disconnect from volume\"\"\"",
            "        self.connector.disconnect_volume(self.fake_connection_properties, None)",
            "",
            "    def test_error_id(self):",
            "        \"\"\"Fail to connect with bad volume name\"\"\"",
            "        self.fake_connection_properties['scaleIO_volume_id'] = 'bad_id'",
            "        self.mock_calls[self.get_volume_api] = self.MockHTTPSResponse(",
            "            dict(errorCode='404', message='Test volume not found'), 404)",
            "",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    def test_error_no_volume_id(self):",
            "        \"\"\"Faile to connect with no volume id\"\"\"",
            "        self.fake_connection_properties['scaleIO_volume_id'] = None",
            "        self.mock_calls[self.get_volume_api] = self.MockHTTPSResponse(",
            "            'null', 200)",
            "",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    def test_error_bad_login(self):",
            "        \"\"\"Fail to connect with bad authentication\"\"\"",
            "        self.mock_calls[self.get_volume_api] = self.MockHTTPSResponse(",
            "            'null', 401)",
            "",
            "        self.mock_calls['login'] = self.MockHTTPSResponse('null', 401)",
            "        self.mock_calls[self.action_format.format(",
            "            'addMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=401, message='bad login'), 401)",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    def test_error_bad_drv_cfg(self):",
            "        \"\"\"Fail to connect with missing rootwrap executable\"\"\"",
            "        self.connector.set_execute(self.fake_missing_execute)",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    def test_error_map_volume(self):",
            "        \"\"\"Fail to connect with REST API failure\"\"\"",
            "        self.mock_calls[self.action_format.format(",
            "            'addMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=self.connector.VOLUME_NOT_MAPPED_ERROR,",
            "                 message='Test error map volume'), 500)",
            "",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "",
            "    @mock.patch('time.sleep')",
            "    def test_error_path_not_found(self, sleep_mock):",
            "        \"\"\"Timeout waiting for volume to map to local file system\"\"\"",
            "        self.mock_object(os, 'listdir', return_value=[\"emc-vol-no-volume\"])",
            "        self.assertRaises(exception.BrickException, self.test_connect_volume)",
            "        self.assertTrue(sleep_mock.called)",
            "",
            "    def test_map_volume_already_mapped(self):",
            "        \"\"\"Ignore REST API failure for volume already mapped\"\"\"",
            "        self.mock_calls[self.action_format.format(",
            "            'addMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=self.connector.VOLUME_ALREADY_MAPPED_ERROR,",
            "                 message='Test error map volume'), 500)",
            "",
            "        self.test_connect_volume()",
            "",
            "    def test_error_disconnect_volume(self):",
            "        \"\"\"Fail to disconnect with REST API failure\"\"\"",
            "        self.mock_calls[self.action_format.format(",
            "            'removeMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=self.connector.VOLUME_ALREADY_MAPPED_ERROR,",
            "                 message='Test error map volume'), 500)",
            "",
            "        self.assertRaises(exception.BrickException,",
            "                          self.test_disconnect_volume)",
            "",
            "    def test_disconnect_volume_not_mapped(self):",
            "        \"\"\"Ignore REST API failure for volume not mapped\"\"\"",
            "        self.mock_calls[self.action_format.format(",
            "            'removeMappedSdc')] = self.MockHTTPSResponse(",
            "            dict(errorCode=self.connector.VOLUME_NOT_MAPPED_ERROR,",
            "                 message='Test error map volume'), 500)",
            "",
            "        self.test_disconnect_volume()",
            "",
            "    def test_extend_volume(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.connector.extend_volume,",
            "                          self.fake_connection_properties)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "50": [
                "ScaleIOConnectorTestCase",
                "setUp"
            ],
            "51": [
                "ScaleIOConnectorTestCase",
                "setUp"
            ]
        },
        "addLocation": []
    }
}