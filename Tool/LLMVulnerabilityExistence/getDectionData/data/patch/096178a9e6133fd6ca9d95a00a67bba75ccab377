{
    "cli/onionshare_cli/web/receive_mode.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "             # Figure out what files should be saved"
            },
            "1": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "             now = datetime.now()"
            },
            "2": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "             date_dir = now.strftime(\"%Y-%m-%d\")"
            },
            "3": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            time_dir = now.strftime(\"%H%M%S\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+            time_dir = now.strftime(\"%H%M%S%f\")"
            },
            "5": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "             self.receive_mode_dir = os.path.join("
            },
            "6": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "                 self.web.settings.get(\"receive\", \"data_dir\"), date_dir, time_dir"
            },
            "7": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "             )"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "OnionShare | https://onionshare.org/",
            "",
            "Copyright (C) 2014-2021 Micah Lee, et al. <micah@micahflee.com>",
            "",
            "This program is free software: you can redistribute it and/or modify",
            "it under the terms of the GNU General Public License as published by",
            "the Free Software Foundation, either version 3 of the License, or",
            "(at your option) any later version.",
            "",
            "This program is distributed in the hope that it will be useful,",
            "but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "GNU General Public License for more details.",
            "",
            "You should have received a copy of the GNU General Public License",
            "along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "",
            "import os",
            "import tempfile",
            "import json",
            "import requests",
            "from datetime import datetime",
            "from flask import Request, request, render_template, make_response, flash, redirect",
            "from werkzeug.utils import secure_filename",
            "",
            "# Receive mode uses a special flask requests object, ReceiveModeRequest, in",
            "# order to keep track of upload progress. Here's what happens when someone",
            "# uploads files:",
            "# - new ReceiveModeRequest object is created",
            "# - ReceiveModeRequest.__init__",
            "#   - creates a directory based on the timestamp",
            "#   - creates empty self.progress = dict, which will map uploaded files to their upload progress",
            "# - ReceiveModeRequest._get_file_stream",
            "#   - called for each file that gets upload",
            "#   - the first time, send REQUEST_STARTED to GUI, and append to self.web.receive_mode.uploads_in_progress",
            "#   - updates self.progress[self.filename] for the current file",
            "#   - uses custom ReceiveModeFile to save file to disk",
            "#   - ReceiveModeRequest.file_write_func called on each write",
            "#     - Display progress in CLI, and send REQUEST_PROGRESS to GUI",
            "#   - ReceiveModeRequest.file_close_func called when each file closes",
            "#     - self.progress[filename][\"complete\"] = True",
            "#  - ReceiveModeRequest.close",
            "#     - send either REQUEST_UPLOAD_CANCELED or REQUEST_UPLOAD_FINISHED to GUI",
            "#     - remove from self.web.receive_mode.uploads_in_progress",
            "",
            "",
            "class ReceiveModeWeb:",
            "    \"\"\"",
            "    All of the web logic for receive mode",
            "    \"\"\"",
            "",
            "    def __init__(self, common, web):",
            "        self.common = common",
            "        self.common.log(\"ReceiveModeWeb\", \"__init__\")",
            "",
            "        self.web = web",
            "",
            "        self.can_upload = True",
            "        self.uploads_in_progress = []",
            "",
            "        # This tracks the history id",
            "        self.cur_history_id = 0",
            "",
            "        # Whether or not we can send REQUEST_INDIVIDUAL_FILE_STARTED",
            "        # and maybe other events when requests come in to this mode",
            "        self.supports_file_requests = True",
            "",
            "        self.define_routes()",
            "",
            "    def define_routes(self):",
            "        \"\"\"",
            "        The web app routes for receiving files",
            "        \"\"\"",
            "",
            "        @self.web.app.route(\"/\", methods=[\"GET\"], provide_automatic_options=False)",
            "        def index():",
            "            history_id = self.cur_history_id",
            "            self.cur_history_id += 1",
            "            self.web.add_request(",
            "                self.web.REQUEST_INDIVIDUAL_FILE_STARTED,",
            "                request.path,",
            "                {\"id\": history_id, \"status_code\": 200},",
            "            )",
            "",
            "            self.web.add_request(self.web.REQUEST_LOAD, request.path)",
            "            return render_template(",
            "                \"receive.html\",",
            "                static_url_path=self.web.static_url_path,",
            "                disable_text=self.web.settings.get(\"receive\", \"disable_text\"),",
            "                disable_files=self.web.settings.get(\"receive\", \"disable_files\"),",
            "                title=self.web.settings.get(\"general\", \"title\")",
            "            )",
            "",
            "        @self.web.app.route(\"/upload\", methods=[\"POST\"], provide_automatic_options=False)",
            "        def upload(ajax=False):",
            "            \"\"\"",
            "            Handle the upload files POST request, though at this point, the files have",
            "            already been uploaded and saved to their correct locations.",
            "            \"\"\"",
            "            message_received = request.includes_message",
            "",
            "            files_received = 0",
            "            if not self.web.settings.get(\"receive\", \"disable_files\"):",
            "                files = request.files.getlist(\"file[]\")",
            "",
            "                filenames = []",
            "                for f in files:",
            "                    if f.filename != \"\":",
            "                        filename = secure_filename(f.filename)",
            "                        filenames.append(filename)",
            "                        local_path = os.path.join(request.receive_mode_dir, filename)",
            "                        basename = os.path.basename(local_path)",
            "",
            "                        # Tell the GUI the receive mode directory for this file",
            "                        self.web.add_request(",
            "                            self.web.REQUEST_UPLOAD_SET_DIR,",
            "                            request.path,",
            "                            {",
            "                                \"id\": request.history_id,",
            "                                \"filename\": basename,",
            "                                \"dir\": request.receive_mode_dir,",
            "                            },",
            "                        )",
            "",
            "                        self.common.log(",
            "                            \"ReceiveModeWeb\",",
            "                            \"define_routes\",",
            "                            f\"/upload, uploaded {f.filename}, saving to {local_path}\",",
            "                        )",
            "                        print(f\"Received: {local_path}\")",
            "",
            "                files_received = len(filenames)",
            "",
            "            # Send webhook if configured",
            "            if (",
            "                self.web.settings.get(\"receive\", \"webhook_url\") is not None",
            "                and not request.upload_error",
            "                and (message_received or files_received)",
            "            ):",
            "                msg = \"\"",
            "                if files_received > 0:",
            "                    if files_received == 1:",
            "                        msg += \"1 file\"",
            "                    else:",
            "                        msg += f\"{files_received} files\"",
            "                if message_received:",
            "                    if msg == \"\":",
            "                        msg = \"A text message\"",
            "                    else:",
            "                        msg += \" and a text message\"",
            "                self.send_webhook_notification(f\"{msg} submitted to OnionShare\")",
            "",
            "            if request.upload_error:",
            "                self.common.log(",
            "                    \"ReceiveModeWeb\",",
            "                    \"define_routes\",",
            "                    \"/upload, there was an upload error\",",
            "                )",
            "",
            "                self.web.add_request(",
            "                    self.web.REQUEST_ERROR_DATA_DIR_CANNOT_CREATE,",
            "                    request.path,",
            "                    {\"receive_mode_dir\": request.receive_mode_dir},",
            "                )",
            "                print(",
            "                    f\"Could not create OnionShare data folder: {request.receive_mode_dir}\"",
            "                )",
            "",
            "                msg = \"Error uploading, please inform the OnionShare user\"",
            "                if ajax:",
            "                    return json.dumps({\"error_flashes\": [msg]})",
            "                else:",
            "                    flash(msg, \"error\")",
            "                    return redirect(\"/\")",
            "",
            "            if ajax:",
            "                info_flashes = []",
            "",
            "            if files_received > 0:",
            "                files_msg = \"\"",
            "                for filename in filenames:",
            "                    files_msg += f\"{filename}, \"",
            "                files_msg = files_msg.rstrip(\", \")",
            "",
            "            if message_received:",
            "                if files_received > 0:",
            "                    msg = f\"Message submitted, uploaded {files_msg}\"",
            "                else:",
            "                    msg = \"Message submitted\"",
            "            else:",
            "                if files_received > 0:",
            "                    msg = f\"Uploaded {files_msg}\"",
            "                else:",
            "                    msg = \"Nothing submitted\"",
            "",
            "            if ajax:",
            "                info_flashes.append(msg)",
            "            else:",
            "                flash(msg, \"info\")",
            "",
            "            if self.can_upload:",
            "                if ajax:",
            "                    return json.dumps({\"info_flashes\": info_flashes})",
            "                else:",
            "                    return redirect(\"/\")",
            "            else:",
            "                if ajax:",
            "                    return json.dumps(",
            "                        {",
            "                            \"new_body\": render_template(",
            "                                \"thankyou.html\",",
            "                                static_url_path=self.web.static_url_path,",
            "                                title=self.web.settings.get(\"general\", \"title\"),",
            "                            )",
            "                        }",
            "                    )",
            "                else:",
            "                    # It was the last upload and the timer ran out",
            "                    return make_response(",
            "                        render_template(\"thankyou.html\"),",
            "                        static_url_path=self.web.static_url_path,",
            "                        title=self.web.settings.get(\"general\", \"title\"),",
            "                    )",
            "",
            "        @self.web.app.route(\"/upload-ajax\", methods=[\"POST\"], provide_automatic_options=False)",
            "        def upload_ajax_public():",
            "            if not self.can_upload:",
            "                return self.web.error403()",
            "            return upload(ajax=True)",
            "",
            "    def send_webhook_notification(self, data):",
            "        self.common.log(\"ReceiveModeWeb\", \"send_webhook_notification\", data)",
            "        try:",
            "            requests.post(",
            "                self.web.settings.get(\"receive\", \"webhook_url\"),",
            "                data=data,",
            "                timeout=5,",
            "                proxies=self.web.proxies,",
            "            )",
            "        except Exception as e:",
            "            print(f\"Webhook notification failed: {e}\")",
            "",
            "",
            "class ReceiveModeWSGIMiddleware(object):",
            "    \"\"\"",
            "    Custom WSGI middleware in order to attach the Web object to environ, so",
            "    ReceiveModeRequest can access it.",
            "    \"\"\"",
            "",
            "    def __init__(self, app, web):",
            "        self.app = app",
            "        self.web = web",
            "",
            "    def __call__(self, environ, start_response):",
            "        environ[\"web\"] = self.web",
            "        environ[\"stop_q\"] = self.web.stop_q",
            "        return self.app(environ, start_response)",
            "",
            "",
            "class ReceiveModeFile(object):",
            "    \"\"\"",
            "    A custom file object that tells ReceiveModeRequest every time data gets",
            "    written to it, in order to track the progress of uploads. It starts out with",
            "    a .part file extension, and when it's complete it removes that extension.",
            "    \"\"\"",
            "",
            "    def __init__(self, request, filename, write_func, close_func):",
            "        self.onionshare_request = request",
            "        self.onionshare_filename = filename",
            "        self.onionshare_write_func = write_func",
            "        self.onionshare_close_func = close_func",
            "",
            "        self.filename = os.path.join(self.onionshare_request.receive_mode_dir, filename)",
            "        self.filename_in_progress = f\"{self.filename}.part\"",
            "",
            "        # Open the file",
            "        self.upload_error = False",
            "        try:",
            "            self.f = open(self.filename_in_progress, \"wb+\")",
            "        except Exception:",
            "            # This will only happen if someone is messing with the data dir while",
            "            # OnionShare is running, but if it does make sure to throw an error",
            "            self.upload_error = True",
            "            self.f = tempfile.TemporaryFile(\"wb+\")",
            "",
            "        # Make all the file-like methods and attributes actually access the",
            "        # TemporaryFile, except for write",
            "        attrs = [",
            "            \"closed\",",
            "            \"detach\",",
            "            \"fileno\",",
            "            \"flush\",",
            "            \"isatty\",",
            "            \"mode\",",
            "            \"name\",",
            "            \"peek\",",
            "            \"raw\",",
            "            \"read\",",
            "            \"read1\",",
            "            \"readable\",",
            "            \"readinto\",",
            "            \"readinto1\",",
            "            \"readline\",",
            "            \"readlines\",",
            "            \"seek\",",
            "            \"seekable\",",
            "            \"tell\",",
            "            \"truncate\",",
            "            \"writable\",",
            "            \"writelines\",",
            "        ]",
            "        for attr in attrs:",
            "            setattr(self, attr, getattr(self.f, attr))",
            "",
            "    def write(self, b):",
            "        \"\"\"",
            "        Custom write method that calls out to onionshare_write_func",
            "        \"\"\"",
            "        if self.upload_error or (not self.onionshare_request.stop_q.empty()):",
            "            self.close()",
            "            self.onionshare_request.close()",
            "            return",
            "",
            "        try:",
            "            bytes_written = self.f.write(b)",
            "            self.onionshare_write_func(self.onionshare_filename, bytes_written)",
            "",
            "        except Exception:",
            "            self.upload_error = True",
            "",
            "    def close(self):",
            "        \"\"\"",
            "        Custom close method that calls out to onionshare_close_func",
            "        \"\"\"",
            "        try:",
            "            self.f.close()",
            "",
            "            if not self.upload_error:",
            "                # Rename the in progress file to the final filename",
            "                os.rename(self.filename_in_progress, self.filename)",
            "",
            "        except Exception:",
            "            self.upload_error = True",
            "",
            "        self.onionshare_close_func(self.onionshare_filename, self.upload_error)",
            "",
            "",
            "class ReceiveModeRequest(Request):",
            "    \"\"\"",
            "    A custom flask Request object that keeps track of how much data has been",
            "    uploaded for each file, for receive mode.",
            "    \"\"\"",
            "",
            "    def __init__(self, environ, populate_request=True, shallow=False):",
            "        super(ReceiveModeRequest, self).__init__(environ, populate_request, shallow)",
            "        self.web = environ[\"web\"]",
            "        self.stop_q = environ[\"stop_q\"]",
            "        self.filename = None",
            "",
            "        # Prevent running the close() method more than once",
            "        self.closed = False",
            "",
            "        # Is this a valid upload request?",
            "        self.upload_request = False",
            "        if self.method == \"POST\":",
            "            if self.path == \"/upload\" or self.path == \"/upload-ajax\":",
            "                self.upload_request = True",
            "",
            "        if self.upload_request:",
            "            self.web.common.log(\"ReceiveModeRequest\", \"__init__\")",
            "",
            "            # No errors yet",
            "            self.upload_error = False",
            "",
            "            # Figure out what files should be saved",
            "            now = datetime.now()",
            "            date_dir = now.strftime(\"%Y-%m-%d\")",
            "            time_dir = now.strftime(\"%H%M%S\")",
            "            self.receive_mode_dir = os.path.join(",
            "                self.web.settings.get(\"receive\", \"data_dir\"), date_dir, time_dir",
            "            )",
            "",
            "            # Create that directory, which shouldn't exist yet",
            "            try:",
            "                os.makedirs(self.receive_mode_dir, 0o700, exist_ok=False)",
            "            except OSError:",
            "                # If this directory already exists, maybe someone else is uploading files at",
            "                # the same second, so use a different name in that case",
            "                if os.path.exists(self.receive_mode_dir):",
            "                    # Keep going until we find a directory name that's available",
            "                    i = 1",
            "                    while True:",
            "                        new_receive_mode_dir = f\"{self.receive_mode_dir}-{i}\"",
            "                        try:",
            "                            os.makedirs(new_receive_mode_dir, 0o700, exist_ok=False)",
            "                            self.receive_mode_dir = new_receive_mode_dir",
            "                            break",
            "                        except OSError:",
            "                            pass",
            "                        i += 1",
            "                        # Failsafe",
            "                        if i == 100:",
            "                            self.web.common.log(",
            "                                \"ReceiveModeRequest\",",
            "                                \"__init__\",",
            "                                \"Error finding available receive mode directory\",",
            "                            )",
            "                            self.upload_error = True",
            "                            break",
            "            except PermissionError:",
            "                self.web.add_request(",
            "                    self.web.REQUEST_ERROR_DATA_DIR_CANNOT_CREATE,",
            "                    request.path,",
            "                    {\"receive_mode_dir\": self.receive_mode_dir},",
            "                )",
            "                print(",
            "                    f\"Could not create OnionShare data folder: {self.receive_mode_dir}\"",
            "                )",
            "                self.web.common.log(",
            "                    \"ReceiveModeRequest\",",
            "                    \"__init__\",",
            "                    \"Permission denied creating receive mode directory\",",
            "                )",
            "                self.upload_error = True",
            "",
            "            # Figure out the message filename, in case there is a message",
            "            self.message_filename = f\"{self.receive_mode_dir}-message.txt\"",
            "",
            "            # If there's an error so far, finish early",
            "            if self.upload_error:",
            "                return",
            "",
            "            # A dictionary that maps filenames to the bytes uploaded so far",
            "            self.progress = {}",
            "",
            "            # Prevent new uploads if we've said so (timer expired)",
            "            if self.web.receive_mode.can_upload:",
            "",
            "                # Create an history_id, attach it to the request",
            "                self.history_id = self.web.receive_mode.cur_history_id",
            "                self.web.receive_mode.cur_history_id += 1",
            "",
            "                # Figure out the content length",
            "                try:",
            "                    self.content_length = int(self.headers[\"Content-Length\"])",
            "                except Exception:",
            "                    self.content_length = 0",
            "",
            "                date_str = datetime.now().strftime(\"%b %d, %I:%M%p\")",
            "                size_str = self.web.common.human_readable_filesize(self.content_length)",
            "                print(f\"{date_str}: Upload of total size {size_str} is starting\")",
            "",
            "                # Don't tell the GUI that a request has started until we start receiving files",
            "                self.told_gui_about_request = False",
            "",
            "                self.previous_file = None",
            "",
            "                # Is there a text message?",
            "                self.includes_message = False",
            "                if not self.web.settings.get(\"receive\", \"disable_text\"):",
            "                    text_message = self.form.get(\"text\")",
            "                    if text_message:",
            "                        if text_message.strip() != \"\":",
            "                            self.includes_message = True",
            "",
            "                            with open(self.message_filename, \"w\") as f:",
            "                                f.write(text_message)",
            "",
            "                            self.web.common.log(",
            "                                \"ReceiveModeRequest\",",
            "                                \"__init__\",",
            "                                f\"saved message to {self.message_filename}\",",
            "                            )",
            "                            print(f\"Received: {self.message_filename}\")",
            "",
            "                            # Tell the GUI about the message",
            "                            self.tell_gui_request_started()",
            "                            self.web.common.log(",
            "                                \"ReceiveModeRequest\",",
            "                                \"__init__\",",
            "                                \"sending REQUEST_UPLOAD_INCLUDES_MESSAGE to GUI\",",
            "                            )",
            "                            self.web.add_request(",
            "                                self.web.REQUEST_UPLOAD_INCLUDES_MESSAGE,",
            "                                self.path,",
            "                                {",
            "                                    \"id\": self.history_id,",
            "                                    \"filename\": self.message_filename,",
            "                                },",
            "                            )",
            "",
            "    def tell_gui_request_started(self):",
            "        # Tell the GUI about the request",
            "        if not self.told_gui_about_request:",
            "            self.web.common.log(",
            "                \"ReceiveModeRequest\",",
            "                \"tell_gui_request_started\",",
            "                \"sending REQUEST_STARTED to GUI\",",
            "            )",
            "            self.web.add_request(",
            "                self.web.REQUEST_STARTED,",
            "                self.path,",
            "                {",
            "                    \"id\": self.history_id,",
            "                    \"content_length\": self.content_length,",
            "                },",
            "            )",
            "            self.web.receive_mode.uploads_in_progress.append(self.history_id)",
            "",
            "            self.told_gui_about_request = True",
            "",
            "    def _get_file_stream(",
            "        self, total_content_length, content_type, filename=None, content_length=None",
            "    ):",
            "        \"\"\"",
            "        This gets called for each file that gets uploaded, and returns an file-like",
            "        writable stream.",
            "        \"\"\"",
            "        if self.upload_request:",
            "            self.tell_gui_request_started()",
            "",
            "            self.filename = secure_filename(filename)",
            "",
            "            self.progress[self.filename] = {\"uploaded_bytes\": 0, \"complete\": False}",
            "",
            "        f = ReceiveModeFile(",
            "            self, self.filename, self.file_write_func, self.file_close_func",
            "        )",
            "        if f.upload_error:",
            "            self.web.common.log(",
            "                \"ReceiveModeRequest\", \"_get_file_stream\", \"Error creating file\"",
            "            )",
            "            self.upload_error = True",
            "        return f",
            "",
            "    def close(self):",
            "        \"\"\"",
            "        Closing the request.",
            "        \"\"\"",
            "        super(ReceiveModeRequest, self).close()",
            "",
            "        # Prevent calling this method more than once per request",
            "        if self.closed:",
            "            return",
            "        self.closed = True",
            "",
            "        if self.upload_request:",
            "            self.web.common.log(\"ReceiveModeRequest\", \"close\")",
            "",
            "            if self.told_gui_about_request:",
            "                history_id = self.history_id",
            "",
            "                if not self.web.stop_q.empty() or (",
            "                    self.filename in self.progress",
            "                    and not self.progress[self.filename][\"complete\"]",
            "                ):",
            "                    # Inform the GUI that the upload has canceled",
            "                    self.web.common.log(",
            "                        \"ReceiveModeRequest\",",
            "                        \"close\",",
            "                        \"sending REQUEST_UPLOAD_CANCELED to GUI\",",
            "                    )",
            "                    self.web.add_request(",
            "                        self.web.REQUEST_UPLOAD_CANCELED,",
            "                        self.path,",
            "                        {\"id\": history_id},",
            "                    )",
            "                else:",
            "                    # Inform the GUI that the upload has finished",
            "                    self.web.common.log(",
            "                        \"ReceiveModeRequest\",",
            "                        \"close\",",
            "                        \"sending REQUEST_UPLOAD_FINISHED to GUI\",",
            "                    )",
            "                    self.web.add_request(",
            "                        self.web.REQUEST_UPLOAD_FINISHED,",
            "                        self.path,",
            "                        {\"id\": history_id},",
            "                    )",
            "                self.web.receive_mode.uploads_in_progress.remove(history_id)",
            "",
            "            # If no files were written to self.receive_mode_dir, delete it",
            "            try:",
            "                if len(os.listdir(self.receive_mode_dir)) == 0:",
            "                    os.rmdir(self.receive_mode_dir)",
            "            except Exception:",
            "                pass",
            "",
            "    def file_write_func(self, filename, length):",
            "        \"\"\"",
            "        This function gets called when a specific file is written to.",
            "        \"\"\"",
            "        if self.closed:",
            "            return",
            "",
            "        if self.upload_request:",
            "            self.progress[filename][\"uploaded_bytes\"] += length",
            "",
            "            if self.previous_file != filename:",
            "                self.previous_file = filename",
            "",
            "            size_str = self.web.common.human_readable_filesize(",
            "                self.progress[filename][\"uploaded_bytes\"]",
            "            )",
            "",
            "            if self.web.common.verbose:",
            "                print(f\"=> {size_str} {filename}\")",
            "            else:",
            "                print(f\"\\r=> {size_str} {filename}          \", end=\"\")",
            "",
            "            # Update the GUI on the upload progress",
            "            if self.told_gui_about_request:",
            "                self.web.add_request(",
            "                    self.web.REQUEST_PROGRESS,",
            "                    self.path,",
            "                    {\"id\": self.history_id, \"progress\": self.progress},",
            "                )",
            "",
            "    def file_close_func(self, filename, upload_error=False):",
            "        \"\"\"",
            "        This function gets called when a specific file is closed.",
            "        \"\"\"",
            "        self.progress[filename][\"complete\"] = True",
            "",
            "        # If the file tells us there was an upload error, let the request know as well",
            "        if upload_error:",
            "            self.upload_error = True"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "OnionShare | https://onionshare.org/",
            "",
            "Copyright (C) 2014-2021 Micah Lee, et al. <micah@micahflee.com>",
            "",
            "This program is free software: you can redistribute it and/or modify",
            "it under the terms of the GNU General Public License as published by",
            "the Free Software Foundation, either version 3 of the License, or",
            "(at your option) any later version.",
            "",
            "This program is distributed in the hope that it will be useful,",
            "but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "GNU General Public License for more details.",
            "",
            "You should have received a copy of the GNU General Public License",
            "along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "",
            "import os",
            "import tempfile",
            "import json",
            "import requests",
            "from datetime import datetime",
            "from flask import Request, request, render_template, make_response, flash, redirect",
            "from werkzeug.utils import secure_filename",
            "",
            "# Receive mode uses a special flask requests object, ReceiveModeRequest, in",
            "# order to keep track of upload progress. Here's what happens when someone",
            "# uploads files:",
            "# - new ReceiveModeRequest object is created",
            "# - ReceiveModeRequest.__init__",
            "#   - creates a directory based on the timestamp",
            "#   - creates empty self.progress = dict, which will map uploaded files to their upload progress",
            "# - ReceiveModeRequest._get_file_stream",
            "#   - called for each file that gets upload",
            "#   - the first time, send REQUEST_STARTED to GUI, and append to self.web.receive_mode.uploads_in_progress",
            "#   - updates self.progress[self.filename] for the current file",
            "#   - uses custom ReceiveModeFile to save file to disk",
            "#   - ReceiveModeRequest.file_write_func called on each write",
            "#     - Display progress in CLI, and send REQUEST_PROGRESS to GUI",
            "#   - ReceiveModeRequest.file_close_func called when each file closes",
            "#     - self.progress[filename][\"complete\"] = True",
            "#  - ReceiveModeRequest.close",
            "#     - send either REQUEST_UPLOAD_CANCELED or REQUEST_UPLOAD_FINISHED to GUI",
            "#     - remove from self.web.receive_mode.uploads_in_progress",
            "",
            "",
            "class ReceiveModeWeb:",
            "    \"\"\"",
            "    All of the web logic for receive mode",
            "    \"\"\"",
            "",
            "    def __init__(self, common, web):",
            "        self.common = common",
            "        self.common.log(\"ReceiveModeWeb\", \"__init__\")",
            "",
            "        self.web = web",
            "",
            "        self.can_upload = True",
            "        self.uploads_in_progress = []",
            "",
            "        # This tracks the history id",
            "        self.cur_history_id = 0",
            "",
            "        # Whether or not we can send REQUEST_INDIVIDUAL_FILE_STARTED",
            "        # and maybe other events when requests come in to this mode",
            "        self.supports_file_requests = True",
            "",
            "        self.define_routes()",
            "",
            "    def define_routes(self):",
            "        \"\"\"",
            "        The web app routes for receiving files",
            "        \"\"\"",
            "",
            "        @self.web.app.route(\"/\", methods=[\"GET\"], provide_automatic_options=False)",
            "        def index():",
            "            history_id = self.cur_history_id",
            "            self.cur_history_id += 1",
            "            self.web.add_request(",
            "                self.web.REQUEST_INDIVIDUAL_FILE_STARTED,",
            "                request.path,",
            "                {\"id\": history_id, \"status_code\": 200},",
            "            )",
            "",
            "            self.web.add_request(self.web.REQUEST_LOAD, request.path)",
            "            return render_template(",
            "                \"receive.html\",",
            "                static_url_path=self.web.static_url_path,",
            "                disable_text=self.web.settings.get(\"receive\", \"disable_text\"),",
            "                disable_files=self.web.settings.get(\"receive\", \"disable_files\"),",
            "                title=self.web.settings.get(\"general\", \"title\")",
            "            )",
            "",
            "        @self.web.app.route(\"/upload\", methods=[\"POST\"], provide_automatic_options=False)",
            "        def upload(ajax=False):",
            "            \"\"\"",
            "            Handle the upload files POST request, though at this point, the files have",
            "            already been uploaded and saved to their correct locations.",
            "            \"\"\"",
            "            message_received = request.includes_message",
            "",
            "            files_received = 0",
            "            if not self.web.settings.get(\"receive\", \"disable_files\"):",
            "                files = request.files.getlist(\"file[]\")",
            "",
            "                filenames = []",
            "                for f in files:",
            "                    if f.filename != \"\":",
            "                        filename = secure_filename(f.filename)",
            "                        filenames.append(filename)",
            "                        local_path = os.path.join(request.receive_mode_dir, filename)",
            "                        basename = os.path.basename(local_path)",
            "",
            "                        # Tell the GUI the receive mode directory for this file",
            "                        self.web.add_request(",
            "                            self.web.REQUEST_UPLOAD_SET_DIR,",
            "                            request.path,",
            "                            {",
            "                                \"id\": request.history_id,",
            "                                \"filename\": basename,",
            "                                \"dir\": request.receive_mode_dir,",
            "                            },",
            "                        )",
            "",
            "                        self.common.log(",
            "                            \"ReceiveModeWeb\",",
            "                            \"define_routes\",",
            "                            f\"/upload, uploaded {f.filename}, saving to {local_path}\",",
            "                        )",
            "                        print(f\"Received: {local_path}\")",
            "",
            "                files_received = len(filenames)",
            "",
            "            # Send webhook if configured",
            "            if (",
            "                self.web.settings.get(\"receive\", \"webhook_url\") is not None",
            "                and not request.upload_error",
            "                and (message_received or files_received)",
            "            ):",
            "                msg = \"\"",
            "                if files_received > 0:",
            "                    if files_received == 1:",
            "                        msg += \"1 file\"",
            "                    else:",
            "                        msg += f\"{files_received} files\"",
            "                if message_received:",
            "                    if msg == \"\":",
            "                        msg = \"A text message\"",
            "                    else:",
            "                        msg += \" and a text message\"",
            "                self.send_webhook_notification(f\"{msg} submitted to OnionShare\")",
            "",
            "            if request.upload_error:",
            "                self.common.log(",
            "                    \"ReceiveModeWeb\",",
            "                    \"define_routes\",",
            "                    \"/upload, there was an upload error\",",
            "                )",
            "",
            "                self.web.add_request(",
            "                    self.web.REQUEST_ERROR_DATA_DIR_CANNOT_CREATE,",
            "                    request.path,",
            "                    {\"receive_mode_dir\": request.receive_mode_dir},",
            "                )",
            "                print(",
            "                    f\"Could not create OnionShare data folder: {request.receive_mode_dir}\"",
            "                )",
            "",
            "                msg = \"Error uploading, please inform the OnionShare user\"",
            "                if ajax:",
            "                    return json.dumps({\"error_flashes\": [msg]})",
            "                else:",
            "                    flash(msg, \"error\")",
            "                    return redirect(\"/\")",
            "",
            "            if ajax:",
            "                info_flashes = []",
            "",
            "            if files_received > 0:",
            "                files_msg = \"\"",
            "                for filename in filenames:",
            "                    files_msg += f\"{filename}, \"",
            "                files_msg = files_msg.rstrip(\", \")",
            "",
            "            if message_received:",
            "                if files_received > 0:",
            "                    msg = f\"Message submitted, uploaded {files_msg}\"",
            "                else:",
            "                    msg = \"Message submitted\"",
            "            else:",
            "                if files_received > 0:",
            "                    msg = f\"Uploaded {files_msg}\"",
            "                else:",
            "                    msg = \"Nothing submitted\"",
            "",
            "            if ajax:",
            "                info_flashes.append(msg)",
            "            else:",
            "                flash(msg, \"info\")",
            "",
            "            if self.can_upload:",
            "                if ajax:",
            "                    return json.dumps({\"info_flashes\": info_flashes})",
            "                else:",
            "                    return redirect(\"/\")",
            "            else:",
            "                if ajax:",
            "                    return json.dumps(",
            "                        {",
            "                            \"new_body\": render_template(",
            "                                \"thankyou.html\",",
            "                                static_url_path=self.web.static_url_path,",
            "                                title=self.web.settings.get(\"general\", \"title\"),",
            "                            )",
            "                        }",
            "                    )",
            "                else:",
            "                    # It was the last upload and the timer ran out",
            "                    return make_response(",
            "                        render_template(\"thankyou.html\"),",
            "                        static_url_path=self.web.static_url_path,",
            "                        title=self.web.settings.get(\"general\", \"title\"),",
            "                    )",
            "",
            "        @self.web.app.route(\"/upload-ajax\", methods=[\"POST\"], provide_automatic_options=False)",
            "        def upload_ajax_public():",
            "            if not self.can_upload:",
            "                return self.web.error403()",
            "            return upload(ajax=True)",
            "",
            "    def send_webhook_notification(self, data):",
            "        self.common.log(\"ReceiveModeWeb\", \"send_webhook_notification\", data)",
            "        try:",
            "            requests.post(",
            "                self.web.settings.get(\"receive\", \"webhook_url\"),",
            "                data=data,",
            "                timeout=5,",
            "                proxies=self.web.proxies,",
            "            )",
            "        except Exception as e:",
            "            print(f\"Webhook notification failed: {e}\")",
            "",
            "",
            "class ReceiveModeWSGIMiddleware(object):",
            "    \"\"\"",
            "    Custom WSGI middleware in order to attach the Web object to environ, so",
            "    ReceiveModeRequest can access it.",
            "    \"\"\"",
            "",
            "    def __init__(self, app, web):",
            "        self.app = app",
            "        self.web = web",
            "",
            "    def __call__(self, environ, start_response):",
            "        environ[\"web\"] = self.web",
            "        environ[\"stop_q\"] = self.web.stop_q",
            "        return self.app(environ, start_response)",
            "",
            "",
            "class ReceiveModeFile(object):",
            "    \"\"\"",
            "    A custom file object that tells ReceiveModeRequest every time data gets",
            "    written to it, in order to track the progress of uploads. It starts out with",
            "    a .part file extension, and when it's complete it removes that extension.",
            "    \"\"\"",
            "",
            "    def __init__(self, request, filename, write_func, close_func):",
            "        self.onionshare_request = request",
            "        self.onionshare_filename = filename",
            "        self.onionshare_write_func = write_func",
            "        self.onionshare_close_func = close_func",
            "",
            "        self.filename = os.path.join(self.onionshare_request.receive_mode_dir, filename)",
            "        self.filename_in_progress = f\"{self.filename}.part\"",
            "",
            "        # Open the file",
            "        self.upload_error = False",
            "        try:",
            "            self.f = open(self.filename_in_progress, \"wb+\")",
            "        except Exception:",
            "            # This will only happen if someone is messing with the data dir while",
            "            # OnionShare is running, but if it does make sure to throw an error",
            "            self.upload_error = True",
            "            self.f = tempfile.TemporaryFile(\"wb+\")",
            "",
            "        # Make all the file-like methods and attributes actually access the",
            "        # TemporaryFile, except for write",
            "        attrs = [",
            "            \"closed\",",
            "            \"detach\",",
            "            \"fileno\",",
            "            \"flush\",",
            "            \"isatty\",",
            "            \"mode\",",
            "            \"name\",",
            "            \"peek\",",
            "            \"raw\",",
            "            \"read\",",
            "            \"read1\",",
            "            \"readable\",",
            "            \"readinto\",",
            "            \"readinto1\",",
            "            \"readline\",",
            "            \"readlines\",",
            "            \"seek\",",
            "            \"seekable\",",
            "            \"tell\",",
            "            \"truncate\",",
            "            \"writable\",",
            "            \"writelines\",",
            "        ]",
            "        for attr in attrs:",
            "            setattr(self, attr, getattr(self.f, attr))",
            "",
            "    def write(self, b):",
            "        \"\"\"",
            "        Custom write method that calls out to onionshare_write_func",
            "        \"\"\"",
            "        if self.upload_error or (not self.onionshare_request.stop_q.empty()):",
            "            self.close()",
            "            self.onionshare_request.close()",
            "            return",
            "",
            "        try:",
            "            bytes_written = self.f.write(b)",
            "            self.onionshare_write_func(self.onionshare_filename, bytes_written)",
            "",
            "        except Exception:",
            "            self.upload_error = True",
            "",
            "    def close(self):",
            "        \"\"\"",
            "        Custom close method that calls out to onionshare_close_func",
            "        \"\"\"",
            "        try:",
            "            self.f.close()",
            "",
            "            if not self.upload_error:",
            "                # Rename the in progress file to the final filename",
            "                os.rename(self.filename_in_progress, self.filename)",
            "",
            "        except Exception:",
            "            self.upload_error = True",
            "",
            "        self.onionshare_close_func(self.onionshare_filename, self.upload_error)",
            "",
            "",
            "class ReceiveModeRequest(Request):",
            "    \"\"\"",
            "    A custom flask Request object that keeps track of how much data has been",
            "    uploaded for each file, for receive mode.",
            "    \"\"\"",
            "",
            "    def __init__(self, environ, populate_request=True, shallow=False):",
            "        super(ReceiveModeRequest, self).__init__(environ, populate_request, shallow)",
            "        self.web = environ[\"web\"]",
            "        self.stop_q = environ[\"stop_q\"]",
            "        self.filename = None",
            "",
            "        # Prevent running the close() method more than once",
            "        self.closed = False",
            "",
            "        # Is this a valid upload request?",
            "        self.upload_request = False",
            "        if self.method == \"POST\":",
            "            if self.path == \"/upload\" or self.path == \"/upload-ajax\":",
            "                self.upload_request = True",
            "",
            "        if self.upload_request:",
            "            self.web.common.log(\"ReceiveModeRequest\", \"__init__\")",
            "",
            "            # No errors yet",
            "            self.upload_error = False",
            "",
            "            # Figure out what files should be saved",
            "            now = datetime.now()",
            "            date_dir = now.strftime(\"%Y-%m-%d\")",
            "            time_dir = now.strftime(\"%H%M%S%f\")",
            "            self.receive_mode_dir = os.path.join(",
            "                self.web.settings.get(\"receive\", \"data_dir\"), date_dir, time_dir",
            "            )",
            "",
            "            # Create that directory, which shouldn't exist yet",
            "            try:",
            "                os.makedirs(self.receive_mode_dir, 0o700, exist_ok=False)",
            "            except OSError:",
            "                # If this directory already exists, maybe someone else is uploading files at",
            "                # the same second, so use a different name in that case",
            "                if os.path.exists(self.receive_mode_dir):",
            "                    # Keep going until we find a directory name that's available",
            "                    i = 1",
            "                    while True:",
            "                        new_receive_mode_dir = f\"{self.receive_mode_dir}-{i}\"",
            "                        try:",
            "                            os.makedirs(new_receive_mode_dir, 0o700, exist_ok=False)",
            "                            self.receive_mode_dir = new_receive_mode_dir",
            "                            break",
            "                        except OSError:",
            "                            pass",
            "                        i += 1",
            "                        # Failsafe",
            "                        if i == 100:",
            "                            self.web.common.log(",
            "                                \"ReceiveModeRequest\",",
            "                                \"__init__\",",
            "                                \"Error finding available receive mode directory\",",
            "                            )",
            "                            self.upload_error = True",
            "                            break",
            "            except PermissionError:",
            "                self.web.add_request(",
            "                    self.web.REQUEST_ERROR_DATA_DIR_CANNOT_CREATE,",
            "                    request.path,",
            "                    {\"receive_mode_dir\": self.receive_mode_dir},",
            "                )",
            "                print(",
            "                    f\"Could not create OnionShare data folder: {self.receive_mode_dir}\"",
            "                )",
            "                self.web.common.log(",
            "                    \"ReceiveModeRequest\",",
            "                    \"__init__\",",
            "                    \"Permission denied creating receive mode directory\",",
            "                )",
            "                self.upload_error = True",
            "",
            "            # Figure out the message filename, in case there is a message",
            "            self.message_filename = f\"{self.receive_mode_dir}-message.txt\"",
            "",
            "            # If there's an error so far, finish early",
            "            if self.upload_error:",
            "                return",
            "",
            "            # A dictionary that maps filenames to the bytes uploaded so far",
            "            self.progress = {}",
            "",
            "            # Prevent new uploads if we've said so (timer expired)",
            "            if self.web.receive_mode.can_upload:",
            "",
            "                # Create an history_id, attach it to the request",
            "                self.history_id = self.web.receive_mode.cur_history_id",
            "                self.web.receive_mode.cur_history_id += 1",
            "",
            "                # Figure out the content length",
            "                try:",
            "                    self.content_length = int(self.headers[\"Content-Length\"])",
            "                except Exception:",
            "                    self.content_length = 0",
            "",
            "                date_str = datetime.now().strftime(\"%b %d, %I:%M%p\")",
            "                size_str = self.web.common.human_readable_filesize(self.content_length)",
            "                print(f\"{date_str}: Upload of total size {size_str} is starting\")",
            "",
            "                # Don't tell the GUI that a request has started until we start receiving files",
            "                self.told_gui_about_request = False",
            "",
            "                self.previous_file = None",
            "",
            "                # Is there a text message?",
            "                self.includes_message = False",
            "                if not self.web.settings.get(\"receive\", \"disable_text\"):",
            "                    text_message = self.form.get(\"text\")",
            "                    if text_message:",
            "                        if text_message.strip() != \"\":",
            "                            self.includes_message = True",
            "",
            "                            with open(self.message_filename, \"w\") as f:",
            "                                f.write(text_message)",
            "",
            "                            self.web.common.log(",
            "                                \"ReceiveModeRequest\",",
            "                                \"__init__\",",
            "                                f\"saved message to {self.message_filename}\",",
            "                            )",
            "                            print(f\"Received: {self.message_filename}\")",
            "",
            "                            # Tell the GUI about the message",
            "                            self.tell_gui_request_started()",
            "                            self.web.common.log(",
            "                                \"ReceiveModeRequest\",",
            "                                \"__init__\",",
            "                                \"sending REQUEST_UPLOAD_INCLUDES_MESSAGE to GUI\",",
            "                            )",
            "                            self.web.add_request(",
            "                                self.web.REQUEST_UPLOAD_INCLUDES_MESSAGE,",
            "                                self.path,",
            "                                {",
            "                                    \"id\": self.history_id,",
            "                                    \"filename\": self.message_filename,",
            "                                },",
            "                            )",
            "",
            "    def tell_gui_request_started(self):",
            "        # Tell the GUI about the request",
            "        if not self.told_gui_about_request:",
            "            self.web.common.log(",
            "                \"ReceiveModeRequest\",",
            "                \"tell_gui_request_started\",",
            "                \"sending REQUEST_STARTED to GUI\",",
            "            )",
            "            self.web.add_request(",
            "                self.web.REQUEST_STARTED,",
            "                self.path,",
            "                {",
            "                    \"id\": self.history_id,",
            "                    \"content_length\": self.content_length,",
            "                },",
            "            )",
            "            self.web.receive_mode.uploads_in_progress.append(self.history_id)",
            "",
            "            self.told_gui_about_request = True",
            "",
            "    def _get_file_stream(",
            "        self, total_content_length, content_type, filename=None, content_length=None",
            "    ):",
            "        \"\"\"",
            "        This gets called for each file that gets uploaded, and returns an file-like",
            "        writable stream.",
            "        \"\"\"",
            "        if self.upload_request:",
            "            self.tell_gui_request_started()",
            "",
            "            self.filename = secure_filename(filename)",
            "",
            "            self.progress[self.filename] = {\"uploaded_bytes\": 0, \"complete\": False}",
            "",
            "        f = ReceiveModeFile(",
            "            self, self.filename, self.file_write_func, self.file_close_func",
            "        )",
            "        if f.upload_error:",
            "            self.web.common.log(",
            "                \"ReceiveModeRequest\", \"_get_file_stream\", \"Error creating file\"",
            "            )",
            "            self.upload_error = True",
            "        return f",
            "",
            "    def close(self):",
            "        \"\"\"",
            "        Closing the request.",
            "        \"\"\"",
            "        super(ReceiveModeRequest, self).close()",
            "",
            "        # Prevent calling this method more than once per request",
            "        if self.closed:",
            "            return",
            "        self.closed = True",
            "",
            "        if self.upload_request:",
            "            self.web.common.log(\"ReceiveModeRequest\", \"close\")",
            "",
            "            if self.told_gui_about_request:",
            "                history_id = self.history_id",
            "",
            "                if not self.web.stop_q.empty() or (",
            "                    self.filename in self.progress",
            "                    and not self.progress[self.filename][\"complete\"]",
            "                ):",
            "                    # Inform the GUI that the upload has canceled",
            "                    self.web.common.log(",
            "                        \"ReceiveModeRequest\",",
            "                        \"close\",",
            "                        \"sending REQUEST_UPLOAD_CANCELED to GUI\",",
            "                    )",
            "                    self.web.add_request(",
            "                        self.web.REQUEST_UPLOAD_CANCELED,",
            "                        self.path,",
            "                        {\"id\": history_id},",
            "                    )",
            "                else:",
            "                    # Inform the GUI that the upload has finished",
            "                    self.web.common.log(",
            "                        \"ReceiveModeRequest\",",
            "                        \"close\",",
            "                        \"sending REQUEST_UPLOAD_FINISHED to GUI\",",
            "                    )",
            "                    self.web.add_request(",
            "                        self.web.REQUEST_UPLOAD_FINISHED,",
            "                        self.path,",
            "                        {\"id\": history_id},",
            "                    )",
            "                self.web.receive_mode.uploads_in_progress.remove(history_id)",
            "",
            "            # If no files were written to self.receive_mode_dir, delete it",
            "            try:",
            "                if len(os.listdir(self.receive_mode_dir)) == 0:",
            "                    os.rmdir(self.receive_mode_dir)",
            "            except Exception:",
            "                pass",
            "",
            "    def file_write_func(self, filename, length):",
            "        \"\"\"",
            "        This function gets called when a specific file is written to.",
            "        \"\"\"",
            "        if self.closed:",
            "            return",
            "",
            "        if self.upload_request:",
            "            self.progress[filename][\"uploaded_bytes\"] += length",
            "",
            "            if self.previous_file != filename:",
            "                self.previous_file = filename",
            "",
            "            size_str = self.web.common.human_readable_filesize(",
            "                self.progress[filename][\"uploaded_bytes\"]",
            "            )",
            "",
            "            if self.web.common.verbose:",
            "                print(f\"=> {size_str} {filename}\")",
            "            else:",
            "                print(f\"\\r=> {size_str} {filename}          \", end=\"\")",
            "",
            "            # Update the GUI on the upload progress",
            "            if self.told_gui_about_request:",
            "                self.web.add_request(",
            "                    self.web.REQUEST_PROGRESS,",
            "                    self.path,",
            "                    {\"id\": self.history_id, \"progress\": self.progress},",
            "                )",
            "",
            "    def file_close_func(self, filename, upload_error=False):",
            "        \"\"\"",
            "        This function gets called when a specific file is closed.",
            "        \"\"\"",
            "        self.progress[filename][\"complete\"] = True",
            "",
            "        # If the file tells us there was an upload error, let the request know as well",
            "        if upload_error:",
            "            self.upload_error = True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "381": [
                "ReceiveModeRequest",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "desktop/tests/test_gui_receive.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import glob"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import pytest"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import requests"
            },
            "4": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         now = datetime.now()"
            },
            "5": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         for _ in range(10):"
            },
            "6": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "             date_dir = now.strftime(\"%Y-%m-%d\")"
            },
            "7": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if identical_files_at_once:"
            },
            "8": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                time_dir = now.strftime(\"%H%M%S-1\")"
            },
            "9": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "10": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                time_dir = now.strftime(\"%H%M%S\")"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            time_dir = now.strftime(\"%H%M%S\")"
            },
            "12": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "             receive_mode_dir = os.path.join("
            },
            "13": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "                 tab.settings.get(\"receive\", \"data_dir\"), date_dir, time_dir"
            },
            "14": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "             )"
            },
            "15": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            expected_filename = os.path.join(receive_mode_dir, expected_basename)"
            },
            "16": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if os.path.exists(expected_filename):"
            },
            "17": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                exists = True"
            },
            "18": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                break"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+            # The directories have microseconds in the name, so we need"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            # to use globbing against directory names containing the same"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            # second in order to try to find the file."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            for path in glob.glob(receive_mode_dir + \"*\"):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+                if os.path.exists(os.path.join(path, expected_basename)):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+                    exists = True"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                    break"
            },
            "26": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             now = now - timedelta(seconds=1)"
            },
            "27": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         self.assertTrue(exists)"
            },
            "29": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         for _ in range(10):"
            },
            "30": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             date_dir = now.strftime(\"%Y-%m-%d\")"
            },
            "31": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "             time_dir = now.strftime(\"%H%M%S\")"
            },
            "32": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            expected_filename = os.path.join("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            expected_estimated_filename = os.path.join("
            },
            "34": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "                 tab.settings.get(\"receive\", \"data_dir\"),"
            },
            "35": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "                 date_dir,"
            },
            "36": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"{time_dir}-message.txt\","
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+                f\"{time_dir}*-message.txt\","
            },
            "38": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "             )"
            },
            "39": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if os.path.exists(expected_filename):"
            },
            "40": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                with open(expected_filename) as f:"
            },
            "41": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    assert f.read() == message"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+            for path in glob.glob(expected_estimated_filename):"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                if os.path.exists(path):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                    with open(path) as f:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                        assert f.read() == message"
            },
            "46": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                exists = True"
            },
            "48": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                break"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                    exists = True"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                    break"
            },
            "51": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "             now = now - timedelta(seconds=1)"
            },
            "52": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         self.assertTrue(exists)"
            }
        },
        "frontPatchFile": [
            "import pytest",
            "import os",
            "import requests",
            "import shutil",
            "import sys",
            "from datetime import datetime, timedelta",
            "",
            "from PySide2 import QtCore, QtTest",
            "",
            "from .gui_base_test import GuiBaseTest",
            "",
            "",
            "class TestReceive(GuiBaseTest):",
            "    # Shared test methods",
            "",
            "    def upload_file(",
            "        self, tab, file_to_upload, expected_basename, identical_files_at_once=False",
            "    ):",
            "        \"\"\"Test that we can upload the file\"\"\"",
            "",
            "        # Wait 2 seconds to make sure the filename, based on timestamp, isn't accidentally reused",
            "        QtTest.QTest.qWait(2000, self.gui.qtapp)",
            "",
            "        files = {\"file[]\": open(file_to_upload, \"rb\")}",
            "        url = f\"http://127.0.0.1:{tab.app.port}/upload\"",
            "        requests.post(url, files=files)",
            "        if identical_files_at_once:",
            "            # Send a duplicate upload to test for collisions",
            "            requests.post(url, files=files)",
            "",
            "        QtTest.QTest.qWait(1000, self.gui.qtapp)",
            "",
            "        # Make sure the file is within the last 10 seconds worth of filenames",
            "        exists = False",
            "        now = datetime.now()",
            "        for _ in range(10):",
            "            date_dir = now.strftime(\"%Y-%m-%d\")",
            "            if identical_files_at_once:",
            "                time_dir = now.strftime(\"%H%M%S-1\")",
            "            else:",
            "                time_dir = now.strftime(\"%H%M%S\")",
            "            receive_mode_dir = os.path.join(",
            "                tab.settings.get(\"receive\", \"data_dir\"), date_dir, time_dir",
            "            )",
            "            expected_filename = os.path.join(receive_mode_dir, expected_basename)",
            "            if os.path.exists(expected_filename):",
            "                exists = True",
            "                break",
            "            now = now - timedelta(seconds=1)",
            "",
            "        self.assertTrue(exists)",
            "",
            "    def upload_file_should_fail(self, tab):",
            "        \"\"\"Test that we can't upload the file when permissions are wrong, and expected content is shown\"\"\"",
            "        QtTest.QTest.qWait(1000, self.gui.qtapp)",
            "",
            "        files = {\"file[]\": open(self.tmpfile_test, \"rb\")}",
            "        url = f\"http://127.0.0.1:{tab.app.port}/upload\"",
            "        r = requests.post(url, files=files)",
            "",
            "        def accept_dialog():",
            "            window = tab.common.gui.qtapp.activeWindow()",
            "            if window:",
            "                window.close()",
            "",
            "        QtCore.QTimer.singleShot(1000, accept_dialog)",
            "        self.assertTrue(\"Error uploading, please inform the OnionShare user\" in r.text)",
            "",
            "    def submit_message(self, tab, message):",
            "        \"\"\"Test that we can submit a message\"\"\"",
            "",
            "        # Wait 2 seconds to make sure the filename, based on timestamp, isn't accidentally reused",
            "        QtTest.QTest.qWait(2000, self.gui.qtapp)",
            "",
            "        url = f\"http://127.0.0.1:{tab.app.port}/upload\"",
            "        requests.post(url, data={\"text\": message})",
            "",
            "        QtTest.QTest.qWait(1000, self.gui.qtapp)",
            "",
            "        # Make sure the file is within the last 10 seconds worth of filenames",
            "        exists = False",
            "        now = datetime.now()",
            "        for _ in range(10):",
            "            date_dir = now.strftime(\"%Y-%m-%d\")",
            "            time_dir = now.strftime(\"%H%M%S\")",
            "            expected_filename = os.path.join(",
            "                tab.settings.get(\"receive\", \"data_dir\"),",
            "                date_dir,",
            "                f\"{time_dir}-message.txt\",",
            "            )",
            "            if os.path.exists(expected_filename):",
            "                with open(expected_filename) as f:",
            "                    assert f.read() == message",
            "",
            "                exists = True",
            "                break",
            "            now = now - timedelta(seconds=1)",
            "",
            "        self.assertTrue(exists)",
            "",
            "    # 'Grouped' tests follow from here",
            "",
            "    def run_all_receive_mode_setup_tests(self, tab):",
            "        \"\"\"Set up a share in Receive mode and start it\"\"\"",
            "        self.history_is_not_visible(tab)",
            "        self.click_toggle_history(tab)",
            "        self.history_is_visible(tab)",
            "        self.server_working_on_start_button_pressed(tab)",
            "        self.server_status_indicator_says_starting(tab)",
            "        self.server_is_started(tab)",
            "        self.web_server_is_running(tab)",
            "        self.url_description_shown(tab)",
            "        self.url_instructions_shown(tab)",
            "        self.url_shown(tab)",
            "        self.have_copy_url_button(tab)",
            "        self.have_show_url_qr_code_button(tab)",
            "        self.client_auth_instructions_shown(tab)",
            "        self.private_key_shown(tab)",
            "        self.have_show_client_auth_qr_code_button(tab)",
            "        self.server_status_indicator_says_started(tab)",
            "",
            "    def run_all_receive_mode_tests(self, tab):",
            "        \"\"\"Submit files and messages in receive mode and stop the share\"\"\"",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        self.history_widgets_present(tab)",
            "        self.counter_incremented(tab, 1)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        self.counter_incremented(tab, 2)",
            "        self.upload_file(tab, self.tmpfile_test2, \"test2.txt\")",
            "        self.counter_incremented(tab, 3)",
            "        self.upload_file(tab, self.tmpfile_test2, \"test2.txt\")",
            "        self.counter_incremented(tab, 4)",
            "        self.submit_message(tab, \"onionshare is an interesting piece of software\")",
            "        self.counter_incremented(tab, 5)",
            "        # Test uploading the same file twice at the same time, and make sure no collisions",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\", True)",
            "        self.counter_incremented(tab, 7)",
            "        self.history_indicator(tab, \"2\")",
            "        self.server_is_stopped(tab)",
            "        self.web_server_is_stopped(tab)",
            "        self.server_status_indicator_says_closed(tab)",
            "        self.server_working_on_start_button_pressed(tab)",
            "        self.server_is_started(tab)",
            "        self.history_indicator(tab, \"2\")",
            "",
            "    def run_all_clear_all_button_tests(self, tab):",
            "        \"\"\"Test the Clear All history button\"\"\"",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        self.history_widgets_present(tab)",
            "        self.clear_all_history_items(tab, 0)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        self.clear_all_history_items(tab, 2)",
            "",
            "    def run_all_upload_non_writable_dir_tests(self, tab):",
            "        \"\"\"Test uploading a file when the data_dir is non-writable\"\"\"",
            "        upload_dir = os.path.join(self.tmpdir.name, \"OnionShare\")",
            "        shutil.rmtree(upload_dir, ignore_errors=True)",
            "        os.makedirs(upload_dir, 0o700)",
            "",
            "        # Set the upload dir setting",
            "        tab.get_mode().data_dir_lineedit.setText(upload_dir)",
            "        tab.settings.set(\"receive\", \"data_dir\", upload_dir)",
            "",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        os.chmod(upload_dir, 0o400)",
            "        self.upload_file_should_fail(tab)",
            "        self.server_is_stopped(tab)",
            "        self.web_server_is_stopped(tab)",
            "        self.server_status_indicator_says_closed(tab)",
            "        os.chmod(upload_dir, 0o700)",
            "",
            "    # Tests",
            "",
            "    def test_clear_all_button(self):",
            "        \"\"\"",
            "        Clear all history items should work",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_clear_all_button_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    def test_autostop_timer(self):",
            "        \"\"\"",
            "        Test autostop timer",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "        tab.get_mode().mode_settings_widget.toggle_advanced_button.click()",
            "        tab.get_mode().mode_settings_widget.autostop_timer_checkbox.click()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        self.set_timeout(tab, 5)",
            "        self.autostop_timer_widget_hidden(tab)",
            "        self.server_timed_out(tab, 15000)",
            "        self.web_server_is_stopped(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    def test_upload(self):",
            "        \"\"\"",
            "        Test uploading files",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_receive_mode_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    @pytest.mark.skipif(sys.platform == \"win32\", reason=\"Windows doesn't have chmod\")",
            "    def test_upload_non_writable_dir(self):",
            "        \"\"\"",
            "        Test uploading files to a non-writable directory",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "",
            "        self.run_all_upload_non_writable_dir_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    def test_public_upload(self):",
            "        \"\"\"",
            "        Test uploading files in public mode",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "        tab.get_mode().mode_settings_widget.public_checkbox.click()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_receive_mode_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    @pytest.mark.skipif(sys.platform == \"win32\", reason=\"Windows doesn't have chmod\")",
            "    def test_public_upload_non_writable_dir(self):",
            "        \"\"\"",
            "        Test uploading files to a non-writable directory in public mode",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "        tab.get_mode().mode_settings_widget.public_checkbox.click()",
            "",
            "        self.run_all_upload_non_writable_dir_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    def test_405_page_returned_for_invalid_methods(self):",
            "        \"\"\"",
            "        Our custom 405 page should return for invalid methods",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "",
            "        tab.get_mode().mode_settings_widget.public_checkbox.click()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        url = f\"http://127.0.0.1:{tab.app.port}/\"",
            "        self.hit_405(url, expected_resp=\"OnionShare: 405 Method Not Allowed\", data = {'foo':'bar'}, methods = [\"put\", \"post\", \"delete\", \"options\"])",
            "",
            "        self.server_is_stopped(tab)",
            "        self.web_server_is_stopped(tab)",
            "        self.server_status_indicator_says_closed(tab)",
            "        self.close_all_tabs()"
        ],
        "afterPatchFile": [
            "import glob",
            "import pytest",
            "import os",
            "import requests",
            "import shutil",
            "import sys",
            "from datetime import datetime, timedelta",
            "",
            "from PySide2 import QtCore, QtTest",
            "",
            "from .gui_base_test import GuiBaseTest",
            "",
            "",
            "class TestReceive(GuiBaseTest):",
            "    # Shared test methods",
            "",
            "    def upload_file(",
            "        self, tab, file_to_upload, expected_basename, identical_files_at_once=False",
            "    ):",
            "        \"\"\"Test that we can upload the file\"\"\"",
            "",
            "        # Wait 2 seconds to make sure the filename, based on timestamp, isn't accidentally reused",
            "        QtTest.QTest.qWait(2000, self.gui.qtapp)",
            "",
            "        files = {\"file[]\": open(file_to_upload, \"rb\")}",
            "        url = f\"http://127.0.0.1:{tab.app.port}/upload\"",
            "        requests.post(url, files=files)",
            "        if identical_files_at_once:",
            "            # Send a duplicate upload to test for collisions",
            "            requests.post(url, files=files)",
            "",
            "        QtTest.QTest.qWait(1000, self.gui.qtapp)",
            "",
            "        # Make sure the file is within the last 10 seconds worth of filenames",
            "        exists = False",
            "        now = datetime.now()",
            "        for _ in range(10):",
            "            date_dir = now.strftime(\"%Y-%m-%d\")",
            "            time_dir = now.strftime(\"%H%M%S\")",
            "            receive_mode_dir = os.path.join(",
            "                tab.settings.get(\"receive\", \"data_dir\"), date_dir, time_dir",
            "            )",
            "            # The directories have microseconds in the name, so we need",
            "            # to use globbing against directory names containing the same",
            "            # second in order to try to find the file.",
            "            for path in glob.glob(receive_mode_dir + \"*\"):",
            "                if os.path.exists(os.path.join(path, expected_basename)):",
            "                    exists = True",
            "                    break",
            "            now = now - timedelta(seconds=1)",
            "",
            "        self.assertTrue(exists)",
            "",
            "    def upload_file_should_fail(self, tab):",
            "        \"\"\"Test that we can't upload the file when permissions are wrong, and expected content is shown\"\"\"",
            "        QtTest.QTest.qWait(1000, self.gui.qtapp)",
            "",
            "        files = {\"file[]\": open(self.tmpfile_test, \"rb\")}",
            "        url = f\"http://127.0.0.1:{tab.app.port}/upload\"",
            "        r = requests.post(url, files=files)",
            "",
            "        def accept_dialog():",
            "            window = tab.common.gui.qtapp.activeWindow()",
            "            if window:",
            "                window.close()",
            "",
            "        QtCore.QTimer.singleShot(1000, accept_dialog)",
            "        self.assertTrue(\"Error uploading, please inform the OnionShare user\" in r.text)",
            "",
            "    def submit_message(self, tab, message):",
            "        \"\"\"Test that we can submit a message\"\"\"",
            "",
            "        # Wait 2 seconds to make sure the filename, based on timestamp, isn't accidentally reused",
            "        QtTest.QTest.qWait(2000, self.gui.qtapp)",
            "",
            "        url = f\"http://127.0.0.1:{tab.app.port}/upload\"",
            "        requests.post(url, data={\"text\": message})",
            "",
            "        QtTest.QTest.qWait(1000, self.gui.qtapp)",
            "",
            "        # Make sure the file is within the last 10 seconds worth of filenames",
            "        exists = False",
            "        now = datetime.now()",
            "        for _ in range(10):",
            "            date_dir = now.strftime(\"%Y-%m-%d\")",
            "            time_dir = now.strftime(\"%H%M%S\")",
            "            expected_estimated_filename = os.path.join(",
            "                tab.settings.get(\"receive\", \"data_dir\"),",
            "                date_dir,",
            "                f\"{time_dir}*-message.txt\",",
            "            )",
            "            for path in glob.glob(expected_estimated_filename):",
            "                if os.path.exists(path):",
            "                    with open(path) as f:",
            "                        assert f.read() == message",
            "",
            "                    exists = True",
            "                    break",
            "            now = now - timedelta(seconds=1)",
            "",
            "        self.assertTrue(exists)",
            "",
            "    # 'Grouped' tests follow from here",
            "",
            "    def run_all_receive_mode_setup_tests(self, tab):",
            "        \"\"\"Set up a share in Receive mode and start it\"\"\"",
            "        self.history_is_not_visible(tab)",
            "        self.click_toggle_history(tab)",
            "        self.history_is_visible(tab)",
            "        self.server_working_on_start_button_pressed(tab)",
            "        self.server_status_indicator_says_starting(tab)",
            "        self.server_is_started(tab)",
            "        self.web_server_is_running(tab)",
            "        self.url_description_shown(tab)",
            "        self.url_instructions_shown(tab)",
            "        self.url_shown(tab)",
            "        self.have_copy_url_button(tab)",
            "        self.have_show_url_qr_code_button(tab)",
            "        self.client_auth_instructions_shown(tab)",
            "        self.private_key_shown(tab)",
            "        self.have_show_client_auth_qr_code_button(tab)",
            "        self.server_status_indicator_says_started(tab)",
            "",
            "    def run_all_receive_mode_tests(self, tab):",
            "        \"\"\"Submit files and messages in receive mode and stop the share\"\"\"",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        self.history_widgets_present(tab)",
            "        self.counter_incremented(tab, 1)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        self.counter_incremented(tab, 2)",
            "        self.upload_file(tab, self.tmpfile_test2, \"test2.txt\")",
            "        self.counter_incremented(tab, 3)",
            "        self.upload_file(tab, self.tmpfile_test2, \"test2.txt\")",
            "        self.counter_incremented(tab, 4)",
            "        self.submit_message(tab, \"onionshare is an interesting piece of software\")",
            "        self.counter_incremented(tab, 5)",
            "        # Test uploading the same file twice at the same time, and make sure no collisions",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\", True)",
            "        self.counter_incremented(tab, 7)",
            "        self.history_indicator(tab, \"2\")",
            "        self.server_is_stopped(tab)",
            "        self.web_server_is_stopped(tab)",
            "        self.server_status_indicator_says_closed(tab)",
            "        self.server_working_on_start_button_pressed(tab)",
            "        self.server_is_started(tab)",
            "        self.history_indicator(tab, \"2\")",
            "",
            "    def run_all_clear_all_button_tests(self, tab):",
            "        \"\"\"Test the Clear All history button\"\"\"",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        self.history_widgets_present(tab)",
            "        self.clear_all_history_items(tab, 0)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        self.clear_all_history_items(tab, 2)",
            "",
            "    def run_all_upload_non_writable_dir_tests(self, tab):",
            "        \"\"\"Test uploading a file when the data_dir is non-writable\"\"\"",
            "        upload_dir = os.path.join(self.tmpdir.name, \"OnionShare\")",
            "        shutil.rmtree(upload_dir, ignore_errors=True)",
            "        os.makedirs(upload_dir, 0o700)",
            "",
            "        # Set the upload dir setting",
            "        tab.get_mode().data_dir_lineedit.setText(upload_dir)",
            "        tab.settings.set(\"receive\", \"data_dir\", upload_dir)",
            "",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        os.chmod(upload_dir, 0o400)",
            "        self.upload_file_should_fail(tab)",
            "        self.server_is_stopped(tab)",
            "        self.web_server_is_stopped(tab)",
            "        self.server_status_indicator_says_closed(tab)",
            "        os.chmod(upload_dir, 0o700)",
            "",
            "    # Tests",
            "",
            "    def test_clear_all_button(self):",
            "        \"\"\"",
            "        Clear all history items should work",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_clear_all_button_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    def test_autostop_timer(self):",
            "        \"\"\"",
            "        Test autostop timer",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "        tab.get_mode().mode_settings_widget.toggle_advanced_button.click()",
            "        tab.get_mode().mode_settings_widget.autostop_timer_checkbox.click()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        self.set_timeout(tab, 5)",
            "        self.autostop_timer_widget_hidden(tab)",
            "        self.server_timed_out(tab, 15000)",
            "        self.web_server_is_stopped(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    def test_upload(self):",
            "        \"\"\"",
            "        Test uploading files",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_receive_mode_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    @pytest.mark.skipif(sys.platform == \"win32\", reason=\"Windows doesn't have chmod\")",
            "    def test_upload_non_writable_dir(self):",
            "        \"\"\"",
            "        Test uploading files to a non-writable directory",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "",
            "        self.run_all_upload_non_writable_dir_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    def test_public_upload(self):",
            "        \"\"\"",
            "        Test uploading files in public mode",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "        tab.get_mode().mode_settings_widget.public_checkbox.click()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_receive_mode_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    @pytest.mark.skipif(sys.platform == \"win32\", reason=\"Windows doesn't have chmod\")",
            "    def test_public_upload_non_writable_dir(self):",
            "        \"\"\"",
            "        Test uploading files to a non-writable directory in public mode",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "        tab.get_mode().mode_settings_widget.public_checkbox.click()",
            "",
            "        self.run_all_upload_non_writable_dir_tests(tab)",
            "",
            "        self.close_all_tabs()",
            "",
            "    def test_405_page_returned_for_invalid_methods(self):",
            "        \"\"\"",
            "        Our custom 405 page should return for invalid methods",
            "        \"\"\"",
            "        tab = self.new_receive_tab()",
            "",
            "        tab.get_mode().mode_settings_widget.public_checkbox.click()",
            "",
            "        self.run_all_common_setup_tests()",
            "        self.run_all_receive_mode_setup_tests(tab)",
            "        self.upload_file(tab, self.tmpfile_test, \"test.txt\")",
            "        url = f\"http://127.0.0.1:{tab.app.port}/\"",
            "        self.hit_405(url, expected_resp=\"OnionShare: 405 Method Not Allowed\", data = {'foo':'bar'}, methods = [\"put\", \"post\", \"delete\", \"options\"])",
            "",
            "        self.server_is_stopped(tab)",
            "        self.web_server_is_stopped(tab)",
            "        self.server_status_indicator_says_closed(tab)",
            "        self.close_all_tabs()"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "38": [
                "TestReceive",
                "upload_file"
            ],
            "39": [
                "TestReceive",
                "upload_file"
            ],
            "40": [
                "TestReceive",
                "upload_file"
            ],
            "41": [
                "TestReceive",
                "upload_file"
            ],
            "45": [
                "TestReceive",
                "upload_file"
            ],
            "46": [
                "TestReceive",
                "upload_file"
            ],
            "47": [
                "TestReceive",
                "upload_file"
            ],
            "48": [
                "TestReceive",
                "upload_file"
            ],
            "86": [
                "TestReceive",
                "submit_message"
            ],
            "89": [
                "TestReceive",
                "submit_message"
            ],
            "91": [
                "TestReceive",
                "submit_message"
            ],
            "92": [
                "TestReceive",
                "submit_message"
            ],
            "93": [
                "TestReceive",
                "submit_message"
            ],
            "95": [
                "TestReceive",
                "submit_message"
            ],
            "96": [
                "TestReceive",
                "submit_message"
            ]
        },
        "addLocation": []
    }
}