{
    "Tests/test_imagemath.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import pytest"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+"
            },
            "2": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from PIL import Image, ImageMath"
            },
            "3": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     assert pixel(ImageMath.eval(\"float(B)**33\", images)) == \"F 8589934592.0\""
            },
            "6": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+def test_prevent_exec():"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        ImageMath.eval(\"exec('pass')\")"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " def test_logical():"
            },
            "14": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     assert pixel(ImageMath.eval(\"not A\", images)) == 0"
            },
            "15": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     assert pixel(ImageMath.eval(\"A and B\", images)) == \"L 2\""
            }
        },
        "frontPatchFile": [
            "from PIL import Image, ImageMath",
            "",
            "",
            "def pixel(im):",
            "    if hasattr(im, \"im\"):",
            "        return f\"{im.mode} {repr(im.getpixel((0, 0)))}\"",
            "    else:",
            "        if isinstance(im, int):",
            "            return int(im)  # hack to deal with booleans",
            "        print(im)",
            "",
            "",
            "A = Image.new(\"L\", (1, 1), 1)",
            "B = Image.new(\"L\", (1, 1), 2)",
            "Z = Image.new(\"L\", (1, 1), 0)  # Z for zero",
            "F = Image.new(\"F\", (1, 1), 3)",
            "I = Image.new(\"I\", (1, 1), 4)  # noqa: E741",
            "",
            "A2 = A.resize((2, 2))",
            "B2 = B.resize((2, 2))",
            "",
            "images = {\"A\": A, \"B\": B, \"F\": F, \"I\": I}",
            "",
            "",
            "def test_sanity():",
            "    assert ImageMath.eval(\"1\") == 1",
            "    assert ImageMath.eval(\"1+A\", A=2) == 3",
            "    assert pixel(ImageMath.eval(\"A+B\", A=A, B=B)) == \"I 3\"",
            "    assert pixel(ImageMath.eval(\"A+B\", images)) == \"I 3\"",
            "    assert pixel(ImageMath.eval(\"float(A)+B\", images)) == \"F 3.0\"",
            "    assert pixel(ImageMath.eval(\"int(float(A)+B)\", images)) == \"I 3\"",
            "",
            "",
            "def test_ops():",
            "    assert pixel(ImageMath.eval(\"-A\", images)) == \"I -1\"",
            "    assert pixel(ImageMath.eval(\"+B\", images)) == \"L 2\"",
            "",
            "    assert pixel(ImageMath.eval(\"A+B\", images)) == \"I 3\"",
            "    assert pixel(ImageMath.eval(\"A-B\", images)) == \"I -1\"",
            "    assert pixel(ImageMath.eval(\"A*B\", images)) == \"I 2\"",
            "    assert pixel(ImageMath.eval(\"A/B\", images)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B**2\", images)) == \"I 4\"",
            "    assert pixel(ImageMath.eval(\"B**33\", images)) == \"I 2147483647\"",
            "",
            "    assert pixel(ImageMath.eval(\"float(A)+B\", images)) == \"F 3.0\"",
            "    assert pixel(ImageMath.eval(\"float(A)-B\", images)) == \"F -1.0\"",
            "    assert pixel(ImageMath.eval(\"float(A)*B\", images)) == \"F 2.0\"",
            "    assert pixel(ImageMath.eval(\"float(A)/B\", images)) == \"F 0.5\"",
            "    assert pixel(ImageMath.eval(\"float(B)**2\", images)) == \"F 4.0\"",
            "    assert pixel(ImageMath.eval(\"float(B)**33\", images)) == \"F 8589934592.0\"",
            "",
            "",
            "def test_logical():",
            "    assert pixel(ImageMath.eval(\"not A\", images)) == 0",
            "    assert pixel(ImageMath.eval(\"A and B\", images)) == \"L 2\"",
            "    assert pixel(ImageMath.eval(\"A or B\", images)) == \"L 1\"",
            "",
            "",
            "def test_convert():",
            "    assert pixel(ImageMath.eval(\"convert(A+B, 'L')\", images)) == \"L 3\"",
            "    assert pixel(ImageMath.eval(\"convert(A+B, '1')\", images)) == \"1 0\"",
            "    assert pixel(ImageMath.eval(\"convert(A+B, 'RGB')\", images)) == \"RGB (3, 3, 3)\"",
            "",
            "",
            "def test_compare():",
            "    assert pixel(ImageMath.eval(\"min(A, B)\", images)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"max(A, B)\", images)) == \"I 2\"",
            "    assert pixel(ImageMath.eval(\"A == 1\", images)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A == 2\", images)) == \"I 0\"",
            "",
            "",
            "def test_one_image_larger():",
            "    assert pixel(ImageMath.eval(\"A+B\", A=A2, B=B)) == \"I 3\"",
            "    assert pixel(ImageMath.eval(\"A+B\", A=A, B=B2)) == \"I 3\"",
            "",
            "",
            "def test_abs():",
            "    assert pixel(ImageMath.eval(\"abs(A)\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"abs(B)\", B=B)) == \"I 2\"",
            "",
            "",
            "def test_binary_mod():",
            "    assert pixel(ImageMath.eval(\"A%A\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B%B\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A%B\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B%A\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z%A\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z%B\", B=B, Z=Z)) == \"I 0\"",
            "",
            "",
            "def test_bitwise_invert():",
            "    assert pixel(ImageMath.eval(\"~Z\", Z=Z)) == \"I -1\"",
            "    assert pixel(ImageMath.eval(\"~A\", A=A)) == \"I -2\"",
            "    assert pixel(ImageMath.eval(\"~B\", B=B)) == \"I -3\"",
            "",
            "",
            "def test_bitwise_and():",
            "    assert pixel(ImageMath.eval(\"Z&Z\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z&A\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A&Z\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A&A\", A=A, Z=Z)) == \"I 1\"",
            "",
            "",
            "def test_bitwise_or():",
            "    assert pixel(ImageMath.eval(\"Z|Z\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z|A\", A=A, Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A|Z\", A=A, Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A|A\", A=A, Z=Z)) == \"I 1\"",
            "",
            "",
            "def test_bitwise_xor():",
            "    assert pixel(ImageMath.eval(\"Z^Z\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z^A\", A=A, Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A^Z\", A=A, Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A^A\", A=A, Z=Z)) == \"I 0\"",
            "",
            "",
            "def test_bitwise_leftshift():",
            "    assert pixel(ImageMath.eval(\"Z<<0\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z<<1\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A<<0\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A<<1\", A=A)) == \"I 2\"",
            "",
            "",
            "def test_bitwise_rightshift():",
            "    assert pixel(ImageMath.eval(\"Z>>0\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z>>1\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A>>0\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A>>1\", A=A)) == \"I 0\"",
            "",
            "",
            "def test_logical_eq():",
            "    assert pixel(ImageMath.eval(\"A==A\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B==B\", B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A==B\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B==A\", A=A, B=B)) == \"I 0\"",
            "",
            "",
            "def test_logical_ne():",
            "    assert pixel(ImageMath.eval(\"A!=A\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B!=B\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A!=B\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B!=A\", A=A, B=B)) == \"I 1\"",
            "",
            "",
            "def test_logical_lt():",
            "    assert pixel(ImageMath.eval(\"A<A\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B<B\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A<B\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B<A\", A=A, B=B)) == \"I 0\"",
            "",
            "",
            "def test_logical_le():",
            "    assert pixel(ImageMath.eval(\"A<=A\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B<=B\", B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A<=B\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B<=A\", A=A, B=B)) == \"I 0\"",
            "",
            "",
            "def test_logical_gt():",
            "    assert pixel(ImageMath.eval(\"A>A\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B>B\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A>B\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B>A\", A=A, B=B)) == \"I 1\"",
            "",
            "",
            "def test_logical_ge():",
            "    assert pixel(ImageMath.eval(\"A>=A\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B>=B\", B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A>=B\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B>=A\", A=A, B=B)) == \"I 1\"",
            "",
            "",
            "def test_logical_equal():",
            "    assert pixel(ImageMath.eval(\"equal(A, A)\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"equal(B, B)\", B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"equal(Z, Z)\", Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"equal(A, B)\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"equal(B, A)\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"equal(A, Z)\", A=A, Z=Z)) == \"I 0\"",
            "",
            "",
            "def test_logical_not_equal():",
            "    assert pixel(ImageMath.eval(\"notequal(A, A)\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"notequal(B, B)\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"notequal(Z, Z)\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"notequal(A, B)\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"notequal(B, A)\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"notequal(A, Z)\", A=A, Z=Z)) == \"I 1\""
        ],
        "afterPatchFile": [
            "import pytest",
            "",
            "from PIL import Image, ImageMath",
            "",
            "",
            "def pixel(im):",
            "    if hasattr(im, \"im\"):",
            "        return f\"{im.mode} {repr(im.getpixel((0, 0)))}\"",
            "    else:",
            "        if isinstance(im, int):",
            "            return int(im)  # hack to deal with booleans",
            "        print(im)",
            "",
            "",
            "A = Image.new(\"L\", (1, 1), 1)",
            "B = Image.new(\"L\", (1, 1), 2)",
            "Z = Image.new(\"L\", (1, 1), 0)  # Z for zero",
            "F = Image.new(\"F\", (1, 1), 3)",
            "I = Image.new(\"I\", (1, 1), 4)  # noqa: E741",
            "",
            "A2 = A.resize((2, 2))",
            "B2 = B.resize((2, 2))",
            "",
            "images = {\"A\": A, \"B\": B, \"F\": F, \"I\": I}",
            "",
            "",
            "def test_sanity():",
            "    assert ImageMath.eval(\"1\") == 1",
            "    assert ImageMath.eval(\"1+A\", A=2) == 3",
            "    assert pixel(ImageMath.eval(\"A+B\", A=A, B=B)) == \"I 3\"",
            "    assert pixel(ImageMath.eval(\"A+B\", images)) == \"I 3\"",
            "    assert pixel(ImageMath.eval(\"float(A)+B\", images)) == \"F 3.0\"",
            "    assert pixel(ImageMath.eval(\"int(float(A)+B)\", images)) == \"I 3\"",
            "",
            "",
            "def test_ops():",
            "    assert pixel(ImageMath.eval(\"-A\", images)) == \"I -1\"",
            "    assert pixel(ImageMath.eval(\"+B\", images)) == \"L 2\"",
            "",
            "    assert pixel(ImageMath.eval(\"A+B\", images)) == \"I 3\"",
            "    assert pixel(ImageMath.eval(\"A-B\", images)) == \"I -1\"",
            "    assert pixel(ImageMath.eval(\"A*B\", images)) == \"I 2\"",
            "    assert pixel(ImageMath.eval(\"A/B\", images)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B**2\", images)) == \"I 4\"",
            "    assert pixel(ImageMath.eval(\"B**33\", images)) == \"I 2147483647\"",
            "",
            "    assert pixel(ImageMath.eval(\"float(A)+B\", images)) == \"F 3.0\"",
            "    assert pixel(ImageMath.eval(\"float(A)-B\", images)) == \"F -1.0\"",
            "    assert pixel(ImageMath.eval(\"float(A)*B\", images)) == \"F 2.0\"",
            "    assert pixel(ImageMath.eval(\"float(A)/B\", images)) == \"F 0.5\"",
            "    assert pixel(ImageMath.eval(\"float(B)**2\", images)) == \"F 4.0\"",
            "    assert pixel(ImageMath.eval(\"float(B)**33\", images)) == \"F 8589934592.0\"",
            "",
            "",
            "def test_prevent_exec():",
            "    with pytest.raises(ValueError):",
            "        ImageMath.eval(\"exec('pass')\")",
            "",
            "",
            "def test_logical():",
            "    assert pixel(ImageMath.eval(\"not A\", images)) == 0",
            "    assert pixel(ImageMath.eval(\"A and B\", images)) == \"L 2\"",
            "    assert pixel(ImageMath.eval(\"A or B\", images)) == \"L 1\"",
            "",
            "",
            "def test_convert():",
            "    assert pixel(ImageMath.eval(\"convert(A+B, 'L')\", images)) == \"L 3\"",
            "    assert pixel(ImageMath.eval(\"convert(A+B, '1')\", images)) == \"1 0\"",
            "    assert pixel(ImageMath.eval(\"convert(A+B, 'RGB')\", images)) == \"RGB (3, 3, 3)\"",
            "",
            "",
            "def test_compare():",
            "    assert pixel(ImageMath.eval(\"min(A, B)\", images)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"max(A, B)\", images)) == \"I 2\"",
            "    assert pixel(ImageMath.eval(\"A == 1\", images)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A == 2\", images)) == \"I 0\"",
            "",
            "",
            "def test_one_image_larger():",
            "    assert pixel(ImageMath.eval(\"A+B\", A=A2, B=B)) == \"I 3\"",
            "    assert pixel(ImageMath.eval(\"A+B\", A=A, B=B2)) == \"I 3\"",
            "",
            "",
            "def test_abs():",
            "    assert pixel(ImageMath.eval(\"abs(A)\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"abs(B)\", B=B)) == \"I 2\"",
            "",
            "",
            "def test_binary_mod():",
            "    assert pixel(ImageMath.eval(\"A%A\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B%B\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A%B\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B%A\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z%A\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z%B\", B=B, Z=Z)) == \"I 0\"",
            "",
            "",
            "def test_bitwise_invert():",
            "    assert pixel(ImageMath.eval(\"~Z\", Z=Z)) == \"I -1\"",
            "    assert pixel(ImageMath.eval(\"~A\", A=A)) == \"I -2\"",
            "    assert pixel(ImageMath.eval(\"~B\", B=B)) == \"I -3\"",
            "",
            "",
            "def test_bitwise_and():",
            "    assert pixel(ImageMath.eval(\"Z&Z\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z&A\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A&Z\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A&A\", A=A, Z=Z)) == \"I 1\"",
            "",
            "",
            "def test_bitwise_or():",
            "    assert pixel(ImageMath.eval(\"Z|Z\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z|A\", A=A, Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A|Z\", A=A, Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A|A\", A=A, Z=Z)) == \"I 1\"",
            "",
            "",
            "def test_bitwise_xor():",
            "    assert pixel(ImageMath.eval(\"Z^Z\", A=A, Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z^A\", A=A, Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A^Z\", A=A, Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A^A\", A=A, Z=Z)) == \"I 0\"",
            "",
            "",
            "def test_bitwise_leftshift():",
            "    assert pixel(ImageMath.eval(\"Z<<0\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z<<1\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A<<0\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A<<1\", A=A)) == \"I 2\"",
            "",
            "",
            "def test_bitwise_rightshift():",
            "    assert pixel(ImageMath.eval(\"Z>>0\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"Z>>1\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A>>0\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A>>1\", A=A)) == \"I 0\"",
            "",
            "",
            "def test_logical_eq():",
            "    assert pixel(ImageMath.eval(\"A==A\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B==B\", B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A==B\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B==A\", A=A, B=B)) == \"I 0\"",
            "",
            "",
            "def test_logical_ne():",
            "    assert pixel(ImageMath.eval(\"A!=A\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B!=B\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A!=B\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B!=A\", A=A, B=B)) == \"I 1\"",
            "",
            "",
            "def test_logical_lt():",
            "    assert pixel(ImageMath.eval(\"A<A\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B<B\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A<B\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B<A\", A=A, B=B)) == \"I 0\"",
            "",
            "",
            "def test_logical_le():",
            "    assert pixel(ImageMath.eval(\"A<=A\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B<=B\", B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A<=B\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B<=A\", A=A, B=B)) == \"I 0\"",
            "",
            "",
            "def test_logical_gt():",
            "    assert pixel(ImageMath.eval(\"A>A\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B>B\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"A>B\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B>A\", A=A, B=B)) == \"I 1\"",
            "",
            "",
            "def test_logical_ge():",
            "    assert pixel(ImageMath.eval(\"A>=A\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"B>=B\", B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"A>=B\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"B>=A\", A=A, B=B)) == \"I 1\"",
            "",
            "",
            "def test_logical_equal():",
            "    assert pixel(ImageMath.eval(\"equal(A, A)\", A=A)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"equal(B, B)\", B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"equal(Z, Z)\", Z=Z)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"equal(A, B)\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"equal(B, A)\", A=A, B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"equal(A, Z)\", A=A, Z=Z)) == \"I 0\"",
            "",
            "",
            "def test_logical_not_equal():",
            "    assert pixel(ImageMath.eval(\"notequal(A, A)\", A=A)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"notequal(B, B)\", B=B)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"notequal(Z, Z)\", Z=Z)) == \"I 0\"",
            "    assert pixel(ImageMath.eval(\"notequal(A, B)\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"notequal(B, A)\", A=A, B=B)) == \"I 1\"",
            "    assert pixel(ImageMath.eval(\"notequal(A, Z)\", A=A, Z=Z)) == \"I 1\""
        ],
        "action": [
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "ecdsa.der"
        ]
    },
    "src/PIL/ImageMath.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "         if hasattr(v, \"im\"):"
            },
            "1": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "             args[k] = _Operand(v)"
            },
            "2": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 248,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    out = builtins.eval(expression, args)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+    code = compile(expression, \"<string>\", \"eval\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+    for name in code.co_names:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        if name not in args and name != \"abs\":"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+            raise ValueError(f\"'{name}' not allowed\")"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+    out = builtins.eval(expression, {\"__builtins\": {\"abs\": abs}}, args)"
            },
            "10": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "     try:"
            },
            "11": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         return out.im"
            },
            "12": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "     except AttributeError:"
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library",
            "# $Id$",
            "#",
            "# a simple math add-on for the Python Imaging Library",
            "#",
            "# History:",
            "# 1999-02-15 fl   Original PIL Plus release",
            "# 2005-05-05 fl   Simplified and cleaned up for PIL 1.1.6",
            "# 2005-09-12 fl   Fixed int() and float() for Python 2.4.1",
            "#",
            "# Copyright (c) 1999-2005 by Secret Labs AB",
            "# Copyright (c) 2005 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import builtins",
            "",
            "from . import Image, _imagingmath",
            "",
            "VERBOSE = 0",
            "",
            "",
            "def _isconstant(v):",
            "    return isinstance(v, (int, float))",
            "",
            "",
            "class _Operand:",
            "    \"\"\"Wraps an image operand, providing standard operators\"\"\"",
            "",
            "    def __init__(self, im):",
            "        self.im = im",
            "",
            "    def __fixup(self, im1):",
            "        # convert image to suitable mode",
            "        if isinstance(im1, _Operand):",
            "            # argument was an image.",
            "            if im1.im.mode in (\"1\", \"L\"):",
            "                return im1.im.convert(\"I\")",
            "            elif im1.im.mode in (\"I\", \"F\"):",
            "                return im1.im",
            "            else:",
            "                raise ValueError(f\"unsupported mode: {im1.im.mode}\")",
            "        else:",
            "            # argument was a constant",
            "            if _isconstant(im1) and self.im.mode in (\"1\", \"L\", \"I\"):",
            "                return Image.new(\"I\", self.im.size, im1)",
            "            else:",
            "                return Image.new(\"F\", self.im.size, im1)",
            "",
            "    def apply(self, op, im1, im2=None, mode=None):",
            "        im1 = self.__fixup(im1)",
            "        if im2 is None:",
            "            # unary operation",
            "            out = Image.new(mode or im1.mode, im1.size, None)",
            "            im1.load()",
            "            try:",
            "                op = getattr(_imagingmath, op + \"_\" + im1.mode)",
            "            except AttributeError as e:",
            "                raise TypeError(f\"bad operand type for '{op}'\") from e",
            "            _imagingmath.unop(op, out.im.id, im1.im.id)",
            "        else:",
            "            # binary operation",
            "            im2 = self.__fixup(im2)",
            "            if im1.mode != im2.mode:",
            "                # convert both arguments to floating point",
            "                if im1.mode != \"F\":",
            "                    im1 = im1.convert(\"F\")",
            "                if im2.mode != \"F\":",
            "                    im2 = im2.convert(\"F\")",
            "                if im1.mode != im2.mode:",
            "                    raise ValueError(\"mode mismatch\")",
            "            if im1.size != im2.size:",
            "                # crop both arguments to a common size",
            "                size = (min(im1.size[0], im2.size[0]), min(im1.size[1], im2.size[1]))",
            "                if im1.size != size:",
            "                    im1 = im1.crop((0, 0) + size)",
            "                if im2.size != size:",
            "                    im2 = im2.crop((0, 0) + size)",
            "                out = Image.new(mode or im1.mode, size, None)",
            "            else:",
            "                out = Image.new(mode or im1.mode, im1.size, None)",
            "            im1.load()",
            "            im2.load()",
            "            try:",
            "                op = getattr(_imagingmath, op + \"_\" + im1.mode)",
            "            except AttributeError as e:",
            "                raise TypeError(f\"bad operand type for '{op}'\") from e",
            "            _imagingmath.binop(op, out.im.id, im1.im.id, im2.im.id)",
            "        return _Operand(out)",
            "",
            "    # unary operators",
            "    def __bool__(self):",
            "        # an image is \"true\" if it contains at least one non-zero pixel",
            "        return self.im.getbbox() is not None",
            "",
            "    def __abs__(self):",
            "        return self.apply(\"abs\", self)",
            "",
            "    def __pos__(self):",
            "        return self",
            "",
            "    def __neg__(self):",
            "        return self.apply(\"neg\", self)",
            "",
            "    # binary operators",
            "    def __add__(self, other):",
            "        return self.apply(\"add\", self, other)",
            "",
            "    def __radd__(self, other):",
            "        return self.apply(\"add\", other, self)",
            "",
            "    def __sub__(self, other):",
            "        return self.apply(\"sub\", self, other)",
            "",
            "    def __rsub__(self, other):",
            "        return self.apply(\"sub\", other, self)",
            "",
            "    def __mul__(self, other):",
            "        return self.apply(\"mul\", self, other)",
            "",
            "    def __rmul__(self, other):",
            "        return self.apply(\"mul\", other, self)",
            "",
            "    def __truediv__(self, other):",
            "        return self.apply(\"div\", self, other)",
            "",
            "    def __rtruediv__(self, other):",
            "        return self.apply(\"div\", other, self)",
            "",
            "    def __mod__(self, other):",
            "        return self.apply(\"mod\", self, other)",
            "",
            "    def __rmod__(self, other):",
            "        return self.apply(\"mod\", other, self)",
            "",
            "    def __pow__(self, other):",
            "        return self.apply(\"pow\", self, other)",
            "",
            "    def __rpow__(self, other):",
            "        return self.apply(\"pow\", other, self)",
            "",
            "    # bitwise",
            "    def __invert__(self):",
            "        return self.apply(\"invert\", self)",
            "",
            "    def __and__(self, other):",
            "        return self.apply(\"and\", self, other)",
            "",
            "    def __rand__(self, other):",
            "        return self.apply(\"and\", other, self)",
            "",
            "    def __or__(self, other):",
            "        return self.apply(\"or\", self, other)",
            "",
            "    def __ror__(self, other):",
            "        return self.apply(\"or\", other, self)",
            "",
            "    def __xor__(self, other):",
            "        return self.apply(\"xor\", self, other)",
            "",
            "    def __rxor__(self, other):",
            "        return self.apply(\"xor\", other, self)",
            "",
            "    def __lshift__(self, other):",
            "        return self.apply(\"lshift\", self, other)",
            "",
            "    def __rshift__(self, other):",
            "        return self.apply(\"rshift\", self, other)",
            "",
            "    # logical",
            "    def __eq__(self, other):",
            "        return self.apply(\"eq\", self, other)",
            "",
            "    def __ne__(self, other):",
            "        return self.apply(\"ne\", self, other)",
            "",
            "    def __lt__(self, other):",
            "        return self.apply(\"lt\", self, other)",
            "",
            "    def __le__(self, other):",
            "        return self.apply(\"le\", self, other)",
            "",
            "    def __gt__(self, other):",
            "        return self.apply(\"gt\", self, other)",
            "",
            "    def __ge__(self, other):",
            "        return self.apply(\"ge\", self, other)",
            "",
            "",
            "# conversions",
            "def imagemath_int(self):",
            "    return _Operand(self.im.convert(\"I\"))",
            "",
            "",
            "def imagemath_float(self):",
            "    return _Operand(self.im.convert(\"F\"))",
            "",
            "",
            "# logical",
            "def imagemath_equal(self, other):",
            "    return self.apply(\"eq\", self, other, mode=\"I\")",
            "",
            "",
            "def imagemath_notequal(self, other):",
            "    return self.apply(\"ne\", self, other, mode=\"I\")",
            "",
            "",
            "def imagemath_min(self, other):",
            "    return self.apply(\"min\", self, other)",
            "",
            "",
            "def imagemath_max(self, other):",
            "    return self.apply(\"max\", self, other)",
            "",
            "",
            "def imagemath_convert(self, mode):",
            "    return _Operand(self.im.convert(mode))",
            "",
            "",
            "ops = {}",
            "for k, v in list(globals().items()):",
            "    if k[:10] == \"imagemath_\":",
            "        ops[k[10:]] = v",
            "",
            "",
            "def eval(expression, _dict={}, **kw):",
            "    \"\"\"",
            "    Evaluates an image expression.",
            "",
            "    :param expression: A string containing a Python-style expression.",
            "    :param options: Values to add to the evaluation context.  You",
            "                    can either use a dictionary, or one or more keyword",
            "                    arguments.",
            "    :return: The evaluated expression. This is usually an image object, but can",
            "             also be an integer, a floating point value, or a pixel tuple,",
            "             depending on the expression.",
            "    \"\"\"",
            "",
            "    # build execution namespace",
            "    args = ops.copy()",
            "    args.update(_dict)",
            "    args.update(kw)",
            "    for k, v in list(args.items()):",
            "        if hasattr(v, \"im\"):",
            "            args[k] = _Operand(v)",
            "",
            "    out = builtins.eval(expression, args)",
            "    try:",
            "        return out.im",
            "    except AttributeError:",
            "        return out"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library",
            "# $Id$",
            "#",
            "# a simple math add-on for the Python Imaging Library",
            "#",
            "# History:",
            "# 1999-02-15 fl   Original PIL Plus release",
            "# 2005-05-05 fl   Simplified and cleaned up for PIL 1.1.6",
            "# 2005-09-12 fl   Fixed int() and float() for Python 2.4.1",
            "#",
            "# Copyright (c) 1999-2005 by Secret Labs AB",
            "# Copyright (c) 2005 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import builtins",
            "",
            "from . import Image, _imagingmath",
            "",
            "VERBOSE = 0",
            "",
            "",
            "def _isconstant(v):",
            "    return isinstance(v, (int, float))",
            "",
            "",
            "class _Operand:",
            "    \"\"\"Wraps an image operand, providing standard operators\"\"\"",
            "",
            "    def __init__(self, im):",
            "        self.im = im",
            "",
            "    def __fixup(self, im1):",
            "        # convert image to suitable mode",
            "        if isinstance(im1, _Operand):",
            "            # argument was an image.",
            "            if im1.im.mode in (\"1\", \"L\"):",
            "                return im1.im.convert(\"I\")",
            "            elif im1.im.mode in (\"I\", \"F\"):",
            "                return im1.im",
            "            else:",
            "                raise ValueError(f\"unsupported mode: {im1.im.mode}\")",
            "        else:",
            "            # argument was a constant",
            "            if _isconstant(im1) and self.im.mode in (\"1\", \"L\", \"I\"):",
            "                return Image.new(\"I\", self.im.size, im1)",
            "            else:",
            "                return Image.new(\"F\", self.im.size, im1)",
            "",
            "    def apply(self, op, im1, im2=None, mode=None):",
            "        im1 = self.__fixup(im1)",
            "        if im2 is None:",
            "            # unary operation",
            "            out = Image.new(mode or im1.mode, im1.size, None)",
            "            im1.load()",
            "            try:",
            "                op = getattr(_imagingmath, op + \"_\" + im1.mode)",
            "            except AttributeError as e:",
            "                raise TypeError(f\"bad operand type for '{op}'\") from e",
            "            _imagingmath.unop(op, out.im.id, im1.im.id)",
            "        else:",
            "            # binary operation",
            "            im2 = self.__fixup(im2)",
            "            if im1.mode != im2.mode:",
            "                # convert both arguments to floating point",
            "                if im1.mode != \"F\":",
            "                    im1 = im1.convert(\"F\")",
            "                if im2.mode != \"F\":",
            "                    im2 = im2.convert(\"F\")",
            "                if im1.mode != im2.mode:",
            "                    raise ValueError(\"mode mismatch\")",
            "            if im1.size != im2.size:",
            "                # crop both arguments to a common size",
            "                size = (min(im1.size[0], im2.size[0]), min(im1.size[1], im2.size[1]))",
            "                if im1.size != size:",
            "                    im1 = im1.crop((0, 0) + size)",
            "                if im2.size != size:",
            "                    im2 = im2.crop((0, 0) + size)",
            "                out = Image.new(mode or im1.mode, size, None)",
            "            else:",
            "                out = Image.new(mode or im1.mode, im1.size, None)",
            "            im1.load()",
            "            im2.load()",
            "            try:",
            "                op = getattr(_imagingmath, op + \"_\" + im1.mode)",
            "            except AttributeError as e:",
            "                raise TypeError(f\"bad operand type for '{op}'\") from e",
            "            _imagingmath.binop(op, out.im.id, im1.im.id, im2.im.id)",
            "        return _Operand(out)",
            "",
            "    # unary operators",
            "    def __bool__(self):",
            "        # an image is \"true\" if it contains at least one non-zero pixel",
            "        return self.im.getbbox() is not None",
            "",
            "    def __abs__(self):",
            "        return self.apply(\"abs\", self)",
            "",
            "    def __pos__(self):",
            "        return self",
            "",
            "    def __neg__(self):",
            "        return self.apply(\"neg\", self)",
            "",
            "    # binary operators",
            "    def __add__(self, other):",
            "        return self.apply(\"add\", self, other)",
            "",
            "    def __radd__(self, other):",
            "        return self.apply(\"add\", other, self)",
            "",
            "    def __sub__(self, other):",
            "        return self.apply(\"sub\", self, other)",
            "",
            "    def __rsub__(self, other):",
            "        return self.apply(\"sub\", other, self)",
            "",
            "    def __mul__(self, other):",
            "        return self.apply(\"mul\", self, other)",
            "",
            "    def __rmul__(self, other):",
            "        return self.apply(\"mul\", other, self)",
            "",
            "    def __truediv__(self, other):",
            "        return self.apply(\"div\", self, other)",
            "",
            "    def __rtruediv__(self, other):",
            "        return self.apply(\"div\", other, self)",
            "",
            "    def __mod__(self, other):",
            "        return self.apply(\"mod\", self, other)",
            "",
            "    def __rmod__(self, other):",
            "        return self.apply(\"mod\", other, self)",
            "",
            "    def __pow__(self, other):",
            "        return self.apply(\"pow\", self, other)",
            "",
            "    def __rpow__(self, other):",
            "        return self.apply(\"pow\", other, self)",
            "",
            "    # bitwise",
            "    def __invert__(self):",
            "        return self.apply(\"invert\", self)",
            "",
            "    def __and__(self, other):",
            "        return self.apply(\"and\", self, other)",
            "",
            "    def __rand__(self, other):",
            "        return self.apply(\"and\", other, self)",
            "",
            "    def __or__(self, other):",
            "        return self.apply(\"or\", self, other)",
            "",
            "    def __ror__(self, other):",
            "        return self.apply(\"or\", other, self)",
            "",
            "    def __xor__(self, other):",
            "        return self.apply(\"xor\", self, other)",
            "",
            "    def __rxor__(self, other):",
            "        return self.apply(\"xor\", other, self)",
            "",
            "    def __lshift__(self, other):",
            "        return self.apply(\"lshift\", self, other)",
            "",
            "    def __rshift__(self, other):",
            "        return self.apply(\"rshift\", self, other)",
            "",
            "    # logical",
            "    def __eq__(self, other):",
            "        return self.apply(\"eq\", self, other)",
            "",
            "    def __ne__(self, other):",
            "        return self.apply(\"ne\", self, other)",
            "",
            "    def __lt__(self, other):",
            "        return self.apply(\"lt\", self, other)",
            "",
            "    def __le__(self, other):",
            "        return self.apply(\"le\", self, other)",
            "",
            "    def __gt__(self, other):",
            "        return self.apply(\"gt\", self, other)",
            "",
            "    def __ge__(self, other):",
            "        return self.apply(\"ge\", self, other)",
            "",
            "",
            "# conversions",
            "def imagemath_int(self):",
            "    return _Operand(self.im.convert(\"I\"))",
            "",
            "",
            "def imagemath_float(self):",
            "    return _Operand(self.im.convert(\"F\"))",
            "",
            "",
            "# logical",
            "def imagemath_equal(self, other):",
            "    return self.apply(\"eq\", self, other, mode=\"I\")",
            "",
            "",
            "def imagemath_notequal(self, other):",
            "    return self.apply(\"ne\", self, other, mode=\"I\")",
            "",
            "",
            "def imagemath_min(self, other):",
            "    return self.apply(\"min\", self, other)",
            "",
            "",
            "def imagemath_max(self, other):",
            "    return self.apply(\"max\", self, other)",
            "",
            "",
            "def imagemath_convert(self, mode):",
            "    return _Operand(self.im.convert(mode))",
            "",
            "",
            "ops = {}",
            "for k, v in list(globals().items()):",
            "    if k[:10] == \"imagemath_\":",
            "        ops[k[10:]] = v",
            "",
            "",
            "def eval(expression, _dict={}, **kw):",
            "    \"\"\"",
            "    Evaluates an image expression.",
            "",
            "    :param expression: A string containing a Python-style expression.",
            "    :param options: Values to add to the evaluation context.  You",
            "                    can either use a dictionary, or one or more keyword",
            "                    arguments.",
            "    :return: The evaluated expression. This is usually an image object, but can",
            "             also be an integer, a floating point value, or a pixel tuple,",
            "             depending on the expression.",
            "    \"\"\"",
            "",
            "    # build execution namespace",
            "    args = ops.copy()",
            "    args.update(_dict)",
            "    args.update(kw)",
            "    for k, v in list(args.items()):",
            "        if hasattr(v, \"im\"):",
            "            args[k] = _Operand(v)",
            "",
            "    code = compile(expression, \"<string>\", \"eval\")",
            "    for name in code.co_names:",
            "        if name not in args and name != \"abs\":",
            "            raise ValueError(f\"'{name}' not allowed\")",
            "",
            "    out = builtins.eval(expression, {\"__builtins\": {\"abs\": abs}}, args)",
            "    try:",
            "        return out.im",
            "    except AttributeError:",
            "        return out"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "249": [
                "eval"
            ]
        },
        "addLocation": []
    }
}