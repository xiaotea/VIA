{
    "src/jinja2/sandbox.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from _string import formatter_field_name_split  # type: ignore"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from collections import abc"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from collections import deque"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from functools import update_wrapper"
            },
            "4": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from string import Formatter"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from markupsafe import EscapeFormatter"
            },
            "7": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " )"
            },
            "8": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def inspect_format_method(callable: t.Callable[..., t.Any]) -> t.Optional[str]:"
            },
            "11": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not isinstance("
            },
            "12": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        callable, (types.MethodType, types.BuiltinMethodType)"
            },
            "13": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ) or callable.__name__ not in (\"format\", \"format_map\"):"
            },
            "14": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return None"
            },
            "15": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "16": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    obj = callable.__self__"
            },
            "17": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "18": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if isinstance(obj, str):"
            },
            "19": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return obj"
            },
            "20": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "21": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return None"
            },
            "22": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "23": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "24": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " def safe_range(*args: int) -> range:"
            },
            "25": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     \"\"\"A range that can't generate ranges with a length of more than"
            },
            "26": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "     MAX_RANGE items."
            },
            "27": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "                     except AttributeError:"
            },
            "28": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "                         pass"
            },
            "29": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "                     else:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+                        fmt = self.wrap_str_format(value)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+                        if fmt is not None:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+                            return fmt"
            },
            "33": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "                         if self.is_safe_attribute(obj, argument, value):"
            },
            "34": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "                             return value"
            },
            "35": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "                         return self.unsafe_undefined(obj, argument)"
            },
            "36": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "             except (TypeError, LookupError):"
            },
            "37": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "                 pass"
            },
            "38": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "         else:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+            fmt = self.wrap_str_format(value)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+            if fmt is not None:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+                return fmt"
            },
            "42": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "             if self.is_safe_attribute(obj, attribute, value):"
            },
            "43": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "                 return value"
            },
            "44": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "             return self.unsafe_undefined(obj, attribute)"
            },
            "45": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "             exc=SecurityError,"
            },
            "46": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "         )"
            },
            "47": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 343,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def format_string("
            },
            "49": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self,"
            },
            "50": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        s: str,"
            },
            "51": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        args: t.Tuple[t.Any, ...],"
            },
            "52": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        kwargs: t.Dict[str, t.Any],"
            },
            "53": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        format_func: t.Optional[t.Callable[..., t.Any]] = None,"
            },
            "54": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ) -> str:"
            },
            "55": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"If a format call is detected, then this is routed through this"
            },
            "56": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        method so that our safety sandbox can be used for it."
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+    def wrap_str_format(self, value: t.Any) -> t.Optional[t.Callable[..., str]]:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+        \"\"\"If the given value is a ``str.format`` or ``str.format_map`` method,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+        return a new function than handles sandboxing. This is done at access"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+        rather than in :meth:`call`, so that calls made without ``call`` are"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+        also sandboxed."
            },
            "62": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "         \"\"\""
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+        if not isinstance("
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+            value, (types.MethodType, types.BuiltinMethodType)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+        ) or value.__name__ not in (\"format\", \"format_map\"):"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+            return None"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        f_self: t.Any = value.__self__"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+        if not isinstance(f_self, str):"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+            return None"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+        str_type: t.Type[str] = type(f_self)"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+        is_format_map = value.__name__ == \"format_map\""
            },
            "75": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "         formatter: SandboxedFormatter"
            },
            "76": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if isinstance(s, Markup):"
            },
            "77": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            formatter = SandboxedEscapeFormatter(self, escape=s.escape)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+        if isinstance(f_self, Markup):"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+            formatter = SandboxedEscapeFormatter(self, escape=f_self.escape)"
            },
            "81": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "         else:"
            },
            "82": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "             formatter = SandboxedFormatter(self)"
            },
            "83": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 368,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if format_func is not None and format_func.__name__ == \"format_map\":"
            },
            "85": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if len(args) != 1 or kwargs:"
            },
            "86": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise TypeError("
            },
            "87": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"format_map() takes exactly one argument\""
            },
            "88": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f\" {len(args) + (kwargs is not None)} given\""
            },
            "89": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+        vformat = formatter.vformat"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+        def wrapper(*args: t.Any, **kwargs: t.Any) -> str:"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+            if is_format_map:"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+                if kwargs:"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+                    raise TypeError(\"format_map() takes no keyword arguments\")"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+                if len(args) != 1:"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+                    raise TypeError("
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+                        f\"format_map() takes exactly one argument ({len(args)} given)\""
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+                    )"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+                kwargs = args[0]"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+                args = ()"
            },
            "104": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 383,
                "PatchRowcode": " "
            },
            "105": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            kwargs = args[0]"
            },
            "106": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            args = ()"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+            return str_type(vformat(f_self, args, kwargs))"
            },
            "108": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 385,
                "PatchRowcode": " "
            },
            "109": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        rv = formatter.vformat(s, args, kwargs)"
            },
            "110": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return type(s)(rv)"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+        return update_wrapper(wrapper, value)"
            },
            "112": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 387,
                "PatchRowcode": " "
            },
            "113": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "     def call("
            },
            "114": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "         __self,  # noqa: B902"
            },
            "115": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "         **kwargs: t.Any,"
            },
            "116": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "     ) -> t.Any:"
            },
            "117": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "         \"\"\"Call an object from sandboxed code.\"\"\""
            },
            "118": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        fmt = inspect_format_method(__obj)"
            },
            "119": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if fmt is not None:"
            },
            "120": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return __self.format_string(fmt, args, kwargs, __obj)"
            },
            "121": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 396,
                "PatchRowcode": " "
            },
            "122": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "         # the double prefixes are to avoid double keyword argument"
            },
            "123": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "         # errors when proxying the call."
            }
        },
        "frontPatchFile": [
            "\"\"\"A sandbox layer that ensures unsafe operations cannot be performed.",
            "Useful when the template itself comes from an untrusted source.",
            "\"\"\"",
            "",
            "import operator",
            "import types",
            "import typing as t",
            "from _string import formatter_field_name_split  # type: ignore",
            "from collections import abc",
            "from collections import deque",
            "from string import Formatter",
            "",
            "from markupsafe import EscapeFormatter",
            "from markupsafe import Markup",
            "",
            "from .environment import Environment",
            "from .exceptions import SecurityError",
            "from .runtime import Context",
            "from .runtime import Undefined",
            "",
            "F = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])",
            "",
            "#: maximum number of items a range may produce",
            "MAX_RANGE = 100000",
            "",
            "#: Unsafe function attributes.",
            "UNSAFE_FUNCTION_ATTRIBUTES: t.Set[str] = set()",
            "",
            "#: Unsafe method attributes. Function attributes are unsafe for methods too.",
            "UNSAFE_METHOD_ATTRIBUTES: t.Set[str] = set()",
            "",
            "#: unsafe generator attributes.",
            "UNSAFE_GENERATOR_ATTRIBUTES = {\"gi_frame\", \"gi_code\"}",
            "",
            "#: unsafe attributes on coroutines",
            "UNSAFE_COROUTINE_ATTRIBUTES = {\"cr_frame\", \"cr_code\"}",
            "",
            "#: unsafe attributes on async generators",
            "UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {\"ag_code\", \"ag_frame\"}",
            "",
            "_mutable_spec: t.Tuple[t.Tuple[t.Type[t.Any], t.FrozenSet[str]], ...] = (",
            "    (",
            "        abc.MutableSet,",
            "        frozenset(",
            "            [",
            "                \"add\",",
            "                \"clear\",",
            "                \"difference_update\",",
            "                \"discard\",",
            "                \"pop\",",
            "                \"remove\",",
            "                \"symmetric_difference_update\",",
            "                \"update\",",
            "            ]",
            "        ),",
            "    ),",
            "    (",
            "        abc.MutableMapping,",
            "        frozenset([\"clear\", \"pop\", \"popitem\", \"setdefault\", \"update\"]),",
            "    ),",
            "    (",
            "        abc.MutableSequence,",
            "        frozenset(",
            "            [\"append\", \"clear\", \"pop\", \"reverse\", \"insert\", \"sort\", \"extend\", \"remove\"]",
            "        ),",
            "    ),",
            "    (",
            "        deque,",
            "        frozenset(",
            "            [",
            "                \"append\",",
            "                \"appendleft\",",
            "                \"clear\",",
            "                \"extend\",",
            "                \"extendleft\",",
            "                \"pop\",",
            "                \"popleft\",",
            "                \"remove\",",
            "                \"rotate\",",
            "            ]",
            "        ),",
            "    ),",
            ")",
            "",
            "",
            "def inspect_format_method(callable: t.Callable[..., t.Any]) -> t.Optional[str]:",
            "    if not isinstance(",
            "        callable, (types.MethodType, types.BuiltinMethodType)",
            "    ) or callable.__name__ not in (\"format\", \"format_map\"):",
            "        return None",
            "",
            "    obj = callable.__self__",
            "",
            "    if isinstance(obj, str):",
            "        return obj",
            "",
            "    return None",
            "",
            "",
            "def safe_range(*args: int) -> range:",
            "    \"\"\"A range that can't generate ranges with a length of more than",
            "    MAX_RANGE items.",
            "    \"\"\"",
            "    rng = range(*args)",
            "",
            "    if len(rng) > MAX_RANGE:",
            "        raise OverflowError(",
            "            \"Range too big. The sandbox blocks ranges larger than\"",
            "            f\" MAX_RANGE ({MAX_RANGE}).\"",
            "        )",
            "",
            "    return rng",
            "",
            "",
            "def unsafe(f: F) -> F:",
            "    \"\"\"Marks a function or method as unsafe.",
            "",
            "    .. code-block: python",
            "",
            "        @unsafe",
            "        def delete(self):",
            "            pass",
            "    \"\"\"",
            "    f.unsafe_callable = True  # type: ignore",
            "    return f",
            "",
            "",
            "def is_internal_attribute(obj: t.Any, attr: str) -> bool:",
            "    \"\"\"Test if the attribute given is an internal python attribute.  For",
            "    example this function returns `True` for the `func_code` attribute of",
            "    python objects.  This is useful if the environment method",
            "    :meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.",
            "",
            "    >>> from jinja2.sandbox import is_internal_attribute",
            "    >>> is_internal_attribute(str, \"mro\")",
            "    True",
            "    >>> is_internal_attribute(str, \"upper\")",
            "    False",
            "    \"\"\"",
            "    if isinstance(obj, types.FunctionType):",
            "        if attr in UNSAFE_FUNCTION_ATTRIBUTES:",
            "            return True",
            "    elif isinstance(obj, types.MethodType):",
            "        if attr in UNSAFE_FUNCTION_ATTRIBUTES or attr in UNSAFE_METHOD_ATTRIBUTES:",
            "            return True",
            "    elif isinstance(obj, type):",
            "        if attr == \"mro\":",
            "            return True",
            "    elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):",
            "        return True",
            "    elif isinstance(obj, types.GeneratorType):",
            "        if attr in UNSAFE_GENERATOR_ATTRIBUTES:",
            "            return True",
            "    elif hasattr(types, \"CoroutineType\") and isinstance(obj, types.CoroutineType):",
            "        if attr in UNSAFE_COROUTINE_ATTRIBUTES:",
            "            return True",
            "    elif hasattr(types, \"AsyncGeneratorType\") and isinstance(",
            "        obj, types.AsyncGeneratorType",
            "    ):",
            "        if attr in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:",
            "            return True",
            "    return attr.startswith(\"__\")",
            "",
            "",
            "def modifies_known_mutable(obj: t.Any, attr: str) -> bool:",
            "    \"\"\"This function checks if an attribute on a builtin mutable object",
            "    (list, dict, set or deque) or the corresponding ABCs would modify it",
            "    if called.",
            "",
            "    >>> modifies_known_mutable({}, \"clear\")",
            "    True",
            "    >>> modifies_known_mutable({}, \"keys\")",
            "    False",
            "    >>> modifies_known_mutable([], \"append\")",
            "    True",
            "    >>> modifies_known_mutable([], \"index\")",
            "    False",
            "",
            "    If called with an unsupported object, ``False`` is returned.",
            "",
            "    >>> modifies_known_mutable(\"foo\", \"upper\")",
            "    False",
            "    \"\"\"",
            "    for typespec, unsafe in _mutable_spec:",
            "        if isinstance(obj, typespec):",
            "            return attr in unsafe",
            "    return False",
            "",
            "",
            "class SandboxedEnvironment(Environment):",
            "    \"\"\"The sandboxed environment.  It works like the regular environment but",
            "    tells the compiler to generate sandboxed code.  Additionally subclasses of",
            "    this environment may override the methods that tell the runtime what",
            "    attributes or functions are safe to access.",
            "",
            "    If the template tries to access insecure code a :exc:`SecurityError` is",
            "    raised.  However also other exceptions may occur during the rendering so",
            "    the caller has to ensure that all exceptions are caught.",
            "    \"\"\"",
            "",
            "    sandboxed = True",
            "",
            "    #: default callback table for the binary operators.  A copy of this is",
            "    #: available on each instance of a sandboxed environment as",
            "    #: :attr:`binop_table`",
            "    default_binop_table: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {",
            "        \"+\": operator.add,",
            "        \"-\": operator.sub,",
            "        \"*\": operator.mul,",
            "        \"/\": operator.truediv,",
            "        \"//\": operator.floordiv,",
            "        \"**\": operator.pow,",
            "        \"%\": operator.mod,",
            "    }",
            "",
            "    #: default callback table for the unary operators.  A copy of this is",
            "    #: available on each instance of a sandboxed environment as",
            "    #: :attr:`unop_table`",
            "    default_unop_table: t.Dict[str, t.Callable[[t.Any], t.Any]] = {",
            "        \"+\": operator.pos,",
            "        \"-\": operator.neg,",
            "    }",
            "",
            "    #: a set of binary operators that should be intercepted.  Each operator",
            "    #: that is added to this set (empty by default) is delegated to the",
            "    #: :meth:`call_binop` method that will perform the operator.  The default",
            "    #: operator callback is specified by :attr:`binop_table`.",
            "    #:",
            "    #: The following binary operators are interceptable:",
            "    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``",
            "    #:",
            "    #: The default operation form the operator table corresponds to the",
            "    #: builtin function.  Intercepted calls are always slower than the native",
            "    #: operator call, so make sure only to intercept the ones you are",
            "    #: interested in.",
            "    #:",
            "    #: .. versionadded:: 2.6",
            "    intercepted_binops: t.FrozenSet[str] = frozenset()",
            "",
            "    #: a set of unary operators that should be intercepted.  Each operator",
            "    #: that is added to this set (empty by default) is delegated to the",
            "    #: :meth:`call_unop` method that will perform the operator.  The default",
            "    #: operator callback is specified by :attr:`unop_table`.",
            "    #:",
            "    #: The following unary operators are interceptable: ``+``, ``-``",
            "    #:",
            "    #: The default operation form the operator table corresponds to the",
            "    #: builtin function.  Intercepted calls are always slower than the native",
            "    #: operator call, so make sure only to intercept the ones you are",
            "    #: interested in.",
            "    #:",
            "    #: .. versionadded:: 2.6",
            "    intercepted_unops: t.FrozenSet[str] = frozenset()",
            "",
            "    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.globals[\"range\"] = safe_range",
            "        self.binop_table = self.default_binop_table.copy()",
            "        self.unop_table = self.default_unop_table.copy()",
            "",
            "    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -> bool:",
            "        \"\"\"The sandboxed environment will call this method to check if the",
            "        attribute of an object is safe to access.  Per default all attributes",
            "        starting with an underscore are considered private as well as the",
            "        special attributes of internal python objects as returned by the",
            "        :func:`is_internal_attribute` function.",
            "        \"\"\"",
            "        return not (attr.startswith(\"_\") or is_internal_attribute(obj, attr))",
            "",
            "    def is_safe_callable(self, obj: t.Any) -> bool:",
            "        \"\"\"Check if an object is safely callable. By default callables",
            "        are considered safe unless decorated with :func:`unsafe`.",
            "",
            "        This also recognizes the Django convention of setting",
            "        ``func.alters_data = True``.",
            "        \"\"\"",
            "        return not (",
            "            getattr(obj, \"unsafe_callable\", False) or getattr(obj, \"alters_data\", False)",
            "        )",
            "",
            "    def call_binop(",
            "        self, context: Context, operator: str, left: t.Any, right: t.Any",
            "    ) -> t.Any:",
            "        \"\"\"For intercepted binary operator calls (:meth:`intercepted_binops`)",
            "        this function is executed instead of the builtin operator.  This can",
            "        be used to fine tune the behavior of certain operators.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return self.binop_table[operator](left, right)",
            "",
            "    def call_unop(self, context: Context, operator: str, arg: t.Any) -> t.Any:",
            "        \"\"\"For intercepted unary operator calls (:meth:`intercepted_unops`)",
            "        this function is executed instead of the builtin operator.  This can",
            "        be used to fine tune the behavior of certain operators.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return self.unop_table[operator](arg)",
            "",
            "    def getitem(",
            "        self, obj: t.Any, argument: t.Union[str, t.Any]",
            "    ) -> t.Union[t.Any, Undefined]:",
            "        \"\"\"Subscribe an object from sandboxed code.\"\"\"",
            "        try:",
            "            return obj[argument]",
            "        except (TypeError, LookupError):",
            "            if isinstance(argument, str):",
            "                try:",
            "                    attr = str(argument)",
            "                except Exception:",
            "                    pass",
            "                else:",
            "                    try:",
            "                        value = getattr(obj, attr)",
            "                    except AttributeError:",
            "                        pass",
            "                    else:",
            "                        if self.is_safe_attribute(obj, argument, value):",
            "                            return value",
            "                        return self.unsafe_undefined(obj, argument)",
            "        return self.undefined(obj=obj, name=argument)",
            "",
            "    def getattr(self, obj: t.Any, attribute: str) -> t.Union[t.Any, Undefined]:",
            "        \"\"\"Subscribe an object from sandboxed code and prefer the",
            "        attribute.  The attribute passed *must* be a bytestring.",
            "        \"\"\"",
            "        try:",
            "            value = getattr(obj, attribute)",
            "        except AttributeError:",
            "            try:",
            "                return obj[attribute]",
            "            except (TypeError, LookupError):",
            "                pass",
            "        else:",
            "            if self.is_safe_attribute(obj, attribute, value):",
            "                return value",
            "            return self.unsafe_undefined(obj, attribute)",
            "        return self.undefined(obj=obj, name=attribute)",
            "",
            "    def unsafe_undefined(self, obj: t.Any, attribute: str) -> Undefined:",
            "        \"\"\"Return an undefined object for unsafe attributes.\"\"\"",
            "        return self.undefined(",
            "            f\"access to attribute {attribute!r} of\"",
            "            f\" {type(obj).__name__!r} object is unsafe.\",",
            "            name=attribute,",
            "            obj=obj,",
            "            exc=SecurityError,",
            "        )",
            "",
            "    def format_string(",
            "        self,",
            "        s: str,",
            "        args: t.Tuple[t.Any, ...],",
            "        kwargs: t.Dict[str, t.Any],",
            "        format_func: t.Optional[t.Callable[..., t.Any]] = None,",
            "    ) -> str:",
            "        \"\"\"If a format call is detected, then this is routed through this",
            "        method so that our safety sandbox can be used for it.",
            "        \"\"\"",
            "        formatter: SandboxedFormatter",
            "        if isinstance(s, Markup):",
            "            formatter = SandboxedEscapeFormatter(self, escape=s.escape)",
            "        else:",
            "            formatter = SandboxedFormatter(self)",
            "",
            "        if format_func is not None and format_func.__name__ == \"format_map\":",
            "            if len(args) != 1 or kwargs:",
            "                raise TypeError(",
            "                    \"format_map() takes exactly one argument\"",
            "                    f\" {len(args) + (kwargs is not None)} given\"",
            "                )",
            "",
            "            kwargs = args[0]",
            "            args = ()",
            "",
            "        rv = formatter.vformat(s, args, kwargs)",
            "        return type(s)(rv)",
            "",
            "    def call(",
            "        __self,  # noqa: B902",
            "        __context: Context,",
            "        __obj: t.Any,",
            "        *args: t.Any,",
            "        **kwargs: t.Any,",
            "    ) -> t.Any:",
            "        \"\"\"Call an object from sandboxed code.\"\"\"",
            "        fmt = inspect_format_method(__obj)",
            "        if fmt is not None:",
            "            return __self.format_string(fmt, args, kwargs, __obj)",
            "",
            "        # the double prefixes are to avoid double keyword argument",
            "        # errors when proxying the call.",
            "        if not __self.is_safe_callable(__obj):",
            "            raise SecurityError(f\"{__obj!r} is not safely callable\")",
            "        return __context.call(__obj, *args, **kwargs)",
            "",
            "",
            "class ImmutableSandboxedEnvironment(SandboxedEnvironment):",
            "    \"\"\"Works exactly like the regular `SandboxedEnvironment` but does not",
            "    permit modifications on the builtin mutable objects `list`, `set`, and",
            "    `dict` by using the :func:`modifies_known_mutable` function.",
            "    \"\"\"",
            "",
            "    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -> bool:",
            "        if not super().is_safe_attribute(obj, attr, value):",
            "            return False",
            "",
            "        return not modifies_known_mutable(obj, attr)",
            "",
            "",
            "class SandboxedFormatter(Formatter):",
            "    def __init__(self, env: Environment, **kwargs: t.Any) -> None:",
            "        self._env = env",
            "        super().__init__(**kwargs)",
            "",
            "    def get_field(",
            "        self, field_name: str, args: t.Sequence[t.Any], kwargs: t.Mapping[str, t.Any]",
            "    ) -> t.Tuple[t.Any, str]:",
            "        first, rest = formatter_field_name_split(field_name)",
            "        obj = self.get_value(first, args, kwargs)",
            "        for is_attr, i in rest:",
            "            if is_attr:",
            "                obj = self._env.getattr(obj, i)",
            "            else:",
            "                obj = self._env.getitem(obj, i)",
            "        return obj, first",
            "",
            "",
            "class SandboxedEscapeFormatter(SandboxedFormatter, EscapeFormatter):",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"A sandbox layer that ensures unsafe operations cannot be performed.",
            "Useful when the template itself comes from an untrusted source.",
            "\"\"\"",
            "",
            "import operator",
            "import types",
            "import typing as t",
            "from _string import formatter_field_name_split  # type: ignore",
            "from collections import abc",
            "from collections import deque",
            "from functools import update_wrapper",
            "from string import Formatter",
            "",
            "from markupsafe import EscapeFormatter",
            "from markupsafe import Markup",
            "",
            "from .environment import Environment",
            "from .exceptions import SecurityError",
            "from .runtime import Context",
            "from .runtime import Undefined",
            "",
            "F = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])",
            "",
            "#: maximum number of items a range may produce",
            "MAX_RANGE = 100000",
            "",
            "#: Unsafe function attributes.",
            "UNSAFE_FUNCTION_ATTRIBUTES: t.Set[str] = set()",
            "",
            "#: Unsafe method attributes. Function attributes are unsafe for methods too.",
            "UNSAFE_METHOD_ATTRIBUTES: t.Set[str] = set()",
            "",
            "#: unsafe generator attributes.",
            "UNSAFE_GENERATOR_ATTRIBUTES = {\"gi_frame\", \"gi_code\"}",
            "",
            "#: unsafe attributes on coroutines",
            "UNSAFE_COROUTINE_ATTRIBUTES = {\"cr_frame\", \"cr_code\"}",
            "",
            "#: unsafe attributes on async generators",
            "UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {\"ag_code\", \"ag_frame\"}",
            "",
            "_mutable_spec: t.Tuple[t.Tuple[t.Type[t.Any], t.FrozenSet[str]], ...] = (",
            "    (",
            "        abc.MutableSet,",
            "        frozenset(",
            "            [",
            "                \"add\",",
            "                \"clear\",",
            "                \"difference_update\",",
            "                \"discard\",",
            "                \"pop\",",
            "                \"remove\",",
            "                \"symmetric_difference_update\",",
            "                \"update\",",
            "            ]",
            "        ),",
            "    ),",
            "    (",
            "        abc.MutableMapping,",
            "        frozenset([\"clear\", \"pop\", \"popitem\", \"setdefault\", \"update\"]),",
            "    ),",
            "    (",
            "        abc.MutableSequence,",
            "        frozenset(",
            "            [\"append\", \"clear\", \"pop\", \"reverse\", \"insert\", \"sort\", \"extend\", \"remove\"]",
            "        ),",
            "    ),",
            "    (",
            "        deque,",
            "        frozenset(",
            "            [",
            "                \"append\",",
            "                \"appendleft\",",
            "                \"clear\",",
            "                \"extend\",",
            "                \"extendleft\",",
            "                \"pop\",",
            "                \"popleft\",",
            "                \"remove\",",
            "                \"rotate\",",
            "            ]",
            "        ),",
            "    ),",
            ")",
            "",
            "",
            "def safe_range(*args: int) -> range:",
            "    \"\"\"A range that can't generate ranges with a length of more than",
            "    MAX_RANGE items.",
            "    \"\"\"",
            "    rng = range(*args)",
            "",
            "    if len(rng) > MAX_RANGE:",
            "        raise OverflowError(",
            "            \"Range too big. The sandbox blocks ranges larger than\"",
            "            f\" MAX_RANGE ({MAX_RANGE}).\"",
            "        )",
            "",
            "    return rng",
            "",
            "",
            "def unsafe(f: F) -> F:",
            "    \"\"\"Marks a function or method as unsafe.",
            "",
            "    .. code-block: python",
            "",
            "        @unsafe",
            "        def delete(self):",
            "            pass",
            "    \"\"\"",
            "    f.unsafe_callable = True  # type: ignore",
            "    return f",
            "",
            "",
            "def is_internal_attribute(obj: t.Any, attr: str) -> bool:",
            "    \"\"\"Test if the attribute given is an internal python attribute.  For",
            "    example this function returns `True` for the `func_code` attribute of",
            "    python objects.  This is useful if the environment method",
            "    :meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.",
            "",
            "    >>> from jinja2.sandbox import is_internal_attribute",
            "    >>> is_internal_attribute(str, \"mro\")",
            "    True",
            "    >>> is_internal_attribute(str, \"upper\")",
            "    False",
            "    \"\"\"",
            "    if isinstance(obj, types.FunctionType):",
            "        if attr in UNSAFE_FUNCTION_ATTRIBUTES:",
            "            return True",
            "    elif isinstance(obj, types.MethodType):",
            "        if attr in UNSAFE_FUNCTION_ATTRIBUTES or attr in UNSAFE_METHOD_ATTRIBUTES:",
            "            return True",
            "    elif isinstance(obj, type):",
            "        if attr == \"mro\":",
            "            return True",
            "    elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):",
            "        return True",
            "    elif isinstance(obj, types.GeneratorType):",
            "        if attr in UNSAFE_GENERATOR_ATTRIBUTES:",
            "            return True",
            "    elif hasattr(types, \"CoroutineType\") and isinstance(obj, types.CoroutineType):",
            "        if attr in UNSAFE_COROUTINE_ATTRIBUTES:",
            "            return True",
            "    elif hasattr(types, \"AsyncGeneratorType\") and isinstance(",
            "        obj, types.AsyncGeneratorType",
            "    ):",
            "        if attr in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:",
            "            return True",
            "    return attr.startswith(\"__\")",
            "",
            "",
            "def modifies_known_mutable(obj: t.Any, attr: str) -> bool:",
            "    \"\"\"This function checks if an attribute on a builtin mutable object",
            "    (list, dict, set or deque) or the corresponding ABCs would modify it",
            "    if called.",
            "",
            "    >>> modifies_known_mutable({}, \"clear\")",
            "    True",
            "    >>> modifies_known_mutable({}, \"keys\")",
            "    False",
            "    >>> modifies_known_mutable([], \"append\")",
            "    True",
            "    >>> modifies_known_mutable([], \"index\")",
            "    False",
            "",
            "    If called with an unsupported object, ``False`` is returned.",
            "",
            "    >>> modifies_known_mutable(\"foo\", \"upper\")",
            "    False",
            "    \"\"\"",
            "    for typespec, unsafe in _mutable_spec:",
            "        if isinstance(obj, typespec):",
            "            return attr in unsafe",
            "    return False",
            "",
            "",
            "class SandboxedEnvironment(Environment):",
            "    \"\"\"The sandboxed environment.  It works like the regular environment but",
            "    tells the compiler to generate sandboxed code.  Additionally subclasses of",
            "    this environment may override the methods that tell the runtime what",
            "    attributes or functions are safe to access.",
            "",
            "    If the template tries to access insecure code a :exc:`SecurityError` is",
            "    raised.  However also other exceptions may occur during the rendering so",
            "    the caller has to ensure that all exceptions are caught.",
            "    \"\"\"",
            "",
            "    sandboxed = True",
            "",
            "    #: default callback table for the binary operators.  A copy of this is",
            "    #: available on each instance of a sandboxed environment as",
            "    #: :attr:`binop_table`",
            "    default_binop_table: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {",
            "        \"+\": operator.add,",
            "        \"-\": operator.sub,",
            "        \"*\": operator.mul,",
            "        \"/\": operator.truediv,",
            "        \"//\": operator.floordiv,",
            "        \"**\": operator.pow,",
            "        \"%\": operator.mod,",
            "    }",
            "",
            "    #: default callback table for the unary operators.  A copy of this is",
            "    #: available on each instance of a sandboxed environment as",
            "    #: :attr:`unop_table`",
            "    default_unop_table: t.Dict[str, t.Callable[[t.Any], t.Any]] = {",
            "        \"+\": operator.pos,",
            "        \"-\": operator.neg,",
            "    }",
            "",
            "    #: a set of binary operators that should be intercepted.  Each operator",
            "    #: that is added to this set (empty by default) is delegated to the",
            "    #: :meth:`call_binop` method that will perform the operator.  The default",
            "    #: operator callback is specified by :attr:`binop_table`.",
            "    #:",
            "    #: The following binary operators are interceptable:",
            "    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``",
            "    #:",
            "    #: The default operation form the operator table corresponds to the",
            "    #: builtin function.  Intercepted calls are always slower than the native",
            "    #: operator call, so make sure only to intercept the ones you are",
            "    #: interested in.",
            "    #:",
            "    #: .. versionadded:: 2.6",
            "    intercepted_binops: t.FrozenSet[str] = frozenset()",
            "",
            "    #: a set of unary operators that should be intercepted.  Each operator",
            "    #: that is added to this set (empty by default) is delegated to the",
            "    #: :meth:`call_unop` method that will perform the operator.  The default",
            "    #: operator callback is specified by :attr:`unop_table`.",
            "    #:",
            "    #: The following unary operators are interceptable: ``+``, ``-``",
            "    #:",
            "    #: The default operation form the operator table corresponds to the",
            "    #: builtin function.  Intercepted calls are always slower than the native",
            "    #: operator call, so make sure only to intercept the ones you are",
            "    #: interested in.",
            "    #:",
            "    #: .. versionadded:: 2.6",
            "    intercepted_unops: t.FrozenSet[str] = frozenset()",
            "",
            "    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.globals[\"range\"] = safe_range",
            "        self.binop_table = self.default_binop_table.copy()",
            "        self.unop_table = self.default_unop_table.copy()",
            "",
            "    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -> bool:",
            "        \"\"\"The sandboxed environment will call this method to check if the",
            "        attribute of an object is safe to access.  Per default all attributes",
            "        starting with an underscore are considered private as well as the",
            "        special attributes of internal python objects as returned by the",
            "        :func:`is_internal_attribute` function.",
            "        \"\"\"",
            "        return not (attr.startswith(\"_\") or is_internal_attribute(obj, attr))",
            "",
            "    def is_safe_callable(self, obj: t.Any) -> bool:",
            "        \"\"\"Check if an object is safely callable. By default callables",
            "        are considered safe unless decorated with :func:`unsafe`.",
            "",
            "        This also recognizes the Django convention of setting",
            "        ``func.alters_data = True``.",
            "        \"\"\"",
            "        return not (",
            "            getattr(obj, \"unsafe_callable\", False) or getattr(obj, \"alters_data\", False)",
            "        )",
            "",
            "    def call_binop(",
            "        self, context: Context, operator: str, left: t.Any, right: t.Any",
            "    ) -> t.Any:",
            "        \"\"\"For intercepted binary operator calls (:meth:`intercepted_binops`)",
            "        this function is executed instead of the builtin operator.  This can",
            "        be used to fine tune the behavior of certain operators.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return self.binop_table[operator](left, right)",
            "",
            "    def call_unop(self, context: Context, operator: str, arg: t.Any) -> t.Any:",
            "        \"\"\"For intercepted unary operator calls (:meth:`intercepted_unops`)",
            "        this function is executed instead of the builtin operator.  This can",
            "        be used to fine tune the behavior of certain operators.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return self.unop_table[operator](arg)",
            "",
            "    def getitem(",
            "        self, obj: t.Any, argument: t.Union[str, t.Any]",
            "    ) -> t.Union[t.Any, Undefined]:",
            "        \"\"\"Subscribe an object from sandboxed code.\"\"\"",
            "        try:",
            "            return obj[argument]",
            "        except (TypeError, LookupError):",
            "            if isinstance(argument, str):",
            "                try:",
            "                    attr = str(argument)",
            "                except Exception:",
            "                    pass",
            "                else:",
            "                    try:",
            "                        value = getattr(obj, attr)",
            "                    except AttributeError:",
            "                        pass",
            "                    else:",
            "                        fmt = self.wrap_str_format(value)",
            "                        if fmt is not None:",
            "                            return fmt",
            "                        if self.is_safe_attribute(obj, argument, value):",
            "                            return value",
            "                        return self.unsafe_undefined(obj, argument)",
            "        return self.undefined(obj=obj, name=argument)",
            "",
            "    def getattr(self, obj: t.Any, attribute: str) -> t.Union[t.Any, Undefined]:",
            "        \"\"\"Subscribe an object from sandboxed code and prefer the",
            "        attribute.  The attribute passed *must* be a bytestring.",
            "        \"\"\"",
            "        try:",
            "            value = getattr(obj, attribute)",
            "        except AttributeError:",
            "            try:",
            "                return obj[attribute]",
            "            except (TypeError, LookupError):",
            "                pass",
            "        else:",
            "            fmt = self.wrap_str_format(value)",
            "            if fmt is not None:",
            "                return fmt",
            "            if self.is_safe_attribute(obj, attribute, value):",
            "                return value",
            "            return self.unsafe_undefined(obj, attribute)",
            "        return self.undefined(obj=obj, name=attribute)",
            "",
            "    def unsafe_undefined(self, obj: t.Any, attribute: str) -> Undefined:",
            "        \"\"\"Return an undefined object for unsafe attributes.\"\"\"",
            "        return self.undefined(",
            "            f\"access to attribute {attribute!r} of\"",
            "            f\" {type(obj).__name__!r} object is unsafe.\",",
            "            name=attribute,",
            "            obj=obj,",
            "            exc=SecurityError,",
            "        )",
            "",
            "    def wrap_str_format(self, value: t.Any) -> t.Optional[t.Callable[..., str]]:",
            "        \"\"\"If the given value is a ``str.format`` or ``str.format_map`` method,",
            "        return a new function than handles sandboxing. This is done at access",
            "        rather than in :meth:`call`, so that calls made without ``call`` are",
            "        also sandboxed.",
            "        \"\"\"",
            "        if not isinstance(",
            "            value, (types.MethodType, types.BuiltinMethodType)",
            "        ) or value.__name__ not in (\"format\", \"format_map\"):",
            "            return None",
            "",
            "        f_self: t.Any = value.__self__",
            "",
            "        if not isinstance(f_self, str):",
            "            return None",
            "",
            "        str_type: t.Type[str] = type(f_self)",
            "        is_format_map = value.__name__ == \"format_map\"",
            "        formatter: SandboxedFormatter",
            "",
            "        if isinstance(f_self, Markup):",
            "            formatter = SandboxedEscapeFormatter(self, escape=f_self.escape)",
            "        else:",
            "            formatter = SandboxedFormatter(self)",
            "",
            "        vformat = formatter.vformat",
            "",
            "        def wrapper(*args: t.Any, **kwargs: t.Any) -> str:",
            "            if is_format_map:",
            "                if kwargs:",
            "                    raise TypeError(\"format_map() takes no keyword arguments\")",
            "",
            "                if len(args) != 1:",
            "                    raise TypeError(",
            "                        f\"format_map() takes exactly one argument ({len(args)} given)\"",
            "                    )",
            "",
            "                kwargs = args[0]",
            "                args = ()",
            "",
            "            return str_type(vformat(f_self, args, kwargs))",
            "",
            "        return update_wrapper(wrapper, value)",
            "",
            "    def call(",
            "        __self,  # noqa: B902",
            "        __context: Context,",
            "        __obj: t.Any,",
            "        *args: t.Any,",
            "        **kwargs: t.Any,",
            "    ) -> t.Any:",
            "        \"\"\"Call an object from sandboxed code.\"\"\"",
            "",
            "        # the double prefixes are to avoid double keyword argument",
            "        # errors when proxying the call.",
            "        if not __self.is_safe_callable(__obj):",
            "            raise SecurityError(f\"{__obj!r} is not safely callable\")",
            "        return __context.call(__obj, *args, **kwargs)",
            "",
            "",
            "class ImmutableSandboxedEnvironment(SandboxedEnvironment):",
            "    \"\"\"Works exactly like the regular `SandboxedEnvironment` but does not",
            "    permit modifications on the builtin mutable objects `list`, `set`, and",
            "    `dict` by using the :func:`modifies_known_mutable` function.",
            "    \"\"\"",
            "",
            "    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -> bool:",
            "        if not super().is_safe_attribute(obj, attr, value):",
            "            return False",
            "",
            "        return not modifies_known_mutable(obj, attr)",
            "",
            "",
            "class SandboxedFormatter(Formatter):",
            "    def __init__(self, env: Environment, **kwargs: t.Any) -> None:",
            "        self._env = env",
            "        super().__init__(**kwargs)",
            "",
            "    def get_field(",
            "        self, field_name: str, args: t.Sequence[t.Any], kwargs: t.Mapping[str, t.Any]",
            "    ) -> t.Tuple[t.Any, str]:",
            "        first, rest = formatter_field_name_split(field_name)",
            "        obj = self.get_value(first, args, kwargs)",
            "        for is_attr, i in rest:",
            "            if is_attr:",
            "                obj = self._env.getattr(obj, i)",
            "            else:",
            "                obj = self._env.getitem(obj, i)",
            "        return obj, first",
            "",
            "",
            "class SandboxedEscapeFormatter(SandboxedFormatter, EscapeFormatter):",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "86": [
                "inspect_format_method"
            ],
            "87": [
                "inspect_format_method"
            ],
            "88": [
                "inspect_format_method"
            ],
            "89": [
                "inspect_format_method"
            ],
            "90": [
                "inspect_format_method"
            ],
            "91": [
                "inspect_format_method"
            ],
            "92": [
                "inspect_format_method"
            ],
            "93": [
                "inspect_format_method"
            ],
            "94": [
                "inspect_format_method"
            ],
            "95": [
                "inspect_format_method"
            ],
            "96": [
                "inspect_format_method"
            ],
            "97": [
                "inspect_format_method"
            ],
            "98": [],
            "99": [],
            "351": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "352": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "353": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "354": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "355": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "356": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "357": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "358": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "359": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "362": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "363": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "367": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "368": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "369": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "370": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "371": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "372": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "374": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "375": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "377": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "378": [
                "SandboxedEnvironment",
                "format_string"
            ],
            "388": [
                "SandboxedEnvironment",
                "call"
            ],
            "389": [
                "SandboxedEnvironment",
                "call"
            ],
            "390": [
                "SandboxedEnvironment",
                "call"
            ]
        },
        "addLocation": []
    }
}