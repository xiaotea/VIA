{
    "src/fava/application.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from flask.wrappers import Response"
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " from flask_babel import Babel  # type: ignore"
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " from flask_babel import get_translations"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+from markupsafe import Markup"
            },
            "4": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " from werkzeug.utils import secure_filename"
            },
            "5": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " from fava import __version__ as fava_version"
            },
            "7": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "         \"_layout.html\","
            },
            "8": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "         active_page=\"help\","
            },
            "9": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "         page_slug=page_slug,"
            },
            "10": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_html=render_template_string("
            },
            "11": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            html,"
            },
            "12": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            beancount_version=beancount_version,"
            },
            "13": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            fava_version=fava_version,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+        help_html=Markup("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+            render_template_string("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+                html,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+                beancount_version=beancount_version,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+                fava_version=fava_version,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+            )"
            },
            "20": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "         ),"
            },
            "21": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "         HELP_PAGES=HELP_PAGES,"
            },
            "22": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "     )"
            }
        },
        "frontPatchFile": [
            "\"\"\"Fava's main WSGI application.",
            "",
            "when using Fava's WSGI app, make sure to set ``app.config['BEANCOUNT_FILES']``.",
            "To start a simple server::",
            "",
            "    from fava.application import app",
            "    app.config['BEANCOUNT_FILES'] = ['/path/to/file.beancount']",
            "    app.run('localhost', 5000)",
            "",
            "Attributes:",
            "    app: An instance of :class:`flask.Flask`, this is Fava's WSGI application.",
            "",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import datetime",
            "import functools",
            "import threading",
            "from io import BytesIO",
            "from typing import Any",
            "",
            "import flask",
            "import markdown2  # type: ignore",
            "import werkzeug.urls",
            "from beancount import __version__ as beancount_version",
            "from beancount.core.account import ACCOUNT_RE",
            "from beancount.utils.text_utils import replace_numbers",
            "from flask import abort",
            "from flask import Flask",
            "from flask import redirect",
            "from flask import render_template",
            "from flask import render_template_string",
            "from flask import request",
            "from flask import send_file",
            "from flask.wrappers import Response",
            "from flask_babel import Babel  # type: ignore",
            "from flask_babel import get_translations",
            "from werkzeug.utils import secure_filename",
            "",
            "from fava import __version__ as fava_version",
            "from fava import LANGUAGES",
            "from fava import template_filters",
            "from fava.context import g",
            "from fava.core import FavaLedger",
            "from fava.core.charts import FavaJSONEncoder",
            "from fava.core.documents import is_document_or_import_file",
            "from fava.help import HELP_PAGES",
            "from fava.helpers import FavaAPIException",
            "from fava.json_api import json_api",
            "from fava.serialisation import serialise",
            "from fava.util import next_key",
            "from fava.util import resource_path",
            "from fava.util import send_file_inline",
            "from fava.util import setup_logging",
            "from fava.util import slugify",
            "from fava.util.date import Interval",
            "from fava.util.excel import HAVE_EXCEL",
            "",
            "",
            "STATIC_FOLDER = resource_path(\"static\")",
            "setup_logging()",
            "app = Flask(  # pylint: disable=invalid-name",
            "    __name__,",
            "    template_folder=str(resource_path(\"templates\")),",
            "    static_folder=str(STATIC_FOLDER),",
            ")",
            "app.register_blueprint(json_api, url_prefix=\"/<bfile>/api\")",
            "",
            "app.json_encoder = FavaJSONEncoder  # type: ignore",
            "jinja_extensions = app.jinja_options.setdefault(\"extensions\", [])",
            "jinja_extensions.append(\"jinja2.ext.do\")",
            "jinja_extensions.append(\"jinja2.ext.loopcontrols\")",
            "app.jinja_env.trim_blocks = True",
            "app.jinja_env.lstrip_blocks = True",
            "",
            "app.config[\"HAVE_EXCEL\"] = HAVE_EXCEL",
            "app.config[\"ACCOUNT_RE\"] = ACCOUNT_RE",
            "",
            "REPORTS = [",
            "    \"balance_sheet\",",
            "    \"commodities\",",
            "    \"documents\",",
            "    \"events\",",
            "    \"editor\",",
            "    \"errors\",",
            "    \"holdings\",",
            "    \"import\",",
            "    \"income_statement\",",
            "    \"journal\",",
            "    \"options\",",
            "    \"query\",",
            "    \"statistics\",",
            "    \"trial_balance\",",
            "]",
            "",
            "",
            "LOAD_FILE_LOCK = threading.Lock()",
            "",
            "",
            "def ledger_slug(ledger: FavaLedger) -> str:",
            "    \"\"\"Generate URL slug for a ledger.\"\"\"",
            "    title_slug = slugify(ledger.options[\"title\"])",
            "    return title_slug or slugify(ledger.beancount_file_path)",
            "",
            "",
            "def update_ledger_slugs(ledgers: list[FavaLedger]) -> None:",
            "    \"\"\"Update the dictionary mapping URL slugs to ledgers.\"\"\"",
            "    ledgers_by_slug: dict[str, FavaLedger] = {}",
            "    for ledger in ledgers:",
            "        slug = ledger_slug(ledger)",
            "        unique_key = next_key(slug, ledgers_by_slug)",
            "        ledgers_by_slug[unique_key] = ledger",
            "    app.config[\"LEDGERS\"] = ledgers_by_slug",
            "",
            "",
            "def _load_file() -> None:",
            "    \"\"\"Load Beancount files.",
            "",
            "    This is run automatically on the first request.",
            "    \"\"\"",
            "    ledgers = [",
            "        FavaLedger(filepath) for filepath in app.config[\"BEANCOUNT_FILES\"]",
            "    ]",
            "    update_ledger_slugs(ledgers)",
            "",
            "",
            "def get_locale() -> str | None:",
            "    \"\"\"Get locale.",
            "",
            "    Returns:",
            "        The locale that should be used for Babel. If not given as an option to",
            "        Fava, guess from browser.",
            "    \"\"\"",
            "    lang = g.ledger.fava_options.language",
            "    if lang is not None:",
            "        return lang",
            "    return request.accept_languages.best_match([\"en\"] + LANGUAGES)",
            "",
            "",
            "BABEL = Babel(app)",
            "BABEL.localeselector(get_locale)",
            "",
            "",
            "for function in template_filters.FILTERS:",
            "    app.add_template_filter(function)  # type: ignore",
            "app.add_template_filter(serialise)",
            "",
            "",
            "@app.url_defaults",
            "def _inject_filters(endpoint: str, values: dict[str, str | None]) -> None:",
            "    if \"bfile\" not in values and app.url_map.is_endpoint_expecting(",
            "        endpoint, \"bfile\"",
            "    ):",
            "        values[\"bfile\"] = g.beancount_file_slug",
            "    if endpoint in [\"static\", \"index\"]:",
            "        return",
            "    for name in [\"conversion\", \"interval\", \"account\", \"filter\", \"time\"]:",
            "        if name not in values:",
            "            values[name] = request.args.get(name)",
            "",
            "",
            "def static_url(filename: str) -> str:",
            "    \"\"\"Return a static url with an mtime query string for cache busting.\"\"\"",
            "    file_path = STATIC_FOLDER / filename",
            "    try:",
            "        mtime = int(file_path.stat().st_mtime)",
            "    except FileNotFoundError:",
            "        mtime = 0",
            "    return url_for(\"static\", filename=filename, mtime=mtime)",
            "",
            "",
            "CACHED_URL_FOR = functools.lru_cache(2048)(flask.url_for)",
            "",
            "",
            "def url_for(endpoint: str, **values: str | int) -> str:",
            "    \"\"\"A wrapper around flask.url_for that uses a cache.\"\"\"",
            "    _inject_filters(endpoint, values)",
            "    return CACHED_URL_FOR(endpoint, **values)",
            "",
            "",
            "def url_for_source(**kwargs: str) -> str:",
            "    \"\"\"URL to source file (possibly link to external editor).\"\"\"",
            "    if g.ledger.fava_options.use_external_editor:",
            "        return (",
            "            f\"beancount://{kwargs.get('file_path')}\"",
            "            + f\"?lineno={kwargs.get('line', 1)}\"",
            "        )",
            "    return url_for(\"report\", report_name=\"editor\", **kwargs)",
            "",
            "",
            "def translations() -> Any:",
            "    \"\"\"Get translations catalog.\"\"\"",
            "    # pylint: disable=protected-access",
            "    return get_translations()._catalog",
            "",
            "",
            "app.add_template_global(static_url, \"static_url\")",
            "app.add_template_global(datetime.date.today, \"today\")",
            "app.add_template_global(url_for, \"url_for\")",
            "app.add_template_global(url_for_source, \"url_for_source\")",
            "app.add_template_global(translations, \"translations\")",
            "",
            "",
            "@app.context_processor",
            "def template_context() -> dict[str, FavaLedger]:",
            "    \"\"\"Inject variables into the template context.\"\"\"",
            "    return dict(ledger=g.ledger)",
            "",
            "",
            "@app.before_request",
            "def _perform_global_filters() -> None:",
            "    if request.endpoint in (\"json_api.get_changed\", \"json_api.get_errors\"):",
            "        return",
            "    ledger = getattr(g, \"ledger\", None)",
            "    if ledger:",
            "        # check (and possibly reload) source file",
            "        if request.blueprint != \"json_api\":",
            "            ledger.changed()",
            "",
            "        g.filtered = ledger.get_filtered(",
            "            account=request.args.get(\"account\"),",
            "            filter=request.args.get(\"filter\"),",
            "            time=request.args.get(\"time\"),",
            "        )",
            "",
            "",
            "@app.after_request",
            "def _incognito(",
            "    response: werkzeug.wrappers.Response,",
            ") -> werkzeug.wrappers.Response:",
            "    \"\"\"Replace all numbers with 'X'.\"\"\"",
            "    if app.config.get(\"INCOGNITO\") and response.content_type.startswith(",
            "        \"text/html\"",
            "    ):",
            "        is_editor = (",
            "            request.endpoint == \"report\"",
            "            and request.view_args is not None",
            "            and request.view_args[\"report_name\"] == \"editor\"",
            "        )",
            "        if not is_editor:",
            "            original_text = response.get_data(as_text=True)",
            "            response.set_data(replace_numbers(original_text))",
            "    return response",
            "",
            "",
            "@app.url_value_preprocessor",
            "def _pull_beancount_file(_: str | None, values: dict[str, str] | None) -> None:",
            "    g.beancount_file_slug = values.pop(\"bfile\", None) if values else None",
            "    with LOAD_FILE_LOCK:",
            "        if not app.config.get(\"LEDGERS\"):",
            "            _load_file()",
            "    if g.beancount_file_slug:",
            "        if g.beancount_file_slug not in app.config[\"LEDGERS\"]:",
            "            if not any(",
            "                g.beancount_file_slug == ledger_slug(ledger)",
            "                for ledger in app.config[\"LEDGERS\"].values()",
            "            ):",
            "                abort(404)",
            "            # one of the file slugs changed, update the mapping",
            "            update_ledger_slugs(app.config[\"LEDGERS\"].values())",
            "        g.ledger = app.config[\"LEDGERS\"][g.beancount_file_slug]",
            "        g.conversion = request.args.get(\"conversion\", \"at_cost\")",
            "        g.interval = Interval.get(request.args.get(\"interval\", \"month\"))",
            "",
            "",
            "@app.errorhandler(FavaAPIException)",
            "def fava_api_exception(error: FavaAPIException) -> str:",
            "    \"\"\"Handle API errors.\"\"\"",
            "    return render_template(",
            "        \"_layout.html\", page_title=\"Error\", content=error.message",
            "    )",
            "",
            "",
            "@app.route(\"/\")",
            "@app.route(\"/<bfile>/\")",
            "def index() -> werkzeug.wrappers.Response:",
            "    \"\"\"Redirect to the Income Statement (of the given or first file).\"\"\"",
            "    if not g.beancount_file_slug:",
            "        g.beancount_file_slug = next(iter(app.config[\"LEDGERS\"]))",
            "    index_url = url_for(\"index\")",
            "    default_path = app.config[\"LEDGERS\"][",
            "        g.beancount_file_slug",
            "    ].fava_options.default_page",
            "    return redirect(f\"{index_url}{default_path}\")",
            "",
            "",
            "@app.route(\"/<bfile>/account/<name>/\")",
            "@app.route(\"/<bfile>/account/<name>/<subreport>/\")",
            "def account(name: str, subreport: str = \"journal\") -> str:",
            "    \"\"\"The account report.\"\"\"",
            "    if subreport in [\"journal\", \"balances\", \"changes\"]:",
            "        return render_template(",
            "            \"account.html\", account_name=name, subreport=subreport",
            "        )",
            "    return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/document/\", methods=[\"GET\"])",
            "def document() -> Response:",
            "    \"\"\"Download a document.\"\"\"",
            "    filename = request.args.get(\"filename\")",
            "    if filename is None:",
            "        return abort(404)",
            "    if is_document_or_import_file(filename, g.ledger):",
            "        return send_file_inline(filename)",
            "    return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/statement/\", methods=[\"GET\"])",
            "def statement() -> Response:",
            "    \"\"\"Download a statement file.\"\"\"",
            "    entry_hash = request.args.get(\"entry_hash\", \"\")",
            "    key = request.args.get(\"key\", \"\")",
            "    document_path = g.ledger.statement_path(entry_hash, key)",
            "    return send_file_inline(document_path)",
            "",
            "",
            "@app.route(\"/<bfile>/holdings/by_<aggregation_key>/\")",
            "def holdings_by(aggregation_key: str) -> str:",
            "    \"\"\"The holdings report.\"\"\"",
            "    if aggregation_key in [\"account\", \"currency\", \"cost_currency\"]:",
            "        return render_template(",
            "            \"_layout.html\",",
            "            active_page=\"holdings\",",
            "            aggregation_key=aggregation_key,",
            "        )",
            "    return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/<report_name>/\")",
            "def report(report_name: str) -> str:",
            "    \"\"\"Endpoint for most reports.\"\"\"",
            "    if report_name in REPORTS:",
            "        return render_template(\"_layout.html\", active_page=report_name)",
            "    return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/extension/<report_name>/\")",
            "def extension_report(report_name: str) -> str:",
            "    \"\"\"Endpoint for extension reports.\"\"\"",
            "    try:",
            "        template, extension = g.ledger.extensions.template_and_extension(",
            "            report_name",
            "        )",
            "        content = render_template_string(template, extension=extension)",
            "        return render_template(",
            "            \"_layout.html\", content=content, page_title=extension.report_title",
            "        )",
            "    except LookupError:",
            "        return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/download-query/query_result.<result_format>\")",
            "def download_query(result_format: str) -> Any:",
            "    \"\"\"Download a query result.\"\"\"",
            "    name, data = g.ledger.query_shell.query_to_file(",
            "        g.filtered.entries, request.args.get(\"query_string\", \"\"), result_format",
            "    )",
            "",
            "    filename = f\"{secure_filename(name.strip())}.{result_format}\"",
            "    return send_file(data, as_attachment=True, download_name=filename)",
            "",
            "",
            "@app.route(\"/<bfile>/download-journal/\")",
            "def download_journal() -> Any:",
            "    \"\"\"Download a Journal file.\"\"\"",
            "    now = datetime.datetime.now().replace(microsecond=0)",
            "    filename = f\"journal_{now.isoformat()}.beancount\"",
            "    data = BytesIO(bytes(render_template(\"beancount_file\"), \"utf8\"))",
            "    return send_file(data, as_attachment=True, download_name=filename)",
            "",
            "",
            "@app.route(\"/<bfile>/help/\", defaults={\"page_slug\": \"_index\"})",
            "@app.route(\"/<bfile>/help/<string:page_slug>\")",
            "def help_page(page_slug: str) -> str:",
            "    \"\"\"Fava's included documentation.\"\"\"",
            "    if page_slug not in HELP_PAGES:",
            "        abort(404)",
            "    html = markdown2.markdown_path(",
            "        (resource_path(\"help\") / (page_slug + \".md\")),",
            "        extras=[\"fenced-code-blocks\", \"tables\", \"header-ids\"],",
            "    )",
            "    return render_template(",
            "        \"_layout.html\",",
            "        active_page=\"help\",",
            "        page_slug=page_slug,",
            "        help_html=render_template_string(",
            "            html,",
            "            beancount_version=beancount_version,",
            "            fava_version=fava_version,",
            "        ),",
            "        HELP_PAGES=HELP_PAGES,",
            "    )",
            "",
            "",
            "@app.route(\"/jump\")",
            "def jump() -> werkzeug.wrappers.Response:",
            "    \"\"\"Redirect back to the referer, replacing some parameters.",
            "",
            "    This is useful for sidebar links, e.g. a link ``/jump?time=year``",
            "    would set the time filter to `year` on the current page.",
            "",
            "    When accessing ``/jump?param1=abc`` from",
            "    ``/example/page?param1=123&param2=456``, this view should redirect to",
            "    ``/example/page?param1=abc&param2=456``.",
            "",
            "    \"\"\"",
            "    url = werkzeug.urls.url_parse(request.referrer)",
            "    qs_dict = url.decode_query()",
            "    for key, values in request.args.lists():",
            "        if values == [\"\"]:",
            "            try:",
            "                del qs_dict[key]",
            "            except KeyError:",
            "                pass",
            "        else:",
            "            qs_dict.setlist(key, values)",
            "",
            "    redirect_url = url.replace(",
            "        query=werkzeug.urls.url_encode(qs_dict, sort=True)",
            "    )",
            "    return redirect(werkzeug.urls.url_unparse(redirect_url))"
        ],
        "afterPatchFile": [
            "\"\"\"Fava's main WSGI application.",
            "",
            "when using Fava's WSGI app, make sure to set ``app.config['BEANCOUNT_FILES']``.",
            "To start a simple server::",
            "",
            "    from fava.application import app",
            "    app.config['BEANCOUNT_FILES'] = ['/path/to/file.beancount']",
            "    app.run('localhost', 5000)",
            "",
            "Attributes:",
            "    app: An instance of :class:`flask.Flask`, this is Fava's WSGI application.",
            "",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import datetime",
            "import functools",
            "import threading",
            "from io import BytesIO",
            "from typing import Any",
            "",
            "import flask",
            "import markdown2  # type: ignore",
            "import werkzeug.urls",
            "from beancount import __version__ as beancount_version",
            "from beancount.core.account import ACCOUNT_RE",
            "from beancount.utils.text_utils import replace_numbers",
            "from flask import abort",
            "from flask import Flask",
            "from flask import redirect",
            "from flask import render_template",
            "from flask import render_template_string",
            "from flask import request",
            "from flask import send_file",
            "from flask.wrappers import Response",
            "from flask_babel import Babel  # type: ignore",
            "from flask_babel import get_translations",
            "from markupsafe import Markup",
            "from werkzeug.utils import secure_filename",
            "",
            "from fava import __version__ as fava_version",
            "from fava import LANGUAGES",
            "from fava import template_filters",
            "from fava.context import g",
            "from fava.core import FavaLedger",
            "from fava.core.charts import FavaJSONEncoder",
            "from fava.core.documents import is_document_or_import_file",
            "from fava.help import HELP_PAGES",
            "from fava.helpers import FavaAPIException",
            "from fava.json_api import json_api",
            "from fava.serialisation import serialise",
            "from fava.util import next_key",
            "from fava.util import resource_path",
            "from fava.util import send_file_inline",
            "from fava.util import setup_logging",
            "from fava.util import slugify",
            "from fava.util.date import Interval",
            "from fava.util.excel import HAVE_EXCEL",
            "",
            "",
            "STATIC_FOLDER = resource_path(\"static\")",
            "setup_logging()",
            "app = Flask(  # pylint: disable=invalid-name",
            "    __name__,",
            "    template_folder=str(resource_path(\"templates\")),",
            "    static_folder=str(STATIC_FOLDER),",
            ")",
            "app.register_blueprint(json_api, url_prefix=\"/<bfile>/api\")",
            "",
            "app.json_encoder = FavaJSONEncoder  # type: ignore",
            "jinja_extensions = app.jinja_options.setdefault(\"extensions\", [])",
            "jinja_extensions.append(\"jinja2.ext.do\")",
            "jinja_extensions.append(\"jinja2.ext.loopcontrols\")",
            "app.jinja_env.trim_blocks = True",
            "app.jinja_env.lstrip_blocks = True",
            "",
            "app.config[\"HAVE_EXCEL\"] = HAVE_EXCEL",
            "app.config[\"ACCOUNT_RE\"] = ACCOUNT_RE",
            "",
            "REPORTS = [",
            "    \"balance_sheet\",",
            "    \"commodities\",",
            "    \"documents\",",
            "    \"events\",",
            "    \"editor\",",
            "    \"errors\",",
            "    \"holdings\",",
            "    \"import\",",
            "    \"income_statement\",",
            "    \"journal\",",
            "    \"options\",",
            "    \"query\",",
            "    \"statistics\",",
            "    \"trial_balance\",",
            "]",
            "",
            "",
            "LOAD_FILE_LOCK = threading.Lock()",
            "",
            "",
            "def ledger_slug(ledger: FavaLedger) -> str:",
            "    \"\"\"Generate URL slug for a ledger.\"\"\"",
            "    title_slug = slugify(ledger.options[\"title\"])",
            "    return title_slug or slugify(ledger.beancount_file_path)",
            "",
            "",
            "def update_ledger_slugs(ledgers: list[FavaLedger]) -> None:",
            "    \"\"\"Update the dictionary mapping URL slugs to ledgers.\"\"\"",
            "    ledgers_by_slug: dict[str, FavaLedger] = {}",
            "    for ledger in ledgers:",
            "        slug = ledger_slug(ledger)",
            "        unique_key = next_key(slug, ledgers_by_slug)",
            "        ledgers_by_slug[unique_key] = ledger",
            "    app.config[\"LEDGERS\"] = ledgers_by_slug",
            "",
            "",
            "def _load_file() -> None:",
            "    \"\"\"Load Beancount files.",
            "",
            "    This is run automatically on the first request.",
            "    \"\"\"",
            "    ledgers = [",
            "        FavaLedger(filepath) for filepath in app.config[\"BEANCOUNT_FILES\"]",
            "    ]",
            "    update_ledger_slugs(ledgers)",
            "",
            "",
            "def get_locale() -> str | None:",
            "    \"\"\"Get locale.",
            "",
            "    Returns:",
            "        The locale that should be used for Babel. If not given as an option to",
            "        Fava, guess from browser.",
            "    \"\"\"",
            "    lang = g.ledger.fava_options.language",
            "    if lang is not None:",
            "        return lang",
            "    return request.accept_languages.best_match([\"en\"] + LANGUAGES)",
            "",
            "",
            "BABEL = Babel(app)",
            "BABEL.localeselector(get_locale)",
            "",
            "",
            "for function in template_filters.FILTERS:",
            "    app.add_template_filter(function)  # type: ignore",
            "app.add_template_filter(serialise)",
            "",
            "",
            "@app.url_defaults",
            "def _inject_filters(endpoint: str, values: dict[str, str | None]) -> None:",
            "    if \"bfile\" not in values and app.url_map.is_endpoint_expecting(",
            "        endpoint, \"bfile\"",
            "    ):",
            "        values[\"bfile\"] = g.beancount_file_slug",
            "    if endpoint in [\"static\", \"index\"]:",
            "        return",
            "    for name in [\"conversion\", \"interval\", \"account\", \"filter\", \"time\"]:",
            "        if name not in values:",
            "            values[name] = request.args.get(name)",
            "",
            "",
            "def static_url(filename: str) -> str:",
            "    \"\"\"Return a static url with an mtime query string for cache busting.\"\"\"",
            "    file_path = STATIC_FOLDER / filename",
            "    try:",
            "        mtime = int(file_path.stat().st_mtime)",
            "    except FileNotFoundError:",
            "        mtime = 0",
            "    return url_for(\"static\", filename=filename, mtime=mtime)",
            "",
            "",
            "CACHED_URL_FOR = functools.lru_cache(2048)(flask.url_for)",
            "",
            "",
            "def url_for(endpoint: str, **values: str | int) -> str:",
            "    \"\"\"A wrapper around flask.url_for that uses a cache.\"\"\"",
            "    _inject_filters(endpoint, values)",
            "    return CACHED_URL_FOR(endpoint, **values)",
            "",
            "",
            "def url_for_source(**kwargs: str) -> str:",
            "    \"\"\"URL to source file (possibly link to external editor).\"\"\"",
            "    if g.ledger.fava_options.use_external_editor:",
            "        return (",
            "            f\"beancount://{kwargs.get('file_path')}\"",
            "            + f\"?lineno={kwargs.get('line', 1)}\"",
            "        )",
            "    return url_for(\"report\", report_name=\"editor\", **kwargs)",
            "",
            "",
            "def translations() -> Any:",
            "    \"\"\"Get translations catalog.\"\"\"",
            "    # pylint: disable=protected-access",
            "    return get_translations()._catalog",
            "",
            "",
            "app.add_template_global(static_url, \"static_url\")",
            "app.add_template_global(datetime.date.today, \"today\")",
            "app.add_template_global(url_for, \"url_for\")",
            "app.add_template_global(url_for_source, \"url_for_source\")",
            "app.add_template_global(translations, \"translations\")",
            "",
            "",
            "@app.context_processor",
            "def template_context() -> dict[str, FavaLedger]:",
            "    \"\"\"Inject variables into the template context.\"\"\"",
            "    return dict(ledger=g.ledger)",
            "",
            "",
            "@app.before_request",
            "def _perform_global_filters() -> None:",
            "    if request.endpoint in (\"json_api.get_changed\", \"json_api.get_errors\"):",
            "        return",
            "    ledger = getattr(g, \"ledger\", None)",
            "    if ledger:",
            "        # check (and possibly reload) source file",
            "        if request.blueprint != \"json_api\":",
            "            ledger.changed()",
            "",
            "        g.filtered = ledger.get_filtered(",
            "            account=request.args.get(\"account\"),",
            "            filter=request.args.get(\"filter\"),",
            "            time=request.args.get(\"time\"),",
            "        )",
            "",
            "",
            "@app.after_request",
            "def _incognito(",
            "    response: werkzeug.wrappers.Response,",
            ") -> werkzeug.wrappers.Response:",
            "    \"\"\"Replace all numbers with 'X'.\"\"\"",
            "    if app.config.get(\"INCOGNITO\") and response.content_type.startswith(",
            "        \"text/html\"",
            "    ):",
            "        is_editor = (",
            "            request.endpoint == \"report\"",
            "            and request.view_args is not None",
            "            and request.view_args[\"report_name\"] == \"editor\"",
            "        )",
            "        if not is_editor:",
            "            original_text = response.get_data(as_text=True)",
            "            response.set_data(replace_numbers(original_text))",
            "    return response",
            "",
            "",
            "@app.url_value_preprocessor",
            "def _pull_beancount_file(_: str | None, values: dict[str, str] | None) -> None:",
            "    g.beancount_file_slug = values.pop(\"bfile\", None) if values else None",
            "    with LOAD_FILE_LOCK:",
            "        if not app.config.get(\"LEDGERS\"):",
            "            _load_file()",
            "    if g.beancount_file_slug:",
            "        if g.beancount_file_slug not in app.config[\"LEDGERS\"]:",
            "            if not any(",
            "                g.beancount_file_slug == ledger_slug(ledger)",
            "                for ledger in app.config[\"LEDGERS\"].values()",
            "            ):",
            "                abort(404)",
            "            # one of the file slugs changed, update the mapping",
            "            update_ledger_slugs(app.config[\"LEDGERS\"].values())",
            "        g.ledger = app.config[\"LEDGERS\"][g.beancount_file_slug]",
            "        g.conversion = request.args.get(\"conversion\", \"at_cost\")",
            "        g.interval = Interval.get(request.args.get(\"interval\", \"month\"))",
            "",
            "",
            "@app.errorhandler(FavaAPIException)",
            "def fava_api_exception(error: FavaAPIException) -> str:",
            "    \"\"\"Handle API errors.\"\"\"",
            "    return render_template(",
            "        \"_layout.html\", page_title=\"Error\", content=error.message",
            "    )",
            "",
            "",
            "@app.route(\"/\")",
            "@app.route(\"/<bfile>/\")",
            "def index() -> werkzeug.wrappers.Response:",
            "    \"\"\"Redirect to the Income Statement (of the given or first file).\"\"\"",
            "    if not g.beancount_file_slug:",
            "        g.beancount_file_slug = next(iter(app.config[\"LEDGERS\"]))",
            "    index_url = url_for(\"index\")",
            "    default_path = app.config[\"LEDGERS\"][",
            "        g.beancount_file_slug",
            "    ].fava_options.default_page",
            "    return redirect(f\"{index_url}{default_path}\")",
            "",
            "",
            "@app.route(\"/<bfile>/account/<name>/\")",
            "@app.route(\"/<bfile>/account/<name>/<subreport>/\")",
            "def account(name: str, subreport: str = \"journal\") -> str:",
            "    \"\"\"The account report.\"\"\"",
            "    if subreport in [\"journal\", \"balances\", \"changes\"]:",
            "        return render_template(",
            "            \"account.html\", account_name=name, subreport=subreport",
            "        )",
            "    return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/document/\", methods=[\"GET\"])",
            "def document() -> Response:",
            "    \"\"\"Download a document.\"\"\"",
            "    filename = request.args.get(\"filename\")",
            "    if filename is None:",
            "        return abort(404)",
            "    if is_document_or_import_file(filename, g.ledger):",
            "        return send_file_inline(filename)",
            "    return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/statement/\", methods=[\"GET\"])",
            "def statement() -> Response:",
            "    \"\"\"Download a statement file.\"\"\"",
            "    entry_hash = request.args.get(\"entry_hash\", \"\")",
            "    key = request.args.get(\"key\", \"\")",
            "    document_path = g.ledger.statement_path(entry_hash, key)",
            "    return send_file_inline(document_path)",
            "",
            "",
            "@app.route(\"/<bfile>/holdings/by_<aggregation_key>/\")",
            "def holdings_by(aggregation_key: str) -> str:",
            "    \"\"\"The holdings report.\"\"\"",
            "    if aggregation_key in [\"account\", \"currency\", \"cost_currency\"]:",
            "        return render_template(",
            "            \"_layout.html\",",
            "            active_page=\"holdings\",",
            "            aggregation_key=aggregation_key,",
            "        )",
            "    return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/<report_name>/\")",
            "def report(report_name: str) -> str:",
            "    \"\"\"Endpoint for most reports.\"\"\"",
            "    if report_name in REPORTS:",
            "        return render_template(\"_layout.html\", active_page=report_name)",
            "    return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/extension/<report_name>/\")",
            "def extension_report(report_name: str) -> str:",
            "    \"\"\"Endpoint for extension reports.\"\"\"",
            "    try:",
            "        template, extension = g.ledger.extensions.template_and_extension(",
            "            report_name",
            "        )",
            "        content = render_template_string(template, extension=extension)",
            "        return render_template(",
            "            \"_layout.html\", content=content, page_title=extension.report_title",
            "        )",
            "    except LookupError:",
            "        return abort(404)",
            "",
            "",
            "@app.route(\"/<bfile>/download-query/query_result.<result_format>\")",
            "def download_query(result_format: str) -> Any:",
            "    \"\"\"Download a query result.\"\"\"",
            "    name, data = g.ledger.query_shell.query_to_file(",
            "        g.filtered.entries, request.args.get(\"query_string\", \"\"), result_format",
            "    )",
            "",
            "    filename = f\"{secure_filename(name.strip())}.{result_format}\"",
            "    return send_file(data, as_attachment=True, download_name=filename)",
            "",
            "",
            "@app.route(\"/<bfile>/download-journal/\")",
            "def download_journal() -> Any:",
            "    \"\"\"Download a Journal file.\"\"\"",
            "    now = datetime.datetime.now().replace(microsecond=0)",
            "    filename = f\"journal_{now.isoformat()}.beancount\"",
            "    data = BytesIO(bytes(render_template(\"beancount_file\"), \"utf8\"))",
            "    return send_file(data, as_attachment=True, download_name=filename)",
            "",
            "",
            "@app.route(\"/<bfile>/help/\", defaults={\"page_slug\": \"_index\"})",
            "@app.route(\"/<bfile>/help/<string:page_slug>\")",
            "def help_page(page_slug: str) -> str:",
            "    \"\"\"Fava's included documentation.\"\"\"",
            "    if page_slug not in HELP_PAGES:",
            "        abort(404)",
            "    html = markdown2.markdown_path(",
            "        (resource_path(\"help\") / (page_slug + \".md\")),",
            "        extras=[\"fenced-code-blocks\", \"tables\", \"header-ids\"],",
            "    )",
            "    return render_template(",
            "        \"_layout.html\",",
            "        active_page=\"help\",",
            "        page_slug=page_slug,",
            "        help_html=Markup(",
            "            render_template_string(",
            "                html,",
            "                beancount_version=beancount_version,",
            "                fava_version=fava_version,",
            "            )",
            "        ),",
            "        HELP_PAGES=HELP_PAGES,",
            "    )",
            "",
            "",
            "@app.route(\"/jump\")",
            "def jump() -> werkzeug.wrappers.Response:",
            "    \"\"\"Redirect back to the referer, replacing some parameters.",
            "",
            "    This is useful for sidebar links, e.g. a link ``/jump?time=year``",
            "    would set the time filter to `year` on the current page.",
            "",
            "    When accessing ``/jump?param1=abc`` from",
            "    ``/example/page?param1=123&param2=456``, this view should redirect to",
            "    ``/example/page?param1=abc&param2=456``.",
            "",
            "    \"\"\"",
            "    url = werkzeug.urls.url_parse(request.referrer)",
            "    qs_dict = url.decode_query()",
            "    for key, values in request.args.lists():",
            "        if values == [\"\"]:",
            "            try:",
            "                del qs_dict[key]",
            "            except KeyError:",
            "                pass",
            "        else:",
            "            qs_dict.setlist(key, values)",
            "",
            "    redirect_url = url.replace(",
            "        query=werkzeug.urls.url_encode(qs_dict, sort=True)",
            "    )",
            "    return redirect(werkzeug.urls.url_unparse(redirect_url))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "387": [
                "help_page"
            ],
            "388": [
                "help_page"
            ],
            "389": [
                "help_page"
            ],
            "390": [
                "help_page"
            ]
        },
        "addLocation": []
    },
    "src/fava/core/file.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from beancount.core.flags import FLAG_SUMMARIZE"
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from beancount.core.flags import FLAG_TRANSFER"
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from beancount.parser.printer import format_entry  # type: ignore"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+from markupsafe import Markup"
            },
            "4": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from fava.core._compat import FLAG_RETURNS"
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from fava.core._compat import FLAG_UNREALIZED"
            },
            "7": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "                 )"
            },
            "8": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "                 self.ledger.extensions.after_insert_entry(entry)"
            },
            "9": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def render_entries(self, entries: Entries) -> Generator[str, None, None]:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+    def render_entries("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        self, entries: Entries"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+    ) -> Generator[Markup, None, None]:"
            },
            "14": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         \"\"\"Return entries in Beancount format."
            },
            "15": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "         Only renders :class:`.Balance` and :class:`.Transaction`."
            },
            "17": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "                 if isinstance(entry, Transaction) and entry.flag in EXCL_FLAGS:"
            },
            "18": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "                     continue"
            },
            "19": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "                 try:"
            },
            "20": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    yield get_entry_slice(entry)[0] + \"\\n\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                    yield Markup(get_entry_slice(entry)[0] + \"\\n\")"
            },
            "22": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "                 except (KeyError, FileNotFoundError):"
            },
            "23": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    yield _format_entry("
            },
            "24": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        entry,"
            },
            "25": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        self.ledger.fava_options.currency_column,"
            },
            "26": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        indent,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+                    yield Markup("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+                        _format_entry("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+                            entry,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+                            self.ledger.fava_options.currency_column,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+                            indent,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+                        )"
            },
            "33": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "                     )"
            },
            "34": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 208,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 209,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"Reading/writing Beancount files.\"\"\"",
            "from __future__ import annotations",
            "",
            "import datetime",
            "import re",
            "import threading",
            "from codecs import decode",
            "from codecs import encode",
            "from hashlib import sha256",
            "from operator import attrgetter",
            "from typing import Generator",
            "from typing import TYPE_CHECKING",
            "",
            "from beancount.core.data import Balance",
            "from beancount.core.data import Directive",
            "from beancount.core.data import Entries",
            "from beancount.core.data import SORT_ORDER",
            "from beancount.core.data import Transaction",
            "from beancount.core.flags import FLAG_CONVERSIONS",
            "from beancount.core.flags import FLAG_MERGING",
            "from beancount.core.flags import FLAG_PADDING",
            "from beancount.core.flags import FLAG_SUMMARIZE",
            "from beancount.core.flags import FLAG_TRANSFER",
            "from beancount.parser.printer import format_entry  # type: ignore",
            "",
            "from fava.core._compat import FLAG_RETURNS",
            "from fava.core._compat import FLAG_UNREALIZED",
            "from fava.core.accounts import get_entry_accounts",
            "from fava.core.fava_options import InsertEntryOption",
            "from fava.core.misc import align",
            "from fava.core.module_base import FavaModule",
            "from fava.helpers import FavaAPIException",
            "from fava.util import next_key",
            "",
            "if TYPE_CHECKING:  # pragma: no cover",
            "    from fava.core import FavaLedger",
            "",
            "#: The flags to exclude when rendering entries.",
            "EXCL_FLAGS = {",
            "    FLAG_PADDING,  # P",
            "    FLAG_SUMMARIZE,  # S",
            "    FLAG_TRANSFER,  # T",
            "    FLAG_CONVERSIONS,  # C",
            "    FLAG_UNREALIZED,  # U",
            "    FLAG_RETURNS,  # R",
            "    FLAG_MERGING,  # M",
            "}",
            "",
            "",
            "def sha256_str(val: str) -> str:",
            "    \"\"\"Hash a string.\"\"\"",
            "    return sha256(encode(val, encoding=\"utf-8\")).hexdigest()",
            "",
            "",
            "class FileModule(FavaModule):",
            "    \"\"\"Functions related to reading/writing to Beancount files.\"\"\"",
            "",
            "    def __init__(self, ledger: FavaLedger) -> None:",
            "        super().__init__(ledger)",
            "        self.lock = threading.Lock()",
            "",
            "    def get_source(self, path: str) -> tuple[str, str]:",
            "        \"\"\"Get source files.",
            "",
            "        Args:",
            "            path: The path of the file.",
            "",
            "        Returns:",
            "            A string with the file contents and the `sha256sum` of the file.",
            "",
            "        Raises:",
            "            FavaAPIException: If the file at `path` is not one of the",
            "                source files.",
            "        \"\"\"",
            "        if path not in self.ledger.options[\"include\"]:",
            "            raise FavaAPIException(\"Trying to read a non-source file\")",
            "",
            "        with open(path, mode=\"rb\") as file:",
            "            contents = file.read()",
            "",
            "        sha256sum = sha256(contents).hexdigest()",
            "        source = decode(contents)",
            "",
            "        return source, sha256sum",
            "",
            "    def set_source(self, path: str, source: str, sha256sum: str) -> str:",
            "        \"\"\"Write to source file.",
            "",
            "        Args:",
            "            path: The path of the file.",
            "            source: A string with the file contents.",
            "            sha256sum: Hash of the file.",
            "",
            "        Returns:",
            "            The `sha256sum` of the updated file.",
            "",
            "        Raises:",
            "            FavaAPIException: If the file at `path` is not one of the",
            "                source files or if the file was changed externally.",
            "        \"\"\"",
            "        with self.lock:",
            "            _, original_sha256sum = self.get_source(path)",
            "            if original_sha256sum != sha256sum:",
            "                raise FavaAPIException(\"The file changed externally.\")",
            "",
            "            contents = encode(source, encoding=\"utf-8\")",
            "            with open(path, \"w+b\") as file:",
            "                file.write(contents)",
            "",
            "            self.ledger.extensions.after_write_source(path, source)",
            "            self.ledger.load_file()",
            "",
            "            return sha256(contents).hexdigest()",
            "",
            "    def insert_metadata(",
            "        self, entry_hash: str, basekey: str, value: str",
            "    ) -> None:",
            "        \"\"\"Insert metadata into a file at lineno.",
            "",
            "        Also, prevent duplicate keys.",
            "        \"\"\"",
            "        with self.lock:",
            "            self.ledger.changed()",
            "            entry: Directive = self.ledger.get_entry(entry_hash)",
            "            key = next_key(basekey, entry.meta)",
            "            indent = self.ledger.fava_options.indent",
            "            insert_metadata_in_file(",
            "                entry.meta[\"filename\"],",
            "                entry.meta[\"lineno\"],",
            "                indent,",
            "                key,",
            "                value,",
            "            )",
            "            self.ledger.extensions.after_insert_metadata(entry, key, value)",
            "",
            "    def save_entry_slice(",
            "        self, entry_hash: str, source_slice: str, sha256sum: str",
            "    ) -> str:",
            "        \"\"\"Save slice of the source file for an entry.",
            "",
            "        Args:",
            "            entry_hash: An entry.",
            "            source_slice: The lines that the entry should be replaced with.",
            "            sha256sum: The sha256sum of the current lines of the entry.",
            "",
            "        Returns:",
            "            The `sha256sum` of the new lines of the entry.",
            "        Raises:",
            "            FavaAPIException: If the entry is not found or the file changed.",
            "        \"\"\"",
            "        with self.lock:",
            "            entry = self.ledger.get_entry(entry_hash)",
            "            ret = save_entry_slice(entry, source_slice, sha256sum)",
            "            self.ledger.extensions.after_entry_modified(entry, source_slice)",
            "            return ret",
            "",
            "    def insert_entries(self, entries: Entries) -> None:",
            "        \"\"\"Insert entries.",
            "",
            "        Args:",
            "            entries: A list of entries.",
            "        \"\"\"",
            "        with self.lock:",
            "            self.ledger.changed()",
            "            fava_options = self.ledger.fava_options",
            "            for entry in sorted(entries, key=incomplete_sortkey):",
            "                insert_options = fava_options.insert_entry",
            "                currency_column = fava_options.currency_column",
            "                indent = fava_options.indent",
            "                fava_options.insert_entry = insert_entry(",
            "                    entry,",
            "                    self.ledger.beancount_file_path,",
            "                    insert_options,",
            "                    currency_column,",
            "                    indent,",
            "                )",
            "                self.ledger.extensions.after_insert_entry(entry)",
            "",
            "    def render_entries(self, entries: Entries) -> Generator[str, None, None]:",
            "        \"\"\"Return entries in Beancount format.",
            "",
            "        Only renders :class:`.Balance` and :class:`.Transaction`.",
            "",
            "        Args:",
            "            entries: A list of entries.",
            "",
            "        Yields:",
            "            The entries rendered in Beancount format.",
            "        \"\"\"",
            "        indent = self.ledger.fava_options.indent",
            "        for entry in entries:",
            "            if isinstance(entry, (Balance, Transaction)):",
            "                if isinstance(entry, Transaction) and entry.flag in EXCL_FLAGS:",
            "                    continue",
            "                try:",
            "                    yield get_entry_slice(entry)[0] + \"\\n\"",
            "                except (KeyError, FileNotFoundError):",
            "                    yield _format_entry(",
            "                        entry,",
            "                        self.ledger.fava_options.currency_column,",
            "                        indent,",
            "                    )",
            "",
            "",
            "def incomplete_sortkey(entry: Directive) -> tuple[datetime.date, int]:",
            "    \"\"\"Sortkey for entries that might have incomplete metadata.\"\"\"",
            "    return (entry.date, SORT_ORDER.get(type(entry), 0))",
            "",
            "",
            "def insert_metadata_in_file(",
            "    filename: str, lineno: int, indent: int, key: str, value: str",
            ") -> None:",
            "    \"\"\"Inserts the specified metadata in the file below lineno, taking into",
            "    account the whitespace in front of the line that lineno.\"\"\"",
            "    with open(filename, encoding=\"utf-8\") as file:",
            "        contents = file.readlines()",
            "",
            "    contents.insert(lineno, f'{\" \" * indent}{key}: \"{value}\"\\n')",
            "",
            "    with open(filename, \"w\", encoding=\"utf-8\") as file:",
            "        file.write(\"\".join(contents))",
            "",
            "",
            "def find_entry_lines(lines: list[str], lineno: int) -> list[str]:",
            "    \"\"\"Lines of entry starting at lineno.",
            "",
            "    Args:",
            "        lines: A list of lines.",
            "        lineno: The 0-based line-index to start at.",
            "    \"\"\"",
            "    entry_lines = [lines[lineno]]",
            "    while True:",
            "        lineno += 1",
            "        try:",
            "            line = lines[lineno]",
            "        except IndexError:",
            "            return entry_lines",
            "        if not line.strip() or re.match(r\"\\S\", line[0]):",
            "            return entry_lines",
            "        entry_lines.append(line)",
            "",
            "",
            "def get_entry_slice(entry: Directive) -> tuple[str, str]:",
            "    \"\"\"Get slice of the source file for an entry.",
            "",
            "    Args:",
            "        entry: An entry.",
            "",
            "    Returns:",
            "        A string containing the lines of the entry and the `sha256sum` of",
            "        these lines.",
            "    \"\"\"",
            "    with open(entry.meta[\"filename\"], encoding=\"utf-8\") as file:",
            "        lines = file.readlines()",
            "",
            "    entry_lines = find_entry_lines(lines, entry.meta[\"lineno\"] - 1)",
            "    entry_source = \"\".join(entry_lines).rstrip(\"\\n\")",
            "",
            "    return entry_source, sha256_str(entry_source)",
            "",
            "",
            "def save_entry_slice(",
            "    entry: Directive, source_slice: str, sha256sum: str",
            ") -> str:",
            "    \"\"\"Save slice of the source file for an entry.",
            "",
            "    Args:",
            "        entry: An entry.",
            "        source_slice: The lines that the entry should be replaced with.",
            "        sha256sum: The sha256sum of the current lines of the entry.",
            "",
            "    Returns:",
            "        The `sha256sum` of the new lines of the entry.",
            "",
            "    Raises:",
            "        FavaAPIException: If the file at `path` is not one of the",
            "            source files.",
            "    \"\"\"",
            "",
            "    with open(entry.meta[\"filename\"], encoding=\"utf-8\") as file:",
            "        lines = file.readlines()",
            "",
            "    first_entry_line = entry.meta[\"lineno\"] - 1",
            "    entry_lines = find_entry_lines(lines, first_entry_line)",
            "    entry_source = \"\".join(entry_lines).rstrip(\"\\n\")",
            "    if sha256_str(entry_source) != sha256sum:",
            "        raise FavaAPIException(\"The file changed externally.\")",
            "",
            "    lines = (",
            "        lines[:first_entry_line]",
            "        + [source_slice + \"\\n\"]",
            "        + lines[first_entry_line + len(entry_lines) :]",
            "    )",
            "    with open(entry.meta[\"filename\"], \"w\", encoding=\"utf-8\") as file:",
            "        file.writelines(lines)",
            "",
            "    return sha256_str(source_slice)",
            "",
            "",
            "def insert_entry(",
            "    entry: Directive,",
            "    default_filename: str,",
            "    insert_options: list[InsertEntryOption],",
            "    currency_column: int,",
            "    indent: int,",
            ") -> list[InsertEntryOption]:",
            "    \"\"\"Insert an entry.",
            "",
            "    Args:",
            "        entry: An entry.",
            "        default_filename: The default file to insert into if no option matches.",
            "        insert_options: Insert options.",
            "        currency_column: The column to align currencies at.",
            "        indent: Number of indent spaces.",
            "",
            "    Returns:",
            "        A list of updated insert options.",
            "    \"\"\"",
            "    filename, lineno = find_insert_position(",
            "        entry, insert_options, default_filename",
            "    )",
            "    content = _format_entry(entry, currency_column, indent)",
            "",
            "    with open(filename, encoding=\"utf-8\") as file:",
            "        contents = file.readlines()",
            "",
            "    if lineno is None:",
            "        # Appending",
            "        contents += \"\\n\" + content",
            "    else:",
            "        contents.insert(lineno, content + \"\\n\")",
            "",
            "    with open(filename, \"w\", encoding=\"utf-8\") as file:",
            "        file.writelines(contents)",
            "",
            "    if lineno is None:",
            "        return insert_options",
            "",
            "    added_lines = content.count(\"\\n\") + 1",
            "    return [",
            "        option._replace(lineno=option.lineno + added_lines)",
            "        if option.filename == filename and option.lineno > lineno",
            "        else option",
            "        for option in insert_options",
            "    ]",
            "",
            "",
            "def _format_entry(entry: Directive, currency_column: int, indent: int) -> str:",
            "    \"\"\"Wrapper that strips unnecessary whitespace from format_entry.\"\"\"",
            "    meta = {",
            "        key: entry.meta[key] for key in entry.meta if not key.startswith(\"_\")",
            "    }",
            "    entry = entry._replace(meta=meta)",
            "    string = align(format_entry(entry, prefix=\" \" * indent), currency_column)",
            "    string = string.replace(\"<class 'beancount.core.number.MISSING'>\", \"\")",
            "    return \"\\n\".join(line.rstrip() for line in string.split(\"\\n\"))",
            "",
            "",
            "def find_insert_position(",
            "    entry: Directive,",
            "    insert_options: list[InsertEntryOption],",
            "    default_filename: str,",
            ") -> tuple[str, int | None]:",
            "    \"\"\"Find insert position for an entry.",
            "",
            "    Args:",
            "        entry: An entry.",
            "        insert_options: A list of InsertOption.",
            "        default_filename: The default file to insert into if no option matches.",
            "",
            "    Returns:",
            "        A tuple of the filename and the line number.",
            "    \"\"\"",
            "",
            "    # Get the list of accounts that should be considered for the entry.",
            "    # For transactions, we want the reversed list of posting accounts.",
            "    accounts = get_entry_accounts(entry)",
            "",
            "    # Make no assumptions about the order of insert_options entries and instead",
            "    # sort them ourselves (by descending dates)",
            "    insert_options = sorted(",
            "        insert_options, key=attrgetter(\"date\"), reverse=True",
            "    )",
            "",
            "    for account in accounts:",
            "        for insert_option in insert_options:",
            "            # Only consider InsertOptions before the entry date.",
            "            if insert_option.date >= entry.date:",
            "                continue",
            "            if insert_option.re.match(account):",
            "                return (insert_option.filename, insert_option.lineno - 1)",
            "",
            "    return (default_filename, None)"
        ],
        "afterPatchFile": [
            "\"\"\"Reading/writing Beancount files.\"\"\"",
            "from __future__ import annotations",
            "",
            "import datetime",
            "import re",
            "import threading",
            "from codecs import decode",
            "from codecs import encode",
            "from hashlib import sha256",
            "from operator import attrgetter",
            "from typing import Generator",
            "from typing import TYPE_CHECKING",
            "",
            "from beancount.core.data import Balance",
            "from beancount.core.data import Directive",
            "from beancount.core.data import Entries",
            "from beancount.core.data import SORT_ORDER",
            "from beancount.core.data import Transaction",
            "from beancount.core.flags import FLAG_CONVERSIONS",
            "from beancount.core.flags import FLAG_MERGING",
            "from beancount.core.flags import FLAG_PADDING",
            "from beancount.core.flags import FLAG_SUMMARIZE",
            "from beancount.core.flags import FLAG_TRANSFER",
            "from beancount.parser.printer import format_entry  # type: ignore",
            "from markupsafe import Markup",
            "",
            "from fava.core._compat import FLAG_RETURNS",
            "from fava.core._compat import FLAG_UNREALIZED",
            "from fava.core.accounts import get_entry_accounts",
            "from fava.core.fava_options import InsertEntryOption",
            "from fava.core.misc import align",
            "from fava.core.module_base import FavaModule",
            "from fava.helpers import FavaAPIException",
            "from fava.util import next_key",
            "",
            "if TYPE_CHECKING:  # pragma: no cover",
            "    from fava.core import FavaLedger",
            "",
            "#: The flags to exclude when rendering entries.",
            "EXCL_FLAGS = {",
            "    FLAG_PADDING,  # P",
            "    FLAG_SUMMARIZE,  # S",
            "    FLAG_TRANSFER,  # T",
            "    FLAG_CONVERSIONS,  # C",
            "    FLAG_UNREALIZED,  # U",
            "    FLAG_RETURNS,  # R",
            "    FLAG_MERGING,  # M",
            "}",
            "",
            "",
            "def sha256_str(val: str) -> str:",
            "    \"\"\"Hash a string.\"\"\"",
            "    return sha256(encode(val, encoding=\"utf-8\")).hexdigest()",
            "",
            "",
            "class FileModule(FavaModule):",
            "    \"\"\"Functions related to reading/writing to Beancount files.\"\"\"",
            "",
            "    def __init__(self, ledger: FavaLedger) -> None:",
            "        super().__init__(ledger)",
            "        self.lock = threading.Lock()",
            "",
            "    def get_source(self, path: str) -> tuple[str, str]:",
            "        \"\"\"Get source files.",
            "",
            "        Args:",
            "            path: The path of the file.",
            "",
            "        Returns:",
            "            A string with the file contents and the `sha256sum` of the file.",
            "",
            "        Raises:",
            "            FavaAPIException: If the file at `path` is not one of the",
            "                source files.",
            "        \"\"\"",
            "        if path not in self.ledger.options[\"include\"]:",
            "            raise FavaAPIException(\"Trying to read a non-source file\")",
            "",
            "        with open(path, mode=\"rb\") as file:",
            "            contents = file.read()",
            "",
            "        sha256sum = sha256(contents).hexdigest()",
            "        source = decode(contents)",
            "",
            "        return source, sha256sum",
            "",
            "    def set_source(self, path: str, source: str, sha256sum: str) -> str:",
            "        \"\"\"Write to source file.",
            "",
            "        Args:",
            "            path: The path of the file.",
            "            source: A string with the file contents.",
            "            sha256sum: Hash of the file.",
            "",
            "        Returns:",
            "            The `sha256sum` of the updated file.",
            "",
            "        Raises:",
            "            FavaAPIException: If the file at `path` is not one of the",
            "                source files or if the file was changed externally.",
            "        \"\"\"",
            "        with self.lock:",
            "            _, original_sha256sum = self.get_source(path)",
            "            if original_sha256sum != sha256sum:",
            "                raise FavaAPIException(\"The file changed externally.\")",
            "",
            "            contents = encode(source, encoding=\"utf-8\")",
            "            with open(path, \"w+b\") as file:",
            "                file.write(contents)",
            "",
            "            self.ledger.extensions.after_write_source(path, source)",
            "            self.ledger.load_file()",
            "",
            "            return sha256(contents).hexdigest()",
            "",
            "    def insert_metadata(",
            "        self, entry_hash: str, basekey: str, value: str",
            "    ) -> None:",
            "        \"\"\"Insert metadata into a file at lineno.",
            "",
            "        Also, prevent duplicate keys.",
            "        \"\"\"",
            "        with self.lock:",
            "            self.ledger.changed()",
            "            entry: Directive = self.ledger.get_entry(entry_hash)",
            "            key = next_key(basekey, entry.meta)",
            "            indent = self.ledger.fava_options.indent",
            "            insert_metadata_in_file(",
            "                entry.meta[\"filename\"],",
            "                entry.meta[\"lineno\"],",
            "                indent,",
            "                key,",
            "                value,",
            "            )",
            "            self.ledger.extensions.after_insert_metadata(entry, key, value)",
            "",
            "    def save_entry_slice(",
            "        self, entry_hash: str, source_slice: str, sha256sum: str",
            "    ) -> str:",
            "        \"\"\"Save slice of the source file for an entry.",
            "",
            "        Args:",
            "            entry_hash: An entry.",
            "            source_slice: The lines that the entry should be replaced with.",
            "            sha256sum: The sha256sum of the current lines of the entry.",
            "",
            "        Returns:",
            "            The `sha256sum` of the new lines of the entry.",
            "        Raises:",
            "            FavaAPIException: If the entry is not found or the file changed.",
            "        \"\"\"",
            "        with self.lock:",
            "            entry = self.ledger.get_entry(entry_hash)",
            "            ret = save_entry_slice(entry, source_slice, sha256sum)",
            "            self.ledger.extensions.after_entry_modified(entry, source_slice)",
            "            return ret",
            "",
            "    def insert_entries(self, entries: Entries) -> None:",
            "        \"\"\"Insert entries.",
            "",
            "        Args:",
            "            entries: A list of entries.",
            "        \"\"\"",
            "        with self.lock:",
            "            self.ledger.changed()",
            "            fava_options = self.ledger.fava_options",
            "            for entry in sorted(entries, key=incomplete_sortkey):",
            "                insert_options = fava_options.insert_entry",
            "                currency_column = fava_options.currency_column",
            "                indent = fava_options.indent",
            "                fava_options.insert_entry = insert_entry(",
            "                    entry,",
            "                    self.ledger.beancount_file_path,",
            "                    insert_options,",
            "                    currency_column,",
            "                    indent,",
            "                )",
            "                self.ledger.extensions.after_insert_entry(entry)",
            "",
            "    def render_entries(",
            "        self, entries: Entries",
            "    ) -> Generator[Markup, None, None]:",
            "        \"\"\"Return entries in Beancount format.",
            "",
            "        Only renders :class:`.Balance` and :class:`.Transaction`.",
            "",
            "        Args:",
            "            entries: A list of entries.",
            "",
            "        Yields:",
            "            The entries rendered in Beancount format.",
            "        \"\"\"",
            "        indent = self.ledger.fava_options.indent",
            "        for entry in entries:",
            "            if isinstance(entry, (Balance, Transaction)):",
            "                if isinstance(entry, Transaction) and entry.flag in EXCL_FLAGS:",
            "                    continue",
            "                try:",
            "                    yield Markup(get_entry_slice(entry)[0] + \"\\n\")",
            "                except (KeyError, FileNotFoundError):",
            "                    yield Markup(",
            "                        _format_entry(",
            "                            entry,",
            "                            self.ledger.fava_options.currency_column,",
            "                            indent,",
            "                        )",
            "                    )",
            "",
            "",
            "def incomplete_sortkey(entry: Directive) -> tuple[datetime.date, int]:",
            "    \"\"\"Sortkey for entries that might have incomplete metadata.\"\"\"",
            "    return (entry.date, SORT_ORDER.get(type(entry), 0))",
            "",
            "",
            "def insert_metadata_in_file(",
            "    filename: str, lineno: int, indent: int, key: str, value: str",
            ") -> None:",
            "    \"\"\"Inserts the specified metadata in the file below lineno, taking into",
            "    account the whitespace in front of the line that lineno.\"\"\"",
            "    with open(filename, encoding=\"utf-8\") as file:",
            "        contents = file.readlines()",
            "",
            "    contents.insert(lineno, f'{\" \" * indent}{key}: \"{value}\"\\n')",
            "",
            "    with open(filename, \"w\", encoding=\"utf-8\") as file:",
            "        file.write(\"\".join(contents))",
            "",
            "",
            "def find_entry_lines(lines: list[str], lineno: int) -> list[str]:",
            "    \"\"\"Lines of entry starting at lineno.",
            "",
            "    Args:",
            "        lines: A list of lines.",
            "        lineno: The 0-based line-index to start at.",
            "    \"\"\"",
            "    entry_lines = [lines[lineno]]",
            "    while True:",
            "        lineno += 1",
            "        try:",
            "            line = lines[lineno]",
            "        except IndexError:",
            "            return entry_lines",
            "        if not line.strip() or re.match(r\"\\S\", line[0]):",
            "            return entry_lines",
            "        entry_lines.append(line)",
            "",
            "",
            "def get_entry_slice(entry: Directive) -> tuple[str, str]:",
            "    \"\"\"Get slice of the source file for an entry.",
            "",
            "    Args:",
            "        entry: An entry.",
            "",
            "    Returns:",
            "        A string containing the lines of the entry and the `sha256sum` of",
            "        these lines.",
            "    \"\"\"",
            "    with open(entry.meta[\"filename\"], encoding=\"utf-8\") as file:",
            "        lines = file.readlines()",
            "",
            "    entry_lines = find_entry_lines(lines, entry.meta[\"lineno\"] - 1)",
            "    entry_source = \"\".join(entry_lines).rstrip(\"\\n\")",
            "",
            "    return entry_source, sha256_str(entry_source)",
            "",
            "",
            "def save_entry_slice(",
            "    entry: Directive, source_slice: str, sha256sum: str",
            ") -> str:",
            "    \"\"\"Save slice of the source file for an entry.",
            "",
            "    Args:",
            "        entry: An entry.",
            "        source_slice: The lines that the entry should be replaced with.",
            "        sha256sum: The sha256sum of the current lines of the entry.",
            "",
            "    Returns:",
            "        The `sha256sum` of the new lines of the entry.",
            "",
            "    Raises:",
            "        FavaAPIException: If the file at `path` is not one of the",
            "            source files.",
            "    \"\"\"",
            "",
            "    with open(entry.meta[\"filename\"], encoding=\"utf-8\") as file:",
            "        lines = file.readlines()",
            "",
            "    first_entry_line = entry.meta[\"lineno\"] - 1",
            "    entry_lines = find_entry_lines(lines, first_entry_line)",
            "    entry_source = \"\".join(entry_lines).rstrip(\"\\n\")",
            "    if sha256_str(entry_source) != sha256sum:",
            "        raise FavaAPIException(\"The file changed externally.\")",
            "",
            "    lines = (",
            "        lines[:first_entry_line]",
            "        + [source_slice + \"\\n\"]",
            "        + lines[first_entry_line + len(entry_lines) :]",
            "    )",
            "    with open(entry.meta[\"filename\"], \"w\", encoding=\"utf-8\") as file:",
            "        file.writelines(lines)",
            "",
            "    return sha256_str(source_slice)",
            "",
            "",
            "def insert_entry(",
            "    entry: Directive,",
            "    default_filename: str,",
            "    insert_options: list[InsertEntryOption],",
            "    currency_column: int,",
            "    indent: int,",
            ") -> list[InsertEntryOption]:",
            "    \"\"\"Insert an entry.",
            "",
            "    Args:",
            "        entry: An entry.",
            "        default_filename: The default file to insert into if no option matches.",
            "        insert_options: Insert options.",
            "        currency_column: The column to align currencies at.",
            "        indent: Number of indent spaces.",
            "",
            "    Returns:",
            "        A list of updated insert options.",
            "    \"\"\"",
            "    filename, lineno = find_insert_position(",
            "        entry, insert_options, default_filename",
            "    )",
            "    content = _format_entry(entry, currency_column, indent)",
            "",
            "    with open(filename, encoding=\"utf-8\") as file:",
            "        contents = file.readlines()",
            "",
            "    if lineno is None:",
            "        # Appending",
            "        contents += \"\\n\" + content",
            "    else:",
            "        contents.insert(lineno, content + \"\\n\")",
            "",
            "    with open(filename, \"w\", encoding=\"utf-8\") as file:",
            "        file.writelines(contents)",
            "",
            "    if lineno is None:",
            "        return insert_options",
            "",
            "    added_lines = content.count(\"\\n\") + 1",
            "    return [",
            "        option._replace(lineno=option.lineno + added_lines)",
            "        if option.filename == filename and option.lineno > lineno",
            "        else option",
            "        for option in insert_options",
            "    ]",
            "",
            "",
            "def _format_entry(entry: Directive, currency_column: int, indent: int) -> str:",
            "    \"\"\"Wrapper that strips unnecessary whitespace from format_entry.\"\"\"",
            "    meta = {",
            "        key: entry.meta[key] for key in entry.meta if not key.startswith(\"_\")",
            "    }",
            "    entry = entry._replace(meta=meta)",
            "    string = align(format_entry(entry, prefix=\" \" * indent), currency_column)",
            "    string = string.replace(\"<class 'beancount.core.number.MISSING'>\", \"\")",
            "    return \"\\n\".join(line.rstrip() for line in string.split(\"\\n\"))",
            "",
            "",
            "def find_insert_position(",
            "    entry: Directive,",
            "    insert_options: list[InsertEntryOption],",
            "    default_filename: str,",
            ") -> tuple[str, int | None]:",
            "    \"\"\"Find insert position for an entry.",
            "",
            "    Args:",
            "        entry: An entry.",
            "        insert_options: A list of InsertOption.",
            "        default_filename: The default file to insert into if no option matches.",
            "",
            "    Returns:",
            "        A tuple of the filename and the line number.",
            "    \"\"\"",
            "",
            "    # Get the list of accounts that should be considered for the entry.",
            "    # For transactions, we want the reversed list of posting accounts.",
            "    accounts = get_entry_accounts(entry)",
            "",
            "    # Make no assumptions about the order of insert_options entries and instead",
            "    # sort them ourselves (by descending dates)",
            "    insert_options = sorted(",
            "        insert_options, key=attrgetter(\"date\"), reverse=True",
            "    )",
            "",
            "    for account in accounts:",
            "        for insert_option in insert_options:",
            "            # Only consider InsertOptions before the entry date.",
            "            if insert_option.date >= entry.date:",
            "                continue",
            "            if insert_option.re.match(account):",
            "                return (insert_option.filename, insert_option.lineno - 1)",
            "",
            "    return (default_filename, None)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "179": [
                "FileModule",
                "render_entries"
            ],
            "196": [
                "FileModule",
                "render_entries"
            ],
            "198": [
                "FileModule",
                "render_entries"
            ],
            "199": [
                "FileModule",
                "render_entries"
            ],
            "200": [
                "FileModule",
                "render_entries"
            ],
            "201": [
                "FileModule",
                "render_entries"
            ]
        },
        "addLocation": []
    },
    "src/fava/template_filters.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from typing import MutableMapping"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from typing import TypeVar"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import flask"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from beancount.core import compare"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from beancount.core import realization"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from beancount.core.account import ACCOUNT_RE"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from beancount.core.data import Directive"
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from beancount.core.inventory import Inventory"
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from beancount.core.number import Decimal"
            },
            "10": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from beancount.core.number import ZERO"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from flask import url_for"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from markupsafe import Markup"
            },
            "13": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from fava.context import g"
            },
            "15": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from fava.core.conversion import cost"
            },
            "16": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     return unicodedata.normalize(\"NFC\", os.path.basename(file_path))"
            },
            "17": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def format_errormsg(message: str) -> str:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+def format_errormsg(message: str) -> Markup:"
            },
            "21": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "     \"\"\"Match account names in error messages and insert HTML links for them.\"\"\""
            },
            "22": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     match = re.search(ACCOUNT_RE, message)"
            },
            "23": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "     if not match:"
            },
            "24": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return message"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        return Markup(message)"
            },
            "26": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     account = match.group()"
            },
            "27": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    url = flask.url_for(\"account\", name=account)"
            },
            "28": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return ("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+    url = url_for(\"account\", name=account)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+    return Markup("
            },
            "31": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         message.replace(account, f'<a href=\"{url}\">{account}</a>')"
            },
            "32": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         .replace(\"for '\", \"for \")"
            },
            "33": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         .replace(\"': \", \": \")"
            }
        },
        "frontPatchFile": [
            "\"\"\"Template filters for Fava.",
            "",
            "All functions in this module will be automatically added as template filters.",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import datetime",
            "import os",
            "import re",
            "import unicodedata",
            "from typing import Any",
            "from typing import MutableMapping",
            "from typing import TypeVar",
            "",
            "import flask",
            "from beancount.core import compare",
            "from beancount.core import realization",
            "from beancount.core.account import ACCOUNT_RE",
            "from beancount.core.data import Directive",
            "from beancount.core.inventory import Inventory",
            "from beancount.core.number import Decimal",
            "from beancount.core.number import ZERO",
            "",
            "from fava.context import g",
            "from fava.core.conversion import cost",
            "from fava.core.conversion import cost_or_value as cost_or_value_without_context",
            "from fava.core.conversion import units",
            "from fava.core.tree import TreeNode",
            "from fava.util.date import Interval",
            "",
            "MappingValue = TypeVar(\"MappingValue\")",
            "",
            "",
            "def remove_keys(",
            "    _dict: MutableMapping[str, MappingValue] | None, keys: list[str]",
            ") -> MutableMapping[str, MappingValue]:",
            "    \"\"\"Remove keys from a dictionary.\"\"\"",
            "    if not _dict:",
            "        return {}",
            "    new = dict(_dict)",
            "    for key in keys:",
            "        try:",
            "            del new[key]",
            "        except KeyError:",
            "            pass",
            "    return new",
            "",
            "",
            "def cost_or_value(",
            "    inventory: Inventory, date: datetime.date | None = None",
            ") -> Any:",
            "    \"\"\"Get the cost or value of an inventory.\"\"\"",
            "    return cost_or_value_without_context(",
            "        inventory, g.conversion, g.ledger.price_map, date",
            "    )",
            "",
            "",
            "def format_currency(",
            "    value: Decimal,",
            "    currency: str | None = None,",
            "    show_if_zero: bool = False,",
            "    invert: bool = False,",
            ") -> str:",
            "    \"\"\"Format a value using the derived precision for a specified currency.\"\"\"",
            "    if not value and not show_if_zero:",
            "        return \"\"",
            "    if value == ZERO:",
            "        return g.ledger.format_decimal(ZERO, currency)",
            "    if invert:",
            "        value = -value",
            "    return g.ledger.format_decimal(value, currency)",
            "",
            "",
            "def format_date(date: datetime.date) -> str:",
            "    \"\"\"Format a date according to the current interval.\"\"\"",
            "    if g.interval is Interval.YEAR:",
            "        return date.strftime(\"%Y\")",
            "    if g.interval is Interval.QUARTER:",
            "        return f\"{date.year}Q{(date.month - 1) // 3 + 1}\"",
            "    if g.interval is Interval.WEEK:",
            "        return date.strftime(\"%YW%W\")",
            "    if g.interval is Interval.DAY:",
            "        return date.strftime(\"%Y-%m-%d\")",
            "    assert g.interval is Interval.MONTH",
            "    return date.strftime(\"%b %Y\")",
            "",
            "",
            "def hash_entry(entry: Directive) -> str:",
            "    \"\"\"Hash an entry.\"\"\"",
            "    return compare.hash_entry(entry)",
            "",
            "",
            "def balance_children(account: realization.RealAccount) -> Inventory:",
            "    \"\"\"Compute the total balance of an account.\"\"\"",
            "    return realization.compute_balance(account)",
            "",
            "",
            "def get_or_create(",
            "    account: realization.RealAccount, account_name: str",
            ") -> realization.RealAccount:",
            "    \"\"\"Get or create a child account.\"\"\"",
            "    if account.account == account_name:",
            "        return account",
            "    return realization.get_or_create(account, account_name)",
            "",
            "",
            "FLAGS_TO_TYPES = {\"*\": \"cleared\", \"!\": \"pending\"}",
            "",
            "",
            "def flag_to_type(flag: str) -> str:",
            "    \"\"\"Names for entry flags.\"\"\"",
            "    return FLAGS_TO_TYPES.get(flag, \"other\")",
            "",
            "",
            "def should_show(account: TreeNode) -> bool:",
            "    \"\"\"Determine whether the account should be shown.\"\"\"",
            "    if not account.balance_children.is_empty() or any(",
            "        should_show(a) for a in account.children",
            "    ):",
            "        return True",
            "    ledger = g.ledger",
            "    filtered = g.filtered",
            "    if account.name not in ledger.accounts:",
            "        return False",
            "    fava_options = ledger.fava_options",
            "    if not fava_options.show_closed_accounts and filtered.account_is_closed(",
            "        account.name",
            "    ):",
            "        return False",
            "    if (",
            "        not fava_options.show_accounts_with_zero_balance",
            "        and account.balance.is_empty()",
            "    ):",
            "        return False",
            "    if (",
            "        not fava_options.show_accounts_with_zero_transactions",
            "        and not account.has_txns",
            "    ):",
            "        return False",
            "    return True",
            "",
            "",
            "def basename(file_path: str) -> str:",
            "    \"\"\"Return the basename of a filepath.\"\"\"",
            "    return unicodedata.normalize(\"NFC\", os.path.basename(file_path))",
            "",
            "",
            "def format_errormsg(message: str) -> str:",
            "    \"\"\"Match account names in error messages and insert HTML links for them.\"\"\"",
            "    match = re.search(ACCOUNT_RE, message)",
            "    if not match:",
            "        return message",
            "    account = match.group()",
            "    url = flask.url_for(\"account\", name=account)",
            "    return (",
            "        message.replace(account, f'<a href=\"{url}\">{account}</a>')",
            "        .replace(\"for '\", \"for \")",
            "        .replace(\"': \", \": \")",
            "    )",
            "",
            "",
            "def collapse_account(account_name: str) -> bool:",
            "    \"\"\"Return true if account should be collapsed.\"\"\"",
            "    collapse_patterns = g.ledger.fava_options.collapse_pattern",
            "    return any(pattern.match(account_name) for pattern in collapse_patterns)",
            "",
            "",
            "FILTERS = [",
            "    balance_children,",
            "    basename,",
            "    collapse_account,",
            "    cost,",
            "    cost_or_value,",
            "    cost_or_value,",
            "    flag_to_type,",
            "    format_currency,",
            "    format_date,",
            "    format_errormsg,",
            "    get_or_create,",
            "    hash_entry,",
            "    remove_keys,",
            "    should_show,",
            "    units,",
            "]"
        ],
        "afterPatchFile": [
            "\"\"\"Template filters for Fava.",
            "",
            "All functions in this module will be automatically added as template filters.",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import datetime",
            "import os",
            "import re",
            "import unicodedata",
            "from typing import Any",
            "from typing import MutableMapping",
            "from typing import TypeVar",
            "",
            "from beancount.core import compare",
            "from beancount.core import realization",
            "from beancount.core.account import ACCOUNT_RE",
            "from beancount.core.data import Directive",
            "from beancount.core.inventory import Inventory",
            "from beancount.core.number import Decimal",
            "from beancount.core.number import ZERO",
            "from flask import url_for",
            "from markupsafe import Markup",
            "",
            "from fava.context import g",
            "from fava.core.conversion import cost",
            "from fava.core.conversion import cost_or_value as cost_or_value_without_context",
            "from fava.core.conversion import units",
            "from fava.core.tree import TreeNode",
            "from fava.util.date import Interval",
            "",
            "MappingValue = TypeVar(\"MappingValue\")",
            "",
            "",
            "def remove_keys(",
            "    _dict: MutableMapping[str, MappingValue] | None, keys: list[str]",
            ") -> MutableMapping[str, MappingValue]:",
            "    \"\"\"Remove keys from a dictionary.\"\"\"",
            "    if not _dict:",
            "        return {}",
            "    new = dict(_dict)",
            "    for key in keys:",
            "        try:",
            "            del new[key]",
            "        except KeyError:",
            "            pass",
            "    return new",
            "",
            "",
            "def cost_or_value(",
            "    inventory: Inventory, date: datetime.date | None = None",
            ") -> Any:",
            "    \"\"\"Get the cost or value of an inventory.\"\"\"",
            "    return cost_or_value_without_context(",
            "        inventory, g.conversion, g.ledger.price_map, date",
            "    )",
            "",
            "",
            "def format_currency(",
            "    value: Decimal,",
            "    currency: str | None = None,",
            "    show_if_zero: bool = False,",
            "    invert: bool = False,",
            ") -> str:",
            "    \"\"\"Format a value using the derived precision for a specified currency.\"\"\"",
            "    if not value and not show_if_zero:",
            "        return \"\"",
            "    if value == ZERO:",
            "        return g.ledger.format_decimal(ZERO, currency)",
            "    if invert:",
            "        value = -value",
            "    return g.ledger.format_decimal(value, currency)",
            "",
            "",
            "def format_date(date: datetime.date) -> str:",
            "    \"\"\"Format a date according to the current interval.\"\"\"",
            "    if g.interval is Interval.YEAR:",
            "        return date.strftime(\"%Y\")",
            "    if g.interval is Interval.QUARTER:",
            "        return f\"{date.year}Q{(date.month - 1) // 3 + 1}\"",
            "    if g.interval is Interval.WEEK:",
            "        return date.strftime(\"%YW%W\")",
            "    if g.interval is Interval.DAY:",
            "        return date.strftime(\"%Y-%m-%d\")",
            "    assert g.interval is Interval.MONTH",
            "    return date.strftime(\"%b %Y\")",
            "",
            "",
            "def hash_entry(entry: Directive) -> str:",
            "    \"\"\"Hash an entry.\"\"\"",
            "    return compare.hash_entry(entry)",
            "",
            "",
            "def balance_children(account: realization.RealAccount) -> Inventory:",
            "    \"\"\"Compute the total balance of an account.\"\"\"",
            "    return realization.compute_balance(account)",
            "",
            "",
            "def get_or_create(",
            "    account: realization.RealAccount, account_name: str",
            ") -> realization.RealAccount:",
            "    \"\"\"Get or create a child account.\"\"\"",
            "    if account.account == account_name:",
            "        return account",
            "    return realization.get_or_create(account, account_name)",
            "",
            "",
            "FLAGS_TO_TYPES = {\"*\": \"cleared\", \"!\": \"pending\"}",
            "",
            "",
            "def flag_to_type(flag: str) -> str:",
            "    \"\"\"Names for entry flags.\"\"\"",
            "    return FLAGS_TO_TYPES.get(flag, \"other\")",
            "",
            "",
            "def should_show(account: TreeNode) -> bool:",
            "    \"\"\"Determine whether the account should be shown.\"\"\"",
            "    if not account.balance_children.is_empty() or any(",
            "        should_show(a) for a in account.children",
            "    ):",
            "        return True",
            "    ledger = g.ledger",
            "    filtered = g.filtered",
            "    if account.name not in ledger.accounts:",
            "        return False",
            "    fava_options = ledger.fava_options",
            "    if not fava_options.show_closed_accounts and filtered.account_is_closed(",
            "        account.name",
            "    ):",
            "        return False",
            "    if (",
            "        not fava_options.show_accounts_with_zero_balance",
            "        and account.balance.is_empty()",
            "    ):",
            "        return False",
            "    if (",
            "        not fava_options.show_accounts_with_zero_transactions",
            "        and not account.has_txns",
            "    ):",
            "        return False",
            "    return True",
            "",
            "",
            "def basename(file_path: str) -> str:",
            "    \"\"\"Return the basename of a filepath.\"\"\"",
            "    return unicodedata.normalize(\"NFC\", os.path.basename(file_path))",
            "",
            "",
            "def format_errormsg(message: str) -> Markup:",
            "    \"\"\"Match account names in error messages and insert HTML links for them.\"\"\"",
            "    match = re.search(ACCOUNT_RE, message)",
            "    if not match:",
            "        return Markup(message)",
            "    account = match.group()",
            "    url = url_for(\"account\", name=account)",
            "    return Markup(",
            "        message.replace(account, f'<a href=\"{url}\">{account}</a>')",
            "        .replace(\"for '\", \"for \")",
            "        .replace(\"': \", \": \")",
            "    )",
            "",
            "",
            "def collapse_account(account_name: str) -> bool:",
            "    \"\"\"Return true if account should be collapsed.\"\"\"",
            "    collapse_patterns = g.ledger.fava_options.collapse_pattern",
            "    return any(pattern.match(account_name) for pattern in collapse_patterns)",
            "",
            "",
            "FILTERS = [",
            "    balance_children,",
            "    basename,",
            "    collapse_account,",
            "    cost,",
            "    cost_or_value,",
            "    cost_or_value,",
            "    flag_to_type,",
            "    format_currency,",
            "    format_date,",
            "    format_errormsg,",
            "    get_or_create,",
            "    hash_entry,",
            "    remove_keys,",
            "    should_show,",
            "    units,",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "148": [
                "format_errormsg"
            ],
            "152": [
                "format_errormsg"
            ],
            "154": [
                "format_errormsg"
            ],
            "155": [
                "format_errormsg"
            ]
        },
        "addLocation": []
    }
}