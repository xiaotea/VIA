import subprocess
import os
import re
import json

pathToCtags = r"ctags"

def ctag_excute(python_filePath):
    try:
        functionList = subprocess.check_output(
            pathToCtags + ' -f - --kinds-Python=* --fields=neKSt "' + python_filePath + '"',
            stderr=subprocess.STDOUT,
            shell=True).decode('utf-8', errors='ignore')
        # print(functionList)
        return functionList
    except subprocess.CalledProcessError as e:
        print(f"Error running ctags on {python_filePath}: {e}")
        return ""

def readFile(filePath):
    with open(filePath, 'r', encoding='utf-8') as f:
        return f.readlines()

def extract_and_preprocess_function_block(lines, start, end, entity_type):
    """
    提取函数代码块
    """
    # 如果 end 为 None，则从 start 提取到文件末尾
    if end is None:
        function_block = lines[start - 1:]
    else:
        function_block = lines[start - 1:end]

    return {
        "code": "".join(function_block),
        "start_line": start,
        "end_line": end,
        "type": entity_type
    }

def extract_variables_with_ctags(filePath):
    functionList = ctag_excute(filePath)
    if not functionList:
        return []

    variables = []
    # 包含 variable 的实体 pattern
    func_pattern = re.compile(r'(variable)')
    start_number = re.compile(r'line:(\d+)')
    # variable 一般没有结束行，用开始行作为结束行

    allFuncs = functionList.split('\n')
    for i in allFuncs:
        _elem_str = re.sub(r'[\t\s ]{2,}', '', i)
        elemList = _elem_str.split('\t')

        # 跳过无效行
        if i == '' or len(elemList) < 5 or not func_pattern.fullmatch(elemList[3]):
            continue

        # 提取变量名和行号
        varName = elemList[0]
        start_match = start_number.search(_elem_str)
        if not start_match:
            continue
        varStartLine = int(start_match.group(1))
        varEndLine = varStartLine

        entity_type = "variable"

        lines = readFile(filePath)
        var_code_block = extract_and_preprocess_function_block(lines, varStartLine, varEndLine, entity_type)

        variables.append({
            "name": varName,
            "start_line": varStartLine,
            "end_line": varEndLine,
            "type": entity_type,
            "code": var_code_block["code"]
        })

    return variables

def extract_code_entities_with_ctags(filePath):
    """
    从指定文件中提取类型为 function、class、member 的实体，忽略 unknown 类型
    """
    functionList = ctag_excute(filePath)
    if not functionList:
        return []

    entities = []
    func_pattern = re.compile(r'(function|member|class)')
    start_number = re.compile(r'line:(\d+)')
    end_number = re.compile(r'end:(\d+)')

    allFuncs = functionList.split('\n')
    for i in allFuncs:
        _elem_str = re.sub(r'[\t\s ]{2,}', '', i)
        elemList = _elem_str.split('\t')

        if i == '' or len(elemList) < 5 or not func_pattern.fullmatch(elemList[3]):
            continue

        entityName = elemList[0]
        start_match = start_number.search(_elem_str)
        end_match = end_number.search(_elem_str)
        if not start_match:
            continue
        entityStartLine = int(start_match.group(1))

        if not end_match:
            entityEndLine = None
        else:
            entityEndLine = int(end_match.group(1))

        if "function" in elemList[3]:
            entity_type = "function"
        elif "class" in elemList[3]:
            entity_type = "class"
        elif "member" in elemList[3]:
            entity_type = "member"
        else:
            continue

        lines = readFile(filePath)
        end_line = entityEndLine if entityEndLine is not None else entityStartLine
        entity_code_block = extract_and_preprocess_function_block(lines, entityStartLine - 5, end_line,
                                                                  entity_type)

        entities.append({
            "name": entityName,
            "start_line": entityStartLine,
            "end_line": entityEndLine,
            "type": entity_type,
            "code": entity_code_block["code"]
        })

    return entities

def preprocessor_fun(pre_file_list, target):
    """
    解析文件列表中的函数信息，并进行预处理
    """
    OSSfuncList = []  # 使用列表而不是字典
    for filePath in pre_file_list:
        # try:
        functions = extract_code_entities_with_ctags(filePath)
        # print(functions)
        if not functions:
            continue

        lines = readFile(filePath)
        for func in functions:
            funcName = func["name"]
            funcStartLine = func["start_line"]
            funcEndLine = func["end_line"] if func["end_line"] else len(lines)

            relative_path = os.path.relpath(filePath, target)
            newname = f"{funcName}##{relative_path.replace(os.sep, '@@')}"

            fun_dict = extract_and_preprocess_function_block(lines, funcStartLine-5, funcEndLine, func["type"])

            OSSfuncList.append({
                "name": newname,
                "details": fun_dict
            })

        # except subprocess.CalledProcessError as e:
        #     print(f"Parser Error in file {filePath}: {e}")
        #     print("Continue parsing...")
        #     continue
        # except Exception as e:
        #     print(f"Unexpected error in file {filePath}: {e}")
        #     print("Continue parsing...")
        #     continue

    return OSSfuncList

