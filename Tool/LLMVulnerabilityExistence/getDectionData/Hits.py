import numpy as np
from ccg import ccg
import os


def hits(adj_matrix, max_iter=100, tol=1e-6):
    n = adj_matrix.shape[0]
    authority = np.ones(n)
    hub = np.ones(n)

    for _ in range(max_iter):
        prev_auth = authority.copy()
        prev_hub = hub.copy()

        new_authority = adj_matrix.T @ prev_hub
        new_hub = adj_matrix @ prev_auth

        auth_norm = np.linalg.norm(new_authority, 2)
        hub_norm = np.linalg.norm(new_hub, 2)

        authority = new_authority / auth_norm if auth_norm > 0 else np.zeros_like(new_authority)
        hub = new_hub / hub_norm if hub_norm > 0 else np.zeros_like(new_hub)

        auth_diff = np.linalg.norm(authority - prev_auth)
        hub_diff = np.linalg.norm(hub - prev_hub)

        if auth_diff < tol and hub_diff < tol:
            break

    return authority, hub

def generate_fun(file_path):
    call_graph = ccg(file_path)
    nodes = list(call_graph.keys())
    n = len(nodes)
    adj_matrix = np.zeros((n, n))
    for i, node in enumerate(nodes):
        for callee in call_graph[node]:
            if callee in nodes:
                j = nodes.index(callee)
                adj_matrix[i][j] = 1

    authority, hub = hits(adj_matrix)

    # 提取入口文件名作为前缀
    relative_entry = file_path
    absolute_entry = os.path.abspath(relative_entry)
    file_name = os.path.basename(absolute_entry)
    name_without_ext, ext = os.path.splitext(file_name)

    # 筛选处理节点列表
    result_nodes = []
    for i in range(n):
        if authority[i] > 0.1 and hub[i] > 0.1:#这里用0.2是测了几个漏洞的结果，如果太小的话提取的函数过于多，导致代码量太大，gpt分析结果差
            result_nodes.append(nodes[i])
    return result_nodes


